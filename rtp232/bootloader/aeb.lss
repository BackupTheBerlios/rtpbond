
aeb.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000066  00800100  0001ff7a  0000200e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f7a  0001e000  0001e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000061  00800166  00800166  00002074  2**0
                  ALLOC
  3 .debug_aranges 000001e0  00000000  00000000  00002074  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000829  00000000  00000000  00002254  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000292e  00000000  00000000  00002a7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000105d  00000000  00000000  000053ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000027f7  00000000  00000000  00006408  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000670  00000000  00000000  00008c00  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000bac  00000000  00000000  00009270  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001630  00000000  00000000  00009e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  0000b44c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0001e000 <__vectors>:
   1e000:	0c 94 46 f0 	jmp	0x1e08c	; 0x1e08c <__ctors_end>
   1e004:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e008:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e00c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e010:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e014:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e018:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e01c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e020:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e024:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e028:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e02c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e030:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e034:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e038:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e03c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e040:	0c 94 3f f8 	jmp	0x1f07e	; 0x1f07e <__vector_16>
   1e044:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e048:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e04c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e050:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e054:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e058:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e05c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e060:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e064:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e068:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e06c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e070:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e074:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e078:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e07c:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e080:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e084:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>
   1e088:	0c 94 66 f0 	jmp	0x1e0cc	; 0x1e0cc <__bad_interrupt>

0001e08c <__ctors_end>:
   1e08c:	11 24       	eor	r1, r1
   1e08e:	1f be       	out	0x3f, r1	; 63
   1e090:	cf ef       	ldi	r28, 0xFF	; 255
   1e092:	d0 e1       	ldi	r29, 0x10	; 16
   1e094:	de bf       	out	0x3e, r29	; 62
   1e096:	cd bf       	out	0x3d, r28	; 61

0001e098 <__do_copy_data>:
   1e098:	11 e0       	ldi	r17, 0x01	; 1
   1e09a:	a0 e0       	ldi	r26, 0x00	; 0
   1e09c:	b1 e0       	ldi	r27, 0x01	; 1
   1e09e:	ea e7       	ldi	r30, 0x7A	; 122
   1e0a0:	ff ef       	ldi	r31, 0xFF	; 255
   1e0a2:	01 e0       	ldi	r16, 0x01	; 1
   1e0a4:	0b bf       	out	0x3b, r16	; 59
   1e0a6:	02 c0       	rjmp	.+4      	; 0x1e0ac <__do_copy_data+0x14>
   1e0a8:	07 90       	elpm	r0, Z+
   1e0aa:	0d 92       	st	X+, r0
   1e0ac:	a6 36       	cpi	r26, 0x66	; 102
   1e0ae:	b1 07       	cpc	r27, r17
   1e0b0:	d9 f7       	brne	.-10     	; 0x1e0a8 <__do_copy_data+0x10>
   1e0b2:	1b be       	out	0x3b, r1	; 59

0001e0b4 <__do_clear_bss>:
   1e0b4:	11 e0       	ldi	r17, 0x01	; 1
   1e0b6:	a6 e6       	ldi	r26, 0x66	; 102
   1e0b8:	b1 e0       	ldi	r27, 0x01	; 1
   1e0ba:	01 c0       	rjmp	.+2      	; 0x1e0be <.do_clear_bss_start>

0001e0bc <.do_clear_bss_loop>:
   1e0bc:	1d 92       	st	X+, r1

0001e0be <.do_clear_bss_start>:
   1e0be:	a7 3c       	cpi	r26, 0xC7	; 199
   1e0c0:	b1 07       	cpc	r27, r17
   1e0c2:	e1 f7       	brne	.-8      	; 0x1e0bc <.do_clear_bss_loop>
   1e0c4:	0e 94 68 f0 	call	0x1e0d0	; 0x1e0d0 <main>
   1e0c8:	0c 94 bb ff 	jmp	0x1ff76	; 0x1ff76 <_exit>

0001e0cc <__bad_interrupt>:
   1e0cc:	0c 94 00 f0 	jmp	0x1e000	; 0x1e000 <__vectors>

0001e0d0 <main>:
  
  
  #ifdef REQUIRES_BOOTLOADER
    /***************** BOOTLOADER ONLY ***********************/
    // Enable change of interrupt vectors 
    MCUCR = (1<<IVCE);
   1e0d0:	81 e0       	ldi	r24, 0x01	; 1
   1e0d2:	85 bf       	out	0x35, r24	; 53
    // Move interrupts to boot flash section
    MCUCR = (1<<IVSEL);
   1e0d4:	82 e0       	ldi	r24, 0x02	; 2
   1e0d6:	85 bf       	out	0x35, r24	; 53
    // Restore interrupts vectors 
    MCUCR = (0<<IVSEL);
  #endif
  
  // Load configuration from EEPROM if valid, else load fallback config
  onInitConfig();
   1e0d8:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <onInitConfig>

  // At first, we initialize the real time clock ...
  onInitClock();
   1e0dc:	0e 94 62 f6 	call	0x1ecc4	; 0x1ecc4 <onInitClock>
  // ... then the timer, it depends on the clock module ...
  onInitTimer();
   1e0e0:	0e 94 6b f6 	call	0x1ecd6	; 0x1ecd6 <onInitTimer>
  // ... Ethernet depends itself on the timer module ...
  onInitEthernet();
   1e0e4:	0e 94 57 f2 	call	0x1e4ae	; 0x1e4ae <onInitEthernet>
    
  #ifdef REQUIRES_WATCHDOG
    onInitWatchdog();  
  #endif
  // ... initialization finished, it is save to enable interrupts...
  sei();
   1e0e8:	78 94       	sei
  
  onInitApplication();
   1e0ea:	0e 94 ee fd 	call	0x1fbdc	; 0x1fbdc <onInitApplication>
   
  for (;;)
  { 
    // Check for timer events
    onTimer();
   1e0ee:	0e 94 82 f6 	call	0x1ed04	; 0x1ed04 <onTimer>
    // COM Event Handler...
    #ifdef REQUIRES_SERIAL
      onSerial();
    #endif
          
    onEthernet();
   1e0f2:	0e 94 c0 f2 	call	0x1e580	; 0x1e580 <onEthernet>
   1e0f6:	fb cf       	rjmp	.-10     	; 0x1e0ee <main+0x1e>

0001e0f8 <arpAddMacByIPv4>:
  
  return;
}

uint8_t arpAddMacByIPv4(ipAddress_t* ip, struct macAddress_t* mac)
{
   1e0f8:	ef 92       	push	r14
   1e0fa:	ff 92       	push	r15
   1e0fc:	0f 93       	push	r16
   1e0fe:	1f 93       	push	r17
   1e100:	cf 93       	push	r28
   1e102:	df 93       	push	r29
   1e104:	8c 01       	movw	r16, r24
   1e106:	f6 2e       	mov	r15, r22
   1e108:	e7 2e       	mov	r14, r23
   1e10a:	e6 e9       	ldi	r30, 0x96	; 150
   1e10c:	f1 e0       	ldi	r31, 0x01	; 1
   1e10e:	65 e0       	ldi	r22, 0x05	; 5
   1e110:	70 e0       	ldi	r23, 0x00	; 0
   1e112:	c0 e0       	ldi	r28, 0x00	; 0
   1e114:	d0 e0       	ldi	r29, 0x00	; 0
   1e116:	35 c0       	rjmp	.+106    	; 0x1e182 <arpAddMacByIPv4+0x8a>
  int i = ARP_CACHE_SIZE;
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
   1e118:	61 50       	subi	r22, 0x01	; 1
   1e11a:	70 40       	sbci	r23, 0x00	; 0
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
   1e11c:	86 81       	ldd	r24, Z+6	; 0x06
   1e11e:	97 81       	ldd	r25, Z+7	; 0x07
   1e120:	a0 85       	ldd	r26, Z+8	; 0x08
   1e122:	b1 85       	ldd	r27, Z+9	; 0x09
   1e124:	82 17       	cp	r24, r18
   1e126:	93 07       	cpc	r25, r19
   1e128:	a4 07       	cpc	r26, r20
   1e12a:	b5 07       	cpc	r27, r21
   1e12c:	11 f5       	brne	.+68     	; 0x1e172 <arpAddMacByIPv4+0x7a>
    {
      hArp.arpCache[i].mac = *mac;
   1e12e:	8b e0       	ldi	r24, 0x0B	; 11
   1e130:	90 e0       	ldi	r25, 0x00	; 0
   1e132:	68 9f       	mul	r22, r24
   1e134:	f0 01       	movw	r30, r0
   1e136:	69 9f       	mul	r22, r25
   1e138:	f0 0d       	add	r31, r0
   1e13a:	78 9f       	mul	r23, r24
   1e13c:	f0 0d       	add	r31, r0
   1e13e:	11 24       	eor	r1, r1
   1e140:	e6 59       	subi	r30, 0x96	; 150
   1e142:	fe 4f       	sbci	r31, 0xFE	; 254
   1e144:	2f 2d       	mov	r18, r15
   1e146:	3e 2d       	mov	r19, r14
   1e148:	c9 01       	movw	r24, r18
   1e14a:	dc 01       	movw	r26, r24
   1e14c:	86 e0       	ldi	r24, 0x06	; 6
   1e14e:	0d 90       	ld	r0, X+
   1e150:	01 92       	st	Z+, r0
   1e152:	81 50       	subi	r24, 0x01	; 1
   1e154:	e1 f7       	brne	.-8      	; 0x1e14e <arpAddMacByIPv4+0x56>
      hArp.arpCache[i].age = 255;
   1e156:	8b e0       	ldi	r24, 0x0B	; 11
   1e158:	90 e0       	ldi	r25, 0x00	; 0
   1e15a:	68 9f       	mul	r22, r24
   1e15c:	f0 01       	movw	r30, r0
   1e15e:	69 9f       	mul	r22, r25
   1e160:	f0 0d       	add	r31, r0
   1e162:	78 9f       	mul	r23, r24
   1e164:	f0 0d       	add	r31, r0
   1e166:	11 24       	eor	r1, r1
   1e168:	e6 59       	subi	r30, 0x96	; 150
   1e16a:	fe 4f       	sbci	r31, 0xFE	; 254
   1e16c:	8f ef       	ldi	r24, 0xFF	; 255
   1e16e:	82 87       	std	Z+10, r24	; 0x0a
   1e170:	20 c0       	rjmp	.+64     	; 0x1e1b2 <arpAddMacByIPv4+0xba>
      return 0;
    }
    
    // we mark is entry as usable if it's overaged or was never used    
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
   1e172:	20 97       	sbiw	r28, 0x00	; 0
   1e174:	21 f0       	breq	.+8      	; 0x1e17e <arpAddMacByIPv4+0x86>
   1e176:	9a 85       	ldd	r25, Y+10	; 0x0a
   1e178:	82 85       	ldd	r24, Z+10	; 0x0a
   1e17a:	98 17       	cp	r25, r24
   1e17c:	08 f4       	brcc	.+2      	; 0x1e180 <arpAddMacByIPv4+0x88>
   1e17e:	ef 01       	movw	r28, r30
   1e180:	3b 97       	sbiw	r30, 0x0b	; 11
   1e182:	d8 01       	movw	r26, r16
   1e184:	2d 91       	ld	r18, X+
   1e186:	3d 91       	ld	r19, X+
   1e188:	4d 91       	ld	r20, X+
   1e18a:	5c 91       	ld	r21, X
uint8_t arpAddMacByIPv4(ipAddress_t* ip, struct macAddress_t* mac)
{
  int i = ARP_CACHE_SIZE;
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
   1e18c:	61 15       	cp	r22, r1
   1e18e:	71 05       	cpc	r23, r1
   1e190:	19 f6       	brne	.-122    	; 0x1e118 <arpAddMacByIPv4+0x20>
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
      oldest = &hArp.arpCache[i]; 
  }
  
  // overwrite the oldest entry
  oldest->ip = *ip;
   1e192:	2e 83       	std	Y+6, r18	; 0x06
   1e194:	3f 83       	std	Y+7, r19	; 0x07
   1e196:	48 87       	std	Y+8, r20	; 0x08
   1e198:	59 87       	std	Y+9, r21	; 0x09
  oldest->mac = *mac;
   1e19a:	de 01       	movw	r26, r28
   1e19c:	8f 2d       	mov	r24, r15
   1e19e:	9e 2d       	mov	r25, r14
   1e1a0:	9c 01       	movw	r18, r24
   1e1a2:	f9 01       	movw	r30, r18
   1e1a4:	86 e0       	ldi	r24, 0x06	; 6
   1e1a6:	01 90       	ld	r0, Z+
   1e1a8:	0d 92       	st	X+, r0
   1e1aa:	81 50       	subi	r24, 0x01	; 1
   1e1ac:	e1 f7       	brne	.-8      	; 0x1e1a6 <arpAddMacByIPv4+0xae>
  oldest->age = 255;
   1e1ae:	8f ef       	ldi	r24, 0xFF	; 255
   1e1b0:	8a 87       	std	Y+10, r24	; 0x0a
  
  return 0;
}
   1e1b2:	80 e0       	ldi	r24, 0x00	; 0
   1e1b4:	df 91       	pop	r29
   1e1b6:	cf 91       	pop	r28
   1e1b8:	1f 91       	pop	r17
   1e1ba:	0f 91       	pop	r16
   1e1bc:	ff 90       	pop	r15
   1e1be:	ef 90       	pop	r14
   1e1c0:	08 95       	ret

0001e1c2 <onInitArp>:
  int i = ARP_CACHE_SIZE;
  
  while (i--)
  {
    // a time to Live of 0 means empty
    hArp.arpCache[i].age = 0;
   1e1c2:	10 92 a0 01 	sts	0x01A0, r1
   1e1c6:	10 92 95 01 	sts	0x0195, r1
   1e1ca:	10 92 8a 01 	sts	0x018A, r1
   1e1ce:	10 92 7f 01 	sts	0x017F, r1
   1e1d2:	10 92 74 01 	sts	0x0174, r1
  }
  
  timerAddTimeout(ARP_AGE_INTERVAL,onArpTimeout);
   1e1d6:	80 e7       	ldi	r24, 0x70	; 112
   1e1d8:	97 e1       	ldi	r25, 0x17	; 23
   1e1da:	62 ef       	ldi	r22, 0xF2	; 242
   1e1dc:	70 ef       	ldi	r23, 0xF0	; 240
   1e1de:	0e 94 cc f6 	call	0x1ed98	; 0x1ed98 <timerAddTimeout>
  
  return;
}
   1e1e2:	08 95       	ret

0001e1e4 <onArpTimeout>:
  return 1;
}


void onArpTimeout()
{
   1e1e4:	e0 ea       	ldi	r30, 0xA0	; 160
   1e1e6:	f1 e0       	ldi	r31, 0x01	; 1
   1e1e8:	06 c0       	rjmp	.+12     	; 0x1e1f6 <onArpTimeout+0x12>
  int i = ARP_CACHE_SIZE;
  while (i--)
  {
    if (hArp.arpCache[i].age == 0)
   1e1ea:	80 81       	ld	r24, Z
   1e1ec:	88 23       	and	r24, r24
   1e1ee:	11 f0       	breq	.+4      	; 0x1e1f4 <onArpTimeout+0x10>
      continue;
    
    hArp.arpCache[i].age--;
   1e1f0:	81 50       	subi	r24, 0x01	; 1
   1e1f2:	80 83       	st	Z, r24
   1e1f4:	3b 97       	sbiw	r30, 0x0b	; 11


void onArpTimeout()
{
  int i = ARP_CACHE_SIZE;
  while (i--)
   1e1f6:	81 e0       	ldi	r24, 0x01	; 1
   1e1f8:	e9 36       	cpi	r30, 0x69	; 105
   1e1fa:	f8 07       	cpc	r31, r24
   1e1fc:	b1 f7       	brne	.-20     	; 0x1e1ea <onArpTimeout+0x6>
  
  // Every entry can age exactly 255 times, ...
  // ... as we age the arpcache very 6 seconds,...
  // ... this results in an total timeout of approx ...
  // ... 25 Minutes.
  timerAddTimeout(ARP_AGE_INTERVAL,onArpTimeout);
   1e1fe:	80 e7       	ldi	r24, 0x70	; 112
   1e200:	97 e1       	ldi	r25, 0x17	; 23
   1e202:	62 ef       	ldi	r22, 0xF2	; 242
   1e204:	70 ef       	ldi	r23, 0xF0	; 240
   1e206:	0e 94 cc f6 	call	0x1ed98	; 0x1ed98 <timerAddTimeout>
  
  return;
}
   1e20a:	08 95       	ret

0001e20c <onArpRequest>:
  
  return onArpRequest(handle,tpa,tha);
}

uint8_t onArpRequest(struct nicRequestHandle_t* handle,ipAddress_t* tpa, struct macAddress_t* tha)
{
   1e20c:	af 92       	push	r10
   1e20e:	bf 92       	push	r11
   1e210:	cf 92       	push	r12
   1e212:	df 92       	push	r13
   1e214:	ef 92       	push	r14
   1e216:	ff 92       	push	r15
   1e218:	0f 93       	push	r16
   1e21a:	1f 93       	push	r17
   1e21c:	df 93       	push	r29
   1e21e:	cf 93       	push	r28
   1e220:	00 d0       	rcall	.+0      	; 0x1e222 <onArpRequest+0x16>
   1e222:	00 d0       	rcall	.+0      	; 0x1e224 <onArpRequest+0x18>
   1e224:	00 d0       	rcall	.+0      	; 0x1e226 <onArpRequest+0x1a>
   1e226:	cd b7       	in	r28, 0x3d	; 61
   1e228:	de b7       	in	r29, 0x3e	; 62
   1e22a:	5c 01       	movw	r10, r24
   1e22c:	8b 01       	movw	r16, r22
   1e22e:	6a 01       	movw	r12, r20
  struct soArpHeader_t* header 
    = (struct soArpHeader_t*) nicAddPacketHeader(handle, sizeof(struct soArpHeader_t));
   1e230:	6c e1       	ldi	r22, 0x1C	; 28
   1e232:	70 e0       	ldi	r23, 0x00	; 0
   1e234:	0e 94 4e fb 	call	0x1f69c	; 0x1f69c <nicAddPacketHeader>
   1e238:	7c 01       	movw	r14, r24

  // Set Hardwaretype to Ethernet...
  header->htype = 0x0100;
   1e23a:	80 e0       	ldi	r24, 0x00	; 0
   1e23c:	91 e0       	ldi	r25, 0x01	; 1
   1e23e:	f7 01       	movw	r30, r14
   1e240:	91 83       	std	Z+1, r25	; 0x01
   1e242:	80 83       	st	Z, r24
  // ... the protocol is IP
  header->ptype = 0x0008;
   1e244:	88 e0       	ldi	r24, 0x08	; 8
   1e246:	90 e0       	ldi	r25, 0x00	; 0
   1e248:	93 83       	std	Z+3, r25	; 0x03
   1e24a:	82 83       	std	Z+2, r24	; 0x02
  // Ethernet addresses are 6bytes long...
  header->hlen  = 0x06;
   1e24c:	86 e0       	ldi	r24, 0x06	; 6
   1e24e:	84 83       	std	Z+4, r24	; 0x04
  // ... ip adresses are 4bytes.
  header->plen  = 0x04;  
   1e250:	84 e0       	ldi	r24, 0x04	; 4
   1e252:	85 83       	std	Z+5, r24	; 0x05
  
  header->tpa = *tpa;  
   1e254:	f8 01       	movw	r30, r16
   1e256:	80 81       	ld	r24, Z
   1e258:	91 81       	ldd	r25, Z+1	; 0x01
   1e25a:	a2 81       	ldd	r26, Z+2	; 0x02
   1e25c:	b3 81       	ldd	r27, Z+3	; 0x03
   1e25e:	f7 01       	movw	r30, r14
   1e260:	80 8f       	std	Z+24, r24	; 0x18
   1e262:	91 8f       	std	Z+25, r25	; 0x19
   1e264:	a2 8f       	std	Z+26, r26	; 0x1a
   1e266:	b3 8f       	std	Z+27, r27	; 0x1b
  // obtain a copy of the hardware address...
  header->sha = *getHardwareAddress();
   1e268:	0e 94 54 f2 	call	0x1e4a8	; 0x1e4a8 <getHardwareAddress>
   1e26c:	d7 01       	movw	r26, r14
   1e26e:	18 96       	adiw	r26, 0x08	; 8
   1e270:	fc 01       	movw	r30, r24
   1e272:	86 e0       	ldi	r24, 0x06	; 6
   1e274:	01 90       	ld	r0, Z+
   1e276:	0d 92       	st	X+, r0
   1e278:	81 50       	subi	r24, 0x01	; 1
   1e27a:	e1 f7       	brne	.-8      	; 0x1e274 <onArpRequest+0x68>
  // set the ip of the sender;
  header->spa = *ipGetAddress();
   1e27c:	0e 94 06 f3 	call	0x1e60c	; 0x1e60c <ipGetAddress>
   1e280:	fc 01       	movw	r30, r24
   1e282:	80 81       	ld	r24, Z
   1e284:	91 81       	ldd	r25, Z+1	; 0x01
   1e286:	a2 81       	ldd	r26, Z+2	; 0x02
   1e288:	b3 81       	ldd	r27, Z+3	; 0x03
   1e28a:	f7 01       	movw	r30, r14
   1e28c:	86 87       	std	Z+14, r24	; 0x0e
   1e28e:	97 87       	std	Z+15, r25	; 0x0f
   1e290:	a0 8b       	std	Z+16, r26	; 0x10
   1e292:	b1 8b       	std	Z+17, r27	; 0x11
  
  if (tha == NULL)
   1e294:	c1 14       	cp	r12, r1
   1e296:	d1 04       	cpc	r13, r1
   1e298:	d1 f4       	brne	.+52     	; 0x1e2ce <onArpRequest+0xc2>
  {
    header->operation  = ARP_OPCODE_REQUEST; 
   1e29a:	80 e0       	ldi	r24, 0x00	; 0
   1e29c:	91 e0       	ldi	r25, 0x01	; 1
   1e29e:	97 83       	std	Z+7, r25	; 0x07
   1e2a0:	86 83       	std	Z+6, r24	; 0x06
    header->tha.octet1 = 0x0000;
   1e2a2:	12 8a       	std	Z+18, r1	; 0x12
    header->tha.octet2 = 0x0000;
   1e2a4:	13 8a       	std	Z+19, r1	; 0x13
    header->tha.octet3 = 0x0000;
   1e2a6:	14 8a       	std	Z+20, r1	; 0x14
    header->tha.octet4 = 0x0000;
   1e2a8:	15 8a       	std	Z+21, r1	; 0x15
    header->tha.octet5 = 0x0000;
   1e2aa:	16 8a       	std	Z+22, r1	; 0x16
    header->tha.octet6 = 0x0000;
   1e2ac:	17 8a       	std	Z+23, r1	; 0x17
    
    // ARP packets are broadcast packets... 
    struct macAddress_t mac
        = { .octet1 = 0xFF,  .octet2 = 0xFF,  .octet3 = 0xFF,
            .octet4 = 0xFF,  .octet5 = 0xFF,  .octet6 = 0xFF  };
   1e2ae:	de 01       	movw	r26, r28
   1e2b0:	11 96       	adiw	r26, 0x01	; 1
   1e2b2:	e0 e0       	ldi	r30, 0x00	; 0
   1e2b4:	f1 e0       	ldi	r31, 0x01	; 1
   1e2b6:	86 e0       	ldi	r24, 0x06	; 6
   1e2b8:	01 90       	ld	r0, Z+
   1e2ba:	0d 92       	st	X+, r0
   1e2bc:	81 50       	subi	r24, 0x01	; 1
   1e2be:	e1 f7       	brne	.-8      	; 0x1e2b8 <onArpRequest+0xac>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, &mac);
   1e2c0:	c5 01       	movw	r24, r10
   1e2c2:	68 e0       	ldi	r22, 0x08	; 8
   1e2c4:	76 e0       	ldi	r23, 0x06	; 6
   1e2c6:	ae 01       	movw	r20, r28
   1e2c8:	4f 5f       	subi	r20, 0xFF	; 255
   1e2ca:	5f 4f       	sbci	r21, 0xFF	; 255
   1e2cc:	11 c0       	rjmp	.+34     	; 0x1e2f0 <onArpRequest+0xe4>
  }
  else
  {
    header->operation = ARP_OPCODE_RESPONSE;
   1e2ce:	80 e0       	ldi	r24, 0x00	; 0
   1e2d0:	92 e0       	ldi	r25, 0x02	; 2
   1e2d2:	f7 01       	movw	r30, r14
   1e2d4:	97 83       	std	Z+7, r25	; 0x07
   1e2d6:	86 83       	std	Z+6, r24	; 0x06
    header->tha = *tha;
   1e2d8:	d7 01       	movw	r26, r14
   1e2da:	52 96       	adiw	r26, 0x12	; 18
   1e2dc:	f6 01       	movw	r30, r12
   1e2de:	86 e0       	ldi	r24, 0x06	; 6
   1e2e0:	01 90       	ld	r0, Z+
   1e2e2:	0d 92       	st	X+, r0
   1e2e4:	81 50       	subi	r24, 0x01	; 1
   1e2e6:	e1 f7       	brne	.-8      	; 0x1e2e0 <onArpRequest+0xd4>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, tha);
   1e2e8:	c5 01       	movw	r24, r10
   1e2ea:	68 e0       	ldi	r22, 0x08	; 8
   1e2ec:	76 e0       	ldi	r23, 0x06	; 6
   1e2ee:	a6 01       	movw	r20, r12
   1e2f0:	0e 94 cf f2 	call	0x1e59e	; 0x1e59e <onEthernetRequest>
  }  
  
}
   1e2f4:	26 96       	adiw	r28, 0x06	; 6
   1e2f6:	0f b6       	in	r0, 0x3f	; 63
   1e2f8:	f8 94       	cli
   1e2fa:	de bf       	out	0x3e, r29	; 62
   1e2fc:	0f be       	out	0x3f, r0	; 63
   1e2fe:	cd bf       	out	0x3d, r28	; 61
   1e300:	cf 91       	pop	r28
   1e302:	df 91       	pop	r29
   1e304:	1f 91       	pop	r17
   1e306:	0f 91       	pop	r16
   1e308:	ff 90       	pop	r15
   1e30a:	ef 90       	pop	r14
   1e30c:	df 90       	pop	r13
   1e30e:	cf 90       	pop	r12
   1e310:	bf 90       	pop	r11
   1e312:	af 90       	pop	r10
   1e314:	08 95       	ret

0001e316 <arpSendResponse>:
    
  return onArpRequest(handle,tpa,NULL);
}

uint8_t arpSendResponse(ipAddress_t* tpa,  struct macAddress_t* tha)
{  
   1e316:	ef 92       	push	r14
   1e318:	ff 92       	push	r15
   1e31a:	0f 93       	push	r16
   1e31c:	1f 93       	push	r17
   1e31e:	8c 01       	movw	r16, r24
   1e320:	7b 01       	movw	r14, r22
  struct nicRequestHandle_t* handle = nicNewRequest();
   1e322:	0e 94 86 fb 	call	0x1f70c	; 0x1f70c <nicNewRequest>
  
  return onArpRequest(handle,tpa,tha);
   1e326:	b8 01       	movw	r22, r16
   1e328:	a7 01       	movw	r20, r14
   1e32a:	0e 94 06 f1 	call	0x1e20c	; 0x1e20c <onArpRequest>
}
   1e32e:	1f 91       	pop	r17
   1e330:	0f 91       	pop	r16
   1e332:	ff 90       	pop	r15
   1e334:	ef 90       	pop	r14
   1e336:	08 95       	ret

0001e338 <onArpResponse>:
  }  
  
}

void onArpResponse(struct nicResponseHandle_t* response, struct macAddress_t* source)
{
   1e338:	ef 92       	push	r14
   1e33a:	ff 92       	push	r15
   1e33c:	0f 93       	push	r16
   1e33e:	1f 93       	push	r17
   1e340:	df 93       	push	r29
   1e342:	cf 93       	push	r28
   1e344:	cd b7       	in	r28, 0x3d	; 61
   1e346:	de b7       	in	r29, 0x3e	; 62
   1e348:	6c 97       	sbiw	r28, 0x1c	; 28
   1e34a:	0f b6       	in	r0, 0x3f	; 63
   1e34c:	f8 94       	cli
   1e34e:	de bf       	out	0x3e, r29	; 62
   1e350:	0f be       	out	0x3f, r0	; 63
   1e352:	cd bf       	out	0x3d, r28	; 61
   1e354:	8c 01       	movw	r16, r24
  // drop if header invalid...
  if (nicResponseSize(response) < sizeof(struct soArpHeader_t))
   1e356:	0e 94 cd fa 	call	0x1f59a	; 0x1f59a <nicResponseSize>
   1e35a:	4c 97       	sbiw	r24, 0x1c	; 28
   1e35c:	08 f4       	brcc	.+2      	; 0x1e360 <onArpResponse+0x28>
   1e35e:	3f c0       	rjmp	.+126    	; 0x1e3de <onArpResponse+0xa6>
    return;  
      
  struct soArpHeader_t header;
  nicResponseRead(response,(char*)(&header),sizeof(header));
   1e360:	c8 01       	movw	r24, r16
   1e362:	be 01       	movw	r22, r28
   1e364:	6f 5f       	subi	r22, 0xFF	; 255
   1e366:	7f 4f       	sbci	r23, 0xFF	; 255
   1e368:	4c e1       	ldi	r20, 0x1C	; 28
   1e36a:	50 e0       	ldi	r21, 0x00	; 0
   1e36c:	0e 94 d7 fa 	call	0x1f5ae	; 0x1f5ae <nicResponseRead>

  // check if the arprequest is understandable
  if ((header.htype != ntohs(0x0001)) || (header.ptype != ntohs(0x0800))
   1e370:	89 81       	ldd	r24, Y+1	; 0x01
   1e372:	9a 81       	ldd	r25, Y+2	; 0x02
   1e374:	80 50       	subi	r24, 0x00	; 0
   1e376:	91 40       	sbci	r25, 0x01	; 1
   1e378:	91 f5       	brne	.+100    	; 0x1e3de <onArpResponse+0xa6>
   1e37a:	8b 81       	ldd	r24, Y+3	; 0x03
   1e37c:	9c 81       	ldd	r25, Y+4	; 0x04
   1e37e:	08 97       	sbiw	r24, 0x08	; 8
   1e380:	71 f5       	brne	.+92     	; 0x1e3de <onArpResponse+0xa6>
   1e382:	8d 81       	ldd	r24, Y+5	; 0x05
   1e384:	86 30       	cpi	r24, 0x06	; 6
   1e386:	59 f5       	brne	.+86     	; 0x1e3de <onArpResponse+0xa6>
   1e388:	8e 81       	ldd	r24, Y+6	; 0x06
   1e38a:	84 30       	cpi	r24, 0x04	; 4
   1e38c:	41 f5       	brne	.+80     	; 0x1e3de <onArpResponse+0xa6>
        || (header.hlen != 0x06) || (header.plen != 0x04))    
    return;
  
  // Someone talking to us?
  if (header.tpa != *ipGetAddress())
   1e38e:	e9 8c       	ldd	r14, Y+25	; 0x19
   1e390:	fa 8c       	ldd	r15, Y+26	; 0x1a
   1e392:	0b 8d       	ldd	r16, Y+27	; 0x1b
   1e394:	1c 8d       	ldd	r17, Y+28	; 0x1c
   1e396:	0e 94 06 f3 	call	0x1e60c	; 0x1e60c <ipGetAddress>
   1e39a:	fc 01       	movw	r30, r24
   1e39c:	80 81       	ld	r24, Z
   1e39e:	91 81       	ldd	r25, Z+1	; 0x01
   1e3a0:	a2 81       	ldd	r26, Z+2	; 0x02
   1e3a2:	b3 81       	ldd	r27, Z+3	; 0x03
   1e3a4:	e8 16       	cp	r14, r24
   1e3a6:	f9 06       	cpc	r15, r25
   1e3a8:	0a 07       	cpc	r16, r26
   1e3aa:	1b 07       	cpc	r17, r27
   1e3ac:	c1 f4       	brne	.+48     	; 0x1e3de <onArpResponse+0xa6>
    return;
   
  switch (header.operation)
   1e3ae:	8f 81       	ldd	r24, Y+7	; 0x07
   1e3b0:	98 85       	ldd	r25, Y+8	; 0x08
   1e3b2:	21 e0       	ldi	r18, 0x01	; 1
   1e3b4:	80 30       	cpi	r24, 0x00	; 0
   1e3b6:	92 07       	cpc	r25, r18
   1e3b8:	21 f0       	breq	.+8      	; 0x1e3c2 <onArpResponse+0x8a>
   1e3ba:	80 50       	subi	r24, 0x00	; 0
   1e3bc:	92 40       	sbci	r25, 0x02	; 2
   1e3be:	79 f4       	brne	.+30     	; 0x1e3de <onArpResponse+0xa6>
   1e3c0:	07 c0       	rjmp	.+14     	; 0x1e3d0 <onArpResponse+0x98>
  {
    case ARP_OPCODE_REQUEST:
      // it's an arp discover, tell him who we are...
      arpSendResponse(&header.spa,&header.sha);
   1e3c2:	ce 01       	movw	r24, r28
   1e3c4:	0f 96       	adiw	r24, 0x0f	; 15
   1e3c6:	be 01       	movw	r22, r28
   1e3c8:	67 5f       	subi	r22, 0xF7	; 247
   1e3ca:	7f 4f       	sbci	r23, 0xFF	; 255
   1e3cc:	0e 94 8b f1 	call	0x1e316	; 0x1e316 <arpSendResponse>
      // ... and then add the mac address...
      // ... yes, here is no break missing, its a fall through statement
    case ARP_OPCODE_RESPONSE:
      // it's an arp reply, update the arp table
      arpAddMacByIPv4(&header.spa,&header.sha);      
   1e3d0:	ce 01       	movw	r24, r28
   1e3d2:	0f 96       	adiw	r24, 0x0f	; 15
   1e3d4:	be 01       	movw	r22, r28
   1e3d6:	67 5f       	subi	r22, 0xF7	; 247
   1e3d8:	7f 4f       	sbci	r23, 0xFF	; 255
   1e3da:	0e 94 7c f0 	call	0x1e0f8	; 0x1e0f8 <arpAddMacByIPv4>
    default:
      break;
  }
  
  return;
}
   1e3de:	6c 96       	adiw	r28, 0x1c	; 28
   1e3e0:	0f b6       	in	r0, 0x3f	; 63
   1e3e2:	f8 94       	cli
   1e3e4:	de bf       	out	0x3e, r29	; 62
   1e3e6:	0f be       	out	0x3f, r0	; 63
   1e3e8:	cd bf       	out	0x3d, r28	; 61
   1e3ea:	cf 91       	pop	r28
   1e3ec:	df 91       	pop	r29
   1e3ee:	1f 91       	pop	r17
   1e3f0:	0f 91       	pop	r16
   1e3f2:	ff 90       	pop	r15
   1e3f4:	ef 90       	pop	r14
   1e3f6:	08 95       	ret

0001e3f8 <arpSendRequest>:
  struct macAddress_t tha; // target hardware address, needs to be 0 on requests
  ipAddress_t tpa;             // target protocol address
};

uint8_t arpSendRequest(ipAddress_t* tpa)
{  
   1e3f8:	0f 93       	push	r16
   1e3fa:	1f 93       	push	r17
   1e3fc:	8c 01       	movw	r16, r24
  struct nicRequestHandle_t* handle = nicNewRequest();    
   1e3fe:	0e 94 86 fb 	call	0x1f70c	; 0x1f70c <nicNewRequest>
    
  return onArpRequest(handle,tpa,NULL);
   1e402:	b8 01       	movw	r22, r16
   1e404:	40 e0       	ldi	r20, 0x00	; 0
   1e406:	50 e0       	ldi	r21, 0x00	; 0
   1e408:	0e 94 06 f1 	call	0x1e20c	; 0x1e20c <onArpRequest>
}
   1e40c:	1f 91       	pop	r17
   1e40e:	0f 91       	pop	r16
   1e410:	08 95       	ret

0001e412 <arpLookupMacByIPv4>:
  
  return 0;
}

uint8_t arpLookupMacByIPv4(ipAddress_t* ip, struct macAddress_t* mac)
{  
   1e412:	0f 93       	push	r16
   1e414:	1f 93       	push	r17
   1e416:	cf 93       	push	r28
   1e418:	df 93       	push	r29
   1e41a:	ec 01       	movw	r28, r24
   1e41c:	16 2f       	mov	r17, r22
   1e41e:	07 2f       	mov	r16, r23
   1e420:	ec e9       	ldi	r30, 0x9C	; 156
   1e422:	f1 e0       	ldi	r31, 0x01	; 1
   1e424:	65 e0       	ldi	r22, 0x05	; 5
   1e426:	70 e0       	ldi	r23, 0x00	; 0
   1e428:	33 c0       	rjmp	.+102    	; 0x1e490 <arpLookupMacByIPv4+0x7e>

  int i = ARP_CACHE_SIZE;
  
  // check for a direct hit...
  while (i--)
   1e42a:	61 50       	subi	r22, 0x01	; 1
   1e42c:	70 40       	sbci	r23, 0x00	; 0
  {
    if (hArp.arpCache[i].ip == *ip)
   1e42e:	20 81       	ld	r18, Z
   1e430:	31 81       	ldd	r19, Z+1	; 0x01
   1e432:	42 81       	ldd	r20, Z+2	; 0x02
   1e434:	53 81       	ldd	r21, Z+3	; 0x03
   1e436:	3b 97       	sbiw	r30, 0x0b	; 11
   1e438:	88 81       	ld	r24, Y
   1e43a:	99 81       	ldd	r25, Y+1	; 0x01
   1e43c:	aa 81       	ldd	r26, Y+2	; 0x02
   1e43e:	bb 81       	ldd	r27, Y+3	; 0x03
   1e440:	28 17       	cp	r18, r24
   1e442:	39 07       	cpc	r19, r25
   1e444:	4a 07       	cpc	r20, r26
   1e446:	5b 07       	cpc	r21, r27
   1e448:	19 f5       	brne	.+70     	; 0x1e490 <arpLookupMacByIPv4+0x7e>
    {
      // copy the mac addres into the buffer
      *mac = hArp.arpCache[i].mac;
   1e44a:	8b e0       	ldi	r24, 0x0B	; 11
   1e44c:	90 e0       	ldi	r25, 0x00	; 0
   1e44e:	68 9f       	mul	r22, r24
   1e450:	f0 01       	movw	r30, r0
   1e452:	69 9f       	mul	r22, r25
   1e454:	f0 0d       	add	r31, r0
   1e456:	78 9f       	mul	r23, r24
   1e458:	f0 0d       	add	r31, r0
   1e45a:	11 24       	eor	r1, r1
   1e45c:	21 2f       	mov	r18, r17
   1e45e:	30 2f       	mov	r19, r16
   1e460:	c9 01       	movw	r24, r18
   1e462:	dc 01       	movw	r26, r24
   1e464:	e6 59       	subi	r30, 0x96	; 150
   1e466:	fe 4f       	sbci	r31, 0xFE	; 254
   1e468:	86 e0       	ldi	r24, 0x06	; 6
   1e46a:	01 90       	ld	r0, Z+
   1e46c:	0d 92       	st	X+, r0
   1e46e:	81 50       	subi	r24, 0x01	; 1
   1e470:	e1 f7       	brne	.-8      	; 0x1e46a <arpLookupMacByIPv4+0x58>
      // and reset the age, as is was most recently used
      hArp.arpCache[i].age = 255;
   1e472:	8b e0       	ldi	r24, 0x0B	; 11
   1e474:	90 e0       	ldi	r25, 0x00	; 0
   1e476:	68 9f       	mul	r22, r24
   1e478:	f0 01       	movw	r30, r0
   1e47a:	69 9f       	mul	r22, r25
   1e47c:	f0 0d       	add	r31, r0
   1e47e:	78 9f       	mul	r23, r24
   1e480:	f0 0d       	add	r31, r0
   1e482:	11 24       	eor	r1, r1
   1e484:	e6 59       	subi	r30, 0x96	; 150
   1e486:	fe 4f       	sbci	r31, 0xFE	; 254
   1e488:	8f ef       	ldi	r24, 0xFF	; 255
   1e48a:	82 87       	std	Z+10, r24	; 0x0a
   1e48c:	80 e0       	ldi	r24, 0x00	; 0
   1e48e:	07 c0       	rjmp	.+14     	; 0x1e49e <arpLookupMacByIPv4+0x8c>
{  

  int i = ARP_CACHE_SIZE;
  
  // check for a direct hit...
  while (i--)
   1e490:	61 15       	cp	r22, r1
   1e492:	71 05       	cpc	r23, r1
   1e494:	51 f6       	brne	.-108    	; 0x1e42a <arpLookupMacByIPv4+0x18>
      return 0;
    }
  }
  
  // ... no hit? Send a request
  arpSendRequest(ip);
   1e496:	ce 01       	movw	r24, r28
   1e498:	0e 94 fc f1 	call	0x1e3f8	; 0x1e3f8 <arpSendRequest>
   1e49c:	81 e0       	ldi	r24, 0x01	; 1
  // ...and return an error
  return 1;
}
   1e49e:	df 91       	pop	r29
   1e4a0:	cf 91       	pop	r28
   1e4a2:	1f 91       	pop	r17
   1e4a4:	0f 91       	pop	r16
   1e4a6:	08 95       	ret

0001e4a8 <getHardwareAddress>:
// yes you realy get a pointer, this is for performance consideration
// never ever change the value of this pointer!
struct macAddress_t* getHardwareAddress()
{
  return &hEthernetAddress;
}
   1e4a8:	86 e0       	ldi	r24, 0x06	; 6
   1e4aa:	91 e0       	ldi	r25, 0x01	; 1
   1e4ac:	08 95       	ret

0001e4ae <onInitEthernet>:
  onEthernetResponse(response);
  nicFreeResponse(response);
}

void onInitEthernet()
{
   1e4ae:	0f 93       	push	r16
   1e4b0:	1f 93       	push	r17
   1e4b2:	df 93       	push	r29
   1e4b4:	cf 93       	push	r28
   1e4b6:	00 d0       	rcall	.+0      	; 0x1e4b8 <onInitEthernet+0xa>
   1e4b8:	00 d0       	rcall	.+0      	; 0x1e4ba <onInitEthernet+0xc>
   1e4ba:	00 d0       	rcall	.+0      	; 0x1e4bc <onInitEthernet+0xe>
   1e4bc:	cd b7       	in	r28, 0x3d	; 61
   1e4be:	de b7       	in	r29, 0x3e	; 62
  // define a struct for the configuration...
  netEthernetEeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)MAC_EEPROM, &buf, sizeof(buf)) ) {
   1e4c0:	80 e0       	ldi	r24, 0x00	; 0
   1e4c2:	92 e0       	ldi	r25, 0x02	; 2
   1e4c4:	8e 01       	movw	r16, r28
   1e4c6:	0f 5f       	subi	r16, 0xFF	; 255
   1e4c8:	1f 4f       	sbci	r17, 0xFF	; 255
   1e4ca:	b8 01       	movw	r22, r16
   1e4cc:	46 e0       	ldi	r20, 0x06	; 6
   1e4ce:	0e 94 64 fe 	call	0x1fcc8	; 0x1fcc8 <EepromReadConfig>
   1e4d2:	88 23       	and	r24, r24
   1e4d4:	41 f0       	breq	.+16     	; 0x1e4e6 <onInitEthernet+0x38>
    hEthernetAddress = buf.mac;
   1e4d6:	a6 e0       	ldi	r26, 0x06	; 6
   1e4d8:	b1 e0       	ldi	r27, 0x01	; 1
   1e4da:	f8 01       	movw	r30, r16
   1e4dc:	86 e0       	ldi	r24, 0x06	; 6
   1e4de:	01 90       	ld	r0, Z+
   1e4e0:	0d 92       	st	X+, r0
   1e4e2:	81 50       	subi	r24, 0x01	; 1
   1e4e4:	e1 f7       	brne	.-8      	; 0x1e4de <onInitEthernet+0x30>
  }
  // else hEthernetAddress keeps the fallback settings

  nicInitialize(&hEthernetAddress);
   1e4e6:	86 e0       	ldi	r24, 0x06	; 6
   1e4e8:	91 e0       	ldi	r25, 0x01	; 1
   1e4ea:	0e 94 b0 fb 	call	0x1f760	; 0x1f760 <nicInitialize>
  
  onInitArp();
   1e4ee:	0e 94 e1 f0 	call	0x1e1c2	; 0x1e1c2 <onInitArp>
  onInitIPv4();  
   1e4f2:	0e 94 09 f3 	call	0x1e612	; 0x1e612 <onInitIPv4>

  return;
}
   1e4f6:	26 96       	adiw	r28, 0x06	; 6
   1e4f8:	0f b6       	in	r0, 0x3f	; 63
   1e4fa:	f8 94       	cli
   1e4fc:	de bf       	out	0x3e, r29	; 62
   1e4fe:	0f be       	out	0x3f, r0	; 63
   1e500:	cd bf       	out	0x3d, r28	; 61
   1e502:	cf 91       	pop	r28
   1e504:	df 91       	pop	r29
   1e506:	1f 91       	pop	r17
   1e508:	0f 91       	pop	r16
   1e50a:	08 95       	ret

0001e50c <onEthernetResponse>:
	
  return 0;
}
  
void onEthernetResponse(struct nicResponseHandle_t* handle)
{
   1e50c:	0f 93       	push	r16
   1e50e:	1f 93       	push	r17
   1e510:	df 93       	push	r29
   1e512:	cf 93       	push	r28
   1e514:	cd b7       	in	r28, 0x3d	; 61
   1e516:	de b7       	in	r29, 0x3e	; 62
   1e518:	2e 97       	sbiw	r28, 0x0e	; 14
   1e51a:	0f b6       	in	r0, 0x3f	; 63
   1e51c:	f8 94       	cli
   1e51e:	de bf       	out	0x3e, r29	; 62
   1e520:	0f be       	out	0x3f, r0	; 63
   1e522:	cd bf       	out	0x3d, r28	; 61
   1e524:	8c 01       	movw	r16, r24
  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
   1e526:	0e 94 cd fa 	call	0x1f59a	; 0x1f59a <nicResponseSize>
   1e52a:	0e 97       	sbiw	r24, 0x0e	; 14
   1e52c:	f0 f0       	brcs	.+60     	; 0x1e56a <onEthernetResponse+0x5e>
	  return;
	
  struct netEthernetHeader_t header;
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
   1e52e:	c8 01       	movw	r24, r16
   1e530:	be 01       	movw	r22, r28
   1e532:	6f 5f       	subi	r22, 0xFF	; 255
   1e534:	7f 4f       	sbci	r23, 0xFF	; 255
   1e536:	4e e0       	ldi	r20, 0x0E	; 14
   1e538:	50 e0       	ldi	r21, 0x00	; 0
   1e53a:	0e 94 d7 fa 	call	0x1f5ae	; 0x1f5ae <nicResponseRead>
	
  switch (header.etherType)
   1e53e:	8d 85       	ldd	r24, Y+13	; 0x0d
   1e540:	9e 85       	ldd	r25, Y+14	; 0x0e
   1e542:	88 30       	cpi	r24, 0x08	; 8
   1e544:	91 05       	cpc	r25, r1
   1e546:	21 f0       	breq	.+8      	; 0x1e550 <onEthernetResponse+0x44>
   1e548:	88 50       	subi	r24, 0x08	; 8
   1e54a:	96 40       	sbci	r25, 0x06	; 6
   1e54c:	71 f4       	brne	.+28     	; 0x1e56a <onEthernetResponse+0x5e>
   1e54e:	07 c0       	rjmp	.+14     	; 0x1e55e <onEthernetResponse+0x52>
  {
    case ETHERTYPE_IP4:
      onIPv4Response(handle,&(header.source));
   1e550:	c8 01       	movw	r24, r16
   1e552:	be 01       	movw	r22, r28
   1e554:	69 5f       	subi	r22, 0xF9	; 249
   1e556:	7f 4f       	sbci	r23, 0xFF	; 255
   1e558:	0e 94 fa f3 	call	0x1e7f4	; 0x1e7f4 <onIPv4Response>
   1e55c:	06 c0       	rjmp	.+12     	; 0x1e56a <onEthernetResponse+0x5e>
      break;
    case ETHERTYPE_ARP:
      onArpResponse(handle,&(header.source));
   1e55e:	c8 01       	movw	r24, r16
   1e560:	be 01       	movw	r22, r28
   1e562:	69 5f       	subi	r22, 0xF9	; 249
   1e564:	7f 4f       	sbci	r23, 0xFF	; 255
   1e566:	0e 94 9c f1 	call	0x1e338	; 0x1e338 <onArpResponse>
      break;
  }

  return;	
}                      
   1e56a:	2e 96       	adiw	r28, 0x0e	; 14
   1e56c:	0f b6       	in	r0, 0x3f	; 63
   1e56e:	f8 94       	cli
   1e570:	de bf       	out	0x3e, r29	; 62
   1e572:	0f be       	out	0x3f, r0	; 63
   1e574:	cd bf       	out	0x3d, r28	; 61
   1e576:	cf 91       	pop	r28
   1e578:	df 91       	pop	r29
   1e57a:	1f 91       	pop	r17
   1e57c:	0f 91       	pop	r16
   1e57e:	08 95       	ret

0001e580 <onEthernet>:

void onEthernet()
{
   1e580:	cf 93       	push	r28
   1e582:	df 93       	push	r29
  struct nicResponseHandle_t* response
      = nicReceiveResponse();
   1e584:	0e 94 8e fb 	call	0x1f71c	; 0x1f71c <nicReceiveResponse>
   1e588:	ec 01       	movw	r28, r24
        
  if (response == NULL)
   1e58a:	00 97       	sbiw	r24, 0x00	; 0
   1e58c:	29 f0       	breq	.+10     	; 0x1e598 <onEthernet+0x18>
    return;
    
  onEthernetResponse(response);
   1e58e:	0e 94 86 f2 	call	0x1e50c	; 0x1e50c <onEthernetResponse>
  nicFreeResponse(response);
   1e592:	ce 01       	movw	r24, r28
   1e594:	0e 94 f5 fa 	call	0x1f5ea	; 0x1f5ea <nicFreeResponse>
}
   1e598:	df 91       	pop	r29
   1e59a:	cf 91       	pop	r28
   1e59c:	08 95       	ret

0001e59e <onEthernetRequest>:
  return &hEthernetAddress;
}

uint8_t onEthernetRequest(struct nicRequestHandle_t* handle, uint16_t type, 
                        struct macAddress_t* destMac)
{
   1e59e:	cf 92       	push	r12
   1e5a0:	df 92       	push	r13
   1e5a2:	ef 92       	push	r14
   1e5a4:	ff 92       	push	r15
   1e5a6:	0f 93       	push	r16
   1e5a8:	1f 93       	push	r17
   1e5aa:	cf 93       	push	r28
   1e5ac:	df 93       	push	r29
   1e5ae:	7c 01       	movw	r14, r24
   1e5b0:	6b 01       	movw	r12, r22
   1e5b2:	14 2f       	mov	r17, r20
   1e5b4:	05 2f       	mov	r16, r21
	struct netEthernetHeader_t* header
	    = (struct netEthernetHeader_t*) nicAddPacketHeader(handle,sizeof(struct netEthernetHeader_t));
   1e5b6:	6e e0       	ldi	r22, 0x0E	; 14
   1e5b8:	70 e0       	ldi	r23, 0x00	; 0
   1e5ba:	0e 94 4e fb 	call	0x1f69c	; 0x1f69c <nicAddPacketHeader>
   1e5be:	fc 01       	movw	r30, r24
	
	header->destination = *destMac;
   1e5c0:	ec 01       	movw	r28, r24
   1e5c2:	21 2f       	mov	r18, r17
   1e5c4:	30 2f       	mov	r19, r16
   1e5c6:	c9 01       	movw	r24, r18
   1e5c8:	dc 01       	movw	r26, r24
   1e5ca:	86 e0       	ldi	r24, 0x06	; 6
   1e5cc:	0d 90       	ld	r0, X+
   1e5ce:	09 92       	st	Y+, r0
   1e5d0:	81 50       	subi	r24, 0x01	; 1
   1e5d2:	e1 f7       	brne	.-8      	; 0x1e5cc <onEthernetRequest+0x2e>
	header->source      = *(getHardwareAddress());
   1e5d4:	ef 01       	movw	r28, r30
   1e5d6:	26 96       	adiw	r28, 0x06	; 6
   1e5d8:	a6 e0       	ldi	r26, 0x06	; 6
   1e5da:	b1 e0       	ldi	r27, 0x01	; 1
   1e5dc:	86 e0       	ldi	r24, 0x06	; 6
   1e5de:	0d 90       	ld	r0, X+
   1e5e0:	09 92       	st	Y+, r0
   1e5e2:	81 50       	subi	r24, 0x01	; 1
   1e5e4:	e1 f7       	brne	.-8      	; 0x1e5de <onEthernetRequest+0x40>
	header->etherType   = type;
   1e5e6:	d5 86       	std	Z+13, r13	; 0x0d
   1e5e8:	c4 86       	std	Z+12, r12	; 0x0c
	
	nicSendPacket(handle,0x00);
   1e5ea:	c7 01       	movw	r24, r14
   1e5ec:	60 e0       	ldi	r22, 0x00	; 0
   1e5ee:	0e 94 2d fc 	call	0x1f85a	; 0x1f85a <nicSendPacket>
	
	nicFreeRequest(handle);
   1e5f2:	c7 01       	movw	r24, r14
   1e5f4:	0e 94 16 fb 	call	0x1f62c	; 0x1f62c <nicFreeRequest>
	
  return 0;
}
   1e5f8:	80 e0       	ldi	r24, 0x00	; 0
   1e5fa:	df 91       	pop	r29
   1e5fc:	cf 91       	pop	r28
   1e5fe:	1f 91       	pop	r17
   1e600:	0f 91       	pop	r16
   1e602:	ff 90       	pop	r15
   1e604:	ef 90       	pop	r14
   1e606:	df 90       	pop	r13
   1e608:	cf 90       	pop	r12
   1e60a:	08 95       	ret

0001e60c <ipGetAddress>:
}

ipAddress_t* ipGetAddress()
{
  return &(hIPv4.host);
}
   1e60c:	8c e0       	ldi	r24, 0x0C	; 12
   1e60e:	91 e0       	ldi	r25, 0x01	; 1
   1e610:	08 95       	ret

0001e612 <onInitIPv4>:

void onInitIPv4()
{
   1e612:	df 93       	push	r29
   1e614:	cf 93       	push	r28
   1e616:	cd b7       	in	r28, 0x3d	; 61
   1e618:	de b7       	in	r29, 0x3e	; 62
   1e61a:	2c 97       	sbiw	r28, 0x0c	; 12
   1e61c:	0f b6       	in	r0, 0x3f	; 63
   1e61e:	f8 94       	cli
   1e620:	de bf       	out	0x3e, r29	; 62
   1e622:	0f be       	out	0x3f, r0	; 63
   1e624:	cd bf       	out	0x3d, r28	; 61
  // define a struct for the configuration...
  netIPv4Eeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)IP4_EEPROM, &buf, sizeof(buf)) ) { 
   1e626:	80 e0       	ldi	r24, 0x00	; 0
   1e628:	91 e0       	ldi	r25, 0x01	; 1
   1e62a:	be 01       	movw	r22, r28
   1e62c:	6f 5f       	subi	r22, 0xFF	; 255
   1e62e:	7f 4f       	sbci	r23, 0xFF	; 255
   1e630:	4c e0       	ldi	r20, 0x0C	; 12
   1e632:	0e 94 64 fe 	call	0x1fcc8	; 0x1fcc8 <EepromReadConfig>
   1e636:	88 23       	and	r24, r24
   1e638:	21 f1       	breq	.+72     	; 0x1e682 <onInitIPv4+0x70>
    hIPv4.host    = buf.host;
   1e63a:	89 81       	ldd	r24, Y+1	; 0x01
   1e63c:	9a 81       	ldd	r25, Y+2	; 0x02
   1e63e:	ab 81       	ldd	r26, Y+3	; 0x03
   1e640:	bc 81       	ldd	r27, Y+4	; 0x04
   1e642:	80 93 0c 01 	sts	0x010C, r24
   1e646:	90 93 0d 01 	sts	0x010D, r25
   1e64a:	a0 93 0e 01 	sts	0x010E, r26
   1e64e:	b0 93 0f 01 	sts	0x010F, r27
    hIPv4.gateway = buf.gateway;
   1e652:	89 85       	ldd	r24, Y+9	; 0x09
   1e654:	9a 85       	ldd	r25, Y+10	; 0x0a
   1e656:	ab 85       	ldd	r26, Y+11	; 0x0b
   1e658:	bc 85       	ldd	r27, Y+12	; 0x0c
   1e65a:	80 93 10 01 	sts	0x0110, r24
   1e65e:	90 93 11 01 	sts	0x0111, r25
   1e662:	a0 93 12 01 	sts	0x0112, r26
   1e666:	b0 93 13 01 	sts	0x0113, r27
    hIPv4.subnet  = buf.subnet;
   1e66a:	8d 81       	ldd	r24, Y+5	; 0x05
   1e66c:	9e 81       	ldd	r25, Y+6	; 0x06
   1e66e:	af 81       	ldd	r26, Y+7	; 0x07
   1e670:	b8 85       	ldd	r27, Y+8	; 0x08
   1e672:	80 93 14 01 	sts	0x0114, r24
   1e676:	90 93 15 01 	sts	0x0115, r25
   1e67a:	a0 93 16 01 	sts	0x0116, r26
   1e67e:	b0 93 17 01 	sts	0x0117, r27
  }
  // else hIPv4 keeps the fallback settings
    
  return;
}
   1e682:	2c 96       	adiw	r28, 0x0c	; 12
   1e684:	0f b6       	in	r0, 0x3f	; 63
   1e686:	f8 94       	cli
   1e688:	de bf       	out	0x3e, r29	; 62
   1e68a:	0f be       	out	0x3f, r0	; 63
   1e68c:	cd bf       	out	0x3d, r28	; 61
   1e68e:	cf 91       	pop	r28
   1e690:	df 91       	pop	r29
   1e692:	08 95       	ret

0001e694 <onIPv4Request>:
  
  return;
}

uint8_t onIPv4Request(struct nicRequestHandle_t* handle, ipAddress_t* destIP, uint8_t protocol)
{
   1e694:	8f 92       	push	r8
   1e696:	9f 92       	push	r9
   1e698:	af 92       	push	r10
   1e69a:	bf 92       	push	r11
   1e69c:	cf 92       	push	r12
   1e69e:	df 92       	push	r13
   1e6a0:	ef 92       	push	r14
   1e6a2:	ff 92       	push	r15
   1e6a4:	0f 93       	push	r16
   1e6a6:	1f 93       	push	r17
   1e6a8:	df 93       	push	r29
   1e6aa:	cf 93       	push	r28
   1e6ac:	00 d0       	rcall	.+0      	; 0x1e6ae <onIPv4Request+0x1a>
   1e6ae:	00 d0       	rcall	.+0      	; 0x1e6b0 <onIPv4Request+0x1c>
   1e6b0:	00 d0       	rcall	.+0      	; 0x1e6b2 <onIPv4Request+0x1e>
   1e6b2:	cd b7       	in	r28, 0x3d	; 61
   1e6b4:	de b7       	in	r29, 0x3e	; 62
   1e6b6:	6c 01       	movw	r12, r24
   1e6b8:	5b 01       	movw	r10, r22
   1e6ba:	e4 2e       	mov	r14, r20
  struct macAddress_t mac;
  
  // check if destination address is within the subnet...
  // ... in case it is not, we have to send the packet to the gateway ...
  // ... yes this nested if is nasty, but we need the performance.
  if (arpLookupMacByIPv4(
   1e6bc:	fb 01       	movw	r30, r22
   1e6be:	80 81       	ld	r24, Z
   1e6c0:	91 81       	ldd	r25, Z+1	; 0x01
   1e6c2:	a2 81       	ldd	r26, Z+2	; 0x02
   1e6c4:	b3 81       	ldd	r27, Z+3	; 0x03
   1e6c6:	20 91 10 01 	lds	r18, 0x0110
   1e6ca:	30 91 11 01 	lds	r19, 0x0111
   1e6ce:	40 91 12 01 	lds	r20, 0x0112
   1e6d2:	50 91 13 01 	lds	r21, 0x0113
   1e6d6:	82 27       	eor	r24, r18
   1e6d8:	93 27       	eor	r25, r19
   1e6da:	a4 27       	eor	r26, r20
   1e6dc:	b5 27       	eor	r27, r21
   1e6de:	20 91 14 01 	lds	r18, 0x0114
   1e6e2:	30 91 15 01 	lds	r19, 0x0115
   1e6e6:	40 91 16 01 	lds	r20, 0x0116
   1e6ea:	50 91 17 01 	lds	r21, 0x0117
   1e6ee:	82 23       	and	r24, r18
   1e6f0:	93 23       	and	r25, r19
   1e6f2:	a4 23       	and	r26, r20
   1e6f4:	b5 23       	and	r27, r21
   1e6f6:	00 97       	sbiw	r24, 0x00	; 0
   1e6f8:	a1 05       	cpc	r26, r1
   1e6fa:	b1 05       	cpc	r27, r1
   1e6fc:	11 f4       	brne	.+4      	; 0x1e702 <onIPv4Request+0x6e>
   1e6fe:	cb 01       	movw	r24, r22
   1e700:	02 c0       	rjmp	.+4      	; 0x1e706 <onIPv4Request+0x72>
   1e702:	80 e1       	ldi	r24, 0x10	; 16
   1e704:	91 e0       	ldi	r25, 0x01	; 1
   1e706:	4e 01       	movw	r8, r28
   1e708:	08 94       	sec
   1e70a:	81 1c       	adc	r8, r1
   1e70c:	91 1c       	adc	r9, r1
   1e70e:	b4 01       	movw	r22, r8
   1e710:	0e 94 09 f2 	call	0x1e412	; 0x1e412 <arpLookupMacByIPv4>
   1e714:	88 23       	and	r24, r24
   1e716:	29 f0       	breq	.+10     	; 0x1e722 <onIPv4Request+0x8e>
      ((((*destIP) & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))?destIP:&hIPv4.gateway),
      &mac) != 0)
  {
    nicFreeRequest(handle);
   1e718:	c6 01       	movw	r24, r12
   1e71a:	0e 94 16 fb 	call	0x1f62c	; 0x1f62c <nicFreeRequest>
   1e71e:	81 e0       	ldi	r24, 0x01	; 1
   1e720:	56 c0       	rjmp	.+172    	; 0x1e7ce <onIPv4Request+0x13a>
    return 1;    
  }
  
  // we passed the lookup, so it is save to assemble the IP header... 
  struct netIPv4Header_t* header
    = (struct netIPv4Header_t*) nicAddPacketHeader(handle,sizeof(struct netIPv4Header_t));
   1e722:	c6 01       	movw	r24, r12
   1e724:	64 e1       	ldi	r22, 0x14	; 20
   1e726:	70 e0       	ldi	r23, 0x00	; 0
   1e728:	0e 94 4e fb 	call	0x1f69c	; 0x1f69c <nicAddPacketHeader>
   1e72c:	8c 01       	movw	r16, r24
  
    // generate the IP Header...
  header->version        = ((0x4 << 4) & 0xF0 )| ( sizeof(struct netIPv4Header_t) >> 2 );
   1e72e:	85 e4       	ldi	r24, 0x45	; 69
   1e730:	f8 01       	movw	r30, r16
   1e732:	80 83       	st	Z, r24
  header->typeOfService  = 0x00;
   1e734:	11 82       	std	Z+1, r1	; 0x01
  header->totalLength    = htons(nicGetPacketSize(handle));
   1e736:	c6 01       	movw	r24, r12
   1e738:	0e 94 bf fa 	call	0x1f57e	; 0x1f57e <nicGetPacketSize>
   1e73c:	f9 2e       	mov	r15, r25
   1e73e:	c6 01       	movw	r24, r12
   1e740:	0e 94 bf fa 	call	0x1f57e	; 0x1f57e <nicGetPacketSize>
   1e744:	38 2f       	mov	r19, r24
   1e746:	20 e0       	ldi	r18, 0x00	; 0
   1e748:	8f 2d       	mov	r24, r15
   1e74a:	90 e0       	ldi	r25, 0x00	; 0
   1e74c:	28 2b       	or	r18, r24
   1e74e:	39 2b       	or	r19, r25
   1e750:	f8 01       	movw	r30, r16
   1e752:	33 83       	std	Z+3, r19	; 0x03
   1e754:	22 83       	std	Z+2, r18	; 0x02
  header->identification = htons(hIPv4.identification);
   1e756:	90 91 18 01 	lds	r25, 0x0118
   1e75a:	80 91 19 01 	lds	r24, 0x0119
   1e75e:	84 83       	std	Z+4, r24	; 0x04
   1e760:	95 83       	std	Z+5, r25	; 0x05
  
  header->destIP = *destIP;
   1e762:	f5 01       	movw	r30, r10
   1e764:	80 81       	ld	r24, Z
   1e766:	91 81       	ldd	r25, Z+1	; 0x01
   1e768:	a2 81       	ldd	r26, Z+2	; 0x02
   1e76a:	b3 81       	ldd	r27, Z+3	; 0x03
   1e76c:	f8 01       	movw	r30, r16
   1e76e:	80 8b       	std	Z+16, r24	; 0x10
   1e770:	91 8b       	std	Z+17, r25	; 0x11
   1e772:	a2 8b       	std	Z+18, r26	; 0x12
   1e774:	b3 8b       	std	Z+19, r27	; 0x13
  header->srcIP  = *ipGetAddress();
   1e776:	80 91 0c 01 	lds	r24, 0x010C
   1e77a:	90 91 0d 01 	lds	r25, 0x010D
   1e77e:	a0 91 0e 01 	lds	r26, 0x010E
   1e782:	b0 91 0f 01 	lds	r27, 0x010F
   1e786:	84 87       	std	Z+12, r24	; 0x0c
   1e788:	95 87       	std	Z+13, r25	; 0x0d
   1e78a:	a6 87       	std	Z+14, r26	; 0x0e
   1e78c:	b7 87       	std	Z+15, r27	; 0x0f
  
  hIPv4.identification++;
   1e78e:	80 91 18 01 	lds	r24, 0x0118
   1e792:	90 91 19 01 	lds	r25, 0x0119
   1e796:	01 96       	adiw	r24, 0x01	; 1
   1e798:	90 93 19 01 	sts	0x0119, r25
   1e79c:	80 93 18 01 	sts	0x0118, r24
  
  header->fragmentation  = htons(0x4000);
   1e7a0:	80 e4       	ldi	r24, 0x40	; 64
   1e7a2:	90 e0       	ldi	r25, 0x00	; 0
   1e7a4:	97 83       	std	Z+7, r25	; 0x07
   1e7a6:	86 83       	std	Z+6, r24	; 0x06
  header->timeToLive     = 128;
   1e7a8:	80 e8       	ldi	r24, 0x80	; 128
   1e7aa:	80 87       	std	Z+8, r24	; 0x08
  header->protocol       = protocol;
   1e7ac:	e1 86       	std	Z+9, r14	; 0x09
 
  // when calculation the header checksum, it is assumed, that... 
  // ... the checksum itself is set to 0x00 
  header->headerCheckSum = 0x00;
   1e7ae:	13 86       	std	Z+11, r1	; 0x0b
   1e7b0:	12 86       	std	Z+10, r1	; 0x0a
  header->headerCheckSum 
   1e7b2:	c8 01       	movw	r24, r16
   1e7b4:	64 e1       	ldi	r22, 0x14	; 20
   1e7b6:	70 e0       	ldi	r23, 0x00	; 0
   1e7b8:	0e 94 05 fe 	call	0x1fc0a	; 0x1fc0a <calculateCheckSum>
   1e7bc:	f8 01       	movw	r30, r16
   1e7be:	93 87       	std	Z+11, r25	; 0x0b
   1e7c0:	82 87       	std	Z+10, r24	; 0x0a
      = calculateCheckSum(header,sizeof(struct netIPv4Header_t));
    
  return onEthernetRequest(handle,ETHERTYPE_IP4, &mac);
   1e7c2:	c6 01       	movw	r24, r12
   1e7c4:	68 e0       	ldi	r22, 0x08	; 8
   1e7c6:	70 e0       	ldi	r23, 0x00	; 0
   1e7c8:	a4 01       	movw	r20, r8
   1e7ca:	0e 94 cf f2 	call	0x1e59e	; 0x1e59e <onEthernetRequest>
}
   1e7ce:	26 96       	adiw	r28, 0x06	; 6
   1e7d0:	0f b6       	in	r0, 0x3f	; 63
   1e7d2:	f8 94       	cli
   1e7d4:	de bf       	out	0x3e, r29	; 62
   1e7d6:	0f be       	out	0x3f, r0	; 63
   1e7d8:	cd bf       	out	0x3d, r28	; 61
   1e7da:	cf 91       	pop	r28
   1e7dc:	df 91       	pop	r29
   1e7de:	1f 91       	pop	r17
   1e7e0:	0f 91       	pop	r16
   1e7e2:	ff 90       	pop	r15
   1e7e4:	ef 90       	pop	r14
   1e7e6:	df 90       	pop	r13
   1e7e8:	cf 90       	pop	r12
   1e7ea:	bf 90       	pop	r11
   1e7ec:	af 90       	pop	r10
   1e7ee:	9f 90       	pop	r9
   1e7f0:	8f 90       	pop	r8
   1e7f2:	08 95       	ret

0001e7f4 <onIPv4Response>:
  ipAddress_t subnet;
  ipAddress_t gateway;
} netIPv4Eeprom_t;

void onIPv4Response(struct nicResponseHandle_t* handle, struct macAddress_t* source)
{
   1e7f4:	ef 92       	push	r14
   1e7f6:	ff 92       	push	r15
   1e7f8:	0f 93       	push	r16
   1e7fa:	1f 93       	push	r17
   1e7fc:	df 93       	push	r29
   1e7fe:	cf 93       	push	r28
   1e800:	cd b7       	in	r28, 0x3d	; 61
   1e802:	de b7       	in	r29, 0x3e	; 62
   1e804:	64 97       	sbiw	r28, 0x14	; 20
   1e806:	0f b6       	in	r0, 0x3f	; 63
   1e808:	f8 94       	cli
   1e80a:	de bf       	out	0x3e, r29	; 62
   1e80c:	0f be       	out	0x3f, r0	; 63
   1e80e:	cd bf       	out	0x3d, r28	; 61
   1e810:	7c 01       	movw	r14, r24
   1e812:	8b 01       	movw	r16, r22
  // if the packet length beyond expectation, drop it...
  if (nicResponseSize(handle) < sizeof(struct netIPv4Header_t))
   1e814:	0e 94 cd fa 	call	0x1f59a	; 0x1f59a <nicResponseSize>
   1e818:	44 97       	sbiw	r24, 0x14	; 20
   1e81a:	08 f4       	brcc	.+2      	; 0x1e81e <onIPv4Response+0x2a>
   1e81c:	4e c0       	rjmp	.+156    	; 0x1e8ba <onIPv4Response+0xc6>
    return;
  
  struct netIPv4Header_t header;
  
  nicResponseRead(handle,(char*)(&header),sizeof(struct netIPv4Header_t));
   1e81e:	c7 01       	movw	r24, r14
   1e820:	be 01       	movw	r22, r28
   1e822:	6f 5f       	subi	r22, 0xFF	; 255
   1e824:	7f 4f       	sbci	r23, 0xFF	; 255
   1e826:	44 e1       	ldi	r20, 0x14	; 20
   1e828:	50 e0       	ldi	r21, 0x00	; 0
   1e82a:	0e 94 d7 fa 	call	0x1f5ae	; 0x1f5ae <nicResponseRead>
  
  // if the sender thinks, we have a different IP address...
  // ... we should definitivly drop the packet.
  if (header.destIP != *ipGetAddress())
   1e82e:	29 89       	ldd	r18, Y+17	; 0x11
   1e830:	3a 89       	ldd	r19, Y+18	; 0x12
   1e832:	4b 89       	ldd	r20, Y+19	; 0x13
   1e834:	5c 89       	ldd	r21, Y+20	; 0x14
   1e836:	80 91 0c 01 	lds	r24, 0x010C
   1e83a:	90 91 0d 01 	lds	r25, 0x010D
   1e83e:	a0 91 0e 01 	lds	r26, 0x010E
   1e842:	b0 91 0f 01 	lds	r27, 0x010F
   1e846:	28 17       	cp	r18, r24
   1e848:	39 07       	cpc	r19, r25
   1e84a:	4a 07       	cpc	r20, r26
   1e84c:	5b 07       	cpc	r21, r27
   1e84e:	a9 f5       	brne	.+106    	; 0x1e8ba <onIPv4Response+0xc6>
    return;
    
  // if knows our IP we should add him to our Arp Cache...
  // ... but ignore all MAC Multi-/Boradcasts Packets...
  // ... otherwise we could poisen our Arp Cache.  
  if ( ! (source->octet1 & (1 << 0)))
   1e850:	f8 01       	movw	r30, r16
   1e852:	80 81       	ld	r24, Z
   1e854:	80 fd       	sbrc	r24, 0
   1e856:	28 c0       	rjmp	.+80     	; 0x1e8a8 <onIPv4Response+0xb4>
  {
    // we should not lean the ip address if, its not within our subnet... 
    // ... instead we should update the arp entry for the gateway
    if ((header.srcIP & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))
   1e858:	80 91 10 01 	lds	r24, 0x0110
   1e85c:	90 91 11 01 	lds	r25, 0x0111
   1e860:	a0 91 12 01 	lds	r26, 0x0112
   1e864:	b0 91 13 01 	lds	r27, 0x0113
   1e868:	2d 85       	ldd	r18, Y+13	; 0x0d
   1e86a:	3e 85       	ldd	r19, Y+14	; 0x0e
   1e86c:	4f 85       	ldd	r20, Y+15	; 0x0f
   1e86e:	58 89       	ldd	r21, Y+16	; 0x10
   1e870:	82 27       	eor	r24, r18
   1e872:	93 27       	eor	r25, r19
   1e874:	a4 27       	eor	r26, r20
   1e876:	b5 27       	eor	r27, r21
   1e878:	20 91 14 01 	lds	r18, 0x0114
   1e87c:	30 91 15 01 	lds	r19, 0x0115
   1e880:	40 91 16 01 	lds	r20, 0x0116
   1e884:	50 91 17 01 	lds	r21, 0x0117
   1e888:	82 23       	and	r24, r18
   1e88a:	93 23       	and	r25, r19
   1e88c:	a4 23       	and	r26, r20
   1e88e:	b5 23       	and	r27, r21
   1e890:	00 97       	sbiw	r24, 0x00	; 0
   1e892:	a1 05       	cpc	r26, r1
   1e894:	b1 05       	cpc	r27, r1
   1e896:	19 f4       	brne	.+6      	; 0x1e89e <onIPv4Response+0xaa>
      arpAddMacByIPv4(&header.srcIP,source);
   1e898:	ce 01       	movw	r24, r28
   1e89a:	0d 96       	adiw	r24, 0x0d	; 13
   1e89c:	02 c0       	rjmp	.+4      	; 0x1e8a2 <onIPv4Response+0xae>
    else
      arpAddMacByIPv4(&hIPv4.gateway,source);
   1e89e:	80 e1       	ldi	r24, 0x10	; 16
   1e8a0:	91 e0       	ldi	r25, 0x01	; 1
   1e8a2:	b8 01       	movw	r22, r16
   1e8a4:	0e 94 7c f0 	call	0x1e0f8	; 0x1e0f8 <arpAddMacByIPv4>
  }
     
    
     
  switch (header.protocol)
   1e8a8:	8a 85       	ldd	r24, Y+10	; 0x0a
   1e8aa:	81 31       	cpi	r24, 0x11	; 17
   1e8ac:	31 f4       	brne	.+12     	; 0x1e8ba <onIPv4Response+0xc6>
  {
    case 0x11:      
      onUdpResponse(handle, &header.srcIP);
   1e8ae:	c7 01       	movw	r24, r14
   1e8b0:	be 01       	movw	r22, r28
   1e8b2:	63 5f       	subi	r22, 0xF3	; 243
   1e8b4:	7f 4f       	sbci	r23, 0xFF	; 255
   1e8b6:	0e 94 6a f4 	call	0x1e8d4	; 0x1e8d4 <onUdpResponse>
      break;
  }
  
  return;
}
   1e8ba:	64 96       	adiw	r28, 0x14	; 20
   1e8bc:	0f b6       	in	r0, 0x3f	; 63
   1e8be:	f8 94       	cli
   1e8c0:	de bf       	out	0x3e, r29	; 62
   1e8c2:	0f be       	out	0x3f, r0	; 63
   1e8c4:	cd bf       	out	0x3d, r28	; 61
   1e8c6:	cf 91       	pop	r28
   1e8c8:	df 91       	pop	r29
   1e8ca:	1f 91       	pop	r17
   1e8cc:	0f 91       	pop	r16
   1e8ce:	ff 90       	pop	r15
   1e8d0:	ef 90       	pop	r14
   1e8d2:	08 95       	ret

0001e8d4 <onUdpResponse>:
  onIPv4Request(handle,&(dest->ip),0x11);
  return;
}

void onUdpResponse(struct nicResponseHandle_t* handle, ipAddress_t* ipAddress)
{
   1e8d4:	ef 92       	push	r14
   1e8d6:	ff 92       	push	r15
   1e8d8:	0f 93       	push	r16
   1e8da:	1f 93       	push	r17
   1e8dc:	df 93       	push	r29
   1e8de:	cf 93       	push	r28
   1e8e0:	cd b7       	in	r28, 0x3d	; 61
   1e8e2:	de b7       	in	r29, 0x3e	; 62
   1e8e4:	2e 97       	sbiw	r28, 0x0e	; 14
   1e8e6:	0f b6       	in	r0, 0x3f	; 63
   1e8e8:	f8 94       	cli
   1e8ea:	de bf       	out	0x3e, r29	; 62
   1e8ec:	0f be       	out	0x3f, r0	; 63
   1e8ee:	cd bf       	out	0x3d, r28	; 61
   1e8f0:	8c 01       	movw	r16, r24
   1e8f2:	7b 01       	movw	r14, r22
  // drop if header invalid...
  if (nicResponseSize(handle) < sizeof(struct soUdpHeader_t))
   1e8f4:	0e 94 cd fa 	call	0x1f59a	; 0x1f59a <nicResponseSize>
   1e8f8:	08 97       	sbiw	r24, 0x08	; 8
   1e8fa:	00 f1       	brcs	.+64     	; 0x1e93c <onUdpResponse+0x68>
    return;  
  
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
   1e8fc:	c8 01       	movw	r24, r16
   1e8fe:	be 01       	movw	r22, r28
   1e900:	69 5f       	subi	r22, 0xF9	; 249
   1e902:	7f 4f       	sbci	r23, 0xFF	; 255
   1e904:	48 e0       	ldi	r20, 0x08	; 8
   1e906:	50 e0       	ldi	r21, 0x00	; 0
   1e908:	0e 94 d7 fa 	call	0x1f5ae	; 0x1f5ae <nicResponseRead>
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
   1e90c:	f7 01       	movw	r30, r14
   1e90e:	20 81       	ld	r18, Z
   1e910:	31 81       	ldd	r19, Z+1	; 0x01
   1e912:	42 81       	ldd	r20, Z+2	; 0x02
   1e914:	53 81       	ldd	r21, Z+3	; 0x03
  netAdr.port = ntohs(header.srcPort); 
   1e916:	7f 81       	ldd	r23, Y+7	; 0x07
   1e918:	68 85       	ldd	r22, Y+8	; 0x08
  
  switch (ntohs(header.destPort))
   1e91a:	99 85       	ldd	r25, Y+9	; 0x09
   1e91c:	8a 85       	ldd	r24, Y+10	; 0x0a
   1e91e:	85 34       	cpi	r24, 0x45	; 69
   1e920:	91 05       	cpc	r25, r1
   1e922:	61 f4       	brne	.+24     	; 0x1e93c <onUdpResponse+0x68>
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
  netAdr.port = ntohs(header.srcPort); 
   1e924:	6d 83       	std	Y+5, r22	; 0x05
   1e926:	7e 83       	std	Y+6, r23	; 0x06
  
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
   1e928:	29 83       	std	Y+1, r18	; 0x01
   1e92a:	3a 83       	std	Y+2, r19	; 0x02
   1e92c:	4b 83       	std	Y+3, r20	; 0x03
   1e92e:	5c 83       	std	Y+4, r21	; 0x04
      onRtpResponse(handle, &netAdr);
      break;
    #endif
    #ifdef REQUIRES_TFTP
    case TFTP_SERVER_PORT :
      onTftpResponse(handle, &netAdr);
   1e930:	c8 01       	movw	r24, r16
   1e932:	be 01       	movw	r22, r28
   1e934:	6f 5f       	subi	r22, 0xFF	; 255
   1e936:	7f 4f       	sbci	r23, 0xFF	; 255
   1e938:	0e 94 c8 f5 	call	0x1eb90	; 0x1eb90 <onTftpResponse>
      break;
    #endif
  } 
  return;
}
   1e93c:	2e 96       	adiw	r28, 0x0e	; 14
   1e93e:	0f b6       	in	r0, 0x3f	; 63
   1e940:	f8 94       	cli
   1e942:	de bf       	out	0x3e, r29	; 62
   1e944:	0f be       	out	0x3f, r0	; 63
   1e946:	cd bf       	out	0x3d, r28	; 61
   1e948:	cf 91       	pop	r28
   1e94a:	df 91       	pop	r29
   1e94c:	1f 91       	pop	r17
   1e94e:	0f 91       	pop	r16
   1e950:	ff 90       	pop	r15
   1e952:	ef 90       	pop	r14
   1e954:	08 95       	ret

0001e956 <onUdpRequest>:
  uint16_t checksum; // if not used set it to 0
};

void onUdpRequest(struct nicRequestHandle_t* handle,
    struct netAddress_t* dest, portAddress_t* srcPort)
{
   1e956:	af 92       	push	r10
   1e958:	bf 92       	push	r11
   1e95a:	cf 92       	push	r12
   1e95c:	df 92       	push	r13
   1e95e:	ef 92       	push	r14
   1e960:	ff 92       	push	r15
   1e962:	0f 93       	push	r16
   1e964:	1f 93       	push	r17
   1e966:	6c 01       	movw	r12, r24
   1e968:	5b 01       	movw	r10, r22
   1e96a:	7a 01       	movw	r14, r20
  // ...generate the UDP Header...
  struct soUdpHeader_t* header 
     = (struct soUdpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soUdpHeader_t));
   1e96c:	68 e0       	ldi	r22, 0x08	; 8
   1e96e:	70 e0       	ldi	r23, 0x00	; 0
   1e970:	0e 94 4e fb 	call	0x1f69c	; 0x1f69c <nicAddPacketHeader>
   1e974:	8c 01       	movw	r16, r24
  
  header->srcPort  = htons(*srcPort);  
   1e976:	f7 01       	movw	r30, r14
   1e978:	90 81       	ld	r25, Z
   1e97a:	81 81       	ldd	r24, Z+1	; 0x01
   1e97c:	f8 01       	movw	r30, r16
   1e97e:	80 83       	st	Z, r24
   1e980:	91 83       	std	Z+1, r25	; 0x01
  header->destPort = htons(dest->port);
   1e982:	f5 01       	movw	r30, r10
   1e984:	94 81       	ldd	r25, Z+4	; 0x04
   1e986:	85 81       	ldd	r24, Z+5	; 0x05
   1e988:	f8 01       	movw	r30, r16
   1e98a:	82 83       	std	Z+2, r24	; 0x02
   1e98c:	93 83       	std	Z+3, r25	; 0x03
  header->checksum = 0x00;
   1e98e:	17 82       	std	Z+7, r1	; 0x07
   1e990:	16 82       	std	Z+6, r1	; 0x06
  header->length   = htons(nicGetPacketSize(handle));
   1e992:	c6 01       	movw	r24, r12
   1e994:	0e 94 bf fa 	call	0x1f57e	; 0x1f57e <nicGetPacketSize>
   1e998:	f9 2e       	mov	r15, r25
   1e99a:	c6 01       	movw	r24, r12
   1e99c:	0e 94 bf fa 	call	0x1f57e	; 0x1f57e <nicGetPacketSize>
   1e9a0:	38 2f       	mov	r19, r24
   1e9a2:	20 e0       	ldi	r18, 0x00	; 0
   1e9a4:	8f 2d       	mov	r24, r15
   1e9a6:	90 e0       	ldi	r25, 0x00	; 0
   1e9a8:	28 2b       	or	r18, r24
   1e9aa:	39 2b       	or	r19, r25
   1e9ac:	f8 01       	movw	r30, r16
   1e9ae:	35 83       	std	Z+5, r19	; 0x05
   1e9b0:	24 83       	std	Z+4, r18	; 0x04
  
  onIPv4Request(handle,&(dest->ip),0x11);
   1e9b2:	c6 01       	movw	r24, r12
   1e9b4:	b5 01       	movw	r22, r10
   1e9b6:	41 e1       	ldi	r20, 0x11	; 17
   1e9b8:	0e 94 4a f3 	call	0x1e694	; 0x1e694 <onIPv4Request>
  return;
}
   1e9bc:	1f 91       	pop	r17
   1e9be:	0f 91       	pop	r16
   1e9c0:	ff 90       	pop	r15
   1e9c2:	ef 90       	pop	r14
   1e9c4:	df 90       	pop	r13
   1e9c6:	cf 90       	pop	r12
   1e9c8:	bf 90       	pop	r11
   1e9ca:	af 90       	pop	r10
   1e9cc:	08 95       	ret

0001e9ce <tftpConnect>:
    timerClearTimeout(hTftp.timer);
    hTftp.timer = timerAddTimeout(TFTP_TIMEOUT,onTimeoutTftp);
  }

  void tftpConnect(struct netAddress_t* netAddr)
  {
   1e9ce:	0f 93       	push	r16
   1e9d0:	1f 93       	push	r17
   1e9d2:	18 2f       	mov	r17, r24
   1e9d4:	09 2f       	mov	r16, r25
    hTftp.destNetAddr = malloc(sizeof (struct netAddress_t));
   1e9d6:	86 e0       	ldi	r24, 0x06	; 6
   1e9d8:	90 e0       	ldi	r25, 0x00	; 0
   1e9da:	0e 94 66 fe 	call	0x1fccc	; 0x1fccc <malloc>
   1e9de:	80 93 66 01 	sts	0x0166, r24
   1e9e2:	90 93 67 01 	sts	0x0167, r25
    *(hTftp.destNetAddr) = *netAddr;
   1e9e6:	dc 01       	movw	r26, r24
   1e9e8:	21 2f       	mov	r18, r17
   1e9ea:	30 2f       	mov	r19, r16
   1e9ec:	c9 01       	movw	r24, r18
   1e9ee:	fc 01       	movw	r30, r24
   1e9f0:	86 e0       	ldi	r24, 0x06	; 6
   1e9f2:	01 90       	ld	r0, Z+
   1e9f4:	0d 92       	st	X+, r0
   1e9f6:	81 50       	subi	r24, 0x01	; 1
   1e9f8:	e1 f7       	brne	.-8      	; 0x1e9f2 <tftpConnect+0x24>
    hTftp.timer = NULL;
   1e9fa:	10 92 69 01 	sts	0x0169, r1
   1e9fe:	10 92 68 01 	sts	0x0168, r1
  }
   1ea02:	1f 91       	pop	r17
   1ea04:	0f 91       	pop	r16
   1ea06:	08 95       	ret

0001ea08 <tftpDisconnect>:

  void tftpDisconnect()
  {
    if (hTftp.timer != NULL)
   1ea08:	80 91 68 01 	lds	r24, 0x0168
   1ea0c:	90 91 69 01 	lds	r25, 0x0169
   1ea10:	00 97       	sbiw	r24, 0x00	; 0
   1ea12:	11 f0       	breq	.+4      	; 0x1ea18 <tftpDisconnect+0x10>
     timerClearTimeout(hTftp.timer);
   1ea14:	0e 94 74 f6 	call	0x1ece8	; 0x1ece8 <timerClearTimeout>
    
    free(hTftp.destNetAddr);
   1ea18:	80 91 66 01 	lds	r24, 0x0166
   1ea1c:	90 91 67 01 	lds	r25, 0x0167
   1ea20:	0e 94 10 ff 	call	0x1fe20	; 0x1fe20 <free>
    hTftp.destNetAddr = NULL;
   1ea24:	10 92 67 01 	sts	0x0167, r1
   1ea28:	10 92 66 01 	sts	0x0166, r1
    hTftp.timer = NULL;    
   1ea2c:	10 92 69 01 	sts	0x0169, r1
   1ea30:	10 92 68 01 	sts	0x0168, r1
  }
   1ea34:	08 95       	ret

0001ea36 <tftpSendError>:
    timerClearTimeout(hTftp.timer);
    hTftp.timer = timerAddTimeout(TFTP_TIMEOUT,onTimeoutTftp);
  }
  
  void tftpSendError(uint16_t errCode, char* errMsg, uint8_t len)
  {
   1ea36:	8f 92       	push	r8
   1ea38:	9f 92       	push	r9
   1ea3a:	af 92       	push	r10
   1ea3c:	bf 92       	push	r11
   1ea3e:	cf 92       	push	r12
   1ea40:	df 92       	push	r13
   1ea42:	ff 92       	push	r15
   1ea44:	0f 93       	push	r16
   1ea46:	1f 93       	push	r17
   1ea48:	df 93       	push	r29
   1ea4a:	cf 93       	push	r28
   1ea4c:	00 d0       	rcall	.+0      	; 0x1ea4e <tftpSendError+0x18>
   1ea4e:	cd b7       	in	r28, 0x3d	; 61
   1ea50:	de b7       	in	r29, 0x3e	; 62
   1ea52:	5c 01       	movw	r10, r24
   1ea54:	4b 01       	movw	r8, r22
   1ea56:	f4 2e       	mov	r15, r20
    if (hTftp.destNetAddr == NULL)
   1ea58:	80 91 66 01 	lds	r24, 0x0166
   1ea5c:	90 91 67 01 	lds	r25, 0x0167
   1ea60:	89 2b       	or	r24, r25
   1ea62:	09 f4       	brne	.+2      	; 0x1ea66 <tftpSendError+0x30>
   1ea64:	42 c0       	rjmp	.+132    	; 0x1eaea <tftpSendError+0xb4>
      return;
    
    struct nicRequestHandle_t* handle = nicNewRequest();
   1ea66:	0e 94 86 fb 	call	0x1f70c	; 0x1f70c <nicNewRequest>
   1ea6a:	6c 01       	movw	r12, r24
    
    char* buf = nicAddPacketHeader(handle,4+len+1);
   1ea6c:	0f 2d       	mov	r16, r15
   1ea6e:	10 e0       	ldi	r17, 0x00	; 0
   1ea70:	b8 01       	movw	r22, r16
   1ea72:	6b 5f       	subi	r22, 0xFB	; 251
   1ea74:	7f 4f       	sbci	r23, 0xFF	; 255
   1ea76:	0e 94 4e fb 	call	0x1f69c	; 0x1f69c <nicAddPacketHeader>
   1ea7a:	9c 01       	movw	r18, r24
    
    *((uint16_t*)buf) = 5;
   1ea7c:	85 e0       	ldi	r24, 0x05	; 5
   1ea7e:	90 e0       	ldi	r25, 0x00	; 0
   1ea80:	f9 01       	movw	r30, r18
   1ea82:	91 83       	std	Z+1, r25	; 0x01
   1ea84:	80 83       	st	Z, r24
    *((uint16_t*)(buf+2)) = errCode;
   1ea86:	b3 82       	std	Z+3, r11	; 0x03
   1ea88:	a2 82       	std	Z+2, r10	; 0x02
    
    (buf+4)[len+1] = '\0';    
   1ea8a:	02 0f       	add	r16, r18
   1ea8c:	13 1f       	adc	r17, r19
   1ea8e:	f8 01       	movw	r30, r16
   1ea90:	15 82       	std	Z+5, r1	; 0x05
   1ea92:	0b c0       	rjmp	.+22     	; 0x1eaaa <tftpSendError+0x74>
    while(len--)
   1ea94:	fa 94       	dec	r15
    {
      (buf+4)[len] = errMsg[len];
   1ea96:	ef 2d       	mov	r30, r15
   1ea98:	f0 e0       	ldi	r31, 0x00	; 0
   1ea9a:	d9 01       	movw	r26, r18
   1ea9c:	ae 0f       	add	r26, r30
   1ea9e:	bf 1f       	adc	r27, r31
   1eaa0:	e8 0d       	add	r30, r8
   1eaa2:	f9 1d       	adc	r31, r9
   1eaa4:	80 81       	ld	r24, Z
   1eaa6:	14 96       	adiw	r26, 0x04	; 4
   1eaa8:	8c 93       	st	X, r24
    
    *((uint16_t*)buf) = 5;
    *((uint16_t*)(buf+2)) = errCode;
    
    (buf+4)[len+1] = '\0';    
    while(len--)
   1eaaa:	ff 20       	and	r15, r15
   1eaac:	99 f7       	brne	.-26     	; 0x1ea94 <tftpSendError+0x5e>
    {
      (buf+4)[len] = errMsg[len];
    }
         
    uint16_t port = 69;
   1eaae:	85 e4       	ldi	r24, 0x45	; 69
   1eab0:	90 e0       	ldi	r25, 0x00	; 0
   1eab2:	9a 83       	std	Y+2, r25	; 0x02
   1eab4:	89 83       	std	Y+1, r24	; 0x01
    onUdpRequest(handle,hTftp.destNetAddr,&port);
   1eab6:	60 91 66 01 	lds	r22, 0x0166
   1eaba:	70 91 67 01 	lds	r23, 0x0167
   1eabe:	c6 01       	movw	r24, r12
   1eac0:	ae 01       	movw	r20, r28
   1eac2:	4f 5f       	subi	r20, 0xFF	; 255
   1eac4:	5f 4f       	sbci	r21, 0xFF	; 255
   1eac6:	0e 94 ab f4 	call	0x1e956	; 0x1e956 <onUdpRequest>
    // Packets are automagically freed upon successfull send..
    
    timerClearTimeout(hTftp.timer);
   1eaca:	80 91 68 01 	lds	r24, 0x0168
   1eace:	90 91 69 01 	lds	r25, 0x0169
   1ead2:	0e 94 74 f6 	call	0x1ece8	; 0x1ece8 <timerClearTimeout>
    hTftp.timer = timerAddTimeout(TFTP_TIMEOUT,onTimeoutTftp);
   1ead6:	80 e2       	ldi	r24, 0x20	; 32
   1ead8:	9e e4       	ldi	r25, 0x4E	; 78
   1eada:	69 e5       	ldi	r22, 0x59	; 89
   1eadc:	76 ef       	ldi	r23, 0xF6	; 246
   1eade:	0e 94 cc f6 	call	0x1ed98	; 0x1ed98 <timerAddTimeout>
   1eae2:	90 93 69 01 	sts	0x0169, r25
   1eae6:	80 93 68 01 	sts	0x0168, r24
  }
   1eaea:	0f 90       	pop	r0
   1eaec:	0f 90       	pop	r0
   1eaee:	cf 91       	pop	r28
   1eaf0:	df 91       	pop	r29
   1eaf2:	1f 91       	pop	r17
   1eaf4:	0f 91       	pop	r16
   1eaf6:	ff 90       	pop	r15
   1eaf8:	df 90       	pop	r13
   1eafa:	cf 90       	pop	r12
   1eafc:	bf 90       	pop	r11
   1eafe:	af 90       	pop	r10
   1eb00:	9f 90       	pop	r9
   1eb02:	8f 90       	pop	r8
   1eb04:	08 95       	ret

0001eb06 <tftpSendAck>:
    onTFtpTimeOut();
  }
  
  
  void tftpSendAck(uint16_t block)
  {
   1eb06:	ef 92       	push	r14
   1eb08:	ff 92       	push	r15
   1eb0a:	0f 93       	push	r16
   1eb0c:	1f 93       	push	r17
   1eb0e:	df 93       	push	r29
   1eb10:	cf 93       	push	r28
   1eb12:	00 d0       	rcall	.+0      	; 0x1eb14 <tftpSendAck+0xe>
   1eb14:	cd b7       	in	r28, 0x3d	; 61
   1eb16:	de b7       	in	r29, 0x3e	; 62
   1eb18:	7c 01       	movw	r14, r24
    if (hTftp.destNetAddr == NULL)
   1eb1a:	80 91 66 01 	lds	r24, 0x0166
   1eb1e:	90 91 67 01 	lds	r25, 0x0167
   1eb22:	89 2b       	or	r24, r25
   1eb24:	61 f1       	breq	.+88     	; 0x1eb7e <tftpSendAck+0x78>
      return;
    
    struct nicRequestHandle_t* handle = nicNewRequest();
   1eb26:	0e 94 86 fb 	call	0x1f70c	; 0x1f70c <nicNewRequest>
   1eb2a:	8c 01       	movw	r16, r24
    
    char* buf = nicAddPacketHeader(handle,4);
   1eb2c:	64 e0       	ldi	r22, 0x04	; 4
   1eb2e:	70 e0       	ldi	r23, 0x00	; 0
   1eb30:	0e 94 4e fb 	call	0x1f69c	; 0x1f69c <nicAddPacketHeader>
   
    *((uint16_t*)buf) = 0x0400;
   1eb34:	fc 01       	movw	r30, r24
   1eb36:	80 e0       	ldi	r24, 0x00	; 0
   1eb38:	94 e0       	ldi	r25, 0x04	; 4
   1eb3a:	91 83       	std	Z+1, r25	; 0x01
   1eb3c:	80 83       	st	Z, r24
    *((uint16_t*)(buf+2)) = block;
   1eb3e:	f3 82       	std	Z+3, r15	; 0x03
   1eb40:	e2 82       	std	Z+2, r14	; 0x02
    
    portAddress_t port = 0x0045;    
   1eb42:	85 e4       	ldi	r24, 0x45	; 69
   1eb44:	90 e0       	ldi	r25, 0x00	; 0
   1eb46:	9a 83       	std	Y+2, r25	; 0x02
   1eb48:	89 83       	std	Y+1, r24	; 0x01
    onUdpRequest(handle,hTftp.destNetAddr,&port);
   1eb4a:	60 91 66 01 	lds	r22, 0x0166
   1eb4e:	70 91 67 01 	lds	r23, 0x0167
   1eb52:	c8 01       	movw	r24, r16
   1eb54:	ae 01       	movw	r20, r28
   1eb56:	4f 5f       	subi	r20, 0xFF	; 255
   1eb58:	5f 4f       	sbci	r21, 0xFF	; 255
   1eb5a:	0e 94 ab f4 	call	0x1e956	; 0x1e956 <onUdpRequest>
    // no need to free the packet, this happens automagically
    
    timerClearTimeout(hTftp.timer);
   1eb5e:	80 91 68 01 	lds	r24, 0x0168
   1eb62:	90 91 69 01 	lds	r25, 0x0169
   1eb66:	0e 94 74 f6 	call	0x1ece8	; 0x1ece8 <timerClearTimeout>
    hTftp.timer = timerAddTimeout(TFTP_TIMEOUT,onTimeoutTftp);
   1eb6a:	80 e2       	ldi	r24, 0x20	; 32
   1eb6c:	9e e4       	ldi	r25, 0x4E	; 78
   1eb6e:	69 e5       	ldi	r22, 0x59	; 89
   1eb70:	76 ef       	ldi	r23, 0xF6	; 246
   1eb72:	0e 94 cc f6 	call	0x1ed98	; 0x1ed98 <timerAddTimeout>
   1eb76:	90 93 69 01 	sts	0x0169, r25
   1eb7a:	80 93 68 01 	sts	0x0168, r24
  }
   1eb7e:	0f 90       	pop	r0
   1eb80:	0f 90       	pop	r0
   1eb82:	cf 91       	pop	r28
   1eb84:	df 91       	pop	r29
   1eb86:	1f 91       	pop	r17
   1eb88:	0f 91       	pop	r16
   1eb8a:	ff 90       	pop	r15
   1eb8c:	ef 90       	pop	r14
   1eb8e:	08 95       	ret

0001eb90 <onTftpResponse>:
    hTftp.destNetAddr = NULL;
    hTftp.timer = NULL;    
  }

  void onTftpResponse(struct nicResponseHandle_t* response, struct netAddress_t* netAddr)
  {    
   1eb90:	af 92       	push	r10
   1eb92:	bf 92       	push	r11
   1eb94:	cf 92       	push	r12
   1eb96:	df 92       	push	r13
   1eb98:	ef 92       	push	r14
   1eb9a:	ff 92       	push	r15
   1eb9c:	0f 93       	push	r16
   1eb9e:	1f 93       	push	r17
   1eba0:	cf 93       	push	r28
   1eba2:	df 93       	push	r29
   1eba4:	6c 01       	movw	r12, r24
   1eba6:	7b 01       	movw	r14, r22
    // This TFTP Server supports only write request (WRQ)...    
    // ... additionally we don't accept concurrent connection
    
    // Read TFTP Payload into Memory...
    uint16_t len = nicResponseSize(response);
   1eba8:	0e 94 cd fa 	call	0x1f59a	; 0x1f59a <nicResponseSize>
   1ebac:	8c 01       	movw	r16, r24
    char* buf = malloc(len);
   1ebae:	0e 94 66 fe 	call	0x1fccc	; 0x1fccc <malloc>
   1ebb2:	ec 01       	movw	r28, r24
    // ... due to the huge payload size, malloc might fail...
    if (buf == NULL)
   1ebb4:	00 97       	sbiw	r24, 0x00	; 0
   1ebb6:	09 f4       	brne	.+2      	; 0x1ebba <onTftpResponse+0x2a>
   1ebb8:	71 c0       	rjmp	.+226    	; 0x1ec9c <onTftpResponse+0x10c>
      return;
    
    // We got the memory allocated, so let use it and load ...
    // ... the Payload into our buffer memory.
    nicResponseRead(response,buf,len);
   1ebba:	c6 01       	movw	r24, r12
   1ebbc:	be 01       	movw	r22, r28
   1ebbe:	a8 01       	movw	r20, r16
   1ebc0:	0e 94 d7 fa 	call	0x1f5ae	; 0x1f5ae <nicResponseRead>
    
    // parse the opcode of the header
    switch (*((uint16_t*)buf))
   1ebc4:	88 81       	ld	r24, Y
   1ebc6:	99 81       	ldd	r25, Y+1	; 0x01
   1ebc8:	22 e0       	ldi	r18, 0x02	; 2
   1ebca:	80 30       	cpi	r24, 0x00	; 0
   1ebcc:	92 07       	cpc	r25, r18
   1ebce:	29 f0       	breq	.+10     	; 0x1ebda <onTftpResponse+0x4a>
   1ebd0:	80 50       	subi	r24, 0x00	; 0
   1ebd2:	93 40       	sbci	r25, 0x03	; 3
   1ebd4:	09 f0       	breq	.+2      	; 0x1ebd8 <onTftpResponse+0x48>
   1ebd6:	5f c0       	rjmp	.+190    	; 0x1ec96 <onTftpResponse+0x106>
   1ebd8:	1b c0       	rjmp	.+54     	; 0x1ec10 <onTftpResponse+0x80>
    {
      case 0x0200: // it is a Write ReQuest (WRQ)
        // avoid concurrent incomming requests...
        if (hTftp.destNetAddr != NULL)
   1ebda:	80 91 66 01 	lds	r24, 0x0166
   1ebde:	90 91 67 01 	lds	r25, 0x0167
   1ebe2:	89 2b       	or	r24, r25
   1ebe4:	09 f0       	breq	.+2      	; 0x1ebe8 <onTftpResponse+0x58>
   1ebe6:	57 c0       	rjmp	.+174    	; 0x1ec96 <onTftpResponse+0x106>
          break;
        
        // accept the connection...
        tftpConnect(netAddr);
   1ebe8:	c7 01       	movw	r24, r14
   1ebea:	0e 94 e7 f4 	call	0x1e9ce	; 0x1e9ce <tftpConnect>
            
        // connection successfully nagociated?
        if (onTftpConnect((buf+2),len-2) != 0)
   1ebee:	02 50       	subi	r16, 0x02	; 2
   1ebf0:	10 40       	sbci	r17, 0x00	; 0
   1ebf2:	ce 01       	movw	r24, r28
   1ebf4:	02 96       	adiw	r24, 0x02	; 2
   1ebf6:	b8 01       	movw	r22, r16
   1ebf8:	0e 94 a2 fd 	call	0x1fb44	; 0x1fb44 <onTftpConnect>
   1ebfc:	88 23       	and	r24, r24
   1ebfe:	19 f0       	breq	.+6      	; 0x1ec06 <onTftpResponse+0x76>
        {
          tftpDisconnect();
   1ec00:	0e 94 04 f5 	call	0x1ea08	; 0x1ea08 <tftpDisconnect>
   1ec04:	48 c0       	rjmp	.+144    	; 0x1ec96 <onTftpResponse+0x106>
          break;
        }
        // accept the connection...
        tftpSendAck(0x00);
   1ec06:	80 e0       	ldi	r24, 0x00	; 0
   1ec08:	90 e0       	ldi	r25, 0x00	; 0
   1ec0a:	0e 94 83 f5 	call	0x1eb06	; 0x1eb06 <tftpSendAck>
   1ec0e:	39 c0       	rjmp	.+114    	; 0x1ec82 <onTftpResponse+0xf2>
        break;
        
      case 0x0300: // we received Data...
        
        // are we expecting data?
        if (hTftp.destNetAddr == 0)
   1ec10:	e0 91 66 01 	lds	r30, 0x0166
   1ec14:	f0 91 67 01 	lds	r31, 0x0167
   1ec18:	30 97       	sbiw	r30, 0x00	; 0
   1ec1a:	e9 f1       	breq	.+122    	; 0x1ec96 <onTftpResponse+0x106>
          break;
    
        if ((hTftp.destNetAddr->ip != netAddr->ip)
   1ec1c:	20 81       	ld	r18, Z
   1ec1e:	31 81       	ldd	r19, Z+1	; 0x01
   1ec20:	42 81       	ldd	r20, Z+2	; 0x02
   1ec22:	53 81       	ldd	r21, Z+3	; 0x03
   1ec24:	d7 01       	movw	r26, r14
   1ec26:	ad 90       	ld	r10, X+
   1ec28:	bd 90       	ld	r11, X+
   1ec2a:	cd 90       	ld	r12, X+
   1ec2c:	dc 90       	ld	r13, X
   1ec2e:	13 97       	sbiw	r26, 0x03	; 3
   1ec30:	2a 15       	cp	r18, r10
   1ec32:	3b 05       	cpc	r19, r11
   1ec34:	4c 05       	cpc	r20, r12
   1ec36:	5d 05       	cpc	r21, r13
   1ec38:	71 f5       	brne	.+92     	; 0x1ec96 <onTftpResponse+0x106>
   1ec3a:	24 81       	ldd	r18, Z+4	; 0x04
   1ec3c:	35 81       	ldd	r19, Z+5	; 0x05
   1ec3e:	14 96       	adiw	r26, 0x04	; 4
   1ec40:	8d 91       	ld	r24, X+
   1ec42:	9c 91       	ld	r25, X
   1ec44:	15 97       	sbiw	r26, 0x05	; 5
   1ec46:	28 17       	cp	r18, r24
   1ec48:	39 07       	cpc	r19, r25
   1ec4a:	29 f5       	brne	.+74     	; 0x1ec96 <onTftpResponse+0x106>
            || (hTftp.destNetAddr->port != netAddr->port))          
          break;
        
        onTftpData(*((uint16_t*)(buf+2)), (buf+4),len-4);     
   1ec4c:	04 50       	subi	r16, 0x04	; 4
   1ec4e:	10 40       	sbci	r17, 0x00	; 0
   1ec50:	be 01       	movw	r22, r28
   1ec52:	6c 5f       	subi	r22, 0xFC	; 252
   1ec54:	7f 4f       	sbci	r23, 0xFF	; 255
   1ec56:	e0 91 ab 01 	lds	r30, 0x01AB
   1ec5a:	f0 91 ac 01 	lds	r31, 0x01AC
   1ec5e:	8a 81       	ldd	r24, Y+2	; 0x02
   1ec60:	9b 81       	ldd	r25, Y+3	; 0x03
   1ec62:	a8 01       	movw	r20, r16
   1ec64:	09 95       	icall
        
        // disconnect, if we received the last packet
        if ((len-4) <= 511)
   1ec66:	00 50       	subi	r16, 0x00	; 0
   1ec68:	12 40       	sbci	r17, 0x02	; 2
   1ec6a:	28 f4       	brcc	.+10     	; 0x1ec76 <onTftpResponse+0xe6>
        {
          tftpDisconnect();
   1ec6c:	0e 94 04 f5 	call	0x1ea08	; 0x1ea08 <tftpDisconnect>
          onTFtpComplete();
   1ec70:	0e 94 11 fd 	call	0x1fa22	; 0x1fa22 <onTFtpComplete>
   1ec74:	10 c0       	rjmp	.+32     	; 0x1ec96 <onTftpResponse+0x106>
        }
        else
        {        
          // update the timeout... 60 more seconds
          timerClearTimeout(hTftp.timer);
   1ec76:	80 91 68 01 	lds	r24, 0x0168
   1ec7a:	90 91 69 01 	lds	r25, 0x0169
   1ec7e:	0e 94 74 f6 	call	0x1ece8	; 0x1ece8 <timerClearTimeout>
          hTftp.timer = timerAddTimeout(TFTP_TIMEOUT,onTimeoutTftp);
   1ec82:	80 e2       	ldi	r24, 0x20	; 32
   1ec84:	9e e4       	ldi	r25, 0x4E	; 78
   1ec86:	69 e5       	ldi	r22, 0x59	; 89
   1ec88:	76 ef       	ldi	r23, 0xF6	; 246
   1ec8a:	0e 94 cc f6 	call	0x1ed98	; 0x1ed98 <timerAddTimeout>
   1ec8e:	90 93 69 01 	sts	0x0169, r25
   1ec92:	80 93 68 01 	sts	0x0168, r24
        // ... we ignore it according to the RFC.
        break;
    }

    // ...finally free the buffer
    free(buf);
   1ec96:	ce 01       	movw	r24, r28
   1ec98:	0e 94 10 ff 	call	0x1fe20	; 0x1fe20 <free>
    
    return;
  }
   1ec9c:	df 91       	pop	r29
   1ec9e:	cf 91       	pop	r28
   1eca0:	1f 91       	pop	r17
   1eca2:	0f 91       	pop	r16
   1eca4:	ff 90       	pop	r15
   1eca6:	ef 90       	pop	r14
   1eca8:	df 90       	pop	r13
   1ecaa:	cf 90       	pop	r12
   1ecac:	bf 90       	pop	r11
   1ecae:	af 90       	pop	r10
   1ecb0:	08 95       	ret

0001ecb2 <onTimeoutTftp>:

  void onTimeoutTftp()
  {
    // as first action we have to null the timer element...
    // ...otherwise we would doublefree memory
    hTftp.timer = NULL;
   1ecb2:	10 92 69 01 	sts	0x0169, r1
   1ecb6:	10 92 68 01 	sts	0x0168, r1
    tftpDisconnect();
   1ecba:	0e 94 04 f5 	call	0x1ea08	; 0x1ea08 <tftpDisconnect>
    onTFtpTimeOut();
   1ecbe:	0e 94 1b fd 	call	0x1fa36	; 0x1fa36 <onTFtpTimeOut>
  }
   1ecc2:	08 95       	ret

0001ecc4 <onInitClock>:
  return rtcGetTime32();
}

void onInitClock()
{
  rtcInitialize();
   1ecc4:	0e 94 65 f8 	call	0x1f0ca	; 0x1f0ca <rtcInitialize>
  return;
}
   1ecc8:	08 95       	ret

0001ecca <clockGetShortTimeStamp>:
  return rtcGetTime64();
}

uint32_t clockGetShortTimeStamp()
{
  return rtcGetTime32();
   1ecca:	0e 94 a9 f8 	call	0x1f152	; 0x1f152 <rtcGetTime32>
}
   1ecce:	08 95       	ret

0001ecd0 <clockGetTimeStamp>:
#include "./../../hal/rtc/rtc.h"
#include "./clock.h"

uint64_t clockGetTimeStamp()
{
  return rtcGetTime64();
   1ecd0:	0e 94 81 f8 	call	0x1f102	; 0x1f102 <rtcGetTime64>
}
   1ecd4:	08 95       	ret

0001ecd6 <onInitTimer>:
}

void onInitTimer()
{
  // Initalize Scheduler
  timerList.firstNode = NULL;
   1ecd6:	10 92 a3 01 	sts	0x01A3, r1
   1ecda:	10 92 a2 01 	sts	0x01A2, r1
  timerList.lastNode = NULL;
   1ecde:	10 92 a5 01 	sts	0x01A5, r1
   1ece2:	10 92 a4 01 	sts	0x01A4, r1
}
   1ece6:	08 95       	ret

0001ece8 <timerClearTimeout>:
}

// after any timeout or calling this function it is essential to NULL 
// the element variable
void timerClearTimeout(struct timerElement_t* element)
{
   1ece8:	0f 93       	push	r16
   1ecea:	1f 93       	push	r17
   1ecec:	8c 01       	movw	r16, r24
    
  removeDlNode(&timerList,(struct dlNode_t*)element);
   1ecee:	82 ea       	ldi	r24, 0xA2	; 162
   1ecf0:	91 e0       	ldi	r25, 0x01	; 1
   1ecf2:	b8 01       	movw	r22, r16
   1ecf4:	0e 94 20 f8 	call	0x1f040	; 0x1f040 <removeDlNode>
  free(element);
   1ecf8:	c8 01       	movw	r24, r16
   1ecfa:	0e 94 10 ff 	call	0x1fe20	; 0x1fe20 <free>
}
   1ecfe:	1f 91       	pop	r17
   1ed00:	0f 91       	pop	r16
   1ed02:	08 95       	ret

0001ed04 <onTimer>:


void onTimer()
{
   1ed04:	af 92       	push	r10
   1ed06:	bf 92       	push	r11
   1ed08:	cf 92       	push	r12
   1ed0a:	df 92       	push	r13
   1ed0c:	ef 92       	push	r14
   1ed0e:	ff 92       	push	r15
   1ed10:	0f 93       	push	r16
   1ed12:	1f 93       	push	r17
  if (timerList.firstNode == NULL)
   1ed14:	e0 91 a2 01 	lds	r30, 0x01A2
   1ed18:	f0 91 a3 01 	lds	r31, 0x01A3
   1ed1c:	30 97       	sbiw	r30, 0x00	; 0
   1ed1e:	99 f1       	breq	.+102    	; 0x1ed86 <onTimer+0x82>
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
   1ed20:	a4 80       	ldd	r10, Z+4	; 0x04
   1ed22:	b5 80       	ldd	r11, Z+5	; 0x05
   1ed24:	c6 80       	ldd	r12, Z+6	; 0x06
   1ed26:	d7 80       	ldd	r13, Z+7	; 0x07
   1ed28:	e0 84       	ldd	r14, Z+8	; 0x08
   1ed2a:	f1 84       	ldd	r15, Z+9	; 0x09
   1ed2c:	12 85       	ldd	r17, Z+10	; 0x0a
   1ed2e:	03 85       	ldd	r16, Z+11	; 0x0b
   1ed30:	0e 94 68 f6 	call	0x1ecd0	; 0x1ecd0 <clockGetTimeStamp>
   1ed34:	90 17       	cp	r25, r16
   1ed36:	38 f1       	brcs	.+78     	; 0x1ed86 <onTimer+0x82>
   1ed38:	09 17       	cp	r16, r25
   1ed3a:	d1 f4       	brne	.+52     	; 0x1ed70 <onTimer+0x6c>
   1ed3c:	81 17       	cp	r24, r17
   1ed3e:	18 f1       	brcs	.+70     	; 0x1ed86 <onTimer+0x82>
   1ed40:	18 17       	cp	r17, r24
   1ed42:	b1 f4       	brne	.+44     	; 0x1ed70 <onTimer+0x6c>
   1ed44:	7f 15       	cp	r23, r15
   1ed46:	f8 f0       	brcs	.+62     	; 0x1ed86 <onTimer+0x82>
   1ed48:	f7 16       	cp	r15, r23
   1ed4a:	91 f4       	brne	.+36     	; 0x1ed70 <onTimer+0x6c>
   1ed4c:	6e 15       	cp	r22, r14
   1ed4e:	d8 f0       	brcs	.+54     	; 0x1ed86 <onTimer+0x82>
   1ed50:	e6 16       	cp	r14, r22
   1ed52:	71 f4       	brne	.+28     	; 0x1ed70 <onTimer+0x6c>
   1ed54:	5d 15       	cp	r21, r13
   1ed56:	b8 f0       	brcs	.+46     	; 0x1ed86 <onTimer+0x82>
   1ed58:	d5 16       	cp	r13, r21
   1ed5a:	51 f4       	brne	.+20     	; 0x1ed70 <onTimer+0x6c>
   1ed5c:	4c 15       	cp	r20, r12
   1ed5e:	98 f0       	brcs	.+38     	; 0x1ed86 <onTimer+0x82>
   1ed60:	c4 16       	cp	r12, r20
   1ed62:	31 f4       	brne	.+12     	; 0x1ed70 <onTimer+0x6c>
   1ed64:	3b 15       	cp	r19, r11
   1ed66:	78 f0       	brcs	.+30     	; 0x1ed86 <onTimer+0x82>
   1ed68:	b3 16       	cp	r11, r19
   1ed6a:	11 f4       	brne	.+4      	; 0x1ed70 <onTimer+0x6c>
   1ed6c:	2a 15       	cp	r18, r10
   1ed6e:	58 f0       	brcs	.+22     	; 0x1ed86 <onTimer+0x82>
    return;
  
  // we need to remove the obsolete timer entry...
  // ... before we do the callback!
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
   1ed70:	e0 91 a2 01 	lds	r30, 0x01A2
   1ed74:	f0 91 a3 01 	lds	r31, 0x01A3
   1ed78:	04 85       	ldd	r16, Z+12	; 0x0c
   1ed7a:	15 85       	ldd	r17, Z+13	; 0x0d
  timerClearTimeout(((struct timerElement_t*)(timerList.firstNode)));
   1ed7c:	cf 01       	movw	r24, r30
   1ed7e:	0e 94 74 f6 	call	0x1ece8	; 0x1ece8 <timerClearTimeout>
  
  // as the entry is removed, we have to use...
  // ...our temporary variable to do the callback
  ((void(*) ()) (callback)) ();
   1ed82:	f8 01       	movw	r30, r16
   1ed84:	09 95       	icall
  
  return; 
}
   1ed86:	1f 91       	pop	r17
   1ed88:	0f 91       	pop	r16
   1ed8a:	ff 90       	pop	r15
   1ed8c:	ef 90       	pop	r14
   1ed8e:	df 90       	pop	r13
   1ed90:	cf 90       	pop	r12
   1ed92:	bf 90       	pop	r11
   1ed94:	af 90       	pop	r10
   1ed96:	08 95       	ret

0001ed98 <timerAddTimeout>:
// which is damm close to 1000ms


struct timerElement_t* timerAddTimeout(uint16_t delay, 
    void (*callback)())
{
   1ed98:	8f 92       	push	r8
   1ed9a:	9f 92       	push	r9
   1ed9c:	af 92       	push	r10
   1ed9e:	bf 92       	push	r11
   1eda0:	cf 92       	push	r12
   1eda2:	df 92       	push	r13
   1eda4:	ef 92       	push	r14
   1eda6:	ff 92       	push	r15
   1eda8:	0f 93       	push	r16
   1edaa:	1f 93       	push	r17
   1edac:	cf 93       	push	r28
   1edae:	df 93       	push	r29
   1edb0:	8c 01       	movw	r16, r24
   1edb2:	4b 01       	movw	r8, r22
  struct timerElement_t* newNode
    = (struct timerElement_t*) malloc(sizeof(struct timerElement_t));
   1edb4:	8e e0       	ldi	r24, 0x0E	; 14
   1edb6:	90 e0       	ldi	r25, 0x00	; 0
   1edb8:	0e 94 66 fe 	call	0x1fccc	; 0x1fccc <malloc>
   1edbc:	ec 01       	movw	r28, r24
  
  // timestamp = now(in ms) + delay
  newNode->timebomb = clockGetTimeStamp()+delay;
   1edbe:	0e 94 68 f6 	call	0x1ecd0	; 0x1ecd0 <clockGetTimeStamp>
   1edc2:	f4 2e       	mov	r15, r20
   1edc4:	e5 2e       	mov	r14, r21
   1edc6:	d6 2e       	mov	r13, r22
   1edc8:	c7 2e       	mov	r12, r23
   1edca:	b8 2e       	mov	r11, r24
   1edcc:	a9 2e       	mov	r10, r25
   1edce:	a8 01       	movw	r20, r16
   1edd0:	12 2f       	mov	r17, r18
   1edd2:	14 0f       	add	r17, r20
   1edd4:	e1 e0       	ldi	r30, 0x01	; 1
   1edd6:	12 17       	cp	r17, r18
   1edd8:	08 f0       	brcs	.+2      	; 0x1eddc <timerAddTimeout+0x44>
   1edda:	e0 e0       	ldi	r30, 0x00	; 0
   1eddc:	03 2f       	mov	r16, r19
   1edde:	05 0f       	add	r16, r21
   1ede0:	f1 e0       	ldi	r31, 0x01	; 1
   1ede2:	03 17       	cp	r16, r19
   1ede4:	08 f0       	brcs	.+2      	; 0x1ede8 <timerAddTimeout+0x50>
   1ede6:	f0 e0       	ldi	r31, 0x00	; 0
   1ede8:	be 2f       	mov	r27, r30
   1edea:	b0 0f       	add	r27, r16
   1edec:	21 e0       	ldi	r18, 0x01	; 1
   1edee:	b0 17       	cp	r27, r16
   1edf0:	08 f0       	brcs	.+2      	; 0x1edf4 <timerAddTimeout+0x5c>
   1edf2:	20 e0       	ldi	r18, 0x00	; 0
   1edf4:	3f 2f       	mov	r19, r31
   1edf6:	32 2b       	or	r19, r18
   1edf8:	3f 0d       	add	r19, r15
   1edfa:	21 e0       	ldi	r18, 0x01	; 1
   1edfc:	3f 15       	cp	r19, r15
   1edfe:	08 f0       	brcs	.+2      	; 0x1ee02 <timerAddTimeout+0x6a>
   1ee00:	20 e0       	ldi	r18, 0x00	; 0
   1ee02:	a2 2f       	mov	r26, r18
   1ee04:	ae 0d       	add	r26, r14
   1ee06:	21 e0       	ldi	r18, 0x01	; 1
   1ee08:	ae 15       	cp	r26, r14
   1ee0a:	08 f0       	brcs	.+2      	; 0x1ee0e <timerAddTimeout+0x76>
   1ee0c:	20 e0       	ldi	r18, 0x00	; 0
   1ee0e:	52 2f       	mov	r21, r18
   1ee10:	5d 0d       	add	r21, r13
   1ee12:	21 e0       	ldi	r18, 0x01	; 1
   1ee14:	5d 15       	cp	r21, r13
   1ee16:	08 f0       	brcs	.+2      	; 0x1ee1a <timerAddTimeout+0x82>
   1ee18:	20 e0       	ldi	r18, 0x00	; 0
   1ee1a:	42 2f       	mov	r20, r18
   1ee1c:	4c 0d       	add	r20, r12
   1ee1e:	21 e0       	ldi	r18, 0x01	; 1
   1ee20:	4c 15       	cp	r20, r12
   1ee22:	08 f0       	brcs	.+2      	; 0x1ee26 <timerAddTimeout+0x8e>
   1ee24:	20 e0       	ldi	r18, 0x00	; 0
   1ee26:	2b 0d       	add	r18, r11
   1ee28:	91 e0       	ldi	r25, 0x01	; 1
   1ee2a:	2b 15       	cp	r18, r11
   1ee2c:	08 f0       	brcs	.+2      	; 0x1ee30 <timerAddTimeout+0x98>
   1ee2e:	90 e0       	ldi	r25, 0x00	; 0
   1ee30:	9a 0d       	add	r25, r10
   1ee32:	1c 83       	std	Y+4, r17	; 0x04
   1ee34:	bd 83       	std	Y+5, r27	; 0x05
   1ee36:	3e 83       	std	Y+6, r19	; 0x06
   1ee38:	af 83       	std	Y+7, r26	; 0x07
   1ee3a:	58 87       	std	Y+8, r21	; 0x08
   1ee3c:	49 87       	std	Y+9, r20	; 0x09
   1ee3e:	2a 87       	std	Y+10, r18	; 0x0a
   1ee40:	9b 87       	std	Y+11, r25	; 0x0b
  newNode->callback = callback;
   1ee42:	9d 86       	std	Y+13, r9	; 0x0d
   1ee44:	8c 86       	std	Y+12, r8	; 0x0c
 
  // If the list is empty, we can do a shortcut...
  if (timerList.firstNode == NULL)
   1ee46:	e0 91 a2 01 	lds	r30, 0x01A2
   1ee4a:	f0 91 a3 01 	lds	r31, 0x01A3
   1ee4e:	30 97       	sbiw	r30, 0x00	; 0
   1ee50:	31 f4       	brne	.+12     	; 0x1ee5e <timerAddTimeout+0xc6>
  {
    insertDlNodeBeginning(&timerList,(struct dlNode_t*)newNode);    
   1ee52:	82 ea       	ldi	r24, 0xA2	; 162
   1ee54:	91 e0       	ldi	r25, 0x01	; 1
   1ee56:	be 01       	movw	r22, r28
   1ee58:	0e 94 b1 f7 	call	0x1ef62	; 0x1ef62 <insertDlNodeBeginning>
   1ee5c:	32 c0       	rjmp	.+100    	; 0x1eec2 <timerAddTimeout+0x12a>
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
  {
    if (((struct timerElement_t*)node)->timebomb > newNode->timebomb)
   1ee5e:	83 85       	ldd	r24, Z+11	; 0x0b
   1ee60:	98 17       	cp	r25, r24
   1ee62:	48 f1       	brcs	.+82     	; 0x1eeb6 <timerAddTimeout+0x11e>
   1ee64:	89 17       	cp	r24, r25
   1ee66:	09 f5       	brne	.+66     	; 0x1eeaa <timerAddTimeout+0x112>
   1ee68:	82 85       	ldd	r24, Z+10	; 0x0a
   1ee6a:	28 17       	cp	r18, r24
   1ee6c:	20 f1       	brcs	.+72     	; 0x1eeb6 <timerAddTimeout+0x11e>
   1ee6e:	82 17       	cp	r24, r18
   1ee70:	e1 f4       	brne	.+56     	; 0x1eeaa <timerAddTimeout+0x112>
   1ee72:	81 85       	ldd	r24, Z+9	; 0x09
   1ee74:	48 17       	cp	r20, r24
   1ee76:	f8 f0       	brcs	.+62     	; 0x1eeb6 <timerAddTimeout+0x11e>
   1ee78:	84 17       	cp	r24, r20
   1ee7a:	b9 f4       	brne	.+46     	; 0x1eeaa <timerAddTimeout+0x112>
   1ee7c:	80 85       	ldd	r24, Z+8	; 0x08
   1ee7e:	58 17       	cp	r21, r24
   1ee80:	d0 f0       	brcs	.+52     	; 0x1eeb6 <timerAddTimeout+0x11e>
   1ee82:	85 17       	cp	r24, r21
   1ee84:	91 f4       	brne	.+36     	; 0x1eeaa <timerAddTimeout+0x112>
   1ee86:	87 81       	ldd	r24, Z+7	; 0x07
   1ee88:	a8 17       	cp	r26, r24
   1ee8a:	a8 f0       	brcs	.+42     	; 0x1eeb6 <timerAddTimeout+0x11e>
   1ee8c:	8a 17       	cp	r24, r26
   1ee8e:	69 f4       	brne	.+26     	; 0x1eeaa <timerAddTimeout+0x112>
   1ee90:	86 81       	ldd	r24, Z+6	; 0x06
   1ee92:	38 17       	cp	r19, r24
   1ee94:	80 f0       	brcs	.+32     	; 0x1eeb6 <timerAddTimeout+0x11e>
   1ee96:	83 17       	cp	r24, r19
   1ee98:	41 f4       	brne	.+16     	; 0x1eeaa <timerAddTimeout+0x112>
   1ee9a:	85 81       	ldd	r24, Z+5	; 0x05
   1ee9c:	b8 17       	cp	r27, r24
   1ee9e:	58 f0       	brcs	.+22     	; 0x1eeb6 <timerAddTimeout+0x11e>
   1eea0:	8b 17       	cp	r24, r27
   1eea2:	19 f4       	brne	.+6      	; 0x1eeaa <timerAddTimeout+0x112>
   1eea4:	84 81       	ldd	r24, Z+4	; 0x04
   1eea6:	18 17       	cp	r17, r24
   1eea8:	30 f0       	brcs	.+12     	; 0x1eeb6 <timerAddTimeout+0x11e>
      break;
    node = node->next;
   1eeaa:	02 80       	ldd	r0, Z+2	; 0x02
   1eeac:	f3 81       	ldd	r31, Z+3	; 0x03
   1eeae:	e0 2d       	mov	r30, r0
  
  // ... otherise we have to add the entry into the sorted list
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
   1eeb0:	30 97       	sbiw	r30, 0x00	; 0
   1eeb2:	a9 f6       	brne	.-86     	; 0x1ee5e <timerAddTimeout+0xc6>
   1eeb4:	14 c0       	rjmp	.+40     	; 0x1eede <timerAddTimeout+0x146>
  {
    insertDlNodeLast(&timerList,(struct dlNode_t*)newNode);    
    return newNode;
  }
  
  insertDlNodeBefore(&timerList,node,(struct dlNode_t*)newNode);
   1eeb6:	82 ea       	ldi	r24, 0xA2	; 162
   1eeb8:	91 e0       	ldi	r25, 0x01	; 1
   1eeba:	bf 01       	movw	r22, r30
   1eebc:	ae 01       	movw	r20, r28
   1eebe:	0e 94 95 f7 	call	0x1ef2a	; 0x1ef2a <insertDlNodeBefore>
 
  return newNode;    
}
   1eec2:	ce 01       	movw	r24, r28
   1eec4:	df 91       	pop	r29
   1eec6:	cf 91       	pop	r28
   1eec8:	1f 91       	pop	r17
   1eeca:	0f 91       	pop	r16
   1eecc:	ff 90       	pop	r15
   1eece:	ef 90       	pop	r14
   1eed0:	df 90       	pop	r13
   1eed2:	cf 90       	pop	r12
   1eed4:	bf 90       	pop	r11
   1eed6:	af 90       	pop	r10
   1eed8:	9f 90       	pop	r9
   1eeda:	8f 90       	pop	r8
   1eedc:	08 95       	ret
  }
  
  // We reached the end of the list without a hit?
  if (node == NULL)
  {
    insertDlNodeLast(&timerList,(struct dlNode_t*)newNode);    
   1eede:	82 ea       	ldi	r24, 0xA2	; 162
   1eee0:	91 e0       	ldi	r25, 0x01	; 1
   1eee2:	be 01       	movw	r22, r28
   1eee4:	0e 94 da f7 	call	0x1efb4	; 0x1efb4 <insertDlNodeLast>
   1eee8:	ec cf       	rjmp	.-40     	; 0x1eec2 <timerAddTimeout+0x12a>

0001eeea <insertDlNodeAfter>:
  #include "./doublyLinkedList.h"
  #include <stdlib.h>
  
  
  void insertDlNodeAfter(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
   1eeea:	cf 93       	push	r28
   1eeec:	df 93       	push	r29
   1eeee:	9c 01       	movw	r18, r24
   1eef0:	db 01       	movw	r26, r22
   1eef2:	fa 01       	movw	r30, r20
    newNode->prev = node;
   1eef4:	71 83       	std	Z+1, r23	; 0x01
   1eef6:	60 83       	st	Z, r22
    newNode->next = node->next;
   1eef8:	12 96       	adiw	r26, 0x02	; 2
   1eefa:	8d 91       	ld	r24, X+
   1eefc:	9c 91       	ld	r25, X
   1eefe:	13 97       	sbiw	r26, 0x03	; 3
   1ef00:	93 83       	std	Z+3, r25	; 0x03
   1ef02:	82 83       	std	Z+2, r24	; 0x02
    
    if (node->next == NULL)
   1ef04:	12 96       	adiw	r26, 0x02	; 2
   1ef06:	cd 91       	ld	r28, X+
   1ef08:	dc 91       	ld	r29, X
   1ef0a:	13 97       	sbiw	r26, 0x03	; 3
   1ef0c:	20 97       	sbiw	r28, 0x00	; 0
   1ef0e:	21 f4       	brne	.+8      	; 0x1ef18 <insertDlNodeAfter+0x2e>
      list->lastNode = newNode;
   1ef10:	e9 01       	movw	r28, r18
   1ef12:	5b 83       	std	Y+3, r21	; 0x03
   1ef14:	4a 83       	std	Y+2, r20	; 0x02
   1ef16:	02 c0       	rjmp	.+4      	; 0x1ef1c <insertDlNodeAfter+0x32>
    else
      node->next->prev = newNode;
   1ef18:	59 83       	std	Y+1, r21	; 0x01
   1ef1a:	48 83       	st	Y, r20
    
    node->next = newNode;
   1ef1c:	13 96       	adiw	r26, 0x03	; 3
   1ef1e:	fc 93       	st	X, r31
   1ef20:	ee 93       	st	-X, r30
   1ef22:	12 97       	sbiw	r26, 0x02	; 2
  }
   1ef24:	df 91       	pop	r29
   1ef26:	cf 91       	pop	r28
   1ef28:	08 95       	ret

0001ef2a <insertDlNodeBefore>:
  
  void insertDlNodeBefore(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
   1ef2a:	cf 93       	push	r28
   1ef2c:	df 93       	push	r29
   1ef2e:	9c 01       	movw	r18, r24
   1ef30:	db 01       	movw	r26, r22
   1ef32:	fa 01       	movw	r30, r20
    newNode->prev = node->prev;
   1ef34:	8d 91       	ld	r24, X+
   1ef36:	9c 91       	ld	r25, X
   1ef38:	11 97       	sbiw	r26, 0x01	; 1
   1ef3a:	91 83       	std	Z+1, r25	; 0x01
   1ef3c:	80 83       	st	Z, r24
    newNode->next = node;
   1ef3e:	73 83       	std	Z+3, r23	; 0x03
   1ef40:	62 83       	std	Z+2, r22	; 0x02
    
    
    if (node->prev == NULL)
   1ef42:	cd 91       	ld	r28, X+
   1ef44:	dc 91       	ld	r29, X
   1ef46:	11 97       	sbiw	r26, 0x01	; 1
   1ef48:	20 97       	sbiw	r28, 0x00	; 0
   1ef4a:	21 f4       	brne	.+8      	; 0x1ef54 <insertDlNodeBefore+0x2a>
      list->firstNode = newNode;
   1ef4c:	e9 01       	movw	r28, r18
   1ef4e:	59 83       	std	Y+1, r21	; 0x01
   1ef50:	48 83       	st	Y, r20
   1ef52:	02 c0       	rjmp	.+4      	; 0x1ef58 <insertDlNodeBefore+0x2e>
    else
      node->prev->next = newNode;
   1ef54:	5b 83       	std	Y+3, r21	; 0x03
   1ef56:	4a 83       	std	Y+2, r20	; 0x02
    
    node->prev = newNode;
   1ef58:	ed 93       	st	X+, r30
   1ef5a:	fc 93       	st	X, r31
  }
   1ef5c:	df 91       	pop	r29
   1ef5e:	cf 91       	pop	r28
   1ef60:	08 95       	ret

0001ef62 <insertDlNodeBeginning>:
  
  void insertDlNodeBeginning(struct dlList_t* list, struct dlNode_t* newNode)
  {
   1ef62:	cf 93       	push	r28
   1ef64:	df 93       	push	r29
   1ef66:	9c 01       	movw	r18, r24
   1ef68:	fb 01       	movw	r30, r22
    if (list->firstNode == NULL)
   1ef6a:	ec 01       	movw	r28, r24
   1ef6c:	a8 81       	ld	r26, Y
   1ef6e:	b9 81       	ldd	r27, Y+1	; 0x01
   1ef70:	10 97       	sbiw	r26, 0x00	; 0
   1ef72:	49 f4       	brne	.+18     	; 0x1ef86 <insertDlNodeBeginning+0x24>
    {
      list->firstNode = newNode;
   1ef74:	79 83       	std	Y+1, r23	; 0x01
   1ef76:	68 83       	st	Y, r22
      list->lastNode = newNode;
   1ef78:	7b 83       	std	Y+3, r23	; 0x03
   1ef7a:	6a 83       	std	Y+2, r22	; 0x02
      
      newNode->prev = NULL;
   1ef7c:	11 82       	std	Z+1, r1	; 0x01
   1ef7e:	10 82       	st	Z, r1
      newNode->next = NULL;
   1ef80:	13 82       	std	Z+3, r1	; 0x03
   1ef82:	12 82       	std	Z+2, r1	; 0x02
   1ef84:	14 c0       	rjmp	.+40     	; 0x1efae <insertDlNodeBeginning+0x4c>
    node->next = newNode;
  }
  
  void insertDlNodeBefore(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    newNode->prev = node->prev;
   1ef86:	8d 91       	ld	r24, X+
   1ef88:	9c 91       	ld	r25, X
   1ef8a:	11 97       	sbiw	r26, 0x01	; 1
   1ef8c:	91 83       	std	Z+1, r25	; 0x01
   1ef8e:	80 83       	st	Z, r24
    newNode->next = node;
   1ef90:	b3 83       	std	Z+3, r27	; 0x03
   1ef92:	a2 83       	std	Z+2, r26	; 0x02
    
    
    if (node->prev == NULL)
   1ef94:	cd 91       	ld	r28, X+
   1ef96:	dc 91       	ld	r29, X
   1ef98:	11 97       	sbiw	r26, 0x01	; 1
   1ef9a:	20 97       	sbiw	r28, 0x00	; 0
   1ef9c:	21 f4       	brne	.+8      	; 0x1efa6 <insertDlNodeBeginning+0x44>
      list->firstNode = newNode;
   1ef9e:	e9 01       	movw	r28, r18
   1efa0:	79 83       	std	Y+1, r23	; 0x01
   1efa2:	68 83       	st	Y, r22
   1efa4:	02 c0       	rjmp	.+4      	; 0x1efaa <insertDlNodeBeginning+0x48>
    else
      node->prev->next = newNode;
   1efa6:	7b 83       	std	Y+3, r23	; 0x03
   1efa8:	6a 83       	std	Y+2, r22	; 0x02
    
    node->prev = newNode;
   1efaa:	ed 93       	st	X+, r30
   1efac:	fc 93       	st	X, r31
      newNode->next = NULL;
    }
    else
      insertDlNodeBefore(list,list->firstNode,newNode);
    
  }
   1efae:	df 91       	pop	r29
   1efb0:	cf 91       	pop	r28
   1efb2:	08 95       	ret

0001efb4 <insertDlNodeLast>:
  
  void insertDlNodeLast(struct dlList_t* list, struct dlNode_t* newNode)
  {
   1efb4:	cf 93       	push	r28
   1efb6:	df 93       	push	r29
   1efb8:	9c 01       	movw	r18, r24
   1efba:	fb 01       	movw	r30, r22
    if (list->lastNode == NULL)
   1efbc:	ec 01       	movw	r28, r24
   1efbe:	aa 81       	ldd	r26, Y+2	; 0x02
   1efc0:	bb 81       	ldd	r27, Y+3	; 0x03
   1efc2:	10 97       	sbiw	r26, 0x00	; 0
   1efc4:	11 f5       	brne	.+68     	; 0x1f00a <insertDlNodeLast+0x56>
    node->prev = newNode;
  }
  
  void insertDlNodeBeginning(struct dlList_t* list, struct dlNode_t* newNode)
  {
    if (list->firstNode == NULL)
   1efc6:	a8 81       	ld	r26, Y
   1efc8:	b9 81       	ldd	r27, Y+1	; 0x01
   1efca:	10 97       	sbiw	r26, 0x00	; 0
   1efcc:	49 f4       	brne	.+18     	; 0x1efe0 <insertDlNodeLast+0x2c>
    {
      list->firstNode = newNode;
   1efce:	79 83       	std	Y+1, r23	; 0x01
   1efd0:	68 83       	st	Y, r22
      list->lastNode = newNode;
   1efd2:	7b 83       	std	Y+3, r23	; 0x03
   1efd4:	6a 83       	std	Y+2, r22	; 0x02
      
      newNode->prev = NULL;
   1efd6:	11 82       	std	Z+1, r1	; 0x01
   1efd8:	10 82       	st	Z, r1
      newNode->next = NULL;
   1efda:	13 82       	std	Z+3, r1	; 0x03
   1efdc:	12 82       	std	Z+2, r1	; 0x02
   1efde:	2d c0       	rjmp	.+90     	; 0x1f03a <insertDlNodeLast+0x86>
    node->next = newNode;
  }
  
  void insertDlNodeBefore(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    newNode->prev = node->prev;
   1efe0:	8d 91       	ld	r24, X+
   1efe2:	9c 91       	ld	r25, X
   1efe4:	11 97       	sbiw	r26, 0x01	; 1
   1efe6:	91 83       	std	Z+1, r25	; 0x01
   1efe8:	80 83       	st	Z, r24
    newNode->next = node;
   1efea:	b3 83       	std	Z+3, r27	; 0x03
   1efec:	a2 83       	std	Z+2, r26	; 0x02
    
    
    if (node->prev == NULL)
   1efee:	cd 91       	ld	r28, X+
   1eff0:	dc 91       	ld	r29, X
   1eff2:	11 97       	sbiw	r26, 0x01	; 1
   1eff4:	20 97       	sbiw	r28, 0x00	; 0
   1eff6:	21 f4       	brne	.+8      	; 0x1f000 <insertDlNodeLast+0x4c>
      list->firstNode = newNode;
   1eff8:	e9 01       	movw	r28, r18
   1effa:	79 83       	std	Y+1, r23	; 0x01
   1effc:	68 83       	st	Y, r22
   1effe:	02 c0       	rjmp	.+4      	; 0x1f004 <insertDlNodeLast+0x50>
    else
      node->prev->next = newNode;
   1f000:	7b 83       	std	Y+3, r23	; 0x03
   1f002:	6a 83       	std	Y+2, r22	; 0x02
    
    node->prev = newNode;
   1f004:	ed 93       	st	X+, r30
   1f006:	fc 93       	st	X, r31
   1f008:	18 c0       	rjmp	.+48     	; 0x1f03a <insertDlNodeLast+0x86>
  #include <stdlib.h>
  
  
  void insertDlNodeAfter(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    newNode->prev = node;
   1f00a:	b1 83       	std	Z+1, r27	; 0x01
   1f00c:	a0 83       	st	Z, r26
    newNode->next = node->next;
   1f00e:	12 96       	adiw	r26, 0x02	; 2
   1f010:	8d 91       	ld	r24, X+
   1f012:	9c 91       	ld	r25, X
   1f014:	13 97       	sbiw	r26, 0x03	; 3
   1f016:	93 83       	std	Z+3, r25	; 0x03
   1f018:	82 83       	std	Z+2, r24	; 0x02
    
    if (node->next == NULL)
   1f01a:	12 96       	adiw	r26, 0x02	; 2
   1f01c:	cd 91       	ld	r28, X+
   1f01e:	dc 91       	ld	r29, X
   1f020:	13 97       	sbiw	r26, 0x03	; 3
   1f022:	20 97       	sbiw	r28, 0x00	; 0
   1f024:	21 f4       	brne	.+8      	; 0x1f02e <insertDlNodeLast+0x7a>
      list->lastNode = newNode;
   1f026:	e9 01       	movw	r28, r18
   1f028:	7b 83       	std	Y+3, r23	; 0x03
   1f02a:	6a 83       	std	Y+2, r22	; 0x02
   1f02c:	02 c0       	rjmp	.+4      	; 0x1f032 <insertDlNodeLast+0x7e>
    else
      node->next->prev = newNode;
   1f02e:	79 83       	std	Y+1, r23	; 0x01
   1f030:	68 83       	st	Y, r22
    
    node->next = newNode;
   1f032:	13 96       	adiw	r26, 0x03	; 3
   1f034:	fc 93       	st	X, r31
   1f036:	ee 93       	st	-X, r30
   1f038:	12 97       	sbiw	r26, 0x02	; 2
  {
    if (list->lastNode == NULL)
      insertDlNodeBeginning(list,newNode);
    else
      insertDlNodeAfter(list,list->lastNode,newNode);
  }
   1f03a:	df 91       	pop	r29
   1f03c:	cf 91       	pop	r28
   1f03e:	08 95       	ret

0001f040 <removeDlNode>:
  
  void removeDlNode(struct dlList_t* list, struct dlNode_t* node)
  {
   1f040:	cf 93       	push	r28
   1f042:	df 93       	push	r29
   1f044:	ec 01       	movw	r28, r24
   1f046:	fb 01       	movw	r30, r22
    if (node->prev == NULL)
   1f048:	a0 81       	ld	r26, Z
   1f04a:	b1 81       	ldd	r27, Z+1	; 0x01
   1f04c:	82 81       	ldd	r24, Z+2	; 0x02
   1f04e:	93 81       	ldd	r25, Z+3	; 0x03
   1f050:	10 97       	sbiw	r26, 0x00	; 0
   1f052:	19 f4       	brne	.+6      	; 0x1f05a <removeDlNode+0x1a>
      list->firstNode = node->next;
   1f054:	99 83       	std	Y+1, r25	; 0x01
   1f056:	88 83       	st	Y, r24
   1f058:	04 c0       	rjmp	.+8      	; 0x1f062 <removeDlNode+0x22>
    else
      node->prev->next = node->next;
   1f05a:	13 96       	adiw	r26, 0x03	; 3
   1f05c:	9c 93       	st	X, r25
   1f05e:	8e 93       	st	-X, r24
   1f060:	12 97       	sbiw	r26, 0x02	; 2
    
    if (node->next == NULL)
   1f062:	a2 81       	ldd	r26, Z+2	; 0x02
   1f064:	b3 81       	ldd	r27, Z+3	; 0x03
   1f066:	60 81       	ld	r22, Z
   1f068:	71 81       	ldd	r23, Z+1	; 0x01
   1f06a:	10 97       	sbiw	r26, 0x00	; 0
   1f06c:	19 f4       	brne	.+6      	; 0x1f074 <removeDlNode+0x34>
      list->lastNode = node->prev;
   1f06e:	7b 83       	std	Y+3, r23	; 0x03
   1f070:	6a 83       	std	Y+2, r22	; 0x02
   1f072:	02 c0       	rjmp	.+4      	; 0x1f078 <removeDlNode+0x38>
    else
      node->next->prev = node->prev;  
   1f074:	6d 93       	st	X+, r22
   1f076:	7c 93       	st	X, r23
  }
   1f078:	df 91       	pop	r29
   1f07a:	cf 91       	pop	r28
   1f07c:	08 95       	ret

0001f07e <__vector_16>:
// ... which is a lot more than the expected livetime of the device
volatile uint32_t overflows;


ISR(TIMER0_OVF_vect)
{
   1f07e:	1f 92       	push	r1
   1f080:	0f 92       	push	r0
   1f082:	0f b6       	in	r0, 0x3f	; 63
   1f084:	0f 92       	push	r0
   1f086:	11 24       	eor	r1, r1
   1f088:	8f 93       	push	r24
   1f08a:	9f 93       	push	r25
   1f08c:	af 93       	push	r26
   1f08e:	bf 93       	push	r27
  // we should get 4 interrupts per Second... 
  TCNT0 = 0;
   1f090:	12 be       	out	0x32, r1	; 50
  overflows++;  
   1f092:	80 91 a6 01 	lds	r24, 0x01A6
   1f096:	90 91 a7 01 	lds	r25, 0x01A7
   1f09a:	a0 91 a8 01 	lds	r26, 0x01A8
   1f09e:	b0 91 a9 01 	lds	r27, 0x01A9
   1f0a2:	01 96       	adiw	r24, 0x01	; 1
   1f0a4:	a1 1d       	adc	r26, r1
   1f0a6:	b1 1d       	adc	r27, r1
   1f0a8:	80 93 a6 01 	sts	0x01A6, r24
   1f0ac:	90 93 a7 01 	sts	0x01A7, r25
   1f0b0:	a0 93 a8 01 	sts	0x01A8, r26
   1f0b4:	b0 93 a9 01 	sts	0x01A9, r27
}
   1f0b8:	bf 91       	pop	r27
   1f0ba:	af 91       	pop	r26
   1f0bc:	9f 91       	pop	r25
   1f0be:	8f 91       	pop	r24
   1f0c0:	0f 90       	pop	r0
   1f0c2:	0f be       	out	0x3f, r0	; 63
   1f0c4:	0f 90       	pop	r0
   1f0c6:	1f 90       	pop	r1
   1f0c8:	18 95       	reti

0001f0ca <rtcInitialize>:

void rtcInitialize()
{
  overflows = 0;
   1f0ca:	10 92 a6 01 	sts	0x01A6, r1
   1f0ce:	10 92 a7 01 	sts	0x01A7, r1
   1f0d2:	10 92 a8 01 	sts	0x01A8, r1
   1f0d6:	10 92 a9 01 	sts	0x01A9, r1
  // ...the timer is asynchronous to out system clock...
  // ... according to the ATMega manual, the following...
  // ... precausions are mandatory.
  
  // Disable interrputs OCIE0 and TOIE0...
  TIMSK &= ~( (1<<OCIE0) | (1<<TOIE0) );
   1f0da:	87 b7       	in	r24, 0x37	; 55
   1f0dc:	8c 7f       	andi	r24, 0xFC	; 252
   1f0de:	87 bf       	out	0x37, r24	; 55
  // ... switch to asynchronous mode...
  ASSR |= (1 << AS0);
   1f0e0:	80 b7       	in	r24, 0x30	; 48
   1f0e2:	88 60       	ori	r24, 0x08	; 8
   1f0e4:	80 bf       	out	0x30, r24	; 48
  // ... clear TCNT0, OCR0 ...
  TCNT0 = 0;
   1f0e6:	12 be       	out	0x32, r1	; 50
  OCR0 = 0;
   1f0e8:	11 be       	out	0x31, r1	; 49
  // ... clear and set TCCR0 to the 32 prescal divider
  TCCR0 = (1 << CS00) |  (1<<CS01);
   1f0ea:	83 e0       	ldi	r24, 0x03	; 3
   1f0ec:	83 bf       	out	0x33, r24	; 51
  
  // now wait for TCN0UB
  while (!(ASSR & (1<< TCN0UB)));
   1f0ee:	00 b6       	in	r0, 0x30	; 48
   1f0f0:	02 fe       	sbrs	r0, 2
   1f0f2:	fd cf       	rjmp	.-6      	; 0x1f0ee <rtcInitialize+0x24>
  
  // Clear Timer Infterrput flags...
  TIFR &= ~( (1<<OCF0) | (1<<TOV0));  
   1f0f4:	86 b7       	in	r24, 0x36	; 54
   1f0f6:	8c 7f       	andi	r24, 0xFC	; 252
   1f0f8:	86 bf       	out	0x36, r24	; 54
  
  // Enable Overflow Interrupt 
  TIMSK |= (1 << TOIE0); 
   1f0fa:	87 b7       	in	r24, 0x37	; 55
   1f0fc:	81 60       	ori	r24, 0x01	; 1
   1f0fe:	87 bf       	out	0x37, r24	; 55
}
   1f100:	08 95       	ret

0001f102 <rtcGetTime64>:

uint64_t rtcGetTime64()
{
   1f102:	af 92       	push	r10
   1f104:	bf 92       	push	r11
   1f106:	cf 92       	push	r12
   1f108:	df 92       	push	r13
   1f10a:	ef 92       	push	r14
   1f10c:	ff 92       	push	r15
   1f10e:	0f 93       	push	r16
   1f110:	1f 93       	push	r17
  return (overflows << 8) + TCNT0;
   1f112:	a0 90 a6 01 	lds	r10, 0x01A6
   1f116:	b0 90 a7 01 	lds	r11, 0x01A7
   1f11a:	c0 90 a8 01 	lds	r12, 0x01A8
   1f11e:	d0 90 a9 01 	lds	r13, 0x01A9
   1f122:	82 b7       	in	r24, 0x32	; 50
   1f124:	dc 2c       	mov	r13, r12
   1f126:	cb 2c       	mov	r12, r11
   1f128:	ba 2c       	mov	r11, r10
   1f12a:	aa 24       	eor	r10, r10
   1f12c:	a8 0e       	add	r10, r24
   1f12e:	b1 1c       	adc	r11, r1
   1f130:	c1 1c       	adc	r12, r1
   1f132:	d1 1c       	adc	r13, r1
}
   1f134:	95 01       	movw	r18, r10
   1f136:	a6 01       	movw	r20, r12
   1f138:	60 e0       	ldi	r22, 0x00	; 0
   1f13a:	70 e0       	ldi	r23, 0x00	; 0
   1f13c:	80 e0       	ldi	r24, 0x00	; 0
   1f13e:	90 e0       	ldi	r25, 0x00	; 0
   1f140:	1f 91       	pop	r17
   1f142:	0f 91       	pop	r16
   1f144:	ff 90       	pop	r15
   1f146:	ef 90       	pop	r14
   1f148:	df 90       	pop	r13
   1f14a:	cf 90       	pop	r12
   1f14c:	bf 90       	pop	r11
   1f14e:	af 90       	pop	r10
   1f150:	08 95       	ret

0001f152 <rtcGetTime32>:

uint32_t rtcGetTime32()
{
  // will cut of the upper 8 bits...
  return (overflows << 8) + TCNT0;
   1f152:	20 91 a6 01 	lds	r18, 0x01A6
   1f156:	30 91 a7 01 	lds	r19, 0x01A7
   1f15a:	40 91 a8 01 	lds	r20, 0x01A8
   1f15e:	50 91 a9 01 	lds	r21, 0x01A9
   1f162:	82 b7       	in	r24, 0x32	; 50
   1f164:	54 2f       	mov	r21, r20
   1f166:	43 2f       	mov	r20, r19
   1f168:	32 2f       	mov	r19, r18
   1f16a:	22 27       	eor	r18, r18
   1f16c:	28 0f       	add	r18, r24
   1f16e:	31 1d       	adc	r19, r1
   1f170:	41 1d       	adc	r20, r1
   1f172:	51 1d       	adc	r21, r1
}
   1f174:	b9 01       	movw	r22, r18
   1f176:	ca 01       	movw	r24, r20
   1f178:	08 95       	ret

0001f17a <rtcGetTime16>:

uint16_t rtcGetTime16()
{
  // will cut of the upper 8 bits...
  return (overflows << 8) + TCNT0;
   1f17a:	20 91 a6 01 	lds	r18, 0x01A6
   1f17e:	30 91 a7 01 	lds	r19, 0x01A7
   1f182:	40 91 a8 01 	lds	r20, 0x01A8
   1f186:	50 91 a9 01 	lds	r21, 0x01A9
   1f18a:	82 b7       	in	r24, 0x32	; 50
   1f18c:	32 2f       	mov	r19, r18
   1f18e:	22 27       	eor	r18, r18
   1f190:	28 0f       	add	r18, r24
   1f192:	31 1d       	adc	r19, r1
}
   1f194:	c9 01       	movw	r24, r18
   1f196:	08 95       	ret

0001f198 <enc28j60_write>:
  uint8_t bank;
} hEnc28j60;


void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
   1f198:	fb 01       	movw	r30, r22
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f19a:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f19c:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
   1f19e:	77 9b       	sbis	0x0e, 7	; 14
   1f1a0:	fe cf       	rjmp	.-4      	; 0x1f19e <enc28j60_write+0x6>
   1f1a2:	07 c0       	rjmp	.+14     	; 0x1f1b2 <enc28j60_write+0x1a>

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f1a4:	80 81       	ld	r24, Z
   1f1a6:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f1a8:	77 9b       	sbis	0x0e, 7	; 14
   1f1aa:	fe cf       	rjmp	.-4      	; 0x1f1a8 <enc28j60_write+0x10>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f1ac:	31 96       	adiw	r30, 0x01	; 1
   1f1ae:	41 50       	subi	r20, 0x01	; 1
   1f1b0:	50 40       	sbci	r21, 0x00	; 0
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f1b2:	41 15       	cp	r20, r1
   1f1b4:	51 05       	cpc	r21, r1
   1f1b6:	b1 f7       	brne	.-20     	; 0x1f1a4 <enc28j60_write+0xc>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f1b8:	c0 9a       	sbi	0x18, 0	; 24
  
  return;
}
   1f1ba:	08 95       	ret

0001f1bc <enc28j60_write_byte>:

// generate some inline helper functions, which is pretty much the same 
// ... as a macro, except they can't cause syntax errors...
void enc28j60_write_byte(uint8_t command, uint8_t buffer)
{
   1f1bc:	df 93       	push	r29
   1f1be:	cf 93       	push	r28
   1f1c0:	0f 92       	push	r0
   1f1c2:	cd b7       	in	r28, 0x3d	; 61
   1f1c4:	de b7       	in	r29, 0x3e	; 62
   1f1c6:	69 83       	std	Y+1, r22	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f1c8:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f1ca:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
   1f1cc:	77 9b       	sbis	0x0e, 7	; 14
   1f1ce:	fe cf       	rjmp	.-4      	; 0x1f1cc <enc28j60_write_byte+0x10>
   1f1d0:	fe 01       	movw	r30, r28
   1f1d2:	31 96       	adiw	r30, 0x01	; 1

  while(length--)
   1f1d4:	9e 01       	movw	r18, r28
   1f1d6:	2e 5f       	subi	r18, 0xFE	; 254
   1f1d8:	3f 4f       	sbci	r19, 0xFF	; 255
   1f1da:	05 c0       	rjmp	.+10     	; 0x1f1e6 <enc28j60_write_byte+0x2a>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f1dc:	80 81       	ld	r24, Z
   1f1de:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f1e0:	77 9b       	sbis	0x0e, 7	; 14
   1f1e2:	fe cf       	rjmp	.-4      	; 0x1f1e0 <enc28j60_write_byte+0x24>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f1e4:	31 96       	adiw	r30, 0x01	; 1
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f1e6:	e2 17       	cp	r30, r18
   1f1e8:	f3 07       	cpc	r31, r19
   1f1ea:	c1 f7       	brne	.-16     	; 0x1f1dc <enc28j60_write_byte+0x20>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f1ec:	c0 9a       	sbi	0x18, 0	; 24
// generate some inline helper functions, which is pretty much the same 
// ... as a macro, except they can't cause syntax errors...
void enc28j60_write_byte(uint8_t command, uint8_t buffer)
{
  return enc28j60_write(command, &buffer, 1);
}
   1f1ee:	0f 90       	pop	r0
   1f1f0:	cf 91       	pop	r28
   1f1f2:	df 91       	pop	r29
   1f1f4:	08 95       	ret

0001f1f6 <enc28j60_read>:


void enc28j60_read(uint8_t command, void* buffer, uint16_t length, uint8_t offset)
{
   1f1f6:	fb 01       	movw	r30, r22

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
   1f1f8:	c0 98       	cbi	0x18, 0	; 24

  //start read cmd:
  SPDR = command;
   1f1fa:	8f b9       	out	0x0f, r24	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
   1f1fc:	77 9b       	sbis	0x0e, 7	; 14
   1f1fe:	fe cf       	rjmp	.-4      	; 0x1f1fc <enc28j60_read+0x6>
   1f200:	04 c0       	rjmp	.+8      	; 0x1f20a <enc28j60_read+0x14>

  // Ignore dummy bytes...
  while(offset--) 
  {
    SPDR = 0x00;
   1f202:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
   1f204:	77 9b       	sbis	0x0e, 7	; 14
   1f206:	fe cf       	rjmp	.-4      	; 0x1f204 <enc28j60_read+0xe>
   1f208:	21 50       	subi	r18, 0x01	; 1
  SPDR = command;
  //wait for completion
  while(!(SPSR & (1<<SPIF)));

  // Ignore dummy bytes...
  while(offset--) 
   1f20a:	22 23       	and	r18, r18
   1f20c:	d1 f7       	brne	.-12     	; 0x1f202 <enc28j60_read+0xc>
   1f20e:	07 c0       	rjmp	.+14     	; 0x1f21e <enc28j60_read+0x28>
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
  {    
    SPDR = 0x00;
   1f210:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
   1f212:	77 9b       	sbis	0x0e, 7	; 14
   1f214:	fe cf       	rjmp	.-4      	; 0x1f212 <enc28j60_read+0x1c>
    *((uint8_t*)(buffer++)) = SPDR;
   1f216:	8f b1       	in	r24, 0x0f	; 15
   1f218:	81 93       	st	Z+, r24
   1f21a:	41 50       	subi	r20, 0x01	; 1
   1f21c:	50 40       	sbci	r21, 0x00	; 0
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
   1f21e:	41 15       	cp	r20, r1
   1f220:	51 05       	cpc	r21, r1
   1f222:	b1 f7       	brne	.-20     	; 0x1f210 <enc28j60_read+0x1a>
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f224:	c0 9a       	sbi	0x18, 0	; 24
	
  return;
}
   1f226:	08 95       	ret

0001f228 <enc28j60_select_bank>:


void enc28j60_select_bank(uint8_t address)
{
   1f228:	df 93       	push	r29
   1f22a:	cf 93       	push	r28
   1f22c:	0f 92       	push	r0
   1f22e:	cd b7       	in	r28, 0x3d	; 61
   1f230:	de b7       	in	r29, 0x3e	; 62
   1f232:	48 2f       	mov	r20, r24

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
   1f234:	87 fd       	sbrc	r24, 7
   1f236:	3d c0       	rjmp	.+122    	; 0x1f2b2 <enc28j60_select_bank+0x8a>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
   1f238:	28 2f       	mov	r18, r24
   1f23a:	30 e0       	ldi	r19, 0x00	; 0
   1f23c:	20 76       	andi	r18, 0x60	; 96
   1f23e:	30 70       	andi	r19, 0x00	; 0
   1f240:	80 91 aa 01 	lds	r24, 0x01AA
   1f244:	90 e0       	ldi	r25, 0x00	; 0
   1f246:	82 17       	cp	r24, r18
   1f248:	93 07       	cpc	r25, r19
   1f24a:	99 f1       	breq	.+102    	; 0x1f2b2 <enc28j60_select_bank+0x8a>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
   1f24c:	83 e0       	ldi	r24, 0x03	; 3
   1f24e:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f250:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f252:	8f eb       	ldi	r24, 0xBF	; 191
   1f254:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
   1f256:	77 9b       	sbis	0x0e, 7	; 14
   1f258:	fe cf       	rjmp	.-4      	; 0x1f256 <enc28j60_select_bank+0x2e>
   1f25a:	fe 01       	movw	r30, r28
   1f25c:	31 96       	adiw	r30, 0x01	; 1

  while(length--)
   1f25e:	be 01       	movw	r22, r28
   1f260:	6e 5f       	subi	r22, 0xFE	; 254
   1f262:	7f 4f       	sbci	r23, 0xFF	; 255
   1f264:	05 c0       	rjmp	.+10     	; 0x1f270 <enc28j60_select_bank+0x48>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f266:	80 81       	ld	r24, Z
   1f268:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f26a:	77 9b       	sbis	0x0e, 7	; 14
   1f26c:	fe cf       	rjmp	.-4      	; 0x1f26a <enc28j60_select_bank+0x42>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f26e:	31 96       	adiw	r30, 0x01	; 1
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f270:	e6 17       	cp	r30, r22
   1f272:	f7 07       	cpc	r31, r23
   1f274:	c1 f7       	brne	.-16     	; 0x1f266 <enc28j60_select_bank+0x3e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f276:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
   1f278:	85 e0       	ldi	r24, 0x05	; 5
   1f27a:	35 95       	asr	r19
   1f27c:	27 95       	ror	r18
   1f27e:	8a 95       	dec	r24
   1f280:	e1 f7       	brne	.-8      	; 0x1f27a <enc28j60_select_bank+0x52>
   1f282:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f284:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f286:	8f e9       	ldi	r24, 0x9F	; 159
   1f288:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
   1f28a:	77 9b       	sbis	0x0e, 7	; 14
   1f28c:	fe cf       	rjmp	.-4      	; 0x1f28a <enc28j60_select_bank+0x62>
   1f28e:	fe 01       	movw	r30, r28
   1f290:	31 96       	adiw	r30, 0x01	; 1

  while(length--)
   1f292:	9e 01       	movw	r18, r28
   1f294:	2e 5f       	subi	r18, 0xFE	; 254
   1f296:	3f 4f       	sbci	r19, 0xFF	; 255
   1f298:	05 c0       	rjmp	.+10     	; 0x1f2a4 <enc28j60_select_bank+0x7c>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f29a:	80 81       	ld	r24, Z
   1f29c:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f29e:	77 9b       	sbis	0x0e, 7	; 14
   1f2a0:	fe cf       	rjmp	.-4      	; 0x1f29e <enc28j60_select_bank+0x76>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f2a2:	31 96       	adiw	r30, 0x01	; 1
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f2a4:	e2 17       	cp	r30, r18
   1f2a6:	f3 07       	cpc	r31, r19
   1f2a8:	c1 f7       	brne	.-16     	; 0x1f29a <enc28j60_select_bank+0x72>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f2aa:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
   1f2ac:	40 76       	andi	r20, 0x60	; 96
   1f2ae:	40 93 aa 01 	sts	0x01AA, r20

  return;
}
   1f2b2:	0f 90       	pop	r0
   1f2b4:	cf 91       	pop	r28
   1f2b6:	df 91       	pop	r29
   1f2b8:	08 95       	ret

0001f2ba <enc28j60_init>:
 
  // Als erstes den SPI Bus aktivieren

  // Set MOSI, SS and SCK output, all others input
  //DDRB = (1<<DDB2)|(1<<DDB1) | (1 << PB4);
  DDRB = (1<<PB2 ) | (1<<PB1) | (1<<PB0);
   1f2ba:	87 e0       	ldi	r24, 0x07	; 7
   1f2bc:	87 bb       	out	0x17, r24	; 23

  // MISO = IN
  DDRB &= ~(1<<PB3); 
   1f2be:	bb 98       	cbi	0x17, 3	; 23

  // Pull up Chipselect to high...
  PORTB |= (1<<PB0);
   1f2c0:	c0 9a       	sbi	0x18, 0	; 24

  // Enable SPI, Master, set clock rate 
  SPCR = (0<<CPOL)|(1<<MSTR)|(0<<DORD)/*|(0<<SPR1)|(0<<SPR0)*/|(1<<SPE);
   1f2c2:	80 e5       	ldi	r24, 0x50	; 80
   1f2c4:	8d b9       	out	0x0d, r24	; 13

  // Double SPI clock
  SPSR = (1<<SPI2X);
   1f2c6:	81 e0       	ldi	r24, 0x01	; 1
   1f2c8:	8e b9       	out	0x0e, r24	; 14

  // TODO: Werden structs nicht automatisch genullt?
  hEnc28j60.bank = 0;
   1f2ca:	10 92 aa 01 	sts	0x01AA, r1

  return;
}
   1f2ce:	08 95       	ret

0001f2d0 <enc28j60_calcOffset>:
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
   1f2d0:	90 e0       	ldi	r25, 0x00	; 0
   1f2d2:	80 76       	andi	r24, 0x60	; 96
   1f2d4:	90 70       	andi	r25, 0x00	; 0
   1f2d6:	80 34       	cpi	r24, 0x40	; 64
   1f2d8:	91 05       	cpc	r25, r1
   1f2da:	21 f0       	breq	.+8      	; 0x1f2e4 <enc28j60_calcOffset+0x14>
   1f2dc:	20 e0       	ldi	r18, 0x00	; 0
   1f2de:	80 36       	cpi	r24, 0x60	; 96
   1f2e0:	91 05       	cpc	r25, r1
   1f2e2:	09 f4       	brne	.+2      	; 0x1f2e6 <enc28j60_calcOffset+0x16>
   1f2e4:	21 e0       	ldi	r18, 0x01	; 1
  {
    return 1;
  }

  return 0;  
}
   1f2e6:	82 2f       	mov	r24, r18
   1f2e8:	08 95       	ret

0001f2ea <enc28j60_rcr2>:

// This function is beeing called from the crget* functions.
// It is inline in order to speedup calling and saving stack memeory
void* enc28j60_rcr2(uint8_t address,  void* buffer, uint16_t len)
{
   1f2ea:	df 92       	push	r13
   1f2ec:	ef 92       	push	r14
   1f2ee:	ff 92       	push	r15
   1f2f0:	0f 93       	push	r16
   1f2f2:	1f 93       	push	r17
   1f2f4:	18 2f       	mov	r17, r24
   1f2f6:	06 2f       	mov	r16, r22
   1f2f8:	d7 2e       	mov	r13, r23
   1f2fa:	7a 01       	movw	r14, r20
  // switch to the corresponding memory bank
  enc28j60_select_bank(address);  
   1f2fc:	0e 94 14 f9 	call	0x1f228	; 0x1f228 <enc28j60_select_bank>
  
  // ... then start reading...
  enc28j60_read(ENC_OP_RCR | (address & ENC_MASK_REGADR), buffer, len, enc28j60_calcOffset(address));
   1f300:	81 2f       	mov	r24, r17
   1f302:	0e 94 68 f9 	call	0x1f2d0	; 0x1f2d0 <enc28j60_calcOffset>
   1f306:	28 2f       	mov	r18, r24
   1f308:	81 2f       	mov	r24, r17
   1f30a:	8f 71       	andi	r24, 0x1F	; 31
   1f30c:	60 2f       	mov	r22, r16
   1f30e:	7d 2d       	mov	r23, r13
   1f310:	a7 01       	movw	r20, r14
   1f312:	0e 94 fb f8 	call	0x1f1f6	; 0x1f1f6 <enc28j60_read>
  
  // now return pointer to the buffer for better usability
  return buffer;
}
   1f316:	80 2f       	mov	r24, r16
   1f318:	9d 2d       	mov	r25, r13
   1f31a:	1f 91       	pop	r17
   1f31c:	0f 91       	pop	r16
   1f31e:	ff 90       	pop	r15
   1f320:	ef 90       	pop	r14
   1f322:	df 90       	pop	r13
   1f324:	08 95       	ret

0001f326 <enc28j60_crgetc>:


uint8_t enc28j60_crgetc(uint8_t address)
{
   1f326:	df 93       	push	r29
   1f328:	cf 93       	push	r28
   1f32a:	0f 92       	push	r0
   1f32c:	cd b7       	in	r28, 0x3d	; 61
   1f32e:	de b7       	in	r29, 0x3e	; 62
  uint8_t buffer;
  enc28j60_rcr2(address,&buffer,1);
   1f330:	be 01       	movw	r22, r28
   1f332:	6f 5f       	subi	r22, 0xFF	; 255
   1f334:	7f 4f       	sbci	r23, 0xFF	; 255
   1f336:	41 e0       	ldi	r20, 0x01	; 1
   1f338:	50 e0       	ldi	r21, 0x00	; 0
   1f33a:	0e 94 75 f9 	call	0x1f2ea	; 0x1f2ea <enc28j60_rcr2>
  return buffer;
}
   1f33e:	89 81       	ldd	r24, Y+1	; 0x01
   1f340:	0f 90       	pop	r0
   1f342:	cf 91       	pop	r28
   1f344:	df 91       	pop	r29
   1f346:	08 95       	ret

0001f348 <enc28j60_crgetw>:

uint16_t enc28j60_crgetw(uint8_t address)
{
   1f348:	df 93       	push	r29
   1f34a:	cf 93       	push	r28
   1f34c:	00 d0       	rcall	.+0      	; 0x1f34e <enc28j60_crgetw+0x6>
   1f34e:	cd b7       	in	r28, 0x3d	; 61
   1f350:	de b7       	in	r29, 0x3e	; 62
  uint16_t buffer;
  enc28j60_rcr2(address,&buffer,2);
   1f352:	be 01       	movw	r22, r28
   1f354:	6f 5f       	subi	r22, 0xFF	; 255
   1f356:	7f 4f       	sbci	r23, 0xFF	; 255
   1f358:	42 e0       	ldi	r20, 0x02	; 2
   1f35a:	50 e0       	ldi	r21, 0x00	; 0
   1f35c:	0e 94 75 f9 	call	0x1f2ea	; 0x1f2ea <enc28j60_rcr2>
  return ((buffer &0x00FF) << 8) | ((buffer&0xFF00) >> 8);
}
   1f360:	8a 81       	ldd	r24, Y+2	; 0x02
   1f362:	99 81       	ldd	r25, Y+1	; 0x01
   1f364:	0f 90       	pop	r0
   1f366:	0f 90       	pop	r0
   1f368:	cf 91       	pop	r28
   1f36a:	df 91       	pop	r29
   1f36c:	08 95       	ret

0001f36e <enc28j60_crgets>:

void* enc28j60_crgets(uint8_t address, void* buffer, uint16_t len)
{
   1f36e:	0f 93       	push	r16
   1f370:	1f 93       	push	r17
   1f372:	16 2f       	mov	r17, r22
   1f374:	07 2f       	mov	r16, r23
  enc28j60_rcr2(address,buffer,len);
   1f376:	0e 94 75 f9 	call	0x1f2ea	; 0x1f2ea <enc28j60_rcr2>
  return buffer; 
}
   1f37a:	81 2f       	mov	r24, r17
   1f37c:	90 2f       	mov	r25, r16
   1f37e:	1f 91       	pop	r17
   1f380:	0f 91       	pop	r16
   1f382:	08 95       	ret

0001f384 <enc28j60_wcr>:
******************************************************************************************/

// Write functions 
//  this function is explicitly declared inline in order to speedup calls
void enc28j60_wcr(uint8_t address, const void* buffer, uint16_t len)
{
   1f384:	ef 92       	push	r14
   1f386:	ff 92       	push	r15
   1f388:	1f 93       	push	r17
   1f38a:	cf 93       	push	r28
   1f38c:	df 93       	push	r29
   1f38e:	18 2f       	mov	r17, r24
   1f390:	7b 01       	movw	r14, r22
   1f392:	ea 01       	movw	r28, r20
  // Speicherbank auswhlen...
  enc28j60_select_bank(address);
   1f394:	0e 94 14 f9 	call	0x1f228	; 0x1f228 <enc28j60_select_bank>
  // ... und die Daten schreiben 
  enc28j60_write(ENC_OP_WCR | (address & ENC_MASK_REGADR),buffer, len);
   1f398:	1f 71       	andi	r17, 0x1F	; 31
   1f39a:	10 64       	ori	r17, 0x40	; 64

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f39c:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f39e:	1f b9       	out	0x0f, r17	; 15

  while(!(SPSR & (1<<SPIF)));
   1f3a0:	77 9b       	sbis	0x0e, 7	; 14
   1f3a2:	fe cf       	rjmp	.-4      	; 0x1f3a0 <enc28j60_wcr+0x1c>
   1f3a4:	09 c0       	rjmp	.+18     	; 0x1f3b8 <enc28j60_wcr+0x34>

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f3a6:	f7 01       	movw	r30, r14
   1f3a8:	80 81       	ld	r24, Z
   1f3aa:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f3ac:	77 9b       	sbis	0x0e, 7	; 14
   1f3ae:	fe cf       	rjmp	.-4      	; 0x1f3ac <enc28j60_wcr+0x28>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f3b0:	08 94       	sec
   1f3b2:	e1 1c       	adc	r14, r1
   1f3b4:	f1 1c       	adc	r15, r1
   1f3b6:	21 97       	sbiw	r28, 0x01	; 1
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f3b8:	20 97       	sbiw	r28, 0x00	; 0
   1f3ba:	a9 f7       	brne	.-22     	; 0x1f3a6 <enc28j60_wcr+0x22>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f3bc:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_select_bank(address);
  // ... und die Daten schreiben 
  enc28j60_write(ENC_OP_WCR | (address & ENC_MASK_REGADR),buffer, len);

  return;
}
   1f3be:	df 91       	pop	r29
   1f3c0:	cf 91       	pop	r28
   1f3c2:	1f 91       	pop	r17
   1f3c4:	ff 90       	pop	r15
   1f3c6:	ef 90       	pop	r14
   1f3c8:	08 95       	ret

0001f3ca <enc28j60_crputc>:

// write a single control register...
void enc28j60_crputc(uint8_t address, uint8_t buffer)
{
   1f3ca:	df 93       	push	r29
   1f3cc:	cf 93       	push	r28
   1f3ce:	0f 92       	push	r0
   1f3d0:	cd b7       	in	r28, 0x3d	; 61
   1f3d2:	de b7       	in	r29, 0x3e	; 62
   1f3d4:	69 83       	std	Y+1, r22	; 0x01
  enc28j60_wcr(address, &buffer, 1);
   1f3d6:	be 01       	movw	r22, r28
   1f3d8:	6f 5f       	subi	r22, 0xFF	; 255
   1f3da:	7f 4f       	sbci	r23, 0xFF	; 255
   1f3dc:	41 e0       	ldi	r20, 0x01	; 1
   1f3de:	50 e0       	ldi	r21, 0x00	; 0
   1f3e0:	0e 94 c2 f9 	call	0x1f384	; 0x1f384 <enc28j60_wcr>
  return;
}
   1f3e4:	0f 90       	pop	r0
   1f3e6:	cf 91       	pop	r28
   1f3e8:	df 91       	pop	r29
   1f3ea:	08 95       	ret

0001f3ec <enc28j60_crputw>:

// write a word into a control registers (usefull for enc pointers)...
// ... the endianess is corrected!
void enc28j60_crputw(uint8_t address, uint16_t buffer)
{
   1f3ec:	df 93       	push	r29
   1f3ee:	cf 93       	push	r28
   1f3f0:	00 d0       	rcall	.+0      	; 0x1f3f2 <enc28j60_crputw+0x6>
   1f3f2:	cd b7       	in	r28, 0x3d	; 61
   1f3f4:	de b7       	in	r29, 0x3e	; 62
   1f3f6:	7a 83       	std	Y+2, r23	; 0x02
   1f3f8:	69 83       	std	Y+1, r22	; 0x01
  // correct the endianness, swap high an low byte
  // buffer = (((uint16_t)buffer &0x00FF) << 8) | (((uint16_t)buffer&0xFF00) >> 8);
  enc28j60_wcr(address, &buffer, 2);
   1f3fa:	be 01       	movw	r22, r28
   1f3fc:	6f 5f       	subi	r22, 0xFF	; 255
   1f3fe:	7f 4f       	sbci	r23, 0xFF	; 255
   1f400:	42 e0       	ldi	r20, 0x02	; 2
   1f402:	50 e0       	ldi	r21, 0x00	; 0
   1f404:	0e 94 c2 f9 	call	0x1f384	; 0x1f384 <enc28j60_wcr>
  return;
}
   1f408:	0f 90       	pop	r0
   1f40a:	0f 90       	pop	r0
   1f40c:	cf 91       	pop	r28
   1f40e:	df 91       	pop	r29
   1f410:	08 95       	ret

0001f412 <enc28j60_crputs>:

void enc28j60_crputs(uint8_t address, const void* buffer, uint16_t len)
{
  enc28j60_wcr(address, buffer, len);
   1f412:	0e 94 c2 f9 	call	0x1f384	; 0x1f384 <enc28j60_wcr>
  return;
}
   1f416:	08 95       	ret

0001f418 <enc28j60_crbfs>:

******************************************************************************************/

// Bit Field Set
void enc28j60_crbfs(uint8_t address, char flags)
{
   1f418:	1f 93       	push	r17
   1f41a:	df 93       	push	r29
   1f41c:	cf 93       	push	r28
   1f41e:	0f 92       	push	r0
   1f420:	cd b7       	in	r28, 0x3d	; 61
   1f422:	de b7       	in	r29, 0x3e	; 62
   1f424:	18 2f       	mov	r17, r24
   1f426:	69 83       	std	Y+1, r22	; 0x01
  enc28j60_select_bank(address);
   1f428:	0e 94 14 f9 	call	0x1f228	; 0x1f228 <enc28j60_select_bank>
  enc28j60_write(ENC_OP_BFS | (address & ENC_MASK_REGADR),&flags,1);
   1f42c:	1f 71       	andi	r17, 0x1F	; 31
   1f42e:	10 68       	ori	r17, 0x80	; 128

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f430:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f432:	1f b9       	out	0x0f, r17	; 15

  while(!(SPSR & (1<<SPIF)));
   1f434:	77 9b       	sbis	0x0e, 7	; 14
   1f436:	fe cf       	rjmp	.-4      	; 0x1f434 <enc28j60_crbfs+0x1c>
   1f438:	fe 01       	movw	r30, r28
   1f43a:	31 96       	adiw	r30, 0x01	; 1

  while(length--)
   1f43c:	9e 01       	movw	r18, r28
   1f43e:	2e 5f       	subi	r18, 0xFE	; 254
   1f440:	3f 4f       	sbci	r19, 0xFF	; 255
   1f442:	05 c0       	rjmp	.+10     	; 0x1f44e <enc28j60_crbfs+0x36>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f444:	80 81       	ld	r24, Z
   1f446:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f448:	77 9b       	sbis	0x0e, 7	; 14
   1f44a:	fe cf       	rjmp	.-4      	; 0x1f448 <enc28j60_crbfs+0x30>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f44c:	31 96       	adiw	r30, 0x01	; 1
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f44e:	e2 17       	cp	r30, r18
   1f450:	f3 07       	cpc	r31, r19
   1f452:	c1 f7       	brne	.-16     	; 0x1f444 <enc28j60_crbfs+0x2c>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f454:	c0 9a       	sbi	0x18, 0	; 24
void enc28j60_crbfs(uint8_t address, char flags)
{
  enc28j60_select_bank(address);
  enc28j60_write(ENC_OP_BFS | (address & ENC_MASK_REGADR),&flags,1);
  return;
}
   1f456:	0f 90       	pop	r0
   1f458:	cf 91       	pop	r28
   1f45a:	df 91       	pop	r29
   1f45c:	1f 91       	pop	r17
   1f45e:	08 95       	ret

0001f460 <enc28j60_crbfc>:

// Bit Field Clear
void enc28j60_crbfc(uint8_t address, char flags)
{
   1f460:	1f 93       	push	r17
   1f462:	df 93       	push	r29
   1f464:	cf 93       	push	r28
   1f466:	0f 92       	push	r0
   1f468:	cd b7       	in	r28, 0x3d	; 61
   1f46a:	de b7       	in	r29, 0x3e	; 62
   1f46c:	18 2f       	mov	r17, r24
   1f46e:	69 83       	std	Y+1, r22	; 0x01
  enc28j60_select_bank(address);
   1f470:	0e 94 14 f9 	call	0x1f228	; 0x1f228 <enc28j60_select_bank>
  enc28j60_write(ENC_OP_BFC | (address & ENC_MASK_REGADR),&flags,1);
   1f474:	1f 71       	andi	r17, 0x1F	; 31
   1f476:	10 6a       	ori	r17, 0xA0	; 160

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f478:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f47a:	1f b9       	out	0x0f, r17	; 15

  while(!(SPSR & (1<<SPIF)));
   1f47c:	77 9b       	sbis	0x0e, 7	; 14
   1f47e:	fe cf       	rjmp	.-4      	; 0x1f47c <enc28j60_crbfc+0x1c>
   1f480:	fe 01       	movw	r30, r28
   1f482:	31 96       	adiw	r30, 0x01	; 1

  while(length--)
   1f484:	9e 01       	movw	r18, r28
   1f486:	2e 5f       	subi	r18, 0xFE	; 254
   1f488:	3f 4f       	sbci	r19, 0xFF	; 255
   1f48a:	05 c0       	rjmp	.+10     	; 0x1f496 <enc28j60_crbfc+0x36>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f48c:	80 81       	ld	r24, Z
   1f48e:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f490:	77 9b       	sbis	0x0e, 7	; 14
   1f492:	fe cf       	rjmp	.-4      	; 0x1f490 <enc28j60_crbfc+0x30>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f494:	31 96       	adiw	r30, 0x01	; 1
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f496:	e2 17       	cp	r30, r18
   1f498:	f3 07       	cpc	r31, r19
   1f49a:	c1 f7       	brne	.-16     	; 0x1f48c <enc28j60_crbfc+0x2c>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f49c:	c0 9a       	sbi	0x18, 0	; 24
void enc28j60_crbfc(uint8_t address, char flags)
{
  enc28j60_select_bank(address);
  enc28j60_write(ENC_OP_BFC | (address & ENC_MASK_REGADR),&flags,1);
  return;
}
   1f49e:	0f 90       	pop	r0
   1f4a0:	cf 91       	pop	r28
   1f4a2:	df 91       	pop	r29
   1f4a4:	1f 91       	pop	r17
   1f4a6:	08 95       	ret

0001f4a8 <enc28j60_bmgetc>:
******************************************************************************************/


// Read a char from Buffer Memory
uint8_t  enc28j60_bmgetc()
{
   1f4a8:	df 93       	push	r29
   1f4aa:	cf 93       	push	r28
   1f4ac:	0f 92       	push	r0
   1f4ae:	cd b7       	in	r28, 0x3d	; 61
   1f4b0:	de b7       	in	r29, 0x3e	; 62
  uint8_t buffer;
  enc28j60_read(ENC_OP_RBM ,&buffer, 1,0);
   1f4b2:	8a e3       	ldi	r24, 0x3A	; 58
   1f4b4:	be 01       	movw	r22, r28
   1f4b6:	6f 5f       	subi	r22, 0xFF	; 255
   1f4b8:	7f 4f       	sbci	r23, 0xFF	; 255
   1f4ba:	41 e0       	ldi	r20, 0x01	; 1
   1f4bc:	50 e0       	ldi	r21, 0x00	; 0
   1f4be:	20 e0       	ldi	r18, 0x00	; 0
   1f4c0:	0e 94 fb f8 	call	0x1f1f6	; 0x1f1f6 <enc28j60_read>
  return buffer;
}
   1f4c4:	89 81       	ldd	r24, Y+1	; 0x01
   1f4c6:	0f 90       	pop	r0
   1f4c8:	cf 91       	pop	r28
   1f4ca:	df 91       	pop	r29
   1f4cc:	08 95       	ret

0001f4ce <enc28j60_bmgetw>:
// Read a word from Buffer Memory
uint16_t enc28j60_bmgetw()
{
   1f4ce:	df 93       	push	r29
   1f4d0:	cf 93       	push	r28
   1f4d2:	00 d0       	rcall	.+0      	; 0x1f4d4 <enc28j60_bmgetw+0x6>
   1f4d4:	cd b7       	in	r28, 0x3d	; 61
   1f4d6:	de b7       	in	r29, 0x3e	; 62
  uint16_t buffer;
  enc28j60_read(ENC_OP_RBM ,&buffer, 2,0);
   1f4d8:	8a e3       	ldi	r24, 0x3A	; 58
   1f4da:	be 01       	movw	r22, r28
   1f4dc:	6f 5f       	subi	r22, 0xFF	; 255
   1f4de:	7f 4f       	sbci	r23, 0xFF	; 255
   1f4e0:	42 e0       	ldi	r20, 0x02	; 2
   1f4e2:	50 e0       	ldi	r21, 0x00	; 0
   1f4e4:	20 e0       	ldi	r18, 0x00	; 0
   1f4e6:	0e 94 fb f8 	call	0x1f1f6	; 0x1f1f6 <enc28j60_read>
  return buffer;
}
   1f4ea:	89 81       	ldd	r24, Y+1	; 0x01
   1f4ec:	9a 81       	ldd	r25, Y+2	; 0x02
   1f4ee:	0f 90       	pop	r0
   1f4f0:	0f 90       	pop	r0
   1f4f2:	cf 91       	pop	r28
   1f4f4:	df 91       	pop	r29
   1f4f6:	08 95       	ret

0001f4f8 <enc28j60_bmgets>:
// Read a string from Buffer Memory
void* enc28j60_bmgets(void* buffer, uint16_t len)
{
   1f4f8:	0f 93       	push	r16
   1f4fa:	1f 93       	push	r17
   1f4fc:	18 2f       	mov	r17, r24
   1f4fe:	09 2f       	mov	r16, r25
   1f500:	ab 01       	movw	r20, r22
  enc28j60_read(ENC_OP_RBM ,buffer, len,0);
   1f502:	8a e3       	ldi	r24, 0x3A	; 58
   1f504:	61 2f       	mov	r22, r17
   1f506:	79 2f       	mov	r23, r25
   1f508:	20 e0       	ldi	r18, 0x00	; 0
   1f50a:	0e 94 fb f8 	call	0x1f1f6	; 0x1f1f6 <enc28j60_read>
  return buffer;
}
   1f50e:	81 2f       	mov	r24, r17
   1f510:	90 2f       	mov	r25, r16
   1f512:	1f 91       	pop	r17
   1f514:	0f 91       	pop	r16
   1f516:	08 95       	ret

0001f518 <enc28j60_bmputs>:



// Write Buffer Register, the byte order is not swaped!
void enc28j60_bmputs(const void* buffer, uint16_t len)
{
   1f518:	fc 01       	movw	r30, r24

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f51a:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f51c:	8a e7       	ldi	r24, 0x7A	; 122
   1f51e:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
   1f520:	77 9b       	sbis	0x0e, 7	; 14
   1f522:	fe cf       	rjmp	.-4      	; 0x1f520 <enc28j60_bmputs+0x8>
   1f524:	07 c0       	rjmp	.+14     	; 0x1f534 <enc28j60_bmputs+0x1c>

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f526:	80 81       	ld	r24, Z
   1f528:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
   1f52a:	77 9b       	sbis	0x0e, 7	; 14
   1f52c:	fe cf       	rjmp	.-4      	; 0x1f52a <enc28j60_bmputs+0x12>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
   1f52e:	31 96       	adiw	r30, 0x01	; 1
   1f530:	61 50       	subi	r22, 0x01	; 1
   1f532:	70 40       	sbci	r23, 0x00	; 0
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
   1f534:	61 15       	cp	r22, r1
   1f536:	71 05       	cpc	r23, r1
   1f538:	b1 f7       	brne	.-20     	; 0x1f526 <enc28j60_bmputs+0xe>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f53a:	c0 9a       	sbi	0x18, 0	; 24
// Write Buffer Register, the byte order is not swaped!
void enc28j60_bmputs(const void* buffer, uint16_t len)
{
  enc28j60_write(ENC_OP_WBM,buffer, len);
  return;
}
   1f53c:	08 95       	ret

0001f53e <enc28j60_reset>:

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
   1f53e:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
   1f540:	8f ef       	ldi	r24, 0xFF	; 255
   1f542:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
   1f544:	77 9b       	sbis	0x0e, 7	; 14
   1f546:	fe cf       	rjmp	.-4      	; 0x1f544 <enc28j60_reset+0x6>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
   1f548:	c0 9a       	sbi	0x18, 0	; 24
// Soft Reset
void enc28j60_reset()
{ 
  enc28j60_write(0xFF,0,0);
  return;
}
   1f54a:	08 95       	ret

0001f54c <enc28j60_prputw>:

// Write phy register
void enc28j60_prputw(uint8_t address, uint16_t buffer)
{
   1f54c:	0f 93       	push	r16
   1f54e:	1f 93       	push	r17
   1f550:	98 2f       	mov	r25, r24
   1f552:	16 2f       	mov	r17, r22
   1f554:	07 2f       	mov	r16, r23
  enc28j60_crputc(ENC_REG_MIREGADR,address);
   1f556:	84 e5       	ldi	r24, 0x54	; 84
   1f558:	69 2f       	mov	r22, r25
   1f55a:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  enc28j60_crputc(ENC_REG_MIWRL, (buffer&0xFF));
   1f55e:	86 e5       	ldi	r24, 0x56	; 86
   1f560:	61 2f       	mov	r22, r17
   1f562:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MIWRH,  (buffer>> 8));
   1f566:	87 e5       	ldi	r24, 0x57	; 87
   1f568:	60 2f       	mov	r22, r16
   1f56a:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  while (enc28j60_crgetc(ENC_REG_MISTAT) & ENC_REG_MISTAT_BUSY);
   1f56e:	8a e6       	ldi	r24, 0x6A	; 106
   1f570:	0e 94 93 f9 	call	0x1f326	; 0x1f326 <enc28j60_crgetc>
   1f574:	80 fd       	sbrc	r24, 0
   1f576:	fb cf       	rjmp	.-10     	; 0x1f56e <enc28j60_prputw+0x22>

  return;
}
   1f578:	1f 91       	pop	r17
   1f57a:	0f 91       	pop	r16
   1f57c:	08 95       	ret

0001f57e <nicGetPacketSize>:
}



uint16_t nicGetPacketSize(const struct nicRequestHandle_t* handle)
{
   1f57e:	fc 01       	movw	r30, r24
  if (handle->packet == NULL)
   1f580:	01 90       	ld	r0, Z+
   1f582:	f0 81       	ld	r31, Z
   1f584:	e0 2d       	mov	r30, r0
   1f586:	30 97       	sbiw	r30, 0x00	; 0
   1f588:	19 f4       	brne	.+6      	; 0x1f590 <nicGetPacketSize+0x12>
   1f58a:	e0 e0       	ldi	r30, 0x00	; 0
   1f58c:	f0 e0       	ldi	r31, 0x00	; 0
   1f58e:	03 c0       	rjmp	.+6      	; 0x1f596 <nicGetPacketSize+0x18>
    return 0;

  return handle->packet->length;
   1f590:	06 80       	ldd	r0, Z+6	; 0x06
   1f592:	f7 81       	ldd	r31, Z+7	; 0x07
   1f594:	e0 2d       	mov	r30, r0
}
   1f596:	cf 01       	movw	r24, r30
   1f598:	08 95       	ret

0001f59a <nicResponseSize>:

  return len;  
}

uint16_t nicResponseSize(struct nicResponseHandle_t* response)
{
   1f59a:	fc 01       	movw	r30, r24
  if (response == 0)
   1f59c:	00 97       	sbiw	r24, 0x00	; 0
   1f59e:	19 f4       	brne	.+6      	; 0x1f5a6 <nicResponseSize+0xc>
   1f5a0:	20 e0       	ldi	r18, 0x00	; 0
   1f5a2:	30 e0       	ldi	r19, 0x00	; 0
   1f5a4:	02 c0       	rjmp	.+4      	; 0x1f5aa <nicResponseSize+0x10>
    return 0;
   
  return response->length;
   1f5a6:	20 81       	ld	r18, Z
   1f5a8:	31 81       	ldd	r19, Z+1	; 0x01
}
   1f5aa:	c9 01       	movw	r24, r18
   1f5ac:	08 95       	ret

0001f5ae <nicResponseRead>:
  
  return;
}

uint16_t nicResponseRead(struct nicResponseHandle_t* response, char* buffer, uint16_t len)
{
   1f5ae:	0f 93       	push	r16
   1f5b0:	1f 93       	push	r17
   1f5b2:	cf 93       	push	r28
   1f5b4:	df 93       	push	r29
   1f5b6:	8c 01       	movw	r16, r24
   1f5b8:	dc 01       	movw	r26, r24
   1f5ba:	ed 91       	ld	r30, X+
   1f5bc:	fc 91       	ld	r31, X
   1f5be:	ea 01       	movw	r28, r20
   1f5c0:	e4 17       	cp	r30, r20
   1f5c2:	f5 07       	cpc	r31, r21
   1f5c4:	08 f4       	brcc	.+2      	; 0x1f5c8 <nicResponseRead+0x1a>
   1f5c6:	ef 01       	movw	r28, r30
  // adjust the length, if it is bigger than the received packet...
  if (response->length < len)
    len = response->length;
         
  // read enc packet...
  enc28j60_bmgets(buffer,len);
   1f5c8:	cb 01       	movw	r24, r22
   1f5ca:	be 01       	movw	r22, r28
   1f5cc:	0e 94 7c fa 	call	0x1f4f8	; 0x1f4f8 <enc28j60_bmgets>
  
  // ...decrement length
  response->length -= len;
   1f5d0:	f8 01       	movw	r30, r16
   1f5d2:	80 81       	ld	r24, Z
   1f5d4:	91 81       	ldd	r25, Z+1	; 0x01
   1f5d6:	8c 1b       	sub	r24, r28
   1f5d8:	9d 0b       	sbc	r25, r29
   1f5da:	91 83       	std	Z+1, r25	; 0x01
   1f5dc:	80 83       	st	Z, r24

  return len;  
}
   1f5de:	ce 01       	movw	r24, r28
   1f5e0:	df 91       	pop	r29
   1f5e2:	cf 91       	pop	r28
   1f5e4:	1f 91       	pop	r17
   1f5e6:	0f 91       	pop	r16
   1f5e8:	08 95       	ret

0001f5ea <nicFreeResponse>:
  
  return handle;  
}

void nicFreeResponse(struct nicResponseHandle_t* response)
{
   1f5ea:	cf 93       	push	r28
   1f5ec:	df 93       	push	r29
   1f5ee:	ec 01       	movw	r28, r24
  
  //fix Packet Pointer (see Errata)
  if (((response->nextPacketPtr)-1 < ENC_ERXST) || ((response->nextPacketPtr)-1 > ENC_ERXND)) 
   1f5f0:	6a 81       	ldd	r22, Y+2	; 0x02
   1f5f2:	7b 81       	ldd	r23, Y+3	; 0x03
   1f5f4:	61 50       	subi	r22, 0x01	; 1
   1f5f6:	70 40       	sbci	r23, 0x00	; 0
   1f5f8:	8a e1       	ldi	r24, 0x1A	; 26
   1f5fa:	60 30       	cpi	r22, 0x00	; 0
   1f5fc:	78 07       	cpc	r23, r24
   1f5fe:	20 f0       	brcs	.+8      	; 0x1f608 <nicFreeResponse+0x1e>
    // TODO: WIRKLICH ENC_ERXND?
    enc28j60_crputw(ENC_REG_ERXRDPTL,ENC_ERXND);
   1f600:	8c e0       	ldi	r24, 0x0C	; 12
   1f602:	6f ef       	ldi	r22, 0xFF	; 255
   1f604:	79 e1       	ldi	r23, 0x19	; 25
   1f606:	01 c0       	rjmp	.+2      	; 0x1f60a <nicFreeResponse+0x20>
  else
    enc28j60_crputw(ENC_REG_ERXRDPTL,(response->nextPacketPtr)-1); 
   1f608:	8c e0       	ldi	r24, 0x0C	; 12
   1f60a:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>

  //decrement packet counter:
  enc28j60_crbfs(ENC_REG_ECON2,ENC_REG_ECON2_PKTDEC);
   1f60e:	8e e9       	ldi	r24, 0x9E	; 158
   1f610:	60 e4       	ldi	r22, 0x40	; 64
   1f612:	0e 94 0c fa 	call	0x1f418	; 0x1f418 <enc28j60_crbfs>
  
  //update the next packet pointer
  enc28j60_crputw(ENC_REG_ERDPTL,(response->nextPacketPtr));  
   1f616:	6a 81       	ldd	r22, Y+2	; 0x02
   1f618:	7b 81       	ldd	r23, Y+3	; 0x03
   1f61a:	80 e0       	ldi	r24, 0x00	; 0
   1f61c:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>
  
  free(response);
   1f620:	ce 01       	movw	r24, r28
   1f622:	0e 94 10 ff 	call	0x1fe20	; 0x1fe20 <free>
  
  return;
}
   1f626:	df 91       	pop	r29
   1f628:	cf 91       	pop	r28
   1f62a:	08 95       	ret

0001f62c <nicFreeRequest>:
  return 1;  
}


void nicFreeRequest(struct nicRequestHandle_t* handle)
{
   1f62c:	0f 93       	push	r16
   1f62e:	1f 93       	push	r17
   1f630:	cf 93       	push	r28
   1f632:	df 93       	push	r29
   1f634:	8c 01       	movw	r16, r24
  if (handle == NULL)
   1f636:	00 97       	sbiw	r24, 0x00	; 0
   1f638:	79 f4       	brne	.+30     	; 0x1f658 <nicFreeRequest+0x2c>
   1f63a:	16 c0       	rjmp	.+44     	; 0x1f668 <nicFreeRequest+0x3c>
      = handle->packet; 
       
  while(packet != NULL)
  {
    // free header if applicable
    if (packet->header.data != NULL)
   1f63c:	88 81       	ld	r24, Y
   1f63e:	99 81       	ldd	r25, Y+1	; 0x01
   1f640:	00 97       	sbiw	r24, 0x00	; 0
   1f642:	11 f0       	breq	.+4      	; 0x1f648 <nicFreeRequest+0x1c>
      free(packet->header.data);
   1f644:	0e 94 10 ff 	call	0x1fe20	; 0x1fe20 <free>
    
    // update the handle...
    handle->packet = packet->payload;
   1f648:	8c 81       	ldd	r24, Y+4	; 0x04
   1f64a:	9d 81       	ldd	r25, Y+5	; 0x05
   1f64c:	f8 01       	movw	r30, r16
   1f64e:	91 83       	std	Z+1, r25	; 0x01
   1f650:	80 83       	st	Z, r24
    // then free the packet...
    free(packet);
   1f652:	ce 01       	movw	r24, r28
   1f654:	0e 94 10 ff 	call	0x1fe20	; 0x1fe20 <free>
    packet = handle->packet;             
   1f658:	f8 01       	movw	r30, r16
   1f65a:	c0 81       	ld	r28, Z
   1f65c:	d1 81       	ldd	r29, Z+1	; 0x01
    return;
	  
  struct soPacket_t *packet
      = handle->packet; 
       
  while(packet != NULL)
   1f65e:	20 97       	sbiw	r28, 0x00	; 0
   1f660:	69 f7       	brne	.-38     	; 0x1f63c <nicFreeRequest+0x10>
    free(packet);
    packet = handle->packet;             
  }  

  // finally free the handle itself...
  free(handle); 
   1f662:	c8 01       	movw	r24, r16
   1f664:	0e 94 10 ff 	call	0x1fe20	; 0x1fe20 <free>
  
  return;
}
   1f668:	df 91       	pop	r29
   1f66a:	cf 91       	pop	r28
   1f66c:	1f 91       	pop	r17
   1f66e:	0f 91       	pop	r16
   1f670:	08 95       	ret

0001f672 <nicWaitForSend>:

  return handle->packet->length;
}

void nicWaitForSend()
{
   1f672:	1f 93       	push	r17
   1f674:	cf 93       	push	r28
   1f676:	df 93       	push	r29
   1f678:	12 e3       	ldi	r17, 0x32	; 50
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
   1f67a:	c0 e0       	ldi	r28, 0x00	; 0
   1f67c:	d0 e9       	ldi	r29, 0x90	; 144
   1f67e:	08 c0       	rjmp	.+16     	; 0x1f690 <nicWaitForSend+0x1e>
  //still sending ?
  uint8_t i = 50;
  while( i-- )
  {
    // finished sending?
    if ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS))
   1f680:	8f e9       	ldi	r24, 0x9F	; 159
   1f682:	0e 94 93 f9 	call	0x1f326	; 0x1f326 <enc28j60_crgetc>
   1f686:	83 ff       	sbrs	r24, 3
   1f688:	05 c0       	rjmp	.+10     	; 0x1f694 <nicWaitForSend+0x22>
   1f68a:	ce 01       	movw	r24, r28
   1f68c:	01 97       	sbiw	r24, 0x01	; 1
   1f68e:	f1 f7       	brne	.-4      	; 0x1f68c <nicWaitForSend+0x1a>

void nicWaitForSend()
{
  //still sending ?
  uint8_t i = 50;
  while( i-- )
   1f690:	11 50       	subi	r17, 0x01	; 1
   1f692:	b0 f7       	brcc	.-20     	; 0x1f680 <nicWaitForSend+0xe>
    _delay_ms(10);    
  }
  
  // ...we waited long enough, continue anyway
  return;
}
   1f694:	df 91       	pop	r29
   1f696:	cf 91       	pop	r28
   1f698:	1f 91       	pop	r17
   1f69a:	08 95       	ret

0001f69c <nicAddPacketHeader>:
  return handle;  
}


void* nicAddPacketHeader(struct nicRequestHandle_t* handle, uint16_t len)
{
   1f69c:	ef 92       	push	r14
   1f69e:	ff 92       	push	r15
   1f6a0:	0f 93       	push	r16
   1f6a2:	1f 93       	push	r17
   1f6a4:	cf 93       	push	r28
   1f6a6:	df 93       	push	r29
   1f6a8:	7c 01       	movw	r14, r24
   1f6aa:	8b 01       	movw	r16, r22

  // construct the encapsulating packet/frame
  
  // first get memory for the packet/frame...
  struct soPacket_t *packet;
  packet = (struct soPacket_t*) malloc(sizeof(struct soPacket_t));
   1f6ac:	88 e0       	ldi	r24, 0x08	; 8
   1f6ae:	90 e0       	ldi	r25, 0x00	; 0
   1f6b0:	0e 94 66 fe 	call	0x1fccc	; 0x1fccc <malloc>
   1f6b4:	ec 01       	movw	r28, r24

  // ... then for the nested header
  packet->header.length = len; 
   1f6b6:	1b 83       	std	Y+3, r17	; 0x03
   1f6b8:	0a 83       	std	Y+2, r16	; 0x02
  if (len == 0 )
   1f6ba:	01 15       	cp	r16, r1
   1f6bc:	11 05       	cpc	r17, r1
   1f6be:	19 f4       	brne	.+6      	; 0x1f6c6 <nicAddPacketHeader+0x2a>
    packet->header.data = NULL;
   1f6c0:	19 82       	std	Y+1, r1	; 0x01
   1f6c2:	18 82       	st	Y, r1
   1f6c4:	05 c0       	rjmp	.+10     	; 0x1f6d0 <nicAddPacketHeader+0x34>
  else 
    packet->header.data = (char*)malloc(len);
   1f6c6:	c8 01       	movw	r24, r16
   1f6c8:	0e 94 66 fe 	call	0x1fccc	; 0x1fccc <malloc>
   1f6cc:	88 83       	st	Y, r24
   1f6ce:	99 83       	std	Y+1, r25	; 0x01
  

  // now set and/or update the payload...
  packet->payload = handle->packet;
   1f6d0:	d7 01       	movw	r26, r14
   1f6d2:	ed 91       	ld	r30, X+
   1f6d4:	fc 91       	ld	r31, X
   1f6d6:	fd 83       	std	Y+5, r31	; 0x05
   1f6d8:	ec 83       	std	Y+4, r30	; 0x04
   1f6da:	2a 81       	ldd	r18, Y+2	; 0x02
   1f6dc:	3b 81       	ldd	r19, Y+3	; 0x03
   
  if (packet->payload == NULL)
   1f6de:	30 97       	sbiw	r30, 0x00	; 0
   1f6e0:	19 f4       	brne	.+6      	; 0x1f6e8 <nicAddPacketHeader+0x4c>
    packet->length = packet->header.length;
   1f6e2:	3f 83       	std	Y+7, r19	; 0x07
   1f6e4:	2e 83       	std	Y+6, r18	; 0x06
   1f6e6:	06 c0       	rjmp	.+12     	; 0x1f6f4 <nicAddPacketHeader+0x58>
  else
  	packet->length  = packet->header.length + packet->payload->length;
   1f6e8:	86 81       	ldd	r24, Z+6	; 0x06
   1f6ea:	97 81       	ldd	r25, Z+7	; 0x07
   1f6ec:	82 0f       	add	r24, r18
   1f6ee:	93 1f       	adc	r25, r19
   1f6f0:	9f 83       	std	Y+7, r25	; 0x07
   1f6f2:	8e 83       	std	Y+6, r24	; 0x06
  
  // now update the packet handle
  handle->packet = packet;
   1f6f4:	f7 01       	movw	r30, r14
   1f6f6:	d1 83       	std	Z+1, r29	; 0x01
   1f6f8:	c0 83       	st	Z, r28
  
  // everything done, so return the header 
  return packet->header.data;  
}
   1f6fa:	88 81       	ld	r24, Y
   1f6fc:	99 81       	ldd	r25, Y+1	; 0x01
   1f6fe:	df 91       	pop	r29
   1f700:	cf 91       	pop	r28
   1f702:	1f 91       	pop	r17
   1f704:	0f 91       	pop	r16
   1f706:	ff 90       	pop	r15
   1f708:	ef 90       	pop	r14
   1f70a:	08 95       	ret

0001f70c <nicNewRequest>:
};

struct nicRequestHandle_t* nicNewRequest()
{
  struct nicRequestHandle_t* handle;
  handle = (struct nicRequestHandle_t*) malloc(sizeof(struct nicRequestHandle_t));
   1f70c:	82 e0       	ldi	r24, 0x02	; 2
   1f70e:	90 e0       	ldi	r25, 0x00	; 0
   1f710:	0e 94 66 fe 	call	0x1fccc	; 0x1fccc <malloc>
   1f714:	fc 01       	movw	r30, r24
  
  handle->packet = NULL;
   1f716:	11 82       	std	Z+1, r1	; 0x01
   1f718:	10 82       	st	Z, r1

  return handle;  
}
   1f71a:	08 95       	ret

0001f71c <nicReceiveResponse>:

  return;
}

struct nicResponseHandle_t* nicReceiveResponse()
{  
   1f71c:	cf 93       	push	r28
   1f71e:	df 93       	push	r29

  // Check the Interruptflags for new Packkets...
  if ((enc28j60_crgetc(ENC_REG_EIR) & ENC_REG_EIR_PKTIF ) == 0)
   1f720:	8c e9       	ldi	r24, 0x9C	; 156
   1f722:	0e 94 93 f9 	call	0x1f326	; 0x1f326 <enc28j60_crgetc>
   1f726:	86 fd       	sbrc	r24, 6
   1f728:	08 c0       	rjmp	.+16     	; 0x1f73a <nicReceiveResponse+0x1e>
    //... and then consult the packet counter (due to bad silicon) 
    if (enc28j60_crgetc(ENC_REG_EPKTCNT) == 0)
   1f72a:	89 e3       	ldi	r24, 0x39	; 57
   1f72c:	0e 94 93 f9 	call	0x1f326	; 0x1f326 <enc28j60_crgetc>
   1f730:	88 23       	and	r24, r24
   1f732:	19 f4       	brne	.+6      	; 0x1f73a <nicReceiveResponse+0x1e>
   1f734:	c0 e0       	ldi	r28, 0x00	; 0
   1f736:	d0 e0       	ldi	r29, 0x00	; 0
   1f738:	0f c0       	rjmp	.+30     	; 0x1f758 <nicReceiveResponse+0x3c>
      return NULL;
 
  // ... generate a handle with a dummy Packet header...
  
  struct nicResponseHandle_t* handle 
      = (struct nicResponseHandle_t*) malloc(sizeof(struct nicResponseHandle_t));
   1f73a:	84 e0       	ldi	r24, 0x04	; 4
   1f73c:	90 e0       	ldi	r25, 0x00	; 0
   1f73e:	0e 94 66 fe 	call	0x1fccc	; 0x1fccc <malloc>
   1f742:	ec 01       	movw	r28, r24
  
  // ...now set and update the readpointer  
  handle->nextPacketPtr = enc28j60_bmgetw();  
   1f744:	0e 94 67 fa 	call	0x1f4ce	; 0x1f4ce <enc28j60_bmgetw>
   1f748:	9b 83       	std	Y+3, r25	; 0x03
   1f74a:	8a 83       	std	Y+2, r24	; 0x02
  
  //update the length...
  handle->length = enc28j60_bmgetw();
   1f74c:	0e 94 67 fa 	call	0x1f4ce	; 0x1f4ce <enc28j60_bmgetw>
   1f750:	99 83       	std	Y+1, r25	; 0x01
   1f752:	88 83       	st	Y, r24

  // ignore the receive Vector   
  enc28j60_bmgetw();
   1f754:	0e 94 67 fa 	call	0x1f4ce	; 0x1f4ce <enc28j60_bmgetw>
  
  return handle;  
}
   1f758:	ce 01       	movw	r24, r28
   1f75a:	df 91       	pop	r29
   1f75c:	cf 91       	pop	r28
   1f75e:	08 95       	ret

0001f760 <nicInitialize>:
  
  return;
}

void nicInitialize(struct macAddress_t* mac)
{
   1f760:	cf 93       	push	r28
   1f762:	df 93       	push	r29
   1f764:	ec 01       	movw	r28, r24
  //TODO Change to Full Duplex Settings...
  enc28j60_init();
   1f766:	0e 94 5d f9 	call	0x1f2ba	; 0x1f2ba <enc28j60_init>
  
  enc28j60_reset();
   1f76a:	0e 94 9f fa 	call	0x1f53e	; 0x1f53e <enc28j60_reset>
   1f76e:	84 ef       	ldi	r24, 0xF4	; 244
   1f770:	91 e0       	ldi	r25, 0x01	; 1
   1f772:	20 e7       	ldi	r18, 0x70	; 112
   1f774:	31 e0       	ldi	r19, 0x01	; 1
   1f776:	f9 01       	movw	r30, r18
   1f778:	31 97       	sbiw	r30, 0x01	; 1
   1f77a:	f1 f7       	brne	.-4      	; 0x1f778 <nicInitialize+0x18>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1f77c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1f77e:	d9 f7       	brne	.-10     	; 0x1f776 <nicInitialize+0x16>
  _delay_ms(50);

  // Let's wait until the ENC28J60 is ready...
  while( (enc28j60_crgetc(ENC_REG_ESTAT) & ENC_REG_ESTAT_CLKRDY) == 0 );
   1f780:	8d e9       	ldi	r24, 0x9D	; 157
   1f782:	0e 94 93 f9 	call	0x1f326	; 0x1f326 <enc28j60_crgetc>
   1f786:	80 ff       	sbrs	r24, 0
   1f788:	fb cf       	rjmp	.-10     	; 0x1f780 <nicInitialize+0x20>
  
  // Setup RX buffers...
  enc28j60_crputc(ENC_REG_ERXSTL, 0x00);
   1f78a:	88 e0       	ldi	r24, 0x08	; 8
   1f78c:	60 e0       	ldi	r22, 0x00	; 0
   1f78e:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_ERXSTH, 0x00);
   1f792:	89 e0       	ldi	r24, 0x09	; 9
   1f794:	60 e0       	ldi	r22, 0x00	; 0
   1f796:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  enc28j60_crputc(ENC_REG_ERXNDL, 0xFF);
   1f79a:	8a e0       	ldi	r24, 0x0A	; 10
   1f79c:	6f ef       	ldi	r22, 0xFF	; 255
   1f79e:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_ERXNDH, 0x19);
   1f7a2:	8b e0       	ldi	r24, 0x0B	; 11
   1f7a4:	69 e1       	ldi	r22, 0x19	; 25
   1f7a6:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  // Setup TX Buffers...
  enc28j60_crputw(ENC_REG_ETXSTL, ENC_ETXST);
   1f7aa:	84 e0       	ldi	r24, 0x04	; 4
   1f7ac:	60 e0       	ldi	r22, 0x00	; 0
   1f7ae:	7a e1       	ldi	r23, 0x1A	; 26
   1f7b0:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXSTL, 0x00);
  //enc28j60_crputc(ENC_REG_ETXSTH, 0x1A);

  enc28j60_crputw(ENC_REG_ETXNDL, ENC_ETXND);
   1f7b4:	86 e0       	ldi	r24, 0x06	; 6
   1f7b6:	6f ef       	ldi	r22, 0xFF	; 255
   1f7b8:	7f e1       	ldi	r23, 0x1F	; 31
   1f7ba:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXNDL, 0xFF);
  //enc28j60_crputc(ENC_REG_ETXNDH, 0x1F);

  // Clear MARST in MACON2 to start Mac Module 
  enc28j60_crputc(ENC_REG_MACON2, 0x00);
   1f7be:	81 e4       	ldi	r24, 0x41	; 65
   1f7c0:	60 e0       	ldi	r22, 0x00	; 0
   1f7c2:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  // enabled MARXEN in MACON1 to enable receive ...
  // ...TXPAUS and RXPAUS for FullDuplex with FlowControl
  enc28j60_crputc(
   1f7c6:	80 e4       	ldi	r24, 0x40	; 64
   1f7c8:	6d e0       	ldi	r22, 0x0D	; 13
   1f7ca:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
      ENC_REG_MACON1, 
      ENC_REG_MACON1_MARXEN | ENC_REG_MACON1_RXPAUS | ENC_REG_MACON1_TXPAUS);

  // enable automatic Padding (PADCFG) automatic CRC ...
  // .. (TXCRCEN) and Framelength Check in MACON3
  enc28j60_crputc(
   1f7ce:	82 e4       	ldi	r24, 0x42	; 66
   1f7d0:	62 e3       	ldi	r22, 0x32	; 50
   1f7d2:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
      ENC_REG_MACON3,
      ENC_REG_MACON3_PADCFG0 | ENC_REG_MACON3_TXCRCEN  | ENC_REG_MACON3_FRMLEN);

  // set Maximum frame length
  // Programm MAMXFL regiserts to set maximum framelength. 1518 (0x5EE) are normal
  enc28j60_crputc(ENC_REG_MAMXFLL,0xEE);
   1f7d6:	8a e4       	ldi	r24, 0x4A	; 74
   1f7d8:	6e ee       	ldi	r22, 0xEE	; 238
   1f7da:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAMXFLH,0x05);
   1f7de:	8b e4       	ldi	r24, 0x4B	; 75
   1f7e0:	65 e0       	ldi	r22, 0x05	; 5
   1f7e2:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  // TODO ENC auf Full duplex setzen...
  // Set MABBIPG with 15h (recommended for Full Duplex)
  enc28j60_crputc(ENC_REG_MABBIPG, 0x12);
   1f7e6:	84 e4       	ldi	r24, 0x44	; 68
   1f7e8:	62 e1       	ldi	r22, 0x12	; 18
   1f7ea:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  // set MAIPGL to 12h
  enc28j60_crputc(ENC_REG_MAIPGL, 0x12);
   1f7ee:	86 e4       	ldi	r24, 0x46	; 70
   1f7f0:	62 e1       	ldi	r22, 0x12	; 18
   1f7f2:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  // set HAIPGH to 0h
  enc28j60_crputc(ENC_REG_MAIPGH, 0x0C);
   1f7f6:	87 e4       	ldi	r24, 0x47	; 71
   1f7f8:	6c e0       	ldi	r22, 0x0C	; 12
   1f7fa:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  
  //10.) programm mac address: BYTE BACKWARD !
  enc28j60_crputc(ENC_REG_MAADR0,mac->octet6);
   1f7fe:	81 e6       	ldi	r24, 0x61	; 97
   1f800:	6d 81       	ldd	r22, Y+5	; 0x05
   1f802:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR1,mac->octet5);
   1f806:	80 e6       	ldi	r24, 0x60	; 96
   1f808:	6c 81       	ldd	r22, Y+4	; 0x04
   1f80a:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR2,mac->octet4);
   1f80e:	83 e6       	ldi	r24, 0x63	; 99
   1f810:	6b 81       	ldd	r22, Y+3	; 0x03
   1f812:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR3,mac->octet3);
   1f816:	82 e6       	ldi	r24, 0x62	; 98
   1f818:	6a 81       	ldd	r22, Y+2	; 0x02
   1f81a:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR4,mac->octet2);
   1f81e:	85 e6       	ldi	r24, 0x65	; 101
   1f820:	69 81       	ldd	r22, Y+1	; 0x01
   1f822:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR5,mac->octet1);
   1f826:	84 e6       	ldi	r24, 0x64	; 100
   1f828:	68 81       	ld	r22, Y
   1f82a:	0e 94 e5 f9 	call	0x1f3ca	; 0x1f3ca <enc28j60_crputc>

  // Initialize Phy
  // TODO PHY flags ber define festlegen...
  // disable loopback
  enc28j60_prputw(0x10,(1 << 8));
   1f82e:	80 e1       	ldi	r24, 0x10	; 16
   1f830:	60 e0       	ldi	r22, 0x00	; 0
   1f832:	71 e0       	ldi	r23, 0x01	; 1
   1f834:	0e 94 a6 fa 	call	0x1f54c	; 0x1f54c <enc28j60_prputw>

  // enable LEDs
  enc28j60_prputw(0x14,0x0472);
   1f838:	84 e1       	ldi	r24, 0x14	; 20
   1f83a:	62 e7       	ldi	r22, 0x72	; 114
   1f83c:	74 e0       	ldi	r23, 0x04	; 4
   1f83e:	0e 94 a6 fa 	call	0x1f54c	; 0x1f54c <enc28j60_prputw>

  // enable receive
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_RXEN);
   1f842:	8f e9       	ldi	r24, 0x9F	; 159
   1f844:	64 e0       	ldi	r22, 0x04	; 4
   1f846:	0e 94 0c fa 	call	0x1f418	; 0x1f418 <enc28j60_crbfs>
  
  // set next packet pointer to 0
  enc28j60_crputw(ENC_REG_ERDPTL,0);
   1f84a:	80 e0       	ldi	r24, 0x00	; 0
   1f84c:	60 e0       	ldi	r22, 0x00	; 0
   1f84e:	70 e0       	ldi	r23, 0x00	; 0
   1f850:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>

  return;
}
   1f854:	df 91       	pop	r29
   1f856:	cf 91       	pop	r28
   1f858:	08 95       	ret

0001f85a <nicSendPacket>:
  // ...we waited long enough, continue anyway
  return;
}

uint8_t nicSendPacket(const struct nicRequestHandle_t* handle, uint8_t flags)
{
   1f85a:	df 92       	push	r13
   1f85c:	ef 92       	push	r14
   1f85e:	ff 92       	push	r15
   1f860:	0f 93       	push	r16
   1f862:	1f 93       	push	r17
   1f864:	df 93       	push	r29
   1f866:	cf 93       	push	r28
   1f868:	0f 92       	push	r0
   1f86a:	cd b7       	in	r28, 0x3d	; 61
   1f86c:	de b7       	in	r29, 0x3e	; 62
   1f86e:	7c 01       	movw	r14, r24
   1f870:	d6 2e       	mov	r13, r22
  // Wait until we are ready to send...
  nicWaitForSend();
   1f872:	0e 94 39 fb 	call	0x1f672	; 0x1f672 <nicWaitForSend>

  // setup tx buffer start
  enc28j60_crputw(ENC_REG_ETXSTL,ENC_ETXST);
   1f876:	84 e0       	ldi	r24, 0x04	; 4
   1f878:	60 e0       	ldi	r22, 0x00	; 0
   1f87a:	7a e1       	ldi	r23, 0x1A	; 26
   1f87c:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXSTL,0x00);
  //enc28j60_crputc(ENC_REG_ETXSTH,0x1A);

  //setup write pointer
  enc28j60_crputw(ENC_REG_EWRPTL,ENC_ETXST);
   1f880:	82 e0       	ldi	r24, 0x02	; 2
   1f882:	60 e0       	ldi	r22, 0x00	; 0
   1f884:	7a e1       	ldi	r23, 0x1A	; 26
   1f886:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_EWRPTL,0x00);
  //enc28j60_crputc(ENC_REG_EWRPTH,0x1A);

  // write control block
  uint8_t dummy = 0;
   1f88a:	19 82       	std	Y+1, r1	; 0x01
  enc28j60_bmputs(&dummy,1);
   1f88c:	ce 01       	movw	r24, r28
   1f88e:	01 96       	adiw	r24, 0x01	; 1
   1f890:	61 e0       	ldi	r22, 0x01	; 1
   1f892:	70 e0       	ldi	r23, 0x00	; 0
   1f894:	0e 94 8c fa 	call	0x1f518	; 0x1f518 <enc28j60_bmputs>
  
  // now start building the packet...
  
  struct soPacket_t* packet = handle->packet;
   1f898:	d7 01       	movw	r26, r14
   1f89a:	0d 91       	ld	r16, X+
   1f89c:	1c 91       	ld	r17, X
   1f89e:	0c c0       	rjmp	.+24     	; 0x1f8b8 <nicSendPacket+0x5e>
       
  while( packet != NULL)
  {    
    enc28j60_bmputs(packet->header.data,packet->header.length);   
   1f8a0:	f8 01       	movw	r30, r16
   1f8a2:	62 81       	ldd	r22, Z+2	; 0x02
   1f8a4:	73 81       	ldd	r23, Z+3	; 0x03
   1f8a6:	80 81       	ld	r24, Z
   1f8a8:	91 81       	ldd	r25, Z+1	; 0x01
   1f8aa:	0e 94 8c fa 	call	0x1f518	; 0x1f518 <enc28j60_bmputs>
    packet = packet->payload;
   1f8ae:	d8 01       	movw	r26, r16
   1f8b0:	14 96       	adiw	r26, 0x04	; 4
   1f8b2:	0d 91       	ld	r16, X+
   1f8b4:	1c 91       	ld	r17, X
   1f8b6:	15 97       	sbiw	r26, 0x05	; 5
  
  // now start building the packet...
  
  struct soPacket_t* packet = handle->packet;
       
  while( packet != NULL)
   1f8b8:	01 15       	cp	r16, r1
   1f8ba:	11 05       	cpc	r17, r1
   1f8bc:	89 f7       	brne	.-30     	; 0x1f8a0 <nicSendPacket+0x46>
    enc28j60_bmputs(packet->header.data,packet->header.length);   
    packet = packet->payload;
  }
  
  // calculate the Packet length...
  enc28j60_crputw(ENC_REG_ETXNDL, ENC_ETXST + handle->packet->length);
   1f8be:	d7 01       	movw	r26, r14
   1f8c0:	ed 91       	ld	r30, X+
   1f8c2:	fc 91       	ld	r31, X
   1f8c4:	66 81       	ldd	r22, Z+6	; 0x06
   1f8c6:	77 81       	ldd	r23, Z+7	; 0x07
   1f8c8:	60 50       	subi	r22, 0x00	; 0
   1f8ca:	76 4e       	sbci	r23, 0xE6	; 230
   1f8cc:	86 e0       	ldi	r24, 0x06	; 6
   1f8ce:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXNDL,0x4E);  
  //enc28j60_crputc(ENC_REG_ETXNDH,0x1A);
  
	// according to the Silicon Errata Document (10. Transmit Logic) ...
  // .. we need to reset the transmit logic...
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_TXRST); 
   1f8d2:	8f e9       	ldi	r24, 0x9F	; 159
   1f8d4:	60 e8       	ldi	r22, 0x80	; 128
   1f8d6:	0e 94 0c fa 	call	0x1f418	; 0x1f418 <enc28j60_crbfs>
  enc28j60_crbfc(ENC_REG_ECON1,ENC_REG_ECON1_TXRST);
   1f8da:	8f e9       	ldi	r24, 0x9F	; 159
   1f8dc:	60 e8       	ldi	r22, 0x80	; 128
   1f8de:	0e 94 30 fa 	call	0x1f460	; 0x1f460 <enc28j60_crbfc>
  
  // transmit request...
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_TXRTS | ENC_REG_ECON1_RXEN);
   1f8e2:	8f e9       	ldi	r24, 0x9F	; 159
   1f8e4:	6c e0       	ldi	r22, 0x0C	; 12
   1f8e6:	0e 94 0c fa 	call	0x1f418	; 0x1f418 <enc28j60_crbfs>

  // this is now debug only...
  // ... 
  
  if (flags & NIC_PACKET_SEND_NOWAIT)
   1f8ea:	1d 2d       	mov	r17, r13
   1f8ec:	d0 fc       	sbrc	r13, 0
   1f8ee:	0f c0       	rjmp	.+30     	; 0x1f90e <nicSendPacket+0xb4>
    return 0;
  
  // wait until transmit is completed...
  while ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS) );
   1f8f0:	8f e9       	ldi	r24, 0x9F	; 159
   1f8f2:	0e 94 93 f9 	call	0x1f326	; 0x1f326 <enc28j60_crgetc>
   1f8f6:	83 ff       	sbrs	r24, 3
   1f8f8:	fb cf       	rjmp	.-10     	; 0x1f8f0 <nicSendPacket+0x96>
  
  if (flags & NIC_PACKET_SEND_NOERRCHK)
   1f8fa:	11 fd       	sbrc	r17, 1
   1f8fc:	08 c0       	rjmp	.+16     	; 0x1f90e <nicSendPacket+0xb4>
    return 0;

  // check ESTAT for send Errors...
  if ((enc28j60_crgetc(ENC_REG_ESTAT) 
   1f8fe:	8d e9       	ldi	r24, 0x9D	; 157
   1f900:	0e 94 93 f9 	call	0x1f326	; 0x1f326 <enc28j60_crgetc>
   1f904:	90 e0       	ldi	r25, 0x00	; 0
   1f906:	82 71       	andi	r24, 0x12	; 18
   1f908:	19 f0       	breq	.+6      	; 0x1f910 <nicSendPacket+0xb6>
   1f90a:	91 e0       	ldi	r25, 0x01	; 1
   1f90c:	01 c0       	rjmp	.+2      	; 0x1f910 <nicSendPacket+0xb6>
   1f90e:	90 e0       	ldi	r25, 0x00	; 0
  // ...Restore read pointer
  
  // parse Vector...
  
  return 1;  
}
   1f910:	89 2f       	mov	r24, r25
   1f912:	0f 90       	pop	r0
   1f914:	cf 91       	pop	r28
   1f916:	df 91       	pop	r29
   1f918:	1f 91       	pop	r17
   1f91a:	0f 91       	pop	r16
   1f91c:	ff 90       	pop	r15
   1f91e:	ef 90       	pop	r14
   1f920:	df 90       	pop	r13
   1f922:	08 95       	ret

0001f924 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
   1f924:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
   1f926:	e1 99       	sbic	0x1c, 1	; 28
   1f928:	fe cf       	rjmp	.-4      	; 0x1f926 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
   1f92a:	3f bb       	out	0x1f, r19	; 31
   1f92c:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
   1f92e:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
   1f930:	0f b6       	in	r0, 0x3f	; 63
   1f932:	f8 94       	cli
   1f934:	e2 9a       	sbi	0x1c, 2	; 28
   1f936:	e1 9a       	sbi	0x1c, 1	; 28
   1f938:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
   1f93a:	08 95       	ret

0001f93c <compareStrings>:
    
    // set 10 sec timeout...
    tftpTimeout = timerAddTimeout(10240, onTFtpComplete);
  }
  
  uint8_t compareStrings(char * s1, char * s2) {
   1f93c:	fc 01       	movw	r30, r24
   1f93e:	db 01       	movw	r26, r22
    while ( *s1 && ( *s1++ == *s2++ ) );
   1f940:	90 81       	ld	r25, Z
   1f942:	99 23       	and	r25, r25
   1f944:	21 f0       	breq	.+8      	; 0x1f94e <compareStrings+0x12>
   1f946:	8d 91       	ld	r24, X+
   1f948:	31 96       	adiw	r30, 0x01	; 1
   1f94a:	98 17       	cp	r25, r24
   1f94c:	c9 f3       	breq	.-14     	; 0x1f940 <compareStrings+0x4>
    if ( *s1 == 0 && *s2 == 0 )
   1f94e:	80 81       	ld	r24, Z
   1f950:	88 23       	and	r24, r24
   1f952:	11 f0       	breq	.+4      	; 0x1f958 <compareStrings+0x1c>
   1f954:	80 e0       	ldi	r24, 0x00	; 0
   1f956:	08 95       	ret
   1f958:	6c 91       	ld	r22, X
   1f95a:	61 11       	cpse	r22, r1
   1f95c:	61 e0       	ldi	r22, 0x01	; 1
   1f95e:	81 e0       	ldi	r24, 0x01	; 1
   1f960:	86 27       	eor	r24, r22
      return 1; // s1 == s2
    else
      return 0; // s1 != s2
  }
   1f962:	08 95       	ret

0001f964 <write_flash_page>:
    return 0;
  */
  }
  
  void write_flash_page(uint32_t page, uint8_t* buf)
  {
   1f964:	bf 92       	push	r11
   1f966:	cf 92       	push	r12
   1f968:	df 92       	push	r13
   1f96a:	ef 92       	push	r14
   1f96c:	ff 92       	push	r15
   1f96e:	0f 93       	push	r16
   1f970:	1f 93       	push	r17
   1f972:	cf 93       	push	r28
   1f974:	df 93       	push	r29
   1f976:	7b 01       	movw	r14, r22
   1f978:	8c 01       	movw	r16, r24
   1f97a:	6a 01       	movw	r12, r20
    uint16_t i;
    
    // Disable interrupts...
    cli();
   1f97c:	f8 94       	cli
    eeprom_busy_wait();
   1f97e:	e1 99       	sbic	0x1c, 1	; 28
   1f980:	fe cf       	rjmp	.-4      	; 0x1f97e <write_flash_page+0x1a>
    boot_page_erase(page);
   1f982:	83 e0       	ldi	r24, 0x03	; 3
   1f984:	f7 01       	movw	r30, r14
   1f986:	00 93 5b 00 	sts	0x005B, r16
   1f98a:	80 93 68 00 	sts	0x0068, r24
   1f98e:	e8 95       	spm
    boot_spm_busy_wait();
   1f990:	80 91 68 00 	lds	r24, 0x0068
   1f994:	80 fd       	sbrc	r24, 0
   1f996:	fc cf       	rjmp	.-8      	; 0x1f990 <write_flash_page+0x2c>
   1f998:	40 e0       	ldi	r20, 0x00	; 0
   1f99a:	50 e0       	ldi	r21, 0x00	; 0
   1f99c:	60 e0       	ldi	r22, 0x00	; 0
   1f99e:	70 e0       	ldi	r23, 0x00	; 0
    for (i = 0; i< SPM_PAGESIZE; i+=2)
    {
      uint16_t w = *buf++;
      w += (*buf++) << 8;
      
      boot_page_fill(page+i,w);
   1f9a0:	bb 24       	eor	r11, r11
   1f9a2:	b3 94       	inc	r11
    boot_page_erase(page);
    boot_spm_busy_wait();
         
    for (i = 0; i< SPM_PAGESIZE; i+=2)
    {
      uint16_t w = *buf++;
   1f9a4:	f6 01       	movw	r30, r12
   1f9a6:	80 81       	ld	r24, Z
      w += (*buf++) << 8;
   1f9a8:	d1 81       	ldd	r29, Z+1	; 0x01
   1f9aa:	c0 e0       	ldi	r28, 0x00	; 0
   1f9ac:	9e 01       	movw	r18, r28
   1f9ae:	28 0f       	add	r18, r24
   1f9b0:	31 1d       	adc	r19, r1
    return 0;
  */
  }
  
  void write_flash_page(uint32_t page, uint8_t* buf)
  {
   1f9b2:	82 e0       	ldi	r24, 0x02	; 2
   1f9b4:	90 e0       	ldi	r25, 0x00	; 0
   1f9b6:	c8 0e       	add	r12, r24
   1f9b8:	d9 1e       	adc	r13, r25
    for (i = 0; i< SPM_PAGESIZE; i+=2)
    {
      uint16_t w = *buf++;
      w += (*buf++) << 8;
      
      boot_page_fill(page+i,w);
   1f9ba:	db 01       	movw	r26, r22
   1f9bc:	ca 01       	movw	r24, r20
   1f9be:	8e 0d       	add	r24, r14
   1f9c0:	9f 1d       	adc	r25, r15
   1f9c2:	a0 1f       	adc	r26, r16
   1f9c4:	b1 1f       	adc	r27, r17
   1f9c6:	09 01       	movw	r0, r18
   1f9c8:	fc 01       	movw	r30, r24
   1f9ca:	a0 93 5b 00 	sts	0x005B, r26
   1f9ce:	b0 92 68 00 	sts	0x0068, r11
   1f9d2:	e8 95       	spm
   1f9d4:	11 24       	eor	r1, r1
   1f9d6:	4e 5f       	subi	r20, 0xFE	; 254
   1f9d8:	5f 4f       	sbci	r21, 0xFF	; 255
   1f9da:	6f 4f       	sbci	r22, 0xFF	; 255
   1f9dc:	7f 4f       	sbci	r23, 0xFF	; 255
    cli();
    eeprom_busy_wait();
    boot_page_erase(page);
    boot_spm_busy_wait();
         
    for (i = 0; i< SPM_PAGESIZE; i+=2)
   1f9de:	40 30       	cpi	r20, 0x00	; 0
   1f9e0:	91 e0       	ldi	r25, 0x01	; 1
   1f9e2:	59 07       	cpc	r21, r25
   1f9e4:	90 e0       	ldi	r25, 0x00	; 0
   1f9e6:	69 07       	cpc	r22, r25
   1f9e8:	90 e0       	ldi	r25, 0x00	; 0
   1f9ea:	79 07       	cpc	r23, r25
   1f9ec:	d9 f6       	brne	.-74     	; 0x1f9a4 <write_flash_page+0x40>
      w += (*buf++) << 8;
      
      boot_page_fill(page+i,w);
    }
    
    boot_page_write(page);
   1f9ee:	85 e0       	ldi	r24, 0x05	; 5
   1f9f0:	f7 01       	movw	r30, r14
   1f9f2:	00 93 5b 00 	sts	0x005B, r16
   1f9f6:	80 93 68 00 	sts	0x0068, r24
   1f9fa:	e8 95       	spm
    boot_spm_busy_wait();
   1f9fc:	80 91 68 00 	lds	r24, 0x0068
   1fa00:	80 fd       	sbrc	r24, 0
   1fa02:	fc cf       	rjmp	.-8      	; 0x1f9fc <write_flash_page+0x98>
    
    boot_rww_enable();
   1fa04:	81 e1       	ldi	r24, 0x11	; 17
   1fa06:	80 93 68 00 	sts	0x0068, r24
   1fa0a:	e8 95       	spm
    
    // Enable interrupts...
    sei();
   1fa0c:	78 94       	sei
  }
   1fa0e:	df 91       	pop	r29
   1fa10:	cf 91       	pop	r28
   1fa12:	1f 91       	pop	r17
   1fa14:	0f 91       	pop	r16
   1fa16:	ff 90       	pop	r15
   1fa18:	ef 90       	pop	r14
   1fa1a:	df 90       	pop	r13
   1fa1c:	cf 90       	pop	r12
   1fa1e:	bf 90       	pop	r11
   1fa20:	08 95       	ret

0001fa22 <onTFtpComplete>:
  // Refused connects, completed transfers or timeouts are causes for 
  // a disconnect. After the disconnect it is not possible to send any data.  
  void onTFtpComplete()
  {
    // disable interrupts...
    cli();
   1fa22:	f8 94       	cli
    /* Enable change of interrupt vectors */
    MCUCR = (1<<IVCE);
   1fa24:	81 e0       	ldi	r24, 0x01	; 1
   1fa26:	85 bf       	out	0x35, r24	; 53
    /* restore interrupts vectors */
    MCUCR = (0<<IVSEL);
   1fa28:	15 be       	out	0x35, r1	; 53
    
    RAMPZ &= ~(1 << RAMPZ0);
   1fa2a:	8b b7       	in	r24, 0x3b	; 59
   1fa2c:	8e 7f       	andi	r24, 0xFE	; 254
   1fa2e:	8b bf       	out	0x3b, r24	; 59
      
    asm("jmp 0"); 
   1fa30:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
      we'll never reach this part
    ((void(*) ())0x0000)();  
          
    return;
	*/
  }
   1fa34:	08 95       	ret

0001fa36 <onTFtpTimeOut>:
    adr.ip =  0x0100A8C0; //192.168.0.1 !Reverse Byte order
    adr.port = 7777;
    portAddress_t port = 55042;
    rtpSendData("Timeout",7,&adr,&port);*/
    return;
  }
   1fa36:	08 95       	ret

0001fa38 <onTftpFlashData>:
  }*/
  

  
  void onTftpFlashData(uint16_t block, char* data, uint16_t len)
  {     
   1fa38:	ef 92       	push	r14
   1fa3a:	ff 92       	push	r15
   1fa3c:	0f 93       	push	r16
   1fa3e:	1f 93       	push	r17
   1fa40:	7c 01       	movw	r14, r24
    // if (htftp.block != block)
    //  return;             
    // block muss kleiner als 480 da der ATMEGA max 480 Pages hat
    write_flash_page(htftp.page,(uint8_t*)data);
   1fa42:	8b 01       	movw	r16, r22
   1fa44:	60 91 af 01 	lds	r22, 0x01AF
   1fa48:	70 91 b0 01 	lds	r23, 0x01B0
   1fa4c:	80 91 b1 01 	lds	r24, 0x01B1
   1fa50:	90 91 b2 01 	lds	r25, 0x01B2
   1fa54:	a8 01       	movw	r20, r16
   1fa56:	0e 94 b2 fc 	call	0x1f964	; 0x1f964 <write_flash_page>
    htftp.page += SPM_PAGESIZE;
   1fa5a:	60 91 af 01 	lds	r22, 0x01AF
   1fa5e:	70 91 b0 01 	lds	r23, 0x01B0
   1fa62:	80 91 b1 01 	lds	r24, 0x01B1
   1fa66:	90 91 b2 01 	lds	r25, 0x01B2
   1fa6a:	60 50       	subi	r22, 0x00	; 0
   1fa6c:	7f 4f       	sbci	r23, 0xFF	; 255
   1fa6e:	8f 4f       	sbci	r24, 0xFF	; 255
   1fa70:	9f 4f       	sbci	r25, 0xFF	; 255
   1fa72:	60 93 af 01 	sts	0x01AF, r22
   1fa76:	70 93 b0 01 	sts	0x01B0, r23
   1fa7a:	80 93 b1 01 	sts	0x01B1, r24
   1fa7e:	90 93 b2 01 	sts	0x01B2, r25
    write_flash_page(htftp.page,(uint8_t*)(data+SPM_PAGESIZE));
   1fa82:	00 50       	subi	r16, 0x00	; 0
   1fa84:	1f 4f       	sbci	r17, 0xFF	; 255
   1fa86:	a8 01       	movw	r20, r16
   1fa88:	0e 94 b2 fc 	call	0x1f964	; 0x1f964 <write_flash_page>
    htftp.page += SPM_PAGESIZE;
   1fa8c:	80 91 af 01 	lds	r24, 0x01AF
   1fa90:	90 91 b0 01 	lds	r25, 0x01B0
   1fa94:	a0 91 b1 01 	lds	r26, 0x01B1
   1fa98:	b0 91 b2 01 	lds	r27, 0x01B2
   1fa9c:	80 50       	subi	r24, 0x00	; 0
   1fa9e:	9f 4f       	sbci	r25, 0xFF	; 255
   1faa0:	af 4f       	sbci	r26, 0xFF	; 255
   1faa2:	bf 4f       	sbci	r27, 0xFF	; 255
   1faa4:	80 93 af 01 	sts	0x01AF, r24
   1faa8:	90 93 b0 01 	sts	0x01B0, r25
   1faac:	a0 93 b1 01 	sts	0x01B1, r26
   1fab0:	b0 93 b2 01 	sts	0x01B2, r27
    
    tftpSendAck(block);
   1fab4:	c7 01       	movw	r24, r14
   1fab6:	0e 94 83 f5 	call	0x1eb06	; 0x1eb06 <tftpSendAck>
    htftp.block++;
   1faba:	ef ea       	ldi	r30, 0xAF	; 175
   1fabc:	f1 e0       	ldi	r31, 0x01	; 1
   1fabe:	92 91       	ld	r25, -Z
   1fac0:	82 91       	ld	r24, -Z
   1fac2:	01 96       	adiw	r24, 0x01	; 1
   1fac4:	91 83       	std	Z+1, r25	; 0x01
   1fac6:	80 83       	st	Z, r24
    adr.port = 7777;
    portAddress_t port = 55042;
    rtpSendData(data,len,&adr,&port);*/    
    
    return;
  }
   1fac8:	1f 91       	pop	r17
   1faca:	0f 91       	pop	r16
   1facc:	ff 90       	pop	r15
   1face:	ef 90       	pop	r14
   1fad0:	08 95       	ret

0001fad2 <onTftpEepromData>:

  void onTftpEepromData(uint16_t block, char* data, uint16_t len) {
   1fad2:	cf 92       	push	r12
   1fad4:	df 92       	push	r13
   1fad6:	ef 92       	push	r14
   1fad8:	ff 92       	push	r15
   1fada:	0f 93       	push	r16
   1fadc:	1f 93       	push	r17
   1fade:	6c 01       	movw	r12, r24
   1fae0:	7a 01       	movw	r14, r20
    //if (block == htftp.block) {
      // Disable interrupts...
      cli();
   1fae2:	f8 94       	cli
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
   1fae4:	80 91 af 01 	lds	r24, 0x01AF
   1fae8:	90 91 b0 01 	lds	r25, 0x01B0
   1faec:	22 e9       	ldi	r18, 0x92	; 146
   1faee:	3c ef       	ldi	r19, 0xFC	; 252
   1faf0:	0e 94 68 ff 	call	0x1fed0	; 0x1fed0 <__eewr_block>

      eeprom_write_block(data, (void*)htftp.page, len);

      // Enable interrupts...
      sei();
   1faf4:	78 94       	sei

      htftp.page += len;
   1faf6:	00 e0       	ldi	r16, 0x00	; 0
   1faf8:	10 e0       	ldi	r17, 0x00	; 0
   1fafa:	80 91 af 01 	lds	r24, 0x01AF
   1fafe:	90 91 b0 01 	lds	r25, 0x01B0
   1fb02:	a0 91 b1 01 	lds	r26, 0x01B1
   1fb06:	b0 91 b2 01 	lds	r27, 0x01B2
   1fb0a:	e8 0e       	add	r14, r24
   1fb0c:	f9 1e       	adc	r15, r25
   1fb0e:	0a 1f       	adc	r16, r26
   1fb10:	1b 1f       	adc	r17, r27
   1fb12:	e0 92 af 01 	sts	0x01AF, r14
   1fb16:	f0 92 b0 01 	sts	0x01B0, r15
   1fb1a:	00 93 b1 01 	sts	0x01B1, r16
   1fb1e:	10 93 b2 01 	sts	0x01B2, r17
      htftp.block++;
   1fb22:	ef ea       	ldi	r30, 0xAF	; 175
   1fb24:	f1 e0       	ldi	r31, 0x01	; 1
   1fb26:	92 91       	ld	r25, -Z
   1fb28:	82 91       	ld	r24, -Z
   1fb2a:	01 96       	adiw	r24, 0x01	; 1
   1fb2c:	91 83       	std	Z+1, r25	; 0x01
   1fb2e:	80 83       	st	Z, r24
    //}

    tftpSendAck(block);
   1fb30:	c6 01       	movw	r24, r12
   1fb32:	0e 94 83 f5 	call	0x1eb06	; 0x1eb06 <tftpSendAck>

    return;
  }
   1fb36:	1f 91       	pop	r17
   1fb38:	0f 91       	pop	r16
   1fb3a:	ff 90       	pop	r15
   1fb3c:	ef 90       	pop	r14
   1fb3e:	df 90       	pop	r13
   1fb40:	cf 90       	pop	r12
   1fb42:	08 95       	ret

0001fb44 <onTftpConnect>:

  // in case of an unsuccessful negotiation always return something not null!
  // otherwise the TFTP Socket will be jammed..
  // a non null value means a connection reject , 0 accepts the connection...
  uint8_t onTftpConnect(char* data, uint16_t len)
  {
   1fb44:	cf 93       	push	r28
   1fb46:	df 93       	push	r29
   1fb48:	ec 01       	movw	r28, r24
    timerClearTimeout(tftpTimeout);
   1fb4a:	80 91 b3 01 	lds	r24, 0x01B3
   1fb4e:	90 91 b4 01 	lds	r25, 0x01B4
   1fb52:	0e 94 74 f6 	call	0x1ece8	; 0x1ece8 <timerClearTimeout>
    //tftpTimeout = NULL;
    htftp.page = 0;
   1fb56:	10 92 af 01 	sts	0x01AF, r1
   1fb5a:	10 92 b0 01 	sts	0x01B0, r1
   1fb5e:	10 92 b1 01 	sts	0x01B1, r1
   1fb62:	10 92 b2 01 	sts	0x01B2, r1
    htftp.block = 1;
   1fb66:	81 e0       	ldi	r24, 0x01	; 1
   1fb68:	90 e0       	ldi	r25, 0x00	; 0
   1fb6a:	90 93 ae 01 	sts	0x01AE, r25
   1fb6e:	80 93 ad 01 	sts	0x01AD, r24
   1fb72:	fe 01       	movw	r30, r28
   1fb74:	aa e1       	ldi	r26, 0x1A	; 26
   1fb76:	b1 e0       	ldi	r27, 0x01	; 1
    // set 10 sec timeout...
    tftpTimeout = timerAddTimeout(10240, onTFtpComplete);
  }
  
  uint8_t compareStrings(char * s1, char * s2) {
    while ( *s1 && ( *s1++ == *s2++ ) );
   1fb78:	90 81       	ld	r25, Z
   1fb7a:	99 23       	and	r25, r25
   1fb7c:	21 f0       	breq	.+8      	; 0x1fb86 <onTftpConnect+0x42>
   1fb7e:	8d 91       	ld	r24, X+
   1fb80:	31 96       	adiw	r30, 0x01	; 1
   1fb82:	98 17       	cp	r25, r24
   1fb84:	c9 f3       	breq	.-14     	; 0x1fb78 <onTftpConnect+0x34>
    if ( *s1 == 0 && *s2 == 0 )
   1fb86:	80 81       	ld	r24, Z
   1fb88:	88 23       	and	r24, r24
   1fb8a:	31 f4       	brne	.+12     	; 0x1fb98 <onTftpConnect+0x54>
   1fb8c:	8c 91       	ld	r24, X
   1fb8e:	88 23       	and	r24, r24
   1fb90:	19 f4       	brne	.+6      	; 0x1fb98 <onTftpConnect+0x54>
    htftp.page = 0;
    htftp.block = 1;

    if (compareStrings(data, "firmware.bin")) {
      // set function-ptr to flash-processing function
      onTftpData = onTftpFlashData;
   1fb92:	8c e1       	ldi	r24, 0x1C	; 28
   1fb94:	9d ef       	ldi	r25, 0xFD	; 253
   1fb96:	11 c0       	rjmp	.+34     	; 0x1fbba <onTftpConnect+0x76>
      //htftp.block = 1;
      return 0;
   1fb98:	e7 e2       	ldi	r30, 0x27	; 39
   1fb9a:	f1 e0       	ldi	r31, 0x01	; 1
    // set 10 sec timeout...
    tftpTimeout = timerAddTimeout(10240, onTFtpComplete);
  }
  
  uint8_t compareStrings(char * s1, char * s2) {
    while ( *s1 && ( *s1++ == *s2++ ) );
   1fb9c:	98 81       	ld	r25, Y
   1fb9e:	99 23       	and	r25, r25
   1fba0:	21 f0       	breq	.+8      	; 0x1fbaa <onTftpConnect+0x66>
   1fba2:	81 91       	ld	r24, Z+
   1fba4:	21 96       	adiw	r28, 0x01	; 1
   1fba6:	98 17       	cp	r25, r24
   1fba8:	c9 f3       	breq	.-14     	; 0x1fb9c <onTftpConnect+0x58>
    if ( *s1 == 0 && *s2 == 0 )
   1fbaa:	88 81       	ld	r24, Y
   1fbac:	88 23       	and	r24, r24
   1fbae:	69 f4       	brne	.+26     	; 0x1fbca <onTftpConnect+0x86>
   1fbb0:	80 81       	ld	r24, Z
   1fbb2:	88 23       	and	r24, r24
   1fbb4:	51 f4       	brne	.+20     	; 0x1fbca <onTftpConnect+0x86>
      return 0;
    }
    
    if (compareStrings(data, "eeprom.bin")) {
      // set function-ptr to eeprom-processing function
      onTftpData = onTftpEepromData;
   1fbb6:	89 e6       	ldi	r24, 0x69	; 105
   1fbb8:	9d ef       	ldi	r25, 0xFD	; 253
   1fbba:	90 93 ac 01 	sts	0x01AC, r25
   1fbbe:	80 93 ab 01 	sts	0x01AB, r24
   1fbc2:	80 e0       	ldi	r24, 0x00	; 0
  /*    
    htftp.block = 1;
    
    return 0;
  */
  }
   1fbc4:	df 91       	pop	r29
   1fbc6:	cf 91       	pop	r28
   1fbc8:	08 95       	ret
      //htftp.block = 0;
      return 0;
    }

    // filename is neither firmware.bin nor eeprom.bin
    tftpSendError(0,"Filename has to be firmware.bin or eeprom.bin",53); 
   1fbca:	80 e0       	ldi	r24, 0x00	; 0
   1fbcc:	90 e0       	ldi	r25, 0x00	; 0
   1fbce:	62 e3       	ldi	r22, 0x32	; 50
   1fbd0:	71 e0       	ldi	r23, 0x01	; 1
   1fbd2:	45 e3       	ldi	r20, 0x35	; 53
   1fbd4:	0e 94 1b f5 	call	0x1ea36	; 0x1ea36 <tftpSendError>
   1fbd8:	81 e0       	ldi	r24, 0x01	; 1
   1fbda:	f4 cf       	rjmp	.-24     	; 0x1fbc4 <onTftpConnect+0x80>

0001fbdc <onInitApplication>:
  void onTftpEepromData(uint16_t block, char * data, uint16_t len);  

  void onInitApplication()
  {
    // 3 gratious arps...
    arpSendRequest(ipGetAddress());
   1fbdc:	0e 94 06 f3 	call	0x1e60c	; 0x1e60c <ipGetAddress>
   1fbe0:	0e 94 fc f1 	call	0x1e3f8	; 0x1e3f8 <arpSendRequest>
    arpSendRequest(ipGetAddress());
   1fbe4:	0e 94 06 f3 	call	0x1e60c	; 0x1e60c <ipGetAddress>
   1fbe8:	0e 94 fc f1 	call	0x1e3f8	; 0x1e3f8 <arpSendRequest>
    arpSendRequest(ipGetAddress());
   1fbec:	0e 94 06 f3 	call	0x1e60c	; 0x1e60c <ipGetAddress>
   1fbf0:	0e 94 fc f1 	call	0x1e3f8	; 0x1e3f8 <arpSendRequest>
    
    // set 10 sec timeout...
    tftpTimeout = timerAddTimeout(10240, onTFtpComplete);
   1fbf4:	80 e0       	ldi	r24, 0x00	; 0
   1fbf6:	98 e2       	ldi	r25, 0x28	; 40
   1fbf8:	61 e1       	ldi	r22, 0x11	; 17
   1fbfa:	7d ef       	ldi	r23, 0xFD	; 253
   1fbfc:	0e 94 cc f6 	call	0x1ed98	; 0x1ed98 <timerAddTimeout>
   1fc00:	90 93 b4 01 	sts	0x01B4, r25
   1fc04:	80 93 b3 01 	sts	0x01B3, r24
  }
   1fc08:	08 95       	ret

0001fc0a <calculateCheckSum>:
#include "./netlib.h"

  // Kann nur die checksummer ber ein e gerade anzahl berechen... 
  uint16_t calculateCheckSum(void* bytes, uint16_t len)
  {
   1fc0a:	dc 01       	movw	r26, r24
   register uint32_t checksum = 0x00000000;
   
   // as we are processing full words, the length of the data ...
   // ... has to be odd. If it's even, we would loose the last byte 
   // ... so we have to take some precautions
   if (len & 0x00000001)
   1fc0c:	60 fd       	sbrc	r22, 0
   1fc0e:	05 c0       	rjmp	.+10     	; 0x1fc1a <calculateCheckSum+0x10>
   1fc10:	20 e0       	ldi	r18, 0x00	; 0
   1fc12:	30 e0       	ldi	r19, 0x00	; 0
   1fc14:	40 e0       	ldi	r20, 0x00	; 0
   1fc16:	50 e0       	ldi	r21, 0x00	; 0
   1fc18:	08 c0       	rjmp	.+16     	; 0x1fc2a <calculateCheckSum+0x20>
     checksum+= (((uint8_t*)bytes)[len]);
   1fc1a:	fc 01       	movw	r30, r24
   1fc1c:	e6 0f       	add	r30, r22
   1fc1e:	f7 1f       	adc	r31, r23
   1fc20:	80 81       	ld	r24, Z
   1fc22:	28 2f       	mov	r18, r24
   1fc24:	30 e0       	ldi	r19, 0x00	; 0
   1fc26:	40 e0       	ldi	r20, 0x00	; 0
   1fc28:	50 e0       	ldi	r21, 0x00	; 0
   
   // now, as we ensured an odd length, we can convert the length...
   // ... from bytes to words  
   len = len >> 1;
   1fc2a:	76 95       	lsr	r23
   1fc2c:	67 95       	ror	r22
   1fc2e:	fb 01       	movw	r30, r22
   1fc30:	e1 50       	subi	r30, 0x01	; 1
   1fc32:	f0 48       	sbci	r31, 0x80	; 128
   1fc34:	ee 0f       	add	r30, r30
   1fc36:	ff 1f       	adc	r31, r31
   1fc38:	ea 0f       	add	r30, r26
   1fc3a:	fb 1f       	adc	r31, r27
   1fc3c:	0b c0       	rjmp	.+22     	; 0x1fc54 <calculateCheckSum+0x4a>

   // calculate the checksum, wordwise
   while (len--)
   1fc3e:	61 50       	subi	r22, 0x01	; 1
   1fc40:	70 40       	sbci	r23, 0x00	; 0
     checksum += (((uint16_t *)bytes)[len]);
   1fc42:	80 81       	ld	r24, Z
   1fc44:	91 81       	ldd	r25, Z+1	; 0x01
   1fc46:	a0 e0       	ldi	r26, 0x00	; 0
   1fc48:	b0 e0       	ldi	r27, 0x00	; 0
   1fc4a:	28 0f       	add	r18, r24
   1fc4c:	39 1f       	adc	r19, r25
   1fc4e:	4a 1f       	adc	r20, r26
   1fc50:	5b 1f       	adc	r21, r27
   1fc52:	32 97       	sbiw	r30, 0x02	; 2
   // now, as we ensured an odd length, we can convert the length...
   // ... from bytes to words  
   len = len >> 1;

   // calculate the checksum, wordwise
   while (len--)
   1fc54:	61 15       	cp	r22, r1
   1fc56:	71 05       	cpc	r23, r1
   1fc58:	91 f7       	brne	.-28     	; 0x1fc3e <calculateCheckSum+0x34>
   1fc5a:	06 c0       	rjmp	.+12     	; 0x1fc68 <calculateCheckSum+0x5e>
     checksum += (((uint16_t *)bytes)[len]);

   // add overflows to the checksum 
   while (checksum>>16)
     checksum = (checksum & 0xffff) + (checksum >> 16);
   1fc5c:	40 70       	andi	r20, 0x00	; 0
   1fc5e:	50 70       	andi	r21, 0x00	; 0
   1fc60:	28 0f       	add	r18, r24
   1fc62:	39 1f       	adc	r19, r25
   1fc64:	4a 1f       	adc	r20, r26
   1fc66:	5b 1f       	adc	r21, r27
   // calculate the checksum, wordwise
   while (len--)
     checksum += (((uint16_t *)bytes)[len]);

   // add overflows to the checksum 
   while (checksum>>16)
   1fc68:	ca 01       	movw	r24, r20
   1fc6a:	aa 27       	eor	r26, r26
   1fc6c:	bb 27       	eor	r27, r27
   1fc6e:	00 97       	sbiw	r24, 0x00	; 0
   1fc70:	a1 05       	cpc	r26, r1
   1fc72:	b1 05       	cpc	r27, r1
   1fc74:	99 f7       	brne	.-26     	; 0x1fc5c <calculateCheckSum+0x52>
   1fc76:	20 95       	com	r18
   1fc78:	30 95       	com	r19
     checksum = (checksum & 0xffff) + (checksum >> 16);

   return ~((uint16_t)checksum);
 };
   1fc7a:	c9 01       	movw	r24, r18
   1fc7c:	08 95       	ret

0001fc7e <onInitConfig>:
Config_t Config;

void onInitConfig()
{
  if ( !EepromReadConfig((void *)CONFIG_EEPROM, &Config.IPv4, sizeof(Config.IPv4)) ) {
    Config.IPv4.remoteAdrData.ip = IP4_REMOTE_HOST_DATA;
   1fc7e:	80 ec       	ldi	r24, 0xC0	; 192
   1fc80:	98 ea       	ldi	r25, 0xA8	; 168
   1fc82:	a0 e0       	ldi	r26, 0x00	; 0
   1fc84:	b1 e0       	ldi	r27, 0x01	; 1
   1fc86:	80 93 b5 01 	sts	0x01B5, r24
   1fc8a:	90 93 b6 01 	sts	0x01B6, r25
   1fc8e:	a0 93 b7 01 	sts	0x01B7, r26
   1fc92:	b0 93 b8 01 	sts	0x01B8, r27
    Config.IPv4.remoteAdrData.port = IP4_REMOTE_PORT_DATA;
   1fc96:	21 e6       	ldi	r18, 0x61	; 97
   1fc98:	3e e1       	ldi	r19, 0x1E	; 30
   1fc9a:	30 93 ba 01 	sts	0x01BA, r19
   1fc9e:	20 93 b9 01 	sts	0x01B9, r18
    Config.IPv4.remoteAdrConfig.ip = IP4_REMOTE_HOST_CONFIG;
   1fca2:	80 93 bb 01 	sts	0x01BB, r24
   1fca6:	90 93 bc 01 	sts	0x01BC, r25
   1fcaa:	a0 93 bd 01 	sts	0x01BD, r26
   1fcae:	b0 93 be 01 	sts	0x01BE, r27
    Config.IPv4.remoteAdrConfig.port = IP4_REMOTE_PORT_CONFIG;
   1fcb2:	30 93 c0 01 	sts	0x01C0, r19
   1fcb6:	20 93 bf 01 	sts	0x01BF, r18
    Config.IPv4.localSrcPort = 55042;
   1fcba:	82 e0       	ldi	r24, 0x02	; 2
   1fcbc:	97 ed       	ldi	r25, 0xD7	; 215
   1fcbe:	90 93 c2 01 	sts	0x01C2, r25
   1fcc2:	80 93 c1 01 	sts	0x01C1, r24
  }
}
   1fcc6:	08 95       	ret

0001fcc8 <EepromReadConfig>:

uint8_t EepromReadConfig(void * baseadr, void * buf, uint8_t len)
{
  // always use fallback config in bootloader application
  return 0;
}
   1fcc8:	80 e0       	ldi	r24, 0x00	; 0
   1fcca:	08 95       	ret

0001fccc <malloc>:
   1fccc:	cf 93       	push	r28
   1fcce:	df 93       	push	r29
   1fcd0:	bc 01       	movw	r22, r24
   1fcd2:	82 30       	cpi	r24, 0x02	; 2
   1fcd4:	91 05       	cpc	r25, r1
   1fcd6:	10 f4       	brcc	.+4      	; 0x1fcdc <malloc+0x10>
   1fcd8:	62 e0       	ldi	r22, 0x02	; 2
   1fcda:	70 e0       	ldi	r23, 0x00	; 0
   1fcdc:	a0 91 c5 01 	lds	r26, 0x01C5
   1fce0:	b0 91 c6 01 	lds	r27, 0x01C6
   1fce4:	ed 01       	movw	r28, r26
   1fce6:	e0 e0       	ldi	r30, 0x00	; 0
   1fce8:	f0 e0       	ldi	r31, 0x00	; 0
   1fcea:	40 e0       	ldi	r20, 0x00	; 0
   1fcec:	50 e0       	ldi	r21, 0x00	; 0
   1fcee:	21 c0       	rjmp	.+66     	; 0x1fd32 <malloc+0x66>
   1fcf0:	88 81       	ld	r24, Y
   1fcf2:	99 81       	ldd	r25, Y+1	; 0x01
   1fcf4:	86 17       	cp	r24, r22
   1fcf6:	97 07       	cpc	r25, r23
   1fcf8:	69 f4       	brne	.+26     	; 0x1fd14 <malloc+0x48>
   1fcfa:	8a 81       	ldd	r24, Y+2	; 0x02
   1fcfc:	9b 81       	ldd	r25, Y+3	; 0x03
   1fcfe:	30 97       	sbiw	r30, 0x00	; 0
   1fd00:	19 f0       	breq	.+6      	; 0x1fd08 <malloc+0x3c>
   1fd02:	93 83       	std	Z+3, r25	; 0x03
   1fd04:	82 83       	std	Z+2, r24	; 0x02
   1fd06:	04 c0       	rjmp	.+8      	; 0x1fd10 <malloc+0x44>
   1fd08:	90 93 c6 01 	sts	0x01C6, r25
   1fd0c:	80 93 c5 01 	sts	0x01C5, r24
   1fd10:	fe 01       	movw	r30, r28
   1fd12:	34 c0       	rjmp	.+104    	; 0x1fd7c <malloc+0xb0>
   1fd14:	68 17       	cp	r22, r24
   1fd16:	79 07       	cpc	r23, r25
   1fd18:	38 f4       	brcc	.+14     	; 0x1fd28 <malloc+0x5c>
   1fd1a:	41 15       	cp	r20, r1
   1fd1c:	51 05       	cpc	r21, r1
   1fd1e:	19 f0       	breq	.+6      	; 0x1fd26 <malloc+0x5a>
   1fd20:	84 17       	cp	r24, r20
   1fd22:	95 07       	cpc	r25, r21
   1fd24:	08 f4       	brcc	.+2      	; 0x1fd28 <malloc+0x5c>
   1fd26:	ac 01       	movw	r20, r24
   1fd28:	fe 01       	movw	r30, r28
   1fd2a:	8a 81       	ldd	r24, Y+2	; 0x02
   1fd2c:	9b 81       	ldd	r25, Y+3	; 0x03
   1fd2e:	9c 01       	movw	r18, r24
   1fd30:	e9 01       	movw	r28, r18
   1fd32:	20 97       	sbiw	r28, 0x00	; 0
   1fd34:	e9 f6       	brne	.-70     	; 0x1fcf0 <malloc+0x24>
   1fd36:	41 15       	cp	r20, r1
   1fd38:	51 05       	cpc	r21, r1
   1fd3a:	a9 f1       	breq	.+106    	; 0x1fda6 <malloc+0xda>
   1fd3c:	ca 01       	movw	r24, r20
   1fd3e:	86 1b       	sub	r24, r22
   1fd40:	97 0b       	sbc	r25, r23
   1fd42:	04 97       	sbiw	r24, 0x04	; 4
   1fd44:	08 f4       	brcc	.+2      	; 0x1fd48 <malloc+0x7c>
   1fd46:	ba 01       	movw	r22, r20
   1fd48:	e0 e0       	ldi	r30, 0x00	; 0
   1fd4a:	f0 e0       	ldi	r31, 0x00	; 0
   1fd4c:	2a c0       	rjmp	.+84     	; 0x1fda2 <malloc+0xd6>
   1fd4e:	8d 91       	ld	r24, X+
   1fd50:	9c 91       	ld	r25, X
   1fd52:	11 97       	sbiw	r26, 0x01	; 1
   1fd54:	84 17       	cp	r24, r20
   1fd56:	95 07       	cpc	r25, r21
   1fd58:	f9 f4       	brne	.+62     	; 0x1fd98 <malloc+0xcc>
   1fd5a:	64 17       	cp	r22, r20
   1fd5c:	75 07       	cpc	r23, r21
   1fd5e:	81 f4       	brne	.+32     	; 0x1fd80 <malloc+0xb4>
   1fd60:	12 96       	adiw	r26, 0x02	; 2
   1fd62:	8d 91       	ld	r24, X+
   1fd64:	9c 91       	ld	r25, X
   1fd66:	13 97       	sbiw	r26, 0x03	; 3
   1fd68:	30 97       	sbiw	r30, 0x00	; 0
   1fd6a:	19 f0       	breq	.+6      	; 0x1fd72 <malloc+0xa6>
   1fd6c:	93 83       	std	Z+3, r25	; 0x03
   1fd6e:	82 83       	std	Z+2, r24	; 0x02
   1fd70:	04 c0       	rjmp	.+8      	; 0x1fd7a <malloc+0xae>
   1fd72:	90 93 c6 01 	sts	0x01C6, r25
   1fd76:	80 93 c5 01 	sts	0x01C5, r24
   1fd7a:	fd 01       	movw	r30, r26
   1fd7c:	32 96       	adiw	r30, 0x02	; 2
   1fd7e:	4c c0       	rjmp	.+152    	; 0x1fe18 <malloc+0x14c>
   1fd80:	ca 01       	movw	r24, r20
   1fd82:	86 1b       	sub	r24, r22
   1fd84:	97 0b       	sbc	r25, r23
   1fd86:	fd 01       	movw	r30, r26
   1fd88:	e8 0f       	add	r30, r24
   1fd8a:	f9 1f       	adc	r31, r25
   1fd8c:	61 93       	st	Z+, r22
   1fd8e:	71 93       	st	Z+, r23
   1fd90:	02 97       	sbiw	r24, 0x02	; 2
   1fd92:	8d 93       	st	X+, r24
   1fd94:	9c 93       	st	X, r25
   1fd96:	40 c0       	rjmp	.+128    	; 0x1fe18 <malloc+0x14c>
   1fd98:	fd 01       	movw	r30, r26
   1fd9a:	82 81       	ldd	r24, Z+2	; 0x02
   1fd9c:	93 81       	ldd	r25, Z+3	; 0x03
   1fd9e:	9c 01       	movw	r18, r24
   1fda0:	d9 01       	movw	r26, r18
   1fda2:	10 97       	sbiw	r26, 0x00	; 0
   1fda4:	a1 f6       	brne	.-88     	; 0x1fd4e <malloc+0x82>
   1fda6:	80 91 c3 01 	lds	r24, 0x01C3
   1fdaa:	90 91 c4 01 	lds	r25, 0x01C4
   1fdae:	89 2b       	or	r24, r25
   1fdb0:	41 f4       	brne	.+16     	; 0x1fdc2 <malloc+0xf6>
   1fdb2:	80 91 62 01 	lds	r24, 0x0162
   1fdb6:	90 91 63 01 	lds	r25, 0x0163
   1fdba:	90 93 c4 01 	sts	0x01C4, r25
   1fdbe:	80 93 c3 01 	sts	0x01C3, r24
   1fdc2:	40 91 64 01 	lds	r20, 0x0164
   1fdc6:	50 91 65 01 	lds	r21, 0x0165
   1fdca:	41 15       	cp	r20, r1
   1fdcc:	51 05       	cpc	r21, r1
   1fdce:	41 f4       	brne	.+16     	; 0x1fde0 <malloc+0x114>
   1fdd0:	4d b7       	in	r20, 0x3d	; 61
   1fdd2:	5e b7       	in	r21, 0x3e	; 62
   1fdd4:	80 91 60 01 	lds	r24, 0x0160
   1fdd8:	90 91 61 01 	lds	r25, 0x0161
   1fddc:	48 1b       	sub	r20, r24
   1fdde:	59 0b       	sbc	r21, r25
   1fde0:	20 91 c3 01 	lds	r18, 0x01C3
   1fde4:	30 91 c4 01 	lds	r19, 0x01C4
   1fde8:	ca 01       	movw	r24, r20
   1fdea:	82 1b       	sub	r24, r18
   1fdec:	93 0b       	sbc	r25, r19
   1fdee:	86 17       	cp	r24, r22
   1fdf0:	97 07       	cpc	r25, r23
   1fdf2:	80 f0       	brcs	.+32     	; 0x1fe14 <malloc+0x148>
   1fdf4:	ab 01       	movw	r20, r22
   1fdf6:	4e 5f       	subi	r20, 0xFE	; 254
   1fdf8:	5f 4f       	sbci	r21, 0xFF	; 255
   1fdfa:	84 17       	cp	r24, r20
   1fdfc:	95 07       	cpc	r25, r21
   1fdfe:	50 f0       	brcs	.+20     	; 0x1fe14 <malloc+0x148>
   1fe00:	42 0f       	add	r20, r18
   1fe02:	53 1f       	adc	r21, r19
   1fe04:	50 93 c4 01 	sts	0x01C4, r21
   1fe08:	40 93 c3 01 	sts	0x01C3, r20
   1fe0c:	f9 01       	movw	r30, r18
   1fe0e:	61 93       	st	Z+, r22
   1fe10:	71 93       	st	Z+, r23
   1fe12:	02 c0       	rjmp	.+4      	; 0x1fe18 <malloc+0x14c>
   1fe14:	e0 e0       	ldi	r30, 0x00	; 0
   1fe16:	f0 e0       	ldi	r31, 0x00	; 0
   1fe18:	cf 01       	movw	r24, r30
   1fe1a:	df 91       	pop	r29
   1fe1c:	cf 91       	pop	r28
   1fe1e:	08 95       	ret

0001fe20 <free>:
   1fe20:	cf 93       	push	r28
   1fe22:	df 93       	push	r29
   1fe24:	00 97       	sbiw	r24, 0x00	; 0
   1fe26:	09 f4       	brne	.+2      	; 0x1fe2a <free+0xa>
   1fe28:	50 c0       	rjmp	.+160    	; 0x1feca <free+0xaa>
   1fe2a:	ec 01       	movw	r28, r24
   1fe2c:	22 97       	sbiw	r28, 0x02	; 2
   1fe2e:	1b 82       	std	Y+3, r1	; 0x03
   1fe30:	1a 82       	std	Y+2, r1	; 0x02
   1fe32:	a0 91 c5 01 	lds	r26, 0x01C5
   1fe36:	b0 91 c6 01 	lds	r27, 0x01C6
   1fe3a:	10 97       	sbiw	r26, 0x00	; 0
   1fe3c:	09 f1       	breq	.+66     	; 0x1fe80 <free+0x60>
   1fe3e:	40 e0       	ldi	r20, 0x00	; 0
   1fe40:	50 e0       	ldi	r21, 0x00	; 0
   1fe42:	ac 17       	cp	r26, r28
   1fe44:	bd 07       	cpc	r27, r29
   1fe46:	08 f1       	brcs	.+66     	; 0x1fe8a <free+0x6a>
   1fe48:	bb 83       	std	Y+3, r27	; 0x03
   1fe4a:	aa 83       	std	Y+2, r26	; 0x02
   1fe4c:	fe 01       	movw	r30, r28
   1fe4e:	21 91       	ld	r18, Z+
   1fe50:	31 91       	ld	r19, Z+
   1fe52:	e2 0f       	add	r30, r18
   1fe54:	f3 1f       	adc	r31, r19
   1fe56:	ae 17       	cp	r26, r30
   1fe58:	bf 07       	cpc	r27, r31
   1fe5a:	79 f4       	brne	.+30     	; 0x1fe7a <free+0x5a>
   1fe5c:	8d 91       	ld	r24, X+
   1fe5e:	9c 91       	ld	r25, X
   1fe60:	11 97       	sbiw	r26, 0x01	; 1
   1fe62:	28 0f       	add	r18, r24
   1fe64:	39 1f       	adc	r19, r25
   1fe66:	2e 5f       	subi	r18, 0xFE	; 254
   1fe68:	3f 4f       	sbci	r19, 0xFF	; 255
   1fe6a:	39 83       	std	Y+1, r19	; 0x01
   1fe6c:	28 83       	st	Y, r18
   1fe6e:	12 96       	adiw	r26, 0x02	; 2
   1fe70:	8d 91       	ld	r24, X+
   1fe72:	9c 91       	ld	r25, X
   1fe74:	13 97       	sbiw	r26, 0x03	; 3
   1fe76:	9b 83       	std	Y+3, r25	; 0x03
   1fe78:	8a 83       	std	Y+2, r24	; 0x02
   1fe7a:	41 15       	cp	r20, r1
   1fe7c:	51 05       	cpc	r21, r1
   1fe7e:	71 f4       	brne	.+28     	; 0x1fe9c <free+0x7c>
   1fe80:	d0 93 c6 01 	sts	0x01C6, r29
   1fe84:	c0 93 c5 01 	sts	0x01C5, r28
   1fe88:	20 c0       	rjmp	.+64     	; 0x1feca <free+0xaa>
   1fe8a:	12 96       	adiw	r26, 0x02	; 2
   1fe8c:	8d 91       	ld	r24, X+
   1fe8e:	9c 91       	ld	r25, X
   1fe90:	13 97       	sbiw	r26, 0x03	; 3
   1fe92:	ad 01       	movw	r20, r26
   1fe94:	00 97       	sbiw	r24, 0x00	; 0
   1fe96:	11 f0       	breq	.+4      	; 0x1fe9c <free+0x7c>
   1fe98:	dc 01       	movw	r26, r24
   1fe9a:	d3 cf       	rjmp	.-90     	; 0x1fe42 <free+0x22>
   1fe9c:	fa 01       	movw	r30, r20
   1fe9e:	d3 83       	std	Z+3, r29	; 0x03
   1fea0:	c2 83       	std	Z+2, r28	; 0x02
   1fea2:	21 91       	ld	r18, Z+
   1fea4:	31 91       	ld	r19, Z+
   1fea6:	e2 0f       	add	r30, r18
   1fea8:	f3 1f       	adc	r31, r19
   1feaa:	ce 17       	cp	r28, r30
   1feac:	df 07       	cpc	r29, r31
   1feae:	69 f4       	brne	.+26     	; 0x1feca <free+0xaa>
   1feb0:	88 81       	ld	r24, Y
   1feb2:	99 81       	ldd	r25, Y+1	; 0x01
   1feb4:	28 0f       	add	r18, r24
   1feb6:	39 1f       	adc	r19, r25
   1feb8:	2e 5f       	subi	r18, 0xFE	; 254
   1feba:	3f 4f       	sbci	r19, 0xFF	; 255
   1febc:	fa 01       	movw	r30, r20
   1febe:	31 83       	std	Z+1, r19	; 0x01
   1fec0:	20 83       	st	Z, r18
   1fec2:	8a 81       	ldd	r24, Y+2	; 0x02
   1fec4:	9b 81       	ldd	r25, Y+3	; 0x03
   1fec6:	93 83       	std	Z+3, r25	; 0x03
   1fec8:	82 83       	std	Z+2, r24	; 0x02
   1feca:	df 91       	pop	r29
   1fecc:	cf 91       	pop	r28
   1fece:	08 95       	ret

0001fed0 <__eewr_block>:
   1fed0:	a0 e0       	ldi	r26, 0x00	; 0
   1fed2:	b0 e0       	ldi	r27, 0x00	; 0
   1fed4:	ee e6       	ldi	r30, 0x6E	; 110
   1fed6:	ff ef       	ldi	r31, 0xFF	; 255
   1fed8:	0c 94 8e ff 	jmp	0x1ff1c	; 0x1ff1c <__prologue_saves__+0x14>
   1fedc:	ec 01       	movw	r28, r24
   1fede:	7b 01       	movw	r14, r22
   1fee0:	8a 01       	movw	r16, r20
   1fee2:	69 01       	movw	r12, r18
   1fee4:	09 c0       	rjmp	.+18     	; 0x1fef8 <__eewr_block+0x28>
   1fee6:	ce 01       	movw	r24, r28
   1fee8:	21 96       	adiw	r28, 0x01	; 1
   1feea:	f7 01       	movw	r30, r14
   1feec:	61 91       	ld	r22, Z+
   1feee:	7f 01       	movw	r14, r30
   1fef0:	f6 01       	movw	r30, r12
   1fef2:	09 95       	icall
   1fef4:	01 50       	subi	r16, 0x01	; 1
   1fef6:	10 40       	sbci	r17, 0x00	; 0
   1fef8:	01 15       	cp	r16, r1
   1fefa:	11 05       	cpc	r17, r1
   1fefc:	a1 f7       	brne	.-24     	; 0x1fee6 <__eewr_block+0x16>
   1fefe:	cd b7       	in	r28, 0x3d	; 61
   1ff00:	de b7       	in	r29, 0x3e	; 62
   1ff02:	e8 e0       	ldi	r30, 0x08	; 8
   1ff04:	0c 94 aa ff 	jmp	0x1ff54	; 0x1ff54 <__epilogue_restores__+0x14>

0001ff08 <__prologue_saves__>:
   1ff08:	2f 92       	push	r2
   1ff0a:	3f 92       	push	r3
   1ff0c:	4f 92       	push	r4
   1ff0e:	5f 92       	push	r5
   1ff10:	6f 92       	push	r6
   1ff12:	7f 92       	push	r7
   1ff14:	8f 92       	push	r8
   1ff16:	9f 92       	push	r9
   1ff18:	af 92       	push	r10
   1ff1a:	bf 92       	push	r11
   1ff1c:	cf 92       	push	r12
   1ff1e:	df 92       	push	r13
   1ff20:	ef 92       	push	r14
   1ff22:	ff 92       	push	r15
   1ff24:	0f 93       	push	r16
   1ff26:	1f 93       	push	r17
   1ff28:	cf 93       	push	r28
   1ff2a:	df 93       	push	r29
   1ff2c:	cd b7       	in	r28, 0x3d	; 61
   1ff2e:	de b7       	in	r29, 0x3e	; 62
   1ff30:	ca 1b       	sub	r28, r26
   1ff32:	db 0b       	sbc	r29, r27
   1ff34:	0f b6       	in	r0, 0x3f	; 63
   1ff36:	f8 94       	cli
   1ff38:	de bf       	out	0x3e, r29	; 62
   1ff3a:	0f be       	out	0x3f, r0	; 63
   1ff3c:	cd bf       	out	0x3d, r28	; 61
   1ff3e:	09 94       	ijmp

0001ff40 <__epilogue_restores__>:
   1ff40:	2a 88       	ldd	r2, Y+18	; 0x12
   1ff42:	39 88       	ldd	r3, Y+17	; 0x11
   1ff44:	48 88       	ldd	r4, Y+16	; 0x10
   1ff46:	5f 84       	ldd	r5, Y+15	; 0x0f
   1ff48:	6e 84       	ldd	r6, Y+14	; 0x0e
   1ff4a:	7d 84       	ldd	r7, Y+13	; 0x0d
   1ff4c:	8c 84       	ldd	r8, Y+12	; 0x0c
   1ff4e:	9b 84       	ldd	r9, Y+11	; 0x0b
   1ff50:	aa 84       	ldd	r10, Y+10	; 0x0a
   1ff52:	b9 84       	ldd	r11, Y+9	; 0x09
   1ff54:	c8 84       	ldd	r12, Y+8	; 0x08
   1ff56:	df 80       	ldd	r13, Y+7	; 0x07
   1ff58:	ee 80       	ldd	r14, Y+6	; 0x06
   1ff5a:	fd 80       	ldd	r15, Y+5	; 0x05
   1ff5c:	0c 81       	ldd	r16, Y+4	; 0x04
   1ff5e:	1b 81       	ldd	r17, Y+3	; 0x03
   1ff60:	aa 81       	ldd	r26, Y+2	; 0x02
   1ff62:	b9 81       	ldd	r27, Y+1	; 0x01
   1ff64:	ce 0f       	add	r28, r30
   1ff66:	d1 1d       	adc	r29, r1
   1ff68:	0f b6       	in	r0, 0x3f	; 63
   1ff6a:	f8 94       	cli
   1ff6c:	de bf       	out	0x3e, r29	; 62
   1ff6e:	0f be       	out	0x3f, r0	; 63
   1ff70:	cd bf       	out	0x3d, r28	; 61
   1ff72:	ed 01       	movw	r28, r26
   1ff74:	08 95       	ret

0001ff76 <_exit>:
   1ff76:	f8 94       	cli

0001ff78 <__stop_program>:
   1ff78:	ff cf       	rjmp	.-2      	; 0x1ff78 <__stop_program>
