
aeb.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000734  00800100  00006124  000061b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006124  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b1  00800834  00800834  000068ec  2**0
                  ALLOC
  3 .debug_aranges 000002c0  00000000  00000000  000068ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000e09  00000000  00000000  00006bac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000064f3  00000000  00000000  000079b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001e1a  00000000  00000000  0000dea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005dc0  00000000  00000000  0000fcc2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000b30  00000000  00000000  00015a84  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000130a  00000000  00000000  000165b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000439b  00000000  00000000  000178be  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000008c0  00000000  00000000  0001bc59  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      30:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      40:	0c 94 3e 10 	jmp	0x207c	; 0x207c <__vector_16>
      44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      48:	0c 94 06 12 	jmp	0x240c	; 0x240c <__vector_18>
      4c:	0c 94 4c 12 	jmp	0x2498	; 0x2498 <__vector_19>
      50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      68:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      6c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      70:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      74:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      78:	0c 94 b9 2d 	jmp	0x5b72	; 0x5b72 <__vector_30>
      7c:	0c 94 3e 2d 	jmp	0x5a7c	; 0x5a7c <__vector_31>
      80:	0c 94 57 2d 	jmp	0x5aae	; 0x5aae <__vector_32>
      84:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      88:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	18 e0       	ldi	r17, 0x08	; 8
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e4 e2       	ldi	r30, 0x24	; 36
      a0:	f1 e6       	ldi	r31, 0x61	; 97
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a4 33       	cpi	r26, 0x34	; 52
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>
      b2:	1b be       	out	0x3b, r1	; 59

000000b4 <__do_clear_bss>:
      b4:	19 e0       	ldi	r17, 0x09	; 9
      b6:	a4 e3       	ldi	r26, 0x34	; 52
      b8:	b8 e0       	ldi	r27, 0x08	; 8
      ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
      bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
      be:	a5 3e       	cpi	r26, 0xE5	; 229
      c0:	b1 07       	cpc	r27, r17
      c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>
      c4:	0e 94 68 00 	call	0xd0	; 0xd0 <main>
      c8:	0c 94 90 30 	jmp	0x6120	; 0x6120 <_exit>

000000cc <__bad_interrupt>:
      cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <main>:
// Main-Funktion
/////////////////////////////////////////////////////////////////////////////
int main()
{
	
  cli();
      d0:	f8 94       	cli

  debug=0;
      d2:	10 92 38 08 	sts	0x0838, r1
      d6:	10 92 37 08 	sts	0x0837, r1
    // Move interrupts to boot flash section
    MCUCR = (1<<IVSEL);
    //+***************** BOOTLOADER ONLY ***********************
  #else
    // Enable change of interrupt vectors 
    MCUCR = (1<<IVCE);
      da:	81 e0       	ldi	r24, 0x01	; 1
      dc:	85 bf       	out	0x35, r24	; 53
    // Restore interrupts vectors 
    MCUCR = (0<<IVSEL);
      de:	15 be       	out	0x35, r1	; 53
  #endif
  


  // Load configuration from EEPROM if valid, else load fallback config
  onInitConfig();
      e0:	0e 94 b2 2c 	call	0x5964	; 0x5964 <onInitConfig>


  // At first, we initialize the real time clock ...
   onInitClock();
      e4:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <onInitClock>
  // ... then the timer, it depends on the clock module ...
 onInitTimer();
      e8:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <onInitTimer>



  // ... Ethernet depends itself on the timer module ...
  onInitEthernet();
      ec:	0e 94 56 07 	call	0xeac	; 0xeac <onInitEthernet>
  #ifdef REQUIRES_SERIAL
    // ... the same applies to the serial module
    onInitSerial();
      f0:	0e 94 c8 0c 	call	0x1990	; 0x1990 <onInitSerial>

com1Initialize(0,0);
      f4:	80 e0       	ldi	r24, 0x00	; 0
      f6:	90 e0       	ldi	r25, 0x00	; 0
      f8:	60 e0       	ldi	r22, 0x00	; 0
      fa:	0e 94 10 2d 	call	0x5a20	; 0x5a20 <com1Initialize>
    onInitWatchdog();  
  #endif
  // ... initialization finished, it is save to enable interrupts...
  
  
  onInitApplication();
      fe:	0e 94 ac 1a 	call	0x3558	; 0x3558 <onInitApplication>




sei();
     102:	78 94       	sei

	while (1)  	// Mainloop-Begin
	{

	 // Check for timer events
    onTimer();
     104:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <onTimer>
   
    // COM Event Handler...
   // #ifdef REQUIRES_SERIAL alx
      onSerial();
     108:	0e 94 95 0c 	call	0x192a	; 0x192a <onSerial>
  //  #endif
           
    onEthernet();
     10c:	0e 94 f6 07 	call	0xfec	; 0xfec <onEthernet>

	if(debug>=1)
     110:	80 91 37 08 	lds	r24, 0x0837
     114:	90 91 38 08 	lds	r25, 0x0838
     118:	89 2b       	or	r24, r25
     11a:	a1 f3       	breq	.-24     	; 0x104 <main+0x34>
	 putString_com1("running");
     11c:	80 e0       	ldi	r24, 0x00	; 0
     11e:	91 e0       	ldi	r25, 0x01	; 1
     120:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
     124:	ef cf       	rjmp	.-34     	; 0x104 <main+0x34>

00000126 <arpAddMacByIPv4>:
     126:	0f 93       	push	r16
     128:	1f 93       	push	r17
     12a:	cf 93       	push	r28
     12c:	df 93       	push	r29
     12e:	fc 01       	movw	r30, r24
     130:	16 2f       	mov	r17, r22
     132:	07 2f       	mov	r16, r23
     134:	20 81       	ld	r18, Z
     136:	31 81       	ldd	r19, Z+1	; 0x01
     138:	42 81       	ldd	r20, Z+2	; 0x02
     13a:	53 81       	ldd	r21, Z+3	; 0x03
     13c:	80 91 6d 08 	lds	r24, 0x086D
     140:	90 91 6e 08 	lds	r25, 0x086E
     144:	a0 91 6f 08 	lds	r26, 0x086F
     148:	b0 91 70 08 	lds	r27, 0x0870
     14c:	82 17       	cp	r24, r18
     14e:	93 07       	cpc	r25, r19
     150:	a4 07       	cpc	r26, r20
     152:	b5 07       	cpc	r27, r21
     154:	09 f4       	brne	.+2      	; 0x158 <arpAddMacByIPv4+0x32>
     156:	72 c0       	rjmp	.+228    	; 0x23c <arpAddMacByIPv4+0x116>
     158:	80 91 62 08 	lds	r24, 0x0862
     15c:	90 91 63 08 	lds	r25, 0x0863
     160:	a0 91 64 08 	lds	r26, 0x0864
     164:	b0 91 65 08 	lds	r27, 0x0865
     168:	82 17       	cp	r24, r18
     16a:	93 07       	cpc	r25, r19
     16c:	a4 07       	cpc	r26, r20
     16e:	b5 07       	cpc	r27, r21
     170:	09 f4       	brne	.+2      	; 0x174 <arpAddMacByIPv4+0x4e>
     172:	92 c0       	rjmp	.+292    	; 0x298 <arpAddMacByIPv4+0x172>
     174:	90 91 71 08 	lds	r25, 0x0871
     178:	80 91 66 08 	lds	r24, 0x0866
     17c:	98 17       	cp	r25, r24
     17e:	08 f0       	brcs	.+2      	; 0x182 <arpAddMacByIPv4+0x5c>
     180:	54 c0       	rjmp	.+168    	; 0x22a <arpAddMacByIPv4+0x104>
     182:	ec e5       	ldi	r30, 0x5C	; 92
     184:	f8 e0       	ldi	r31, 0x08	; 8
     186:	80 91 57 08 	lds	r24, 0x0857
     18a:	90 91 58 08 	lds	r25, 0x0858
     18e:	a0 91 59 08 	lds	r26, 0x0859
     192:	b0 91 5a 08 	lds	r27, 0x085A
     196:	82 17       	cp	r24, r18
     198:	93 07       	cpc	r25, r19
     19a:	a4 07       	cpc	r26, r20
     19c:	b5 07       	cpc	r27, r21
     19e:	09 f4       	brne	.+2      	; 0x1a2 <arpAddMacByIPv4+0x7c>
     1a0:	72 c0       	rjmp	.+228    	; 0x286 <arpAddMacByIPv4+0x160>
     1a2:	92 85       	ldd	r25, Z+10	; 0x0a
     1a4:	80 91 5b 08 	lds	r24, 0x085B
     1a8:	98 17       	cp	r25, r24
     1aa:	e0 f1       	brcs	.+120    	; 0x224 <arpAddMacByIPv4+0xfe>
     1ac:	80 91 4c 08 	lds	r24, 0x084C
     1b0:	90 91 4d 08 	lds	r25, 0x084D
     1b4:	a0 91 4e 08 	lds	r26, 0x084E
     1b8:	b0 91 4f 08 	lds	r27, 0x084F
     1bc:	82 17       	cp	r24, r18
     1be:	93 07       	cpc	r25, r19
     1c0:	a4 07       	cpc	r26, r20
     1c2:	b5 07       	cpc	r27, r21
     1c4:	09 f4       	brne	.+2      	; 0x1c8 <arpAddMacByIPv4+0xa2>
     1c6:	62 c0       	rjmp	.+196    	; 0x28c <arpAddMacByIPv4+0x166>
     1c8:	92 85       	ldd	r25, Z+10	; 0x0a
     1ca:	80 91 50 08 	lds	r24, 0x0850
     1ce:	98 17       	cp	r25, r24
     1d0:	78 f1       	brcs	.+94     	; 0x230 <arpAddMacByIPv4+0x10a>
     1d2:	80 91 41 08 	lds	r24, 0x0841
     1d6:	90 91 42 08 	lds	r25, 0x0842
     1da:	a0 91 43 08 	lds	r26, 0x0843
     1de:	b0 91 44 08 	lds	r27, 0x0844
     1e2:	82 17       	cp	r24, r18
     1e4:	93 07       	cpc	r25, r19
     1e6:	a4 07       	cpc	r26, r20
     1e8:	b5 07       	cpc	r27, r21
     1ea:	09 f4       	brne	.+2      	; 0x1ee <arpAddMacByIPv4+0xc8>
     1ec:	52 c0       	rjmp	.+164    	; 0x292 <arpAddMacByIPv4+0x16c>
     1ee:	92 85       	ldd	r25, Z+10	; 0x0a
     1f0:	80 91 45 08 	lds	r24, 0x0845
     1f4:	98 17       	cp	r25, r24
     1f6:	f8 f0       	brcs	.+62     	; 0x236 <arpAddMacByIPv4+0x110>
     1f8:	26 83       	std	Z+6, r18	; 0x06
     1fa:	37 83       	std	Z+7, r19	; 0x07
     1fc:	40 87       	std	Z+8, r20	; 0x08
     1fe:	51 87       	std	Z+9, r21	; 0x09
     200:	ef 01       	movw	r28, r30
     202:	81 2f       	mov	r24, r17
     204:	90 2f       	mov	r25, r16
     206:	9c 01       	movw	r18, r24
     208:	d9 01       	movw	r26, r18
     20a:	86 e0       	ldi	r24, 0x06	; 6
     20c:	0d 90       	ld	r0, X+
     20e:	09 92       	st	Y+, r0
     210:	81 50       	subi	r24, 0x01	; 1
     212:	e1 f7       	brne	.-8      	; 0x20c <arpAddMacByIPv4+0xe6>
     214:	8f ef       	ldi	r24, 0xFF	; 255
     216:	82 87       	std	Z+10, r24	; 0x0a
     218:	80 e0       	ldi	r24, 0x00	; 0
     21a:	df 91       	pop	r29
     21c:	cf 91       	pop	r28
     21e:	1f 91       	pop	r17
     220:	0f 91       	pop	r16
     222:	08 95       	ret
     224:	e1 e5       	ldi	r30, 0x51	; 81
     226:	f8 e0       	ldi	r31, 0x08	; 8
     228:	c1 cf       	rjmp	.-126    	; 0x1ac <arpAddMacByIPv4+0x86>
     22a:	e7 e6       	ldi	r30, 0x67	; 103
     22c:	f8 e0       	ldi	r31, 0x08	; 8
     22e:	ab cf       	rjmp	.-170    	; 0x186 <arpAddMacByIPv4+0x60>
     230:	e6 e4       	ldi	r30, 0x46	; 70
     232:	f8 e0       	ldi	r31, 0x08	; 8
     234:	ce cf       	rjmp	.-100    	; 0x1d2 <arpAddMacByIPv4+0xac>
     236:	eb e3       	ldi	r30, 0x3B	; 59
     238:	f8 e0       	ldi	r31, 0x08	; 8
     23a:	de cf       	rjmp	.-68     	; 0x1f8 <arpAddMacByIPv4+0xd2>
     23c:	44 e0       	ldi	r20, 0x04	; 4
     23e:	50 e0       	ldi	r21, 0x00	; 0
     240:	ba 01       	movw	r22, r20
     242:	66 0f       	add	r22, r22
     244:	77 1f       	adc	r23, r23
     246:	ea 01       	movw	r28, r20
     248:	cc 0f       	add	r28, r28
     24a:	dd 1f       	adc	r29, r29
     24c:	cc 0f       	add	r28, r28
     24e:	dd 1f       	adc	r29, r29
     250:	cc 0f       	add	r28, r28
     252:	dd 1f       	adc	r29, r29
     254:	fb 01       	movw	r30, r22
     256:	ec 0f       	add	r30, r28
     258:	fd 1f       	adc	r31, r29
     25a:	e4 0f       	add	r30, r20
     25c:	f5 1f       	adc	r31, r21
     25e:	e5 5c       	subi	r30, 0xC5	; 197
     260:	f7 4f       	sbci	r31, 0xF7	; 247
     262:	81 2f       	mov	r24, r17
     264:	90 2f       	mov	r25, r16
     266:	9c 01       	movw	r18, r24
     268:	d9 01       	movw	r26, r18
     26a:	86 e0       	ldi	r24, 0x06	; 6
     26c:	0d 90       	ld	r0, X+
     26e:	01 92       	st	Z+, r0
     270:	81 50       	subi	r24, 0x01	; 1
     272:	e1 f7       	brne	.-8      	; 0x26c <arpAddMacByIPv4+0x146>
     274:	c6 0f       	add	r28, r22
     276:	d7 1f       	adc	r29, r23
     278:	c4 0f       	add	r28, r20
     27a:	d5 1f       	adc	r29, r21
     27c:	c5 5c       	subi	r28, 0xC5	; 197
     27e:	d7 4f       	sbci	r29, 0xF7	; 247
     280:	8f ef       	ldi	r24, 0xFF	; 255
     282:	8a 87       	std	Y+10, r24	; 0x0a
     284:	c9 cf       	rjmp	.-110    	; 0x218 <arpAddMacByIPv4+0xf2>
     286:	42 e0       	ldi	r20, 0x02	; 2
     288:	50 e0       	ldi	r21, 0x00	; 0
     28a:	da cf       	rjmp	.-76     	; 0x240 <arpAddMacByIPv4+0x11a>
     28c:	41 e0       	ldi	r20, 0x01	; 1
     28e:	50 e0       	ldi	r21, 0x00	; 0
     290:	d7 cf       	rjmp	.-82     	; 0x240 <arpAddMacByIPv4+0x11a>
     292:	40 e0       	ldi	r20, 0x00	; 0
     294:	50 e0       	ldi	r21, 0x00	; 0
     296:	d4 cf       	rjmp	.-88     	; 0x240 <arpAddMacByIPv4+0x11a>
     298:	43 e0       	ldi	r20, 0x03	; 3
     29a:	50 e0       	ldi	r21, 0x00	; 0
     29c:	d1 cf       	rjmp	.-94     	; 0x240 <arpAddMacByIPv4+0x11a>

0000029e <onInitArp>:
     29e:	10 92 71 08 	sts	0x0871, r1
     2a2:	10 92 66 08 	sts	0x0866, r1
     2a6:	10 92 5b 08 	sts	0x085B, r1
     2aa:	10 92 50 08 	sts	0x0850, r1
     2ae:	10 92 45 08 	sts	0x0845, r1
     2b2:	80 e7       	ldi	r24, 0x70	; 112
     2b4:	97 e1       	ldi	r25, 0x17	; 23
     2b6:	60 e6       	ldi	r22, 0x60	; 96
     2b8:	71 e0       	ldi	r23, 0x01	; 1
     2ba:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <timerAddTimeout>
     2be:	08 95       	ret

000002c0 <onArpTimeout>:
     2c0:	80 91 71 08 	lds	r24, 0x0871
     2c4:	88 23       	and	r24, r24
     2c6:	19 f0       	breq	.+6      	; 0x2ce <onArpTimeout+0xe>
     2c8:	81 50       	subi	r24, 0x01	; 1
     2ca:	80 93 71 08 	sts	0x0871, r24
     2ce:	80 91 66 08 	lds	r24, 0x0866
     2d2:	88 23       	and	r24, r24
     2d4:	19 f0       	breq	.+6      	; 0x2dc <onArpTimeout+0x1c>
     2d6:	81 50       	subi	r24, 0x01	; 1
     2d8:	80 93 66 08 	sts	0x0866, r24
     2dc:	80 91 5b 08 	lds	r24, 0x085B
     2e0:	88 23       	and	r24, r24
     2e2:	19 f0       	breq	.+6      	; 0x2ea <onArpTimeout+0x2a>
     2e4:	81 50       	subi	r24, 0x01	; 1
     2e6:	80 93 5b 08 	sts	0x085B, r24
     2ea:	80 91 50 08 	lds	r24, 0x0850
     2ee:	88 23       	and	r24, r24
     2f0:	19 f0       	breq	.+6      	; 0x2f8 <onArpTimeout+0x38>
     2f2:	81 50       	subi	r24, 0x01	; 1
     2f4:	80 93 50 08 	sts	0x0850, r24
     2f8:	80 91 45 08 	lds	r24, 0x0845
     2fc:	88 23       	and	r24, r24
     2fe:	19 f0       	breq	.+6      	; 0x306 <onArpTimeout+0x46>
     300:	81 50       	subi	r24, 0x01	; 1
     302:	80 93 45 08 	sts	0x0845, r24
     306:	80 e7       	ldi	r24, 0x70	; 112
     308:	97 e1       	ldi	r25, 0x17	; 23
     30a:	60 e6       	ldi	r22, 0x60	; 96
     30c:	71 e0       	ldi	r23, 0x01	; 1
     30e:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <timerAddTimeout>
     312:	08 95       	ret

00000314 <onArpRequest>:
     314:	af 92       	push	r10
     316:	bf 92       	push	r11
     318:	cf 92       	push	r12
     31a:	df 92       	push	r13
     31c:	ef 92       	push	r14
     31e:	ff 92       	push	r15
     320:	0f 93       	push	r16
     322:	1f 93       	push	r17
     324:	df 93       	push	r29
     326:	cf 93       	push	r28
     328:	00 d0       	rcall	.+0      	; 0x32a <onArpRequest+0x16>
     32a:	00 d0       	rcall	.+0      	; 0x32c <onArpRequest+0x18>
     32c:	00 d0       	rcall	.+0      	; 0x32e <onArpRequest+0x1a>
     32e:	cd b7       	in	r28, 0x3d	; 61
     330:	de b7       	in	r29, 0x3e	; 62
     332:	5c 01       	movw	r10, r24
     334:	8b 01       	movw	r16, r22
     336:	6a 01       	movw	r12, r20
     338:	6c e1       	ldi	r22, 0x1C	; 28
     33a:	70 e0       	ldi	r23, 0x00	; 0
     33c:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     340:	7c 01       	movw	r14, r24
     342:	80 e0       	ldi	r24, 0x00	; 0
     344:	91 e0       	ldi	r25, 0x01	; 1
     346:	f7 01       	movw	r30, r14
     348:	91 83       	std	Z+1, r25	; 0x01
     34a:	80 83       	st	Z, r24
     34c:	88 e0       	ldi	r24, 0x08	; 8
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	93 83       	std	Z+3, r25	; 0x03
     352:	82 83       	std	Z+2, r24	; 0x02
     354:	86 e0       	ldi	r24, 0x06	; 6
     356:	84 83       	std	Z+4, r24	; 0x04
     358:	84 e0       	ldi	r24, 0x04	; 4
     35a:	85 83       	std	Z+5, r24	; 0x05
     35c:	f8 01       	movw	r30, r16
     35e:	80 81       	ld	r24, Z
     360:	91 81       	ldd	r25, Z+1	; 0x01
     362:	a2 81       	ldd	r26, Z+2	; 0x02
     364:	b3 81       	ldd	r27, Z+3	; 0x03
     366:	f7 01       	movw	r30, r14
     368:	80 8f       	std	Z+24, r24	; 0x18
     36a:	91 8f       	std	Z+25, r25	; 0x19
     36c:	a2 8f       	std	Z+26, r26	; 0x1a
     36e:	b3 8f       	std	Z+27, r27	; 0x1b
     370:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     374:	d7 01       	movw	r26, r14
     376:	18 96       	adiw	r26, 0x08	; 8
     378:	fc 01       	movw	r30, r24
     37a:	86 e0       	ldi	r24, 0x06	; 6
     37c:	01 90       	ld	r0, Z+
     37e:	0d 92       	st	X+, r0
     380:	81 50       	subi	r24, 0x01	; 1
     382:	e1 f7       	brne	.-8      	; 0x37c <onArpRequest+0x68>
     384:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     388:	fc 01       	movw	r30, r24
     38a:	80 81       	ld	r24, Z
     38c:	91 81       	ldd	r25, Z+1	; 0x01
     38e:	a2 81       	ldd	r26, Z+2	; 0x02
     390:	b3 81       	ldd	r27, Z+3	; 0x03
     392:	f7 01       	movw	r30, r14
     394:	86 87       	std	Z+14, r24	; 0x0e
     396:	97 87       	std	Z+15, r25	; 0x0f
     398:	a0 8b       	std	Z+16, r26	; 0x10
     39a:	b1 8b       	std	Z+17, r27	; 0x11
     39c:	c1 14       	cp	r12, r1
     39e:	d1 04       	cpc	r13, r1
     3a0:	21 f1       	breq	.+72     	; 0x3ea <onArpRequest+0xd6>
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	92 e0       	ldi	r25, 0x02	; 2
     3a6:	f7 01       	movw	r30, r14
     3a8:	97 83       	std	Z+7, r25	; 0x07
     3aa:	86 83       	std	Z+6, r24	; 0x06
     3ac:	d7 01       	movw	r26, r14
     3ae:	52 96       	adiw	r26, 0x12	; 18
     3b0:	f6 01       	movw	r30, r12
     3b2:	86 e0       	ldi	r24, 0x06	; 6
     3b4:	01 90       	ld	r0, Z+
     3b6:	0d 92       	st	X+, r0
     3b8:	81 50       	subi	r24, 0x01	; 1
     3ba:	e1 f7       	brne	.-8      	; 0x3b4 <onArpRequest+0xa0>
     3bc:	c5 01       	movw	r24, r10
     3be:	68 e0       	ldi	r22, 0x08	; 8
     3c0:	76 e0       	ldi	r23, 0x06	; 6
     3c2:	a6 01       	movw	r20, r12
     3c4:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     3c8:	26 96       	adiw	r28, 0x06	; 6
     3ca:	0f b6       	in	r0, 0x3f	; 63
     3cc:	f8 94       	cli
     3ce:	de bf       	out	0x3e, r29	; 62
     3d0:	0f be       	out	0x3f, r0	; 63
     3d2:	cd bf       	out	0x3d, r28	; 61
     3d4:	cf 91       	pop	r28
     3d6:	df 91       	pop	r29
     3d8:	1f 91       	pop	r17
     3da:	0f 91       	pop	r16
     3dc:	ff 90       	pop	r15
     3de:	ef 90       	pop	r14
     3e0:	df 90       	pop	r13
     3e2:	cf 90       	pop	r12
     3e4:	bf 90       	pop	r11
     3e6:	af 90       	pop	r10
     3e8:	08 95       	ret
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	91 e0       	ldi	r25, 0x01	; 1
     3ee:	97 83       	std	Z+7, r25	; 0x07
     3f0:	86 83       	std	Z+6, r24	; 0x06
     3f2:	12 8a       	std	Z+18, r1	; 0x12
     3f4:	13 8a       	std	Z+19, r1	; 0x13
     3f6:	14 8a       	std	Z+20, r1	; 0x14
     3f8:	15 8a       	std	Z+21, r1	; 0x15
     3fa:	16 8a       	std	Z+22, r1	; 0x16
     3fc:	17 8a       	std	Z+23, r1	; 0x17
     3fe:	ae 01       	movw	r20, r28
     400:	4f 5f       	subi	r20, 0xFF	; 255
     402:	5f 4f       	sbci	r21, 0xFF	; 255
     404:	da 01       	movw	r26, r20
     406:	e8 e0       	ldi	r30, 0x08	; 8
     408:	f1 e0       	ldi	r31, 0x01	; 1
     40a:	86 e0       	ldi	r24, 0x06	; 6
     40c:	01 90       	ld	r0, Z+
     40e:	0d 92       	st	X+, r0
     410:	81 50       	subi	r24, 0x01	; 1
     412:	e1 f7       	brne	.-8      	; 0x40c <onArpRequest+0xf8>
     414:	c5 01       	movw	r24, r10
     416:	68 e0       	ldi	r22, 0x08	; 8
     418:	76 e0       	ldi	r23, 0x06	; 6
     41a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     41e:	d4 cf       	rjmp	.-88     	; 0x3c8 <onArpRequest+0xb4>

00000420 <arpSendResponse>:
     420:	af 92       	push	r10
     422:	bf 92       	push	r11
     424:	cf 92       	push	r12
     426:	df 92       	push	r13
     428:	ef 92       	push	r14
     42a:	ff 92       	push	r15
     42c:	0f 93       	push	r16
     42e:	1f 93       	push	r17
     430:	df 93       	push	r29
     432:	cf 93       	push	r28
     434:	00 d0       	rcall	.+0      	; 0x436 <arpSendResponse+0x16>
     436:	00 d0       	rcall	.+0      	; 0x438 <arpSendResponse+0x18>
     438:	00 d0       	rcall	.+0      	; 0x43a <arpSendResponse+0x1a>
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
     43e:	8c 01       	movw	r16, r24
     440:	6b 01       	movw	r12, r22
     442:	0e 94 66 19 	call	0x32cc	; 0x32cc <nicNewRequest>
     446:	5c 01       	movw	r10, r24
     448:	6c e1       	ldi	r22, 0x1C	; 28
     44a:	70 e0       	ldi	r23, 0x00	; 0
     44c:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     450:	7c 01       	movw	r14, r24
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	91 e0       	ldi	r25, 0x01	; 1
     456:	f7 01       	movw	r30, r14
     458:	91 83       	std	Z+1, r25	; 0x01
     45a:	80 83       	st	Z, r24
     45c:	88 e0       	ldi	r24, 0x08	; 8
     45e:	90 e0       	ldi	r25, 0x00	; 0
     460:	93 83       	std	Z+3, r25	; 0x03
     462:	82 83       	std	Z+2, r24	; 0x02
     464:	86 e0       	ldi	r24, 0x06	; 6
     466:	84 83       	std	Z+4, r24	; 0x04
     468:	84 e0       	ldi	r24, 0x04	; 4
     46a:	85 83       	std	Z+5, r24	; 0x05
     46c:	f8 01       	movw	r30, r16
     46e:	80 81       	ld	r24, Z
     470:	91 81       	ldd	r25, Z+1	; 0x01
     472:	a2 81       	ldd	r26, Z+2	; 0x02
     474:	b3 81       	ldd	r27, Z+3	; 0x03
     476:	f7 01       	movw	r30, r14
     478:	80 8f       	std	Z+24, r24	; 0x18
     47a:	91 8f       	std	Z+25, r25	; 0x19
     47c:	a2 8f       	std	Z+26, r26	; 0x1a
     47e:	b3 8f       	std	Z+27, r27	; 0x1b
     480:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     484:	d7 01       	movw	r26, r14
     486:	18 96       	adiw	r26, 0x08	; 8
     488:	fc 01       	movw	r30, r24
     48a:	86 e0       	ldi	r24, 0x06	; 6
     48c:	01 90       	ld	r0, Z+
     48e:	0d 92       	st	X+, r0
     490:	81 50       	subi	r24, 0x01	; 1
     492:	e1 f7       	brne	.-8      	; 0x48c <arpSendResponse+0x6c>
     494:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     498:	fc 01       	movw	r30, r24
     49a:	80 81       	ld	r24, Z
     49c:	91 81       	ldd	r25, Z+1	; 0x01
     49e:	a2 81       	ldd	r26, Z+2	; 0x02
     4a0:	b3 81       	ldd	r27, Z+3	; 0x03
     4a2:	f7 01       	movw	r30, r14
     4a4:	86 87       	std	Z+14, r24	; 0x0e
     4a6:	97 87       	std	Z+15, r25	; 0x0f
     4a8:	a0 8b       	std	Z+16, r26	; 0x10
     4aa:	b1 8b       	std	Z+17, r27	; 0x11
     4ac:	c1 14       	cp	r12, r1
     4ae:	d1 04       	cpc	r13, r1
     4b0:	21 f1       	breq	.+72     	; 0x4fa <arpSendResponse+0xda>
     4b2:	80 e0       	ldi	r24, 0x00	; 0
     4b4:	92 e0       	ldi	r25, 0x02	; 2
     4b6:	f7 01       	movw	r30, r14
     4b8:	97 83       	std	Z+7, r25	; 0x07
     4ba:	86 83       	std	Z+6, r24	; 0x06
     4bc:	d7 01       	movw	r26, r14
     4be:	52 96       	adiw	r26, 0x12	; 18
     4c0:	f6 01       	movw	r30, r12
     4c2:	86 e0       	ldi	r24, 0x06	; 6
     4c4:	01 90       	ld	r0, Z+
     4c6:	0d 92       	st	X+, r0
     4c8:	81 50       	subi	r24, 0x01	; 1
     4ca:	e1 f7       	brne	.-8      	; 0x4c4 <arpSendResponse+0xa4>
     4cc:	c5 01       	movw	r24, r10
     4ce:	68 e0       	ldi	r22, 0x08	; 8
     4d0:	76 e0       	ldi	r23, 0x06	; 6
     4d2:	a6 01       	movw	r20, r12
     4d4:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     4d8:	26 96       	adiw	r28, 0x06	; 6
     4da:	0f b6       	in	r0, 0x3f	; 63
     4dc:	f8 94       	cli
     4de:	de bf       	out	0x3e, r29	; 62
     4e0:	0f be       	out	0x3f, r0	; 63
     4e2:	cd bf       	out	0x3d, r28	; 61
     4e4:	cf 91       	pop	r28
     4e6:	df 91       	pop	r29
     4e8:	1f 91       	pop	r17
     4ea:	0f 91       	pop	r16
     4ec:	ff 90       	pop	r15
     4ee:	ef 90       	pop	r14
     4f0:	df 90       	pop	r13
     4f2:	cf 90       	pop	r12
     4f4:	bf 90       	pop	r11
     4f6:	af 90       	pop	r10
     4f8:	08 95       	ret
     4fa:	80 e0       	ldi	r24, 0x00	; 0
     4fc:	91 e0       	ldi	r25, 0x01	; 1
     4fe:	97 83       	std	Z+7, r25	; 0x07
     500:	86 83       	std	Z+6, r24	; 0x06
     502:	12 8a       	std	Z+18, r1	; 0x12
     504:	13 8a       	std	Z+19, r1	; 0x13
     506:	14 8a       	std	Z+20, r1	; 0x14
     508:	15 8a       	std	Z+21, r1	; 0x15
     50a:	16 8a       	std	Z+22, r1	; 0x16
     50c:	17 8a       	std	Z+23, r1	; 0x17
     50e:	ae 01       	movw	r20, r28
     510:	4f 5f       	subi	r20, 0xFF	; 255
     512:	5f 4f       	sbci	r21, 0xFF	; 255
     514:	da 01       	movw	r26, r20
     516:	e8 e0       	ldi	r30, 0x08	; 8
     518:	f1 e0       	ldi	r31, 0x01	; 1
     51a:	86 e0       	ldi	r24, 0x06	; 6
     51c:	01 90       	ld	r0, Z+
     51e:	0d 92       	st	X+, r0
     520:	81 50       	subi	r24, 0x01	; 1
     522:	e1 f7       	brne	.-8      	; 0x51c <arpSendResponse+0xfc>
     524:	c5 01       	movw	r24, r10
     526:	68 e0       	ldi	r22, 0x08	; 8
     528:	76 e0       	ldi	r23, 0x06	; 6
     52a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     52e:	d4 cf       	rjmp	.-88     	; 0x4d8 <arpSendResponse+0xb8>

00000530 <onArpResponse>:
     530:	ef 92       	push	r14
     532:	ff 92       	push	r15
     534:	0f 93       	push	r16
     536:	1f 93       	push	r17
     538:	df 93       	push	r29
     53a:	cf 93       	push	r28
     53c:	cd b7       	in	r28, 0x3d	; 61
     53e:	de b7       	in	r29, 0x3e	; 62
     540:	6c 97       	sbiw	r28, 0x1c	; 28
     542:	0f b6       	in	r0, 0x3f	; 63
     544:	f8 94       	cli
     546:	de bf       	out	0x3e, r29	; 62
     548:	0f be       	out	0x3f, r0	; 63
     54a:	cd bf       	out	0x3d, r28	; 61
     54c:	8c 01       	movw	r16, r24
     54e:	0e 94 b7 18 	call	0x316e	; 0x316e <nicResponseSize>
     552:	4c 97       	sbiw	r24, 0x1c	; 28
     554:	68 f4       	brcc	.+26     	; 0x570 <onArpResponse+0x40>
     556:	6c 96       	adiw	r28, 0x1c	; 28
     558:	0f b6       	in	r0, 0x3f	; 63
     55a:	f8 94       	cli
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	0f be       	out	0x3f, r0	; 63
     560:	cd bf       	out	0x3d, r28	; 61
     562:	cf 91       	pop	r28
     564:	df 91       	pop	r29
     566:	1f 91       	pop	r17
     568:	0f 91       	pop	r16
     56a:	ff 90       	pop	r15
     56c:	ef 90       	pop	r14
     56e:	08 95       	ret
     570:	c8 01       	movw	r24, r16
     572:	be 01       	movw	r22, r28
     574:	6f 5f       	subi	r22, 0xFF	; 255
     576:	7f 4f       	sbci	r23, 0xFF	; 255
     578:	4c e1       	ldi	r20, 0x1C	; 28
     57a:	50 e0       	ldi	r21, 0x00	; 0
     57c:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
     580:	89 81       	ldd	r24, Y+1	; 0x01
     582:	9a 81       	ldd	r25, Y+2	; 0x02
     584:	80 50       	subi	r24, 0x00	; 0
     586:	91 40       	sbci	r25, 0x01	; 1
     588:	31 f7       	brne	.-52     	; 0x556 <onArpResponse+0x26>
     58a:	8b 81       	ldd	r24, Y+3	; 0x03
     58c:	9c 81       	ldd	r25, Y+4	; 0x04
     58e:	08 97       	sbiw	r24, 0x08	; 8
     590:	11 f7       	brne	.-60     	; 0x556 <onArpResponse+0x26>
     592:	8d 81       	ldd	r24, Y+5	; 0x05
     594:	86 30       	cpi	r24, 0x06	; 6
     596:	f9 f6       	brne	.-66     	; 0x556 <onArpResponse+0x26>
     598:	8e 81       	ldd	r24, Y+6	; 0x06
     59a:	84 30       	cpi	r24, 0x04	; 4
     59c:	e1 f6       	brne	.-72     	; 0x556 <onArpResponse+0x26>
     59e:	e9 8c       	ldd	r14, Y+25	; 0x19
     5a0:	fa 8c       	ldd	r15, Y+26	; 0x1a
     5a2:	0b 8d       	ldd	r16, Y+27	; 0x1b
     5a4:	1c 8d       	ldd	r17, Y+28	; 0x1c
     5a6:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     5aa:	fc 01       	movw	r30, r24
     5ac:	80 81       	ld	r24, Z
     5ae:	91 81       	ldd	r25, Z+1	; 0x01
     5b0:	a2 81       	ldd	r26, Z+2	; 0x02
     5b2:	b3 81       	ldd	r27, Z+3	; 0x03
     5b4:	e8 16       	cp	r14, r24
     5b6:	f9 06       	cpc	r15, r25
     5b8:	0a 07       	cpc	r16, r26
     5ba:	1b 07       	cpc	r17, r27
     5bc:	61 f6       	brne	.-104    	; 0x556 <onArpResponse+0x26>
     5be:	8f 81       	ldd	r24, Y+7	; 0x07
     5c0:	98 85       	ldd	r25, Y+8	; 0x08
     5c2:	21 e0       	ldi	r18, 0x01	; 1
     5c4:	80 30       	cpi	r24, 0x00	; 0
     5c6:	92 07       	cpc	r25, r18
     5c8:	89 f0       	breq	.+34     	; 0x5ec <onArpResponse+0xbc>
     5ca:	80 50       	subi	r24, 0x00	; 0
     5cc:	92 40       	sbci	r25, 0x02	; 2
     5ce:	09 f0       	breq	.+2      	; 0x5d2 <onArpResponse+0xa2>
     5d0:	c2 cf       	rjmp	.-124    	; 0x556 <onArpResponse+0x26>
     5d2:	3f e0       	ldi	r19, 0x0F	; 15
     5d4:	e3 2e       	mov	r14, r19
     5d6:	f1 2c       	mov	r15, r1
     5d8:	ec 0e       	add	r14, r28
     5da:	fd 1e       	adc	r15, r29
     5dc:	8e 01       	movw	r16, r28
     5de:	07 5f       	subi	r16, 0xF7	; 247
     5e0:	1f 4f       	sbci	r17, 0xFF	; 255
     5e2:	c7 01       	movw	r24, r14
     5e4:	b8 01       	movw	r22, r16
     5e6:	0e 94 93 00 	call	0x126	; 0x126 <arpAddMacByIPv4>
     5ea:	b5 cf       	rjmp	.-150    	; 0x556 <onArpResponse+0x26>
     5ec:	2f e0       	ldi	r18, 0x0F	; 15
     5ee:	e2 2e       	mov	r14, r18
     5f0:	f1 2c       	mov	r15, r1
     5f2:	ec 0e       	add	r14, r28
     5f4:	fd 1e       	adc	r15, r29
     5f6:	8e 01       	movw	r16, r28
     5f8:	07 5f       	subi	r16, 0xF7	; 247
     5fa:	1f 4f       	sbci	r17, 0xFF	; 255
     5fc:	c7 01       	movw	r24, r14
     5fe:	b8 01       	movw	r22, r16
     600:	0e 94 10 02 	call	0x420	; 0x420 <arpSendResponse>
     604:	ee cf       	rjmp	.-36     	; 0x5e2 <onArpResponse+0xb2>

00000606 <arpSendRequest>:
     606:	cf 92       	push	r12
     608:	df 92       	push	r13
     60a:	ef 92       	push	r14
     60c:	ff 92       	push	r15
     60e:	0f 93       	push	r16
     610:	1f 93       	push	r17
     612:	df 93       	push	r29
     614:	cf 93       	push	r28
     616:	00 d0       	rcall	.+0      	; 0x618 <arpSendRequest+0x12>
     618:	00 d0       	rcall	.+0      	; 0x61a <arpSendRequest+0x14>
     61a:	00 d0       	rcall	.+0      	; 0x61c <arpSendRequest+0x16>
     61c:	cd b7       	in	r28, 0x3d	; 61
     61e:	de b7       	in	r29, 0x3e	; 62
     620:	8c 01       	movw	r16, r24
     622:	0e 94 66 19 	call	0x32cc	; 0x32cc <nicNewRequest>
     626:	6c 01       	movw	r12, r24
     628:	6c e1       	ldi	r22, 0x1C	; 28
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     630:	7c 01       	movw	r14, r24
     632:	80 e0       	ldi	r24, 0x00	; 0
     634:	91 e0       	ldi	r25, 0x01	; 1
     636:	f7 01       	movw	r30, r14
     638:	91 83       	std	Z+1, r25	; 0x01
     63a:	80 83       	st	Z, r24
     63c:	88 e0       	ldi	r24, 0x08	; 8
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	93 83       	std	Z+3, r25	; 0x03
     642:	82 83       	std	Z+2, r24	; 0x02
     644:	86 e0       	ldi	r24, 0x06	; 6
     646:	84 83       	std	Z+4, r24	; 0x04
     648:	84 e0       	ldi	r24, 0x04	; 4
     64a:	85 83       	std	Z+5, r24	; 0x05
     64c:	f8 01       	movw	r30, r16
     64e:	80 81       	ld	r24, Z
     650:	91 81       	ldd	r25, Z+1	; 0x01
     652:	a2 81       	ldd	r26, Z+2	; 0x02
     654:	b3 81       	ldd	r27, Z+3	; 0x03
     656:	f7 01       	movw	r30, r14
     658:	80 8f       	std	Z+24, r24	; 0x18
     65a:	91 8f       	std	Z+25, r25	; 0x19
     65c:	a2 8f       	std	Z+26, r26	; 0x1a
     65e:	b3 8f       	std	Z+27, r27	; 0x1b
     660:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     664:	d7 01       	movw	r26, r14
     666:	18 96       	adiw	r26, 0x08	; 8
     668:	fc 01       	movw	r30, r24
     66a:	86 e0       	ldi	r24, 0x06	; 6
     66c:	01 90       	ld	r0, Z+
     66e:	0d 92       	st	X+, r0
     670:	81 50       	subi	r24, 0x01	; 1
     672:	e1 f7       	brne	.-8      	; 0x66c <arpSendRequest+0x66>
     674:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     678:	fc 01       	movw	r30, r24
     67a:	80 81       	ld	r24, Z
     67c:	91 81       	ldd	r25, Z+1	; 0x01
     67e:	a2 81       	ldd	r26, Z+2	; 0x02
     680:	b3 81       	ldd	r27, Z+3	; 0x03
     682:	f7 01       	movw	r30, r14
     684:	86 87       	std	Z+14, r24	; 0x0e
     686:	97 87       	std	Z+15, r25	; 0x0f
     688:	a0 8b       	std	Z+16, r26	; 0x10
     68a:	b1 8b       	std	Z+17, r27	; 0x11
     68c:	80 e0       	ldi	r24, 0x00	; 0
     68e:	91 e0       	ldi	r25, 0x01	; 1
     690:	97 83       	std	Z+7, r25	; 0x07
     692:	86 83       	std	Z+6, r24	; 0x06
     694:	12 8a       	std	Z+18, r1	; 0x12
     696:	13 8a       	std	Z+19, r1	; 0x13
     698:	14 8a       	std	Z+20, r1	; 0x14
     69a:	15 8a       	std	Z+21, r1	; 0x15
     69c:	16 8a       	std	Z+22, r1	; 0x16
     69e:	17 8a       	std	Z+23, r1	; 0x17
     6a0:	ae 01       	movw	r20, r28
     6a2:	4f 5f       	subi	r20, 0xFF	; 255
     6a4:	5f 4f       	sbci	r21, 0xFF	; 255
     6a6:	da 01       	movw	r26, r20
     6a8:	e8 e0       	ldi	r30, 0x08	; 8
     6aa:	f1 e0       	ldi	r31, 0x01	; 1
     6ac:	86 e0       	ldi	r24, 0x06	; 6
     6ae:	01 90       	ld	r0, Z+
     6b0:	0d 92       	st	X+, r0
     6b2:	81 50       	subi	r24, 0x01	; 1
     6b4:	e1 f7       	brne	.-8      	; 0x6ae <arpSendRequest+0xa8>
     6b6:	c6 01       	movw	r24, r12
     6b8:	68 e0       	ldi	r22, 0x08	; 8
     6ba:	76 e0       	ldi	r23, 0x06	; 6
     6bc:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     6c0:	26 96       	adiw	r28, 0x06	; 6
     6c2:	0f b6       	in	r0, 0x3f	; 63
     6c4:	f8 94       	cli
     6c6:	de bf       	out	0x3e, r29	; 62
     6c8:	0f be       	out	0x3f, r0	; 63
     6ca:	cd bf       	out	0x3d, r28	; 61
     6cc:	cf 91       	pop	r28
     6ce:	df 91       	pop	r29
     6d0:	1f 91       	pop	r17
     6d2:	0f 91       	pop	r16
     6d4:	ff 90       	pop	r15
     6d6:	ef 90       	pop	r14
     6d8:	df 90       	pop	r13
     6da:	cf 90       	pop	r12
     6dc:	08 95       	ret

000006de <arpLookupMacByIPv4>:
     6de:	cf 92       	push	r12
     6e0:	df 92       	push	r13
     6e2:	ef 92       	push	r14
     6e4:	ff 92       	push	r15
     6e6:	0f 93       	push	r16
     6e8:	1f 93       	push	r17
     6ea:	df 93       	push	r29
     6ec:	cf 93       	push	r28
     6ee:	00 d0       	rcall	.+0      	; 0x6f0 <arpLookupMacByIPv4+0x12>
     6f0:	00 d0       	rcall	.+0      	; 0x6f2 <arpLookupMacByIPv4+0x14>
     6f2:	00 d0       	rcall	.+0      	; 0x6f4 <arpLookupMacByIPv4+0x16>
     6f4:	cd b7       	in	r28, 0x3d	; 61
     6f6:	de b7       	in	r29, 0x3e	; 62
     6f8:	7c 01       	movw	r14, r24
     6fa:	dc 01       	movw	r26, r24
     6fc:	2d 91       	ld	r18, X+
     6fe:	3d 91       	ld	r19, X+
     700:	4d 91       	ld	r20, X+
     702:	5c 91       	ld	r21, X
     704:	80 91 6d 08 	lds	r24, 0x086D
     708:	90 91 6e 08 	lds	r25, 0x086E
     70c:	a0 91 6f 08 	lds	r26, 0x086F
     710:	b0 91 70 08 	lds	r27, 0x0870
     714:	82 17       	cp	r24, r18
     716:	93 07       	cpc	r25, r19
     718:	a4 07       	cpc	r26, r20
     71a:	b5 07       	cpc	r27, r21
     71c:	09 f4       	brne	.+2      	; 0x720 <arpLookupMacByIPv4+0x42>
     71e:	c0 c0       	rjmp	.+384    	; 0x8a0 <arpLookupMacByIPv4+0x1c2>
     720:	80 91 62 08 	lds	r24, 0x0862
     724:	90 91 63 08 	lds	r25, 0x0863
     728:	a0 91 64 08 	lds	r26, 0x0864
     72c:	b0 91 65 08 	lds	r27, 0x0865
     730:	82 17       	cp	r24, r18
     732:	93 07       	cpc	r25, r19
     734:	a4 07       	cpc	r26, r20
     736:	b5 07       	cpc	r27, r21
     738:	09 f4       	brne	.+2      	; 0x73c <arpLookupMacByIPv4+0x5e>
     73a:	b5 c0       	rjmp	.+362    	; 0x8a6 <arpLookupMacByIPv4+0x1c8>
     73c:	80 91 57 08 	lds	r24, 0x0857
     740:	90 91 58 08 	lds	r25, 0x0858
     744:	a0 91 59 08 	lds	r26, 0x0859
     748:	b0 91 5a 08 	lds	r27, 0x085A
     74c:	82 17       	cp	r24, r18
     74e:	93 07       	cpc	r25, r19
     750:	a4 07       	cpc	r26, r20
     752:	b5 07       	cpc	r27, r21
     754:	09 f4       	brne	.+2      	; 0x758 <arpLookupMacByIPv4+0x7a>
     756:	aa c0       	rjmp	.+340    	; 0x8ac <arpLookupMacByIPv4+0x1ce>
     758:	80 91 4c 08 	lds	r24, 0x084C
     75c:	90 91 4d 08 	lds	r25, 0x084D
     760:	a0 91 4e 08 	lds	r26, 0x084E
     764:	b0 91 4f 08 	lds	r27, 0x084F
     768:	82 17       	cp	r24, r18
     76a:	93 07       	cpc	r25, r19
     76c:	a4 07       	cpc	r26, r20
     76e:	b5 07       	cpc	r27, r21
     770:	09 f4       	brne	.+2      	; 0x774 <arpLookupMacByIPv4+0x96>
     772:	9f c0       	rjmp	.+318    	; 0x8b2 <arpLookupMacByIPv4+0x1d4>
     774:	80 91 41 08 	lds	r24, 0x0841
     778:	90 91 42 08 	lds	r25, 0x0842
     77c:	a0 91 43 08 	lds	r26, 0x0843
     780:	b0 91 44 08 	lds	r27, 0x0844
     784:	82 17       	cp	r24, r18
     786:	93 07       	cpc	r25, r19
     788:	a4 07       	cpc	r26, r20
     78a:	b5 07       	cpc	r27, r21
     78c:	09 f4       	brne	.+2      	; 0x790 <arpLookupMacByIPv4+0xb2>
     78e:	51 c0       	rjmp	.+162    	; 0x832 <arpLookupMacByIPv4+0x154>
     790:	0e 94 66 19 	call	0x32cc	; 0x32cc <nicNewRequest>
     794:	6c 01       	movw	r12, r24
     796:	6c e1       	ldi	r22, 0x1C	; 28
     798:	70 e0       	ldi	r23, 0x00	; 0
     79a:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     79e:	8c 01       	movw	r16, r24
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	91 e0       	ldi	r25, 0x01	; 1
     7a4:	f8 01       	movw	r30, r16
     7a6:	91 83       	std	Z+1, r25	; 0x01
     7a8:	80 83       	st	Z, r24
     7aa:	88 e0       	ldi	r24, 0x08	; 8
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	93 83       	std	Z+3, r25	; 0x03
     7b0:	82 83       	std	Z+2, r24	; 0x02
     7b2:	86 e0       	ldi	r24, 0x06	; 6
     7b4:	84 83       	std	Z+4, r24	; 0x04
     7b6:	84 e0       	ldi	r24, 0x04	; 4
     7b8:	85 83       	std	Z+5, r24	; 0x05
     7ba:	f7 01       	movw	r30, r14
     7bc:	80 81       	ld	r24, Z
     7be:	91 81       	ldd	r25, Z+1	; 0x01
     7c0:	a2 81       	ldd	r26, Z+2	; 0x02
     7c2:	b3 81       	ldd	r27, Z+3	; 0x03
     7c4:	f8 01       	movw	r30, r16
     7c6:	80 8f       	std	Z+24, r24	; 0x18
     7c8:	91 8f       	std	Z+25, r25	; 0x19
     7ca:	a2 8f       	std	Z+26, r26	; 0x1a
     7cc:	b3 8f       	std	Z+27, r27	; 0x1b
     7ce:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     7d2:	d8 01       	movw	r26, r16
     7d4:	18 96       	adiw	r26, 0x08	; 8
     7d6:	fc 01       	movw	r30, r24
     7d8:	86 e0       	ldi	r24, 0x06	; 6
     7da:	01 90       	ld	r0, Z+
     7dc:	0d 92       	st	X+, r0
     7de:	81 50       	subi	r24, 0x01	; 1
     7e0:	e1 f7       	brne	.-8      	; 0x7da <arpLookupMacByIPv4+0xfc>
     7e2:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     7e6:	fc 01       	movw	r30, r24
     7e8:	80 81       	ld	r24, Z
     7ea:	91 81       	ldd	r25, Z+1	; 0x01
     7ec:	a2 81       	ldd	r26, Z+2	; 0x02
     7ee:	b3 81       	ldd	r27, Z+3	; 0x03
     7f0:	f8 01       	movw	r30, r16
     7f2:	86 87       	std	Z+14, r24	; 0x0e
     7f4:	97 87       	std	Z+15, r25	; 0x0f
     7f6:	a0 8b       	std	Z+16, r26	; 0x10
     7f8:	b1 8b       	std	Z+17, r27	; 0x11
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	91 e0       	ldi	r25, 0x01	; 1
     7fe:	97 83       	std	Z+7, r25	; 0x07
     800:	86 83       	std	Z+6, r24	; 0x06
     802:	12 8a       	std	Z+18, r1	; 0x12
     804:	13 8a       	std	Z+19, r1	; 0x13
     806:	14 8a       	std	Z+20, r1	; 0x14
     808:	15 8a       	std	Z+21, r1	; 0x15
     80a:	16 8a       	std	Z+22, r1	; 0x16
     80c:	17 8a       	std	Z+23, r1	; 0x17
     80e:	ae 01       	movw	r20, r28
     810:	4f 5f       	subi	r20, 0xFF	; 255
     812:	5f 4f       	sbci	r21, 0xFF	; 255
     814:	da 01       	movw	r26, r20
     816:	e8 e0       	ldi	r30, 0x08	; 8
     818:	f1 e0       	ldi	r31, 0x01	; 1
     81a:	86 e0       	ldi	r24, 0x06	; 6
     81c:	01 90       	ld	r0, Z+
     81e:	0d 92       	st	X+, r0
     820:	81 50       	subi	r24, 0x01	; 1
     822:	e1 f7       	brne	.-8      	; 0x81c <arpLookupMacByIPv4+0x13e>
     824:	c6 01       	movw	r24, r12
     826:	68 e0       	ldi	r22, 0x08	; 8
     828:	76 e0       	ldi	r23, 0x06	; 6
     82a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	28 c0       	rjmp	.+80     	; 0x882 <arpLookupMacByIPv4+0x1a4>
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
     836:	8a 01       	movw	r16, r20
     838:	00 0f       	add	r16, r16
     83a:	11 1f       	adc	r17, r17
     83c:	7a 01       	movw	r14, r20
     83e:	ee 0c       	add	r14, r14
     840:	ff 1c       	adc	r15, r15
     842:	ee 0c       	add	r14, r14
     844:	ff 1c       	adc	r15, r15
     846:	ee 0c       	add	r14, r14
     848:	ff 1c       	adc	r15, r15
     84a:	f8 01       	movw	r30, r16
     84c:	ee 0d       	add	r30, r14
     84e:	ff 1d       	adc	r31, r15
     850:	e4 0f       	add	r30, r20
     852:	f5 1f       	adc	r31, r21
     854:	9b 01       	movw	r18, r22
     856:	e5 5c       	subi	r30, 0xC5	; 197
     858:	f7 4f       	sbci	r31, 0xF7	; 247
     85a:	86 e0       	ldi	r24, 0x06	; 6
     85c:	01 90       	ld	r0, Z+
     85e:	d9 01       	movw	r26, r18
     860:	0d 92       	st	X+, r0
     862:	9d 01       	movw	r18, r26
     864:	81 50       	subi	r24, 0x01	; 1
     866:	d1 f7       	brne	.-12     	; 0x85c <arpLookupMacByIPv4+0x17e>
     868:	e0 0e       	add	r14, r16
     86a:	f1 1e       	adc	r15, r17
     86c:	e4 0e       	add	r14, r20
     86e:	f5 1e       	adc	r15, r21
     870:	eb e3       	ldi	r30, 0x3B	; 59
     872:	f8 e0       	ldi	r31, 0x08	; 8
     874:	ee 0e       	add	r14, r30
     876:	ff 1e       	adc	r15, r31
     878:	8f ef       	ldi	r24, 0xFF	; 255
     87a:	d7 01       	movw	r26, r14
     87c:	1a 96       	adiw	r26, 0x0a	; 10
     87e:	8c 93       	st	X, r24
     880:	80 e0       	ldi	r24, 0x00	; 0
     882:	26 96       	adiw	r28, 0x06	; 6
     884:	0f b6       	in	r0, 0x3f	; 63
     886:	f8 94       	cli
     888:	de bf       	out	0x3e, r29	; 62
     88a:	0f be       	out	0x3f, r0	; 63
     88c:	cd bf       	out	0x3d, r28	; 61
     88e:	cf 91       	pop	r28
     890:	df 91       	pop	r29
     892:	1f 91       	pop	r17
     894:	0f 91       	pop	r16
     896:	ff 90       	pop	r15
     898:	ef 90       	pop	r14
     89a:	df 90       	pop	r13
     89c:	cf 90       	pop	r12
     89e:	08 95       	ret
     8a0:	44 e0       	ldi	r20, 0x04	; 4
     8a2:	50 e0       	ldi	r21, 0x00	; 0
     8a4:	c8 cf       	rjmp	.-112    	; 0x836 <arpLookupMacByIPv4+0x158>
     8a6:	43 e0       	ldi	r20, 0x03	; 3
     8a8:	50 e0       	ldi	r21, 0x00	; 0
     8aa:	c5 cf       	rjmp	.-118    	; 0x836 <arpLookupMacByIPv4+0x158>
     8ac:	42 e0       	ldi	r20, 0x02	; 2
     8ae:	50 e0       	ldi	r21, 0x00	; 0
     8b0:	c2 cf       	rjmp	.-124    	; 0x836 <arpLookupMacByIPv4+0x158>
     8b2:	41 e0       	ldi	r20, 0x01	; 1
     8b4:	50 e0       	ldi	r21, 0x00	; 0
     8b6:	bf cf       	rjmp	.-130    	; 0x836 <arpLookupMacByIPv4+0x158>

000008b8 <onInitRtp>:
  }
  
  void onInitRtp()
  {
    return;
  }
     8b8:	08 95       	ret

000008ba <onRtpResponse>:
    
    return;
  }
  
  void onRtpResponse(struct nicResponseHandle_t* response, struct netAddress_t* netAddr)
  {
     8ba:	ef 92       	push	r14
     8bc:	ff 92       	push	r15
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	df 93       	push	r29
     8c4:	cf 93       	push	r28
     8c6:	cd b7       	in	r28, 0x3d	; 61
     8c8:	de b7       	in	r29, 0x3e	; 62
     8ca:	66 97       	sbiw	r28, 0x16	; 22
     8cc:	0f b6       	in	r0, 0x3f	; 63
     8ce:	f8 94       	cli
     8d0:	de bf       	out	0x3e, r29	; 62
     8d2:	0f be       	out	0x3f, r0	; 63
     8d4:	cd bf       	out	0x3d, r28	; 61
     8d6:	7c 01       	movw	r14, r24



    if (nicResponseSize(response) < sizeof(struct soRtpHeader_t))
     8d8:	0e 94 b7 18 	call	0x316e	; 0x316e <nicResponseSize>
     8dc:	0c 97       	sbiw	r24, 0x0c	; 12
     8de:	68 f4       	brcc	.+26     	; 0x8fa <onRtpResponse+0x40>

      free(buf);
    }  
#endif  
    return;
  }
     8e0:	66 96       	adiw	r28, 0x16	; 22
     8e2:	0f b6       	in	r0, 0x3f	; 63
     8e4:	f8 94       	cli
     8e6:	de bf       	out	0x3e, r29	; 62
     8e8:	0f be       	out	0x3f, r0	; 63
     8ea:	cd bf       	out	0x3d, r28	; 61
     8ec:	cf 91       	pop	r28
     8ee:	df 91       	pop	r29
     8f0:	1f 91       	pop	r17
     8f2:	0f 91       	pop	r16
     8f4:	ff 90       	pop	r15
     8f6:	ef 90       	pop	r14
     8f8:	08 95       	ret

    if (nicResponseSize(response) < sizeof(struct soRtpHeader_t))
      return;  
 
    struct soRtpHeader_t header;    
    nicResponseRead(response,(char*)(&header),sizeof(struct soRtpHeader_t));
     8fa:	c7 01       	movw	r24, r14
     8fc:	be 01       	movw	r22, r28
     8fe:	65 5f       	subi	r22, 0xF5	; 245
     900:	7f 4f       	sbci	r23, 0xFF	; 255
     902:	4c e0       	ldi	r20, 0x0C	; 12
     904:	50 e0       	ldi	r21, 0x00	; 0
     906:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>

    if (header.type == 0x4D)
     90a:	8c 85       	ldd	r24, Y+12	; 0x0c
     90c:	8d 34       	cpi	r24, 0x4D	; 77
     90e:	19 f1       	breq	.+70     	; 0x956 <onRtpResponse+0x9c>
      onRtpData(buf,len);
      
      free(buf);
    }
#ifdef REQUIRES_RCFG
    else if (header.type == 0x25)
     910:	85 32       	cpi	r24, 0x25	; 37
     912:	31 f7       	brne	.-52     	; 0x8e0 <onRtpResponse+0x26>
    {
      struct cdpHeader_t cdpHeader;
      nicResponseRead(response,(char*)(&cdpHeader), sizeof(struct cdpHeader_t));
     914:	c7 01       	movw	r24, r14
     916:	be 01       	movw	r22, r28
     918:	6f 5f       	subi	r22, 0xFF	; 255
     91a:	7f 4f       	sbci	r23, 0xFF	; 255
     91c:	4a e0       	ldi	r20, 0x0A	; 10
     91e:	50 e0       	ldi	r21, 0x00	; 0
     920:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
      
      if (cdpHeader.length == 0)
     924:	89 81       	ldd	r24, Y+1	; 0x01
     926:	88 23       	and	r24, r24
     928:	d9 f2       	breq	.-74     	; 0x8e0 <onRtpResponse+0x26>
        return;
      
      char* buf = malloc(cdpHeader.length);
     92a:	90 e0       	ldi	r25, 0x00	; 0
     92c:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
     930:	18 2f       	mov	r17, r24
     932:	09 2f       	mov	r16, r25
      uint8_t len = nicResponseRead(response,buf,cdpHeader.length);
     934:	49 81       	ldd	r20, Y+1	; 0x01
     936:	c7 01       	movw	r24, r14
     938:	61 2f       	mov	r22, r17
     93a:	70 2f       	mov	r23, r16
     93c:	50 e0       	ldi	r21, 0x00	; 0
     93e:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
     942:	68 2f       	mov	r22, r24

      onRtpControl(buf,len);
     944:	81 2f       	mov	r24, r17
     946:	90 2f       	mov	r25, r16
     948:	0e 94 54 29 	call	0x52a8	; 0x52a8 <onRtpControl>

      free(buf);
     94c:	81 2f       	mov	r24, r17
     94e:	90 2f       	mov	r25, r16
     950:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
     954:	c5 cf       	rjmp	.-118    	; 0x8e0 <onRtpResponse+0x26>
    nicResponseRead(response,(char*)(&header),sizeof(struct soRtpHeader_t));

    if (header.type == 0x4D)
    {
      struct cdpHeader_t cdpHeader;
      nicResponseRead(response,(char*)(&cdpHeader), sizeof(struct cdpHeader_t));
     956:	c7 01       	movw	r24, r14
     958:	be 01       	movw	r22, r28
     95a:	6f 5f       	subi	r22, 0xFF	; 255
     95c:	7f 4f       	sbci	r23, 0xFF	; 255
     95e:	4a e0       	ldi	r20, 0x0A	; 10
     960:	50 e0       	ldi	r21, 0x00	; 0
     962:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
      
      if (cdpHeader.length == 0)
     966:	89 81       	ldd	r24, Y+1	; 0x01
     968:	88 23       	and	r24, r24
     96a:	09 f4       	brne	.+2      	; 0x96e <onRtpResponse+0xb4>
     96c:	b9 cf       	rjmp	.-142    	; 0x8e0 <onRtpResponse+0x26>
        return;
      
      char* buf = malloc(cdpHeader.length);
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
     974:	18 2f       	mov	r17, r24
     976:	09 2f       	mov	r16, r25
      uint8_t len = nicResponseRead(response,buf,cdpHeader.length);
     978:	49 81       	ldd	r20, Y+1	; 0x01
     97a:	c7 01       	movw	r24, r14
     97c:	61 2f       	mov	r22, r17
     97e:	70 2f       	mov	r23, r16
     980:	50 e0       	ldi	r21, 0x00	; 0
     982:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
     986:	68 2f       	mov	r22, r24


	  
      
      onRtpData(buf,len);
     988:	81 2f       	mov	r24, r17
     98a:	90 2f       	mov	r25, r16
     98c:	0e 94 b7 1a 	call	0x356e	; 0x356e <onRtpData>
      
      free(buf);
     990:	81 2f       	mov	r24, r17
     992:	90 2f       	mov	r25, r16
     994:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
     998:	a3 cf       	rjmp	.-186    	; 0x8e0 <onRtpResponse+0x26>

0000099a <onRtpRequest>:
    return;
  }
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
     99a:	6f 92       	push	r6
     99c:	7f 92       	push	r7
     99e:	8f 92       	push	r8
     9a0:	9f 92       	push	r9
     9a2:	af 92       	push	r10
     9a4:	bf 92       	push	r11
     9a6:	cf 92       	push	r12
     9a8:	df 92       	push	r13
     9aa:	ef 92       	push	r14
     9ac:	ff 92       	push	r15
     9ae:	0f 93       	push	r16
     9b0:	1f 93       	push	r17
     9b2:	5c 01       	movw	r10, r24
     9b4:	16 2f       	mov	r17, r22
     9b6:	4a 01       	movw	r8, r20
     9b8:	39 01       	movw	r6, r18
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     9ba:	6c e0       	ldi	r22, 0x0C	; 12
     9bc:	70 e0       	ldi	r23, 0x00	; 0
     9be:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     9c2:	6c 01       	movw	r12, r24



   
    header->version = 0x80;
     9c4:	80 e8       	ldi	r24, 0x80	; 128
     9c6:	f6 01       	movw	r30, r12
     9c8:	80 83       	st	Z, r24
    header->type = type;     
     9ca:	11 83       	std	Z+1, r17	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     9cc:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     9d0:	16 2f       	mov	r17, r22
     9d2:	00 27       	eor	r16, r16
     9d4:	ff 24       	eor	r15, r15
     9d6:	ee 24       	eor	r14, r14
     9d8:	29 2f       	mov	r18, r25
     9da:	33 27       	eor	r19, r19
     9dc:	44 27       	eor	r20, r20
     9de:	55 27       	eor	r21, r21
     9e0:	e2 2a       	or	r14, r18
     9e2:	f3 2a       	or	r15, r19
     9e4:	04 2b       	or	r16, r20
     9e6:	15 2b       	or	r17, r21
     9e8:	9b 01       	movw	r18, r22
     9ea:	ac 01       	movw	r20, r24
     9ec:	20 70       	andi	r18, 0x00	; 0
     9ee:	30 70       	andi	r19, 0x00	; 0
     9f0:	50 70       	andi	r21, 0x00	; 0
     9f2:	23 2f       	mov	r18, r19
     9f4:	34 2f       	mov	r19, r20
     9f6:	45 2f       	mov	r20, r21
     9f8:	55 27       	eor	r21, r21
     9fa:	e2 2a       	or	r14, r18
     9fc:	f3 2a       	or	r15, r19
     9fe:	04 2b       	or	r16, r20
     a00:	15 2b       	or	r17, r21
     a02:	60 70       	andi	r22, 0x00	; 0
     a04:	80 70       	andi	r24, 0x00	; 0
     a06:	90 70       	andi	r25, 0x00	; 0
     a08:	98 2f       	mov	r25, r24
     a0a:	87 2f       	mov	r24, r23
     a0c:	76 2f       	mov	r23, r22
     a0e:	66 27       	eor	r22, r22
     a10:	e6 2a       	or	r14, r22
     a12:	f7 2a       	or	r15, r23
     a14:	08 2b       	or	r16, r24
     a16:	19 2b       	or	r17, r25
     a18:	f6 01       	movw	r30, r12
     a1a:	e4 82       	std	Z+4, r14	; 0x04
     a1c:	f5 82       	std	Z+5, r15	; 0x05
     a1e:	06 83       	std	Z+6, r16	; 0x06
     a20:	17 83       	std	Z+7, r17	; 0x07
    header->ssrc = 0x00;
     a22:	10 86       	std	Z+8, r1	; 0x08
     a24:	11 86       	std	Z+9, r1	; 0x09
     a26:	12 86       	std	Z+10, r1	; 0x0a
     a28:	13 86       	std	Z+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     a2a:	80 91 73 08 	lds	r24, 0x0873
     a2e:	90 91 74 08 	lds	r25, 0x0874
     a32:	92 83       	std	Z+2, r25	; 0x02
     a34:	83 83       	std	Z+3, r24	; 0x03


    
    rtpSequence++;
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	90 93 74 08 	sts	0x0874, r25
     a3c:	80 93 73 08 	sts	0x0873, r24


    
    onUdpRequest(handle,destNetAddr,srcPort);  
     a40:	c5 01       	movw	r24, r10
     a42:	b4 01       	movw	r22, r8
     a44:	a3 01       	movw	r20, r6
     a46:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>
    
    return;
  }
     a4a:	1f 91       	pop	r17
     a4c:	0f 91       	pop	r16
     a4e:	ff 90       	pop	r15
     a50:	ef 90       	pop	r14
     a52:	df 90       	pop	r13
     a54:	cf 90       	pop	r12
     a56:	bf 90       	pop	r11
     a58:	af 90       	pop	r10
     a5a:	9f 90       	pop	r9
     a5c:	8f 90       	pop	r8
     a5e:	7f 90       	pop	r7
     a60:	6f 90       	pop	r6
     a62:	08 95       	ret

00000a64 <rtpSendCommand>:


 
  void rtpSendCommand(char* data, uint16_t len, 
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
     a64:	6f 92       	push	r6
     a66:	7f 92       	push	r7
     a68:	8f 92       	push	r8
     a6a:	9f 92       	push	r9
     a6c:	af 92       	push	r10
     a6e:	bf 92       	push	r11
     a70:	cf 92       	push	r12
     a72:	df 92       	push	r13
     a74:	ef 92       	push	r14
     a76:	ff 92       	push	r15
     a78:	0f 93       	push	r16
     a7a:	1f 93       	push	r17
     a7c:	cf 93       	push	r28
     a7e:	df 93       	push	r29
     a80:	8c 01       	movw	r16, r24
     a82:	eb 01       	movw	r28, r22
     a84:	4a 01       	movw	r8, r20
     a86:	39 01       	movw	r6, r18
    // create a new Packet, ...
    struct nicRequestHandle_t* handle = nicNewRequest();
     a88:	0e 94 66 19 	call	0x32cc	; 0x32cc <nicNewRequest>
     a8c:	5c 01       	movw	r10, r24
    


	if(len!=0)
     a8e:	20 97       	sbiw	r28, 0x00	; 0
     a90:	09 f4       	brne	.+2      	; 0xa94 <rtpSendCommand+0x30>
     a92:	7e c0       	rjmp	.+252    	; 0xb90 <rtpSendCommand+0x12c>
	{
    // .... append the Payload...
	    char* buf = nicAddPacketHeader(handle,len+sizeof(struct cdpHeader_t));
     a94:	be 01       	movw	r22, r28
     a96:	66 5f       	subi	r22, 0xF6	; 246
     a98:	7f 4f       	sbci	r23, 0xFF	; 255
     a9a:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     a9e:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = len;
     aa0:	c0 83       	st	Z, r28
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     aa2:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     aa4:	12 82       	std	Z+2, r1	; 0x02
     aa6:	13 82       	std	Z+3, r1	; 0x03
     aa8:	14 82       	std	Z+4, r1	; 0x04
     aaa:	15 82       	std	Z+5, r1	; 0x05
     aac:	16 82       	std	Z+6, r1	; 0x06
     aae:	17 82       	std	Z+7, r1	; 0x07
     ab0:	10 86       	std	Z+8, r1	; 0x08
     ab2:	11 86       	std	Z+9, r1	; 0x09
     ab4:	9e 01       	movw	r18, r28
     ab6:	21 50       	subi	r18, 0x01	; 1
     ab8:	30 40       	sbci	r19, 0x00	; 0
     aba:	d8 01       	movw	r26, r16
     abc:	a2 0f       	add	r26, r18
     abe:	b3 1f       	adc	r27, r19
     ac0:	ec 0f       	add	r30, r28
     ac2:	fd 1f       	adc	r31, r29
     ac4:	02 c0       	rjmp	.+4      	; 0xaca <rtpSendCommand+0x66>
     ac6:	21 50       	subi	r18, 0x01	; 1
     ac8:	30 40       	sbci	r19, 0x00	; 0
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    while(len--)
	    {
	      buf[len] = data[len];
     aca:	8c 91       	ld	r24, X
     acc:	81 87       	std	Z+9, r24	; 0x09
     ace:	11 97       	sbiw	r26, 0x01	; 1
     ad0:	31 97       	sbiw	r30, 0x01	; 1
	    ((struct cdpHeader_t*)buf)->reserved = 0;
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    while(len--)
     ad2:	21 15       	cp	r18, r1
     ad4:	31 05       	cpc	r19, r1
     ad6:	b9 f7       	brne	.-18     	; 0xac6 <rtpSendCommand+0x62>
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     ad8:	c5 01       	movw	r24, r10
     ada:	6c e0       	ldi	r22, 0x0C	; 12
     adc:	70 e0       	ldi	r23, 0x00	; 0
     ade:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     ae2:	6c 01       	movw	r12, r24



   
    header->version = 0x80;
     ae4:	80 e8       	ldi	r24, 0x80	; 128
     ae6:	f6 01       	movw	r30, r12
     ae8:	80 83       	st	Z, r24
    header->type = type;     
     aea:	85 e2       	ldi	r24, 0x25	; 37
     aec:	81 83       	std	Z+1, r24	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     aee:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     af2:	16 2f       	mov	r17, r22
     af4:	00 27       	eor	r16, r16
     af6:	ff 24       	eor	r15, r15
     af8:	ee 24       	eor	r14, r14
     afa:	29 2f       	mov	r18, r25
     afc:	33 27       	eor	r19, r19
     afe:	44 27       	eor	r20, r20
     b00:	55 27       	eor	r21, r21
     b02:	e2 2a       	or	r14, r18
     b04:	f3 2a       	or	r15, r19
     b06:	04 2b       	or	r16, r20
     b08:	15 2b       	or	r17, r21
     b0a:	9b 01       	movw	r18, r22
     b0c:	ac 01       	movw	r20, r24
     b0e:	20 70       	andi	r18, 0x00	; 0
     b10:	30 70       	andi	r19, 0x00	; 0
     b12:	50 70       	andi	r21, 0x00	; 0
     b14:	23 2f       	mov	r18, r19
     b16:	34 2f       	mov	r19, r20
     b18:	45 2f       	mov	r20, r21
     b1a:	55 27       	eor	r21, r21
     b1c:	e2 2a       	or	r14, r18
     b1e:	f3 2a       	or	r15, r19
     b20:	04 2b       	or	r16, r20
     b22:	15 2b       	or	r17, r21
     b24:	60 70       	andi	r22, 0x00	; 0
     b26:	80 70       	andi	r24, 0x00	; 0
     b28:	90 70       	andi	r25, 0x00	; 0
     b2a:	98 2f       	mov	r25, r24
     b2c:	87 2f       	mov	r24, r23
     b2e:	76 2f       	mov	r23, r22
     b30:	66 27       	eor	r22, r22
     b32:	e6 2a       	or	r14, r22
     b34:	f7 2a       	or	r15, r23
     b36:	08 2b       	or	r16, r24
     b38:	19 2b       	or	r17, r25
     b3a:	d6 01       	movw	r26, r12
     b3c:	14 96       	adiw	r26, 0x04	; 4
     b3e:	ed 92       	st	X+, r14
     b40:	fd 92       	st	X+, r15
     b42:	0d 93       	st	X+, r16
     b44:	1c 93       	st	X, r17
     b46:	17 97       	sbiw	r26, 0x07	; 7
    header->ssrc = 0x00;
     b48:	e6 01       	movw	r28, r12
     b4a:	18 86       	std	Y+8, r1	; 0x08
     b4c:	19 86       	std	Y+9, r1	; 0x09
     b4e:	1a 86       	std	Y+10, r1	; 0x0a
     b50:	1b 86       	std	Y+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     b52:	80 91 73 08 	lds	r24, 0x0873
     b56:	90 91 74 08 	lds	r25, 0x0874
     b5a:	9a 83       	std	Y+2, r25	; 0x02
     b5c:	8b 83       	std	Y+3, r24	; 0x03


    
    rtpSequence++;
     b5e:	01 96       	adiw	r24, 0x01	; 1
     b60:	90 93 74 08 	sts	0x0874, r25
     b64:	80 93 73 08 	sts	0x0873, r24


    
    onUdpRequest(handle,destNetAddr,srcPort);  
     b68:	c5 01       	movw	r24, r10
     b6a:	b4 01       	movw	r22, r8
     b6c:	a3 01       	movw	r20, r6
     b6e:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>
  
    // ...and add the RTP Header...
    onRtpRequest(handle,0x25,destNetAddr,srcPort);
    
    return;
  }
     b72:	df 91       	pop	r29
     b74:	cf 91       	pop	r28
     b76:	1f 91       	pop	r17
     b78:	0f 91       	pop	r16
     b7a:	ff 90       	pop	r15
     b7c:	ef 90       	pop	r14
     b7e:	df 90       	pop	r13
     b80:	cf 90       	pop	r12
     b82:	bf 90       	pop	r11
     b84:	af 90       	pop	r10
     b86:	9f 90       	pop	r9
     b88:	8f 90       	pop	r8
     b8a:	7f 90       	pop	r7
     b8c:	6f 90       	pop	r6
     b8e:	08 95       	ret
	    }
	}
	else //iamalive paket
	{
		len=9;
		char* buf = nicAddPacketHeader(handle,len+sizeof(struct cdpHeader_t));
     b90:	63 e1       	ldi	r22, 0x13	; 19
     b92:	70 e0       	ldi	r23, 0x00	; 0
     b94:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     b98:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = 0;	//here 0 because it is not a real command answer
     b9a:	10 82       	st	Z, r1
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     b9c:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     b9e:	12 82       	std	Z+2, r1	; 0x02
     ba0:	13 82       	std	Z+3, r1	; 0x03
     ba2:	14 82       	std	Z+4, r1	; 0x04
     ba4:	15 82       	std	Z+5, r1	; 0x05
     ba6:	16 82       	std	Z+6, r1	; 0x06
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	10 86       	std	Z+8, r1	; 0x08
     bac:	11 86       	std	Z+9, r1	; 0x09
    
	    buf = buf+sizeof(struct cdpHeader_t);
     bae:	dc 01       	movw	r26, r24
     bb0:	1a 96       	adiw	r26, 0x0a	; 10
    
	    while(len--)
	    {
	      buf[len] = data[len];
     bb2:	e8 01       	movw	r28, r16
     bb4:	88 85       	ldd	r24, Y+8	; 0x08
     bb6:	18 96       	adiw	r26, 0x08	; 8
     bb8:	8c 93       	st	X, r24
     bba:	18 97       	sbiw	r26, 0x08	; 8
     bbc:	8f 81       	ldd	r24, Y+7	; 0x07
     bbe:	17 96       	adiw	r26, 0x07	; 7
     bc0:	8c 93       	st	X, r24
     bc2:	17 97       	sbiw	r26, 0x07	; 7
     bc4:	8e 81       	ldd	r24, Y+6	; 0x06
     bc6:	16 96       	adiw	r26, 0x06	; 6
     bc8:	8c 93       	st	X, r24
     bca:	16 97       	sbiw	r26, 0x06	; 6
     bcc:	8d 81       	ldd	r24, Y+5	; 0x05
     bce:	15 96       	adiw	r26, 0x05	; 5
     bd0:	8c 93       	st	X, r24
     bd2:	15 97       	sbiw	r26, 0x05	; 5
     bd4:	8c 81       	ldd	r24, Y+4	; 0x04
     bd6:	14 96       	adiw	r26, 0x04	; 4
     bd8:	8c 93       	st	X, r24
     bda:	14 97       	sbiw	r26, 0x04	; 4
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	13 96       	adiw	r26, 0x03	; 3
     be0:	8c 93       	st	X, r24
     be2:	13 97       	sbiw	r26, 0x03	; 3
     be4:	8a 81       	ldd	r24, Y+2	; 0x02
     be6:	12 96       	adiw	r26, 0x02	; 2
     be8:	8c 93       	st	X, r24
     bea:	12 97       	sbiw	r26, 0x02	; 2
     bec:	89 81       	ldd	r24, Y+1	; 0x01
     bee:	11 96       	adiw	r26, 0x01	; 1
     bf0:	8c 93       	st	X, r24
     bf2:	88 81       	ld	r24, Y
     bf4:	82 87       	std	Z+10, r24	; 0x0a
     bf6:	70 cf       	rjmp	.-288    	; 0xad8 <rtpSendCommand+0x74>

00000bf8 <rtpSendCDPData>:


  
  void rtpSendCDPData(char* data, uint16_t len, 
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
     bf8:	6f 92       	push	r6
     bfa:	7f 92       	push	r7
     bfc:	8f 92       	push	r8
     bfe:	9f 92       	push	r9
     c00:	af 92       	push	r10
     c02:	bf 92       	push	r11
     c04:	cf 92       	push	r12
     c06:	df 92       	push	r13
     c08:	ef 92       	push	r14
     c0a:	ff 92       	push	r15
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	8c 01       	movw	r16, r24
     c16:	eb 01       	movw	r28, r22
     c18:	4a 01       	movw	r8, r20
     c1a:	39 01       	movw	r6, r18

  
    	if(len!=0)
     c1c:	61 15       	cp	r22, r1
     c1e:	71 05       	cpc	r23, r1
     c20:	09 f4       	brne	.+2      	; 0xc24 <rtpSendCDPData+0x2c>
     c22:	7d c0       	rjmp	.+250    	; 0xd1e <rtpSendCDPData+0x126>
  


  
    // create a new Packet, ...
    struct nicRequestHandle_t* handle = nicNewRequest();
     c24:	0e 94 66 19 	call	0x32cc	; 0x32cc <nicNewRequest>
     c28:	5c 01       	movw	r10, r24

 
	    // ... append the Payload
	    char* buf = nicAddPacketHeader(handle,150+sizeof(struct cdpHeader_t));
     c2a:	60 ea       	ldi	r22, 0xA0	; 160
     c2c:	70 e0       	ldi	r23, 0x00	; 0
     c2e:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     c32:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = len;
     c34:	c0 83       	st	Z, r28
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     c36:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     c38:	12 82       	std	Z+2, r1	; 0x02
     c3a:	13 82       	std	Z+3, r1	; 0x03
     c3c:	14 82       	std	Z+4, r1	; 0x04
     c3e:	15 82       	std	Z+5, r1	; 0x05
     c40:	16 82       	std	Z+6, r1	; 0x06
     c42:	17 82       	std	Z+7, r1	; 0x07
     c44:	10 86       	std	Z+8, r1	; 0x08
     c46:	11 86       	std	Z+9, r1	; 0x09
     c48:	9e 01       	movw	r18, r28
     c4a:	21 50       	subi	r18, 0x01	; 1
     c4c:	30 40       	sbci	r19, 0x00	; 0
     c4e:	d8 01       	movw	r26, r16
     c50:	a2 0f       	add	r26, r18
     c52:	b3 1f       	adc	r27, r19
     c54:	ec 0f       	add	r30, r28
     c56:	fd 1f       	adc	r31, r29
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <rtpSendCDPData+0x66>
     c5a:	21 50       	subi	r18, 0x01	; 1
     c5c:	30 40       	sbci	r19, 0x00	; 0
	    buf = buf+sizeof(struct cdpHeader_t);

    
	    while(len--)
	    {
	      buf[len] = data[len];
     c5e:	8c 91       	ld	r24, X
     c60:	81 87       	std	Z+9, r24	; 0x09
     c62:	11 97       	sbiw	r26, 0x01	; 1
     c64:	31 97       	sbiw	r30, 0x01	; 1
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
    
	    buf = buf+sizeof(struct cdpHeader_t);

    
	    while(len--)
     c66:	21 15       	cp	r18, r1
     c68:	31 05       	cpc	r19, r1
     c6a:	b9 f7       	brne	.-18     	; 0xc5a <rtpSendCDPData+0x62>
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     c6c:	c5 01       	movw	r24, r10
     c6e:	6c e0       	ldi	r22, 0x0C	; 12
     c70:	70 e0       	ldi	r23, 0x00	; 0
     c72:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     c76:	6c 01       	movw	r12, r24



   
    header->version = 0x80;
     c78:	80 e8       	ldi	r24, 0x80	; 128
     c7a:	f6 01       	movw	r30, r12
     c7c:	80 83       	st	Z, r24
    header->type = type;     
     c7e:	8d e4       	ldi	r24, 0x4D	; 77
     c80:	81 83       	std	Z+1, r24	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     c82:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     c86:	16 2f       	mov	r17, r22
     c88:	00 27       	eor	r16, r16
     c8a:	ff 24       	eor	r15, r15
     c8c:	ee 24       	eor	r14, r14
     c8e:	29 2f       	mov	r18, r25
     c90:	33 27       	eor	r19, r19
     c92:	44 27       	eor	r20, r20
     c94:	55 27       	eor	r21, r21
     c96:	e2 2a       	or	r14, r18
     c98:	f3 2a       	or	r15, r19
     c9a:	04 2b       	or	r16, r20
     c9c:	15 2b       	or	r17, r21
     c9e:	9b 01       	movw	r18, r22
     ca0:	ac 01       	movw	r20, r24
     ca2:	20 70       	andi	r18, 0x00	; 0
     ca4:	30 70       	andi	r19, 0x00	; 0
     ca6:	50 70       	andi	r21, 0x00	; 0
     ca8:	23 2f       	mov	r18, r19
     caa:	34 2f       	mov	r19, r20
     cac:	45 2f       	mov	r20, r21
     cae:	55 27       	eor	r21, r21
     cb0:	e2 2a       	or	r14, r18
     cb2:	f3 2a       	or	r15, r19
     cb4:	04 2b       	or	r16, r20
     cb6:	15 2b       	or	r17, r21
     cb8:	60 70       	andi	r22, 0x00	; 0
     cba:	80 70       	andi	r24, 0x00	; 0
     cbc:	90 70       	andi	r25, 0x00	; 0
     cbe:	98 2f       	mov	r25, r24
     cc0:	87 2f       	mov	r24, r23
     cc2:	76 2f       	mov	r23, r22
     cc4:	66 27       	eor	r22, r22
     cc6:	e6 2a       	or	r14, r22
     cc8:	f7 2a       	or	r15, r23
     cca:	08 2b       	or	r16, r24
     ccc:	19 2b       	or	r17, r25
     cce:	f6 01       	movw	r30, r12
     cd0:	e4 82       	std	Z+4, r14	; 0x04
     cd2:	f5 82       	std	Z+5, r15	; 0x05
     cd4:	06 83       	std	Z+6, r16	; 0x06
     cd6:	17 83       	std	Z+7, r17	; 0x07
    header->ssrc = 0x00;
     cd8:	10 86       	std	Z+8, r1	; 0x08
     cda:	11 86       	std	Z+9, r1	; 0x09
     cdc:	12 86       	std	Z+10, r1	; 0x0a
     cde:	13 86       	std	Z+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     ce0:	80 91 73 08 	lds	r24, 0x0873
     ce4:	90 91 74 08 	lds	r25, 0x0874
     ce8:	92 83       	std	Z+2, r25	; 0x02
     cea:	83 83       	std	Z+3, r24	; 0x03


    
    rtpSequence++;
     cec:	01 96       	adiw	r24, 0x01	; 1
     cee:	90 93 74 08 	sts	0x0874, r25
     cf2:	80 93 73 08 	sts	0x0873, r24


    
    onUdpRequest(handle,destNetAddr,srcPort);  
     cf6:	c5 01       	movw	r24, r10
     cf8:	b4 01       	movw	r22, r8
     cfa:	a3 01       	movw	r20, r6
     cfc:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>



  
    return;
  }
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	1f 91       	pop	r17
     d06:	0f 91       	pop	r16
     d08:	ff 90       	pop	r15
     d0a:	ef 90       	pop	r14
     d0c:	df 90       	pop	r13
     d0e:	cf 90       	pop	r12
     d10:	bf 90       	pop	r11
     d12:	af 90       	pop	r10
     d14:	9f 90       	pop	r9
     d16:	8f 90       	pop	r8
     d18:	7f 90       	pop	r7
     d1a:	6f 90       	pop	r6
     d1c:	08 95       	ret
	else //iam alive len=0
	{

	
    // create a new Packet, ...
    struct nicRequestHandle_t* handle = nicNewRequest();
     d1e:	0e 94 66 19 	call	0x32cc	; 0x32cc <nicNewRequest>
     d22:	ec 01       	movw	r28, r24

 
	    // ... append the Payload
	    char* buf = nicAddPacketHeader(handle,150+sizeof(struct cdpHeader_t));
     d24:	60 ea       	ldi	r22, 0xA0	; 160
     d26:	70 e0       	ldi	r23, 0x00	; 0
     d28:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     d2c:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = 0;
     d2e:	10 82       	st	Z, r1
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     d30:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     d32:	12 82       	std	Z+2, r1	; 0x02
     d34:	13 82       	std	Z+3, r1	; 0x03
     d36:	14 82       	std	Z+4, r1	; 0x04
     d38:	15 82       	std	Z+5, r1	; 0x05
     d3a:	16 82       	std	Z+6, r1	; 0x06
     d3c:	17 82       	std	Z+7, r1	; 0x07
     d3e:	10 86       	std	Z+8, r1	; 0x08
     d40:	11 86       	std	Z+9, r1	; 0x09
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    strcpy(buf,"iamalive\0");
     d42:	3a 96       	adiw	r30, 0x0a	; 10
     d44:	ae e0       	ldi	r26, 0x0E	; 14
     d46:	b1 e0       	ldi	r27, 0x01	; 1
     d48:	89 e0       	ldi	r24, 0x09	; 9
     d4a:	0d 90       	ld	r0, X+
     d4c:	01 92       	st	Z+, r0
     d4e:	81 50       	subi	r24, 0x01	; 1
     d50:	e1 f7       	brne	.-8      	; 0xd4a <rtpSendCDPData+0x152>
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     d52:	ce 01       	movw	r24, r28
     d54:	6c e0       	ldi	r22, 0x0C	; 12
     d56:	70 e0       	ldi	r23, 0x00	; 0
     d58:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     d5c:	6c 01       	movw	r12, r24



   
    header->version = 0x80;
     d5e:	80 e8       	ldi	r24, 0x80	; 128
     d60:	f6 01       	movw	r30, r12
     d62:	80 83       	st	Z, r24
    header->type = type;     
     d64:	8d e4       	ldi	r24, 0x4D	; 77
     d66:	81 83       	std	Z+1, r24	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     d68:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     d6c:	16 2f       	mov	r17, r22
     d6e:	00 27       	eor	r16, r16
     d70:	ff 24       	eor	r15, r15
     d72:	ee 24       	eor	r14, r14
     d74:	29 2f       	mov	r18, r25
     d76:	33 27       	eor	r19, r19
     d78:	44 27       	eor	r20, r20
     d7a:	55 27       	eor	r21, r21
     d7c:	e2 2a       	or	r14, r18
     d7e:	f3 2a       	or	r15, r19
     d80:	04 2b       	or	r16, r20
     d82:	15 2b       	or	r17, r21
     d84:	9b 01       	movw	r18, r22
     d86:	ac 01       	movw	r20, r24
     d88:	20 70       	andi	r18, 0x00	; 0
     d8a:	30 70       	andi	r19, 0x00	; 0
     d8c:	50 70       	andi	r21, 0x00	; 0
     d8e:	23 2f       	mov	r18, r19
     d90:	34 2f       	mov	r19, r20
     d92:	45 2f       	mov	r20, r21
     d94:	55 27       	eor	r21, r21
     d96:	e2 2a       	or	r14, r18
     d98:	f3 2a       	or	r15, r19
     d9a:	04 2b       	or	r16, r20
     d9c:	15 2b       	or	r17, r21
     d9e:	60 70       	andi	r22, 0x00	; 0
     da0:	80 70       	andi	r24, 0x00	; 0
     da2:	90 70       	andi	r25, 0x00	; 0
     da4:	98 2f       	mov	r25, r24
     da6:	87 2f       	mov	r24, r23
     da8:	76 2f       	mov	r23, r22
     daa:	66 27       	eor	r22, r22
     dac:	e6 2a       	or	r14, r22
     dae:	f7 2a       	or	r15, r23
     db0:	08 2b       	or	r16, r24
     db2:	19 2b       	or	r17, r25
     db4:	f6 01       	movw	r30, r12
     db6:	e4 82       	std	Z+4, r14	; 0x04
     db8:	f5 82       	std	Z+5, r15	; 0x05
     dba:	06 83       	std	Z+6, r16	; 0x06
     dbc:	17 83       	std	Z+7, r17	; 0x07
    header->ssrc = 0x00;
     dbe:	10 86       	std	Z+8, r1	; 0x08
     dc0:	11 86       	std	Z+9, r1	; 0x09
     dc2:	12 86       	std	Z+10, r1	; 0x0a
     dc4:	13 86       	std	Z+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     dc6:	80 91 73 08 	lds	r24, 0x0873
     dca:	90 91 74 08 	lds	r25, 0x0874
     dce:	92 83       	std	Z+2, r25	; 0x02
     dd0:	83 83       	std	Z+3, r24	; 0x03


    
    rtpSequence++;
     dd2:	01 96       	adiw	r24, 0x01	; 1
     dd4:	90 93 74 08 	sts	0x0874, r25
     dd8:	80 93 73 08 	sts	0x0873, r24


    
    onUdpRequest(handle,destNetAddr,srcPort);  
     ddc:	ce 01       	movw	r24, r28
     dde:	b4 01       	movw	r22, r8
     de0:	a3 01       	movw	r20, r6
     de2:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>
     de6:	8c cf       	rjmp	.-232    	; 0xd00 <rtpSendCDPData+0x108>

00000de8 <getHardwareAddress>:
// yes you realy get a pointer, this is for performance consideration
// never ever change the value of this pointer!
struct macAddress_t* getHardwareAddress()
{
  return &hEthernetAddress;
}
     de8:	88 e1       	ldi	r24, 0x18	; 24
     dea:	91 e0       	ldi	r25, 0x01	; 1
     dec:	08 95       	ret

00000dee <ethernetEepromGetConfig>:

  EepromWriteConfig((void*)MAC_EEPROM, &buf, sizeof(buf));
}

void ethernetEepromGetConfig(uint8_t * mac)
{
     dee:	ef 92       	push	r14
     df0:	ff 92       	push	r15
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
     df6:	df 93       	push	r29
     df8:	cf 93       	push	r28
     dfa:	00 d0       	rcall	.+0      	; 0xdfc <ethernetEepromGetConfig+0xe>
     dfc:	00 d0       	rcall	.+0      	; 0xdfe <ethernetEepromGetConfig+0x10>
     dfe:	00 d0       	rcall	.+0      	; 0xe00 <ethernetEepromGetConfig+0x12>
     e00:	cd b7       	in	r28, 0x3d	; 61
     e02:	de b7       	in	r29, 0x3e	; 62
     e04:	8c 01       	movw	r16, r24
  netEthernetEeprom_t buf;
  if ( !EepromReadConfig((void*)MAC_EEPROM, &buf, sizeof(buf)) ) {
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	92 e0       	ldi	r25, 0x02	; 2
     e0a:	7e 01       	movw	r14, r28
     e0c:	08 94       	sec
     e0e:	e1 1c       	adc	r14, r1
     e10:	f1 1c       	adc	r15, r1
     e12:	b7 01       	movw	r22, r14
     e14:	46 e0       	ldi	r20, 0x06	; 6
     e16:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
     e1a:	88 23       	and	r24, r24
     e1c:	41 f4       	brne	.+16     	; 0xe2e <ethernetEepromGetConfig+0x40>
    buf.mac = hEthernetAddress;
     e1e:	d7 01       	movw	r26, r14
     e20:	e8 e1       	ldi	r30, 0x18	; 24
     e22:	f1 e0       	ldi	r31, 0x01	; 1
     e24:	86 e0       	ldi	r24, 0x06	; 6
     e26:	01 90       	ld	r0, Z+
     e28:	0d 92       	st	X+, r0
     e2a:	81 50       	subi	r24, 0x01	; 1
     e2c:	e1 f7       	brne	.-8      	; 0xe26 <ethernetEepromGetConfig+0x38>
  }
  mac[0] = buf.mac.octet1;
     e2e:	89 81       	ldd	r24, Y+1	; 0x01
     e30:	f8 01       	movw	r30, r16
     e32:	80 83       	st	Z, r24
  mac[1] = buf.mac.octet2;
     e34:	8a 81       	ldd	r24, Y+2	; 0x02
     e36:	81 83       	std	Z+1, r24	; 0x01
  mac[2] = buf.mac.octet3;
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	82 83       	std	Z+2, r24	; 0x02
  mac[3] = buf.mac.octet4;
     e3c:	8c 81       	ldd	r24, Y+4	; 0x04
     e3e:	83 83       	std	Z+3, r24	; 0x03
  mac[4] = buf.mac.octet5;
     e40:	8d 81       	ldd	r24, Y+5	; 0x05
     e42:	84 83       	std	Z+4, r24	; 0x04
  mac[5] = buf.mac.octet6;
     e44:	8e 81       	ldd	r24, Y+6	; 0x06
     e46:	85 83       	std	Z+5, r24	; 0x05
}
     e48:	26 96       	adiw	r28, 0x06	; 6
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	f8 94       	cli
     e4e:	de bf       	out	0x3e, r29	; 62
     e50:	0f be       	out	0x3f, r0	; 63
     e52:	cd bf       	out	0x3d, r28	; 61
     e54:	cf 91       	pop	r28
     e56:	df 91       	pop	r29
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	08 95       	ret

00000e62 <ethernetEepromSetConfig>:
}

#ifdef REQUIRES_RCFG

void ethernetEepromSetConfig(uint8_t * mac)
{
     e62:	df 93       	push	r29
     e64:	cf 93       	push	r28
     e66:	00 d0       	rcall	.+0      	; 0xe68 <ethernetEepromSetConfig+0x6>
     e68:	00 d0       	rcall	.+0      	; 0xe6a <ethernetEepromSetConfig+0x8>
     e6a:	00 d0       	rcall	.+0      	; 0xe6c <ethernetEepromSetConfig+0xa>
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
     e70:	fc 01       	movw	r30, r24
  netEthernetEeprom_t buf;
  buf.mac.octet1 = mac[0];
     e72:	80 81       	ld	r24, Z
     e74:	89 83       	std	Y+1, r24	; 0x01
  buf.mac.octet2 = mac[1];
     e76:	81 81       	ldd	r24, Z+1	; 0x01
     e78:	8a 83       	std	Y+2, r24	; 0x02
  buf.mac.octet3 = mac[2];
     e7a:	82 81       	ldd	r24, Z+2	; 0x02
     e7c:	8b 83       	std	Y+3, r24	; 0x03
  buf.mac.octet4 = mac[3];
     e7e:	83 81       	ldd	r24, Z+3	; 0x03
     e80:	8c 83       	std	Y+4, r24	; 0x04
  buf.mac.octet5 = mac[4];
     e82:	84 81       	ldd	r24, Z+4	; 0x04
     e84:	8d 83       	std	Y+5, r24	; 0x05
  buf.mac.octet6 = mac[5];
     e86:	85 81       	ldd	r24, Z+5	; 0x05
     e88:	8e 83       	std	Y+6, r24	; 0x06

  EepromWriteConfig((void*)MAC_EEPROM, &buf, sizeof(buf));
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	92 e0       	ldi	r25, 0x02	; 2
     e8e:	be 01       	movw	r22, r28
     e90:	6f 5f       	subi	r22, 0xFF	; 255
     e92:	7f 4f       	sbci	r23, 0xFF	; 255
     e94:	46 e0       	ldi	r20, 0x06	; 6
     e96:	0e 94 49 2a 	call	0x5492	; 0x5492 <EepromWriteConfig>
}
     e9a:	26 96       	adiw	r28, 0x06	; 6
     e9c:	0f b6       	in	r0, 0x3f	; 63
     e9e:	f8 94       	cli
     ea0:	de bf       	out	0x3e, r29	; 62
     ea2:	0f be       	out	0x3f, r0	; 63
     ea4:	cd bf       	out	0x3d, r28	; 61
     ea6:	cf 91       	pop	r28
     ea8:	df 91       	pop	r29
     eaa:	08 95       	ret

00000eac <onInitEthernet>:
  onEthernetResponse(response);
  nicFreeResponse(response);
}

void onInitEthernet()
{
     eac:	0f 93       	push	r16
     eae:	1f 93       	push	r17
     eb0:	df 93       	push	r29
     eb2:	cf 93       	push	r28
     eb4:	00 d0       	rcall	.+0      	; 0xeb6 <onInitEthernet+0xa>
     eb6:	00 d0       	rcall	.+0      	; 0xeb8 <onInitEthernet+0xc>
     eb8:	00 d0       	rcall	.+0      	; 0xeba <onInitEthernet+0xe>
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62

  // define a struct for the configuration...
  netEthernetEeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)MAC_EEPROM, &buf, sizeof(buf)) ) {
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	92 e0       	ldi	r25, 0x02	; 2
     ec2:	8e 01       	movw	r16, r28
     ec4:	0f 5f       	subi	r16, 0xFF	; 255
     ec6:	1f 4f       	sbci	r17, 0xFF	; 255
     ec8:	b8 01       	movw	r22, r16
     eca:	46 e0       	ldi	r20, 0x06	; 6
     ecc:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
     ed0:	88 23       	and	r24, r24
     ed2:	41 f0       	breq	.+16     	; 0xee4 <onInitEthernet+0x38>
    hEthernetAddress = buf.mac;
     ed4:	a8 e1       	ldi	r26, 0x18	; 24
     ed6:	b1 e0       	ldi	r27, 0x01	; 1
     ed8:	f8 01       	movw	r30, r16
     eda:	86 e0       	ldi	r24, 0x06	; 6
     edc:	01 90       	ld	r0, Z+
     ede:	0d 92       	st	X+, r0
     ee0:	81 50       	subi	r24, 0x01	; 1
     ee2:	e1 f7       	brne	.-8      	; 0xedc <onInitEthernet+0x30>
  }
  // else hEthernetAddress keeps the fallback settings

  nicInitialize(&hEthernetAddress);
     ee4:	88 e1       	ldi	r24, 0x18	; 24
     ee6:	91 e0       	ldi	r25, 0x01	; 1
     ee8:	0e 94 90 19 	call	0x3320	; 0x3320 <nicInitialize>
  
  onInitArp();
     eec:	0e 94 4f 01 	call	0x29e	; 0x29e <onInitArp>
  onInitIPv4();  
     ef0:	0e 94 22 09 	call	0x1244	; 0x1244 <onInitIPv4>



  return;
}
     ef4:	26 96       	adiw	r28, 0x06	; 6
     ef6:	0f b6       	in	r0, 0x3f	; 63
     ef8:	f8 94       	cli
     efa:	de bf       	out	0x3e, r29	; 62
     efc:	0f be       	out	0x3f, r0	; 63
     efe:	cd bf       	out	0x3d, r28	; 61
     f00:	cf 91       	pop	r28
     f02:	df 91       	pop	r29
     f04:	1f 91       	pop	r17
     f06:	0f 91       	pop	r16
     f08:	08 95       	ret

00000f0a <onEthernetResponse>:
	
  return 0;
}
  
void onEthernetResponse(struct nicResponseHandle_t* handle)
{
     f0a:	0f 93       	push	r16
     f0c:	1f 93       	push	r17
     f0e:	df 93       	push	r29
     f10:	cf 93       	push	r28
     f12:	cd b7       	in	r28, 0x3d	; 61
     f14:	de b7       	in	r29, 0x3e	; 62
     f16:	2e 97       	sbiw	r28, 0x0e	; 14
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	f8 94       	cli
     f1c:	de bf       	out	0x3e, r29	; 62
     f1e:	0f be       	out	0x3f, r0	; 63
     f20:	cd bf       	out	0x3d, r28	; 61
     f22:	8c 01       	movw	r16, r24

// putString_com1("Ether-Empfangen");


  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
     f24:	0e 94 b7 18 	call	0x316e	; 0x316e <nicResponseSize>
     f28:	0e 97       	sbiw	r24, 0x0e	; 14
     f2a:	58 f4       	brcc	.+22     	; 0xf42 <onEthernetResponse+0x38>
      onArpResponse(handle,&(header.source));
      break;
  }

  return;	
}                      
     f2c:	2e 96       	adiw	r28, 0x0e	; 14
     f2e:	0f b6       	in	r0, 0x3f	; 63
     f30:	f8 94       	cli
     f32:	de bf       	out	0x3e, r29	; 62
     f34:	0f be       	out	0x3f, r0	; 63
     f36:	cd bf       	out	0x3d, r28	; 61
     f38:	cf 91       	pop	r28
     f3a:	df 91       	pop	r29
     f3c:	1f 91       	pop	r17
     f3e:	0f 91       	pop	r16
     f40:	08 95       	ret
  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
	  return;
	
  struct netEthernetHeader_t header;
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
     f42:	c8 01       	movw	r24, r16
     f44:	be 01       	movw	r22, r28
     f46:	6f 5f       	subi	r22, 0xFF	; 255
     f48:	7f 4f       	sbci	r23, 0xFF	; 255
     f4a:	4e e0       	ldi	r20, 0x0E	; 14
     f4c:	50 e0       	ldi	r21, 0x00	; 0
     f4e:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
	
  switch (header.etherType)
     f52:	8d 85       	ldd	r24, Y+13	; 0x0d
     f54:	9e 85       	ldd	r25, Y+14	; 0x0e
     f56:	88 30       	cpi	r24, 0x08	; 8
     f58:	91 05       	cpc	r25, r1
     f5a:	51 f0       	breq	.+20     	; 0xf70 <onEthernetResponse+0x66>
     f5c:	88 50       	subi	r24, 0x08	; 8
     f5e:	96 40       	sbci	r25, 0x06	; 6
     f60:	29 f7       	brne	.-54     	; 0xf2c <onEthernetResponse+0x22>
//	  putString_com1("IP-Empfangen");

      break;
    case ETHERTYPE_ARP:

      onArpResponse(handle,&(header.source));
     f62:	c8 01       	movw	r24, r16
     f64:	be 01       	movw	r22, r28
     f66:	69 5f       	subi	r22, 0xF9	; 249
     f68:	7f 4f       	sbci	r23, 0xFF	; 255
     f6a:	0e 94 98 02 	call	0x530	; 0x530 <onArpResponse>
     f6e:	de cf       	rjmp	.-68     	; 0xf2c <onEthernetResponse+0x22>
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
	
  switch (header.etherType)
  {
    case ETHERTYPE_IP4: 
      onIPv4Response(handle,&(header.source));
     f70:	c8 01       	movw	r24, r16
     f72:	be 01       	movw	r22, r28
     f74:	69 5f       	subi	r22, 0xF9	; 249
     f76:	7f 4f       	sbci	r23, 0xFF	; 255
     f78:	0e 94 14 0b 	call	0x1628	; 0x1628 <onIPv4Response>
     f7c:	d7 cf       	rjmp	.-82     	; 0xf2c <onEthernetResponse+0x22>

00000f7e <onEthernetRequest>:
  return &hEthernetAddress;
}

uint8_t onEthernetRequest(struct nicRequestHandle_t* handle, uint16_t type, 
                        struct macAddress_t* destMac)
{
     f7e:	cf 92       	push	r12
     f80:	df 92       	push	r13
     f82:	ef 92       	push	r14
     f84:	ff 92       	push	r15
     f86:	0f 93       	push	r16
     f88:	1f 93       	push	r17
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	7c 01       	movw	r14, r24
     f90:	6b 01       	movw	r12, r22
     f92:	14 2f       	mov	r17, r20
     f94:	05 2f       	mov	r16, r21
	struct netEthernetHeader_t* header
	    = (struct netEthernetHeader_t*) nicAddPacketHeader(handle,sizeof(struct netEthernetHeader_t));
     f96:	6e e0       	ldi	r22, 0x0E	; 14
     f98:	70 e0       	ldi	r23, 0x00	; 0
     f9a:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
     f9e:	fc 01       	movw	r30, r24
	
	header->destination = *destMac;
     fa0:	ec 01       	movw	r28, r24
     fa2:	21 2f       	mov	r18, r17
     fa4:	30 2f       	mov	r19, r16
     fa6:	c9 01       	movw	r24, r18
     fa8:	dc 01       	movw	r26, r24
     faa:	86 e0       	ldi	r24, 0x06	; 6
     fac:	0d 90       	ld	r0, X+
     fae:	09 92       	st	Y+, r0
     fb0:	81 50       	subi	r24, 0x01	; 1
     fb2:	e1 f7       	brne	.-8      	; 0xfac <onEthernetRequest+0x2e>
	header->source      = *(getHardwareAddress());
     fb4:	ef 01       	movw	r28, r30
     fb6:	26 96       	adiw	r28, 0x06	; 6
     fb8:	a8 e1       	ldi	r26, 0x18	; 24
     fba:	b1 e0       	ldi	r27, 0x01	; 1
     fbc:	86 e0       	ldi	r24, 0x06	; 6
     fbe:	0d 90       	ld	r0, X+
     fc0:	09 92       	st	Y+, r0
     fc2:	81 50       	subi	r24, 0x01	; 1
     fc4:	e1 f7       	brne	.-8      	; 0xfbe <onEthernetRequest+0x40>
	header->etherType   = type;
     fc6:	d5 86       	std	Z+13, r13	; 0x0d
     fc8:	c4 86       	std	Z+12, r12	; 0x0c

	

	nicSendPacket(handle,0x00);
     fca:	c7 01       	movw	r24, r14
     fcc:	60 e0       	ldi	r22, 0x00	; 0
     fce:	0e 94 2f 1a 	call	0x345e	; 0x345e <nicSendPacket>
	
	nicFreeRequest(handle);
     fd2:	c7 01       	movw	r24, r14
     fd4:	0e 94 03 19 	call	0x3206	; 0x3206 <nicFreeRequest>


	
  return 0;
}
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	df 91       	pop	r29
     fdc:	cf 91       	pop	r28
     fde:	1f 91       	pop	r17
     fe0:	0f 91       	pop	r16
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	df 90       	pop	r13
     fe8:	cf 90       	pop	r12
     fea:	08 95       	ret

00000fec <onEthernet>:

  return;	
}                      

void onEthernet()
{
     fec:	0f 93       	push	r16
     fee:	1f 93       	push	r17
     ff0:	df 93       	push	r29
     ff2:	cf 93       	push	r28
     ff4:	cd b7       	in	r28, 0x3d	; 61
     ff6:	de b7       	in	r29, 0x3e	; 62
     ff8:	2e 97       	sbiw	r28, 0x0e	; 14
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	f8 94       	cli
     ffe:	de bf       	out	0x3e, r29	; 62
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	cd bf       	out	0x3d, r28	; 61
  struct nicResponseHandle_t* response
      = nicReceiveResponse();
    1004:	0e 94 6e 19 	call	0x32dc	; 0x32dc <nicReceiveResponse>
    1008:	8c 01       	movw	r16, r24
        
  if (response == NULL)
    100a:	00 97       	sbiw	r24, 0x00	; 0
    100c:	39 f0       	breq	.+14     	; 0x101c <onEthernet+0x30>

// putString_com1("Ether-Empfangen");


  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
    100e:	0e 94 b7 18 	call	0x316e	; 0x316e <nicResponseSize>
    1012:	0e 97       	sbiw	r24, 0x0e	; 14
    1014:	70 f4       	brcc	.+28     	; 0x1032 <onEthernet+0x46>
        
  if (response == NULL)
    return;
    
  onEthernetResponse(response);
  nicFreeResponse(response);
    1016:	c8 01       	movw	r24, r16
    1018:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <nicFreeResponse>
}
    101c:	2e 96       	adiw	r28, 0x0e	; 14
    101e:	0f b6       	in	r0, 0x3f	; 63
    1020:	f8 94       	cli
    1022:	de bf       	out	0x3e, r29	; 62
    1024:	0f be       	out	0x3f, r0	; 63
    1026:	cd bf       	out	0x3d, r28	; 61
    1028:	cf 91       	pop	r28
    102a:	df 91       	pop	r29
    102c:	1f 91       	pop	r17
    102e:	0f 91       	pop	r16
    1030:	08 95       	ret
  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
	  return;
	
  struct netEthernetHeader_t header;
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
    1032:	c8 01       	movw	r24, r16
    1034:	be 01       	movw	r22, r28
    1036:	6f 5f       	subi	r22, 0xFF	; 255
    1038:	7f 4f       	sbci	r23, 0xFF	; 255
    103a:	4e e0       	ldi	r20, 0x0E	; 14
    103c:	50 e0       	ldi	r21, 0x00	; 0
    103e:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
	
  switch (header.etherType)
    1042:	8d 85       	ldd	r24, Y+13	; 0x0d
    1044:	9e 85       	ldd	r25, Y+14	; 0x0e
    1046:	88 30       	cpi	r24, 0x08	; 8
    1048:	91 05       	cpc	r25, r1
    104a:	51 f0       	breq	.+20     	; 0x1060 <onEthernet+0x74>
    104c:	88 50       	subi	r24, 0x08	; 8
    104e:	96 40       	sbci	r25, 0x06	; 6
    1050:	11 f7       	brne	.-60     	; 0x1016 <onEthernet+0x2a>
//	  putString_com1("IP-Empfangen");

      break;
    case ETHERTYPE_ARP:

      onArpResponse(handle,&(header.source));
    1052:	c8 01       	movw	r24, r16
    1054:	be 01       	movw	r22, r28
    1056:	69 5f       	subi	r22, 0xF9	; 249
    1058:	7f 4f       	sbci	r23, 0xFF	; 255
    105a:	0e 94 98 02 	call	0x530	; 0x530 <onArpResponse>
    105e:	db cf       	rjmp	.-74     	; 0x1016 <onEthernet+0x2a>
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
	
  switch (header.etherType)
  {
    case ETHERTYPE_IP4: 
      onIPv4Response(handle,&(header.source));
    1060:	c8 01       	movw	r24, r16
    1062:	be 01       	movw	r22, r28
    1064:	69 5f       	subi	r22, 0xF9	; 249
    1066:	7f 4f       	sbci	r23, 0xFF	; 255
    1068:	0e 94 14 0b 	call	0x1628	; 0x1628 <onIPv4Response>
    106c:	d4 cf       	rjmp	.-88     	; 0x1016 <onEthernet+0x2a>

0000106e <ipGetAddress>:
}

ipAddress_t* ipGetAddress()
{
  return &(hIPv4.host);
}
    106e:	8e e1       	ldi	r24, 0x1E	; 30
    1070:	91 e0       	ldi	r25, 0x01	; 1
    1072:	08 95       	ret

00001074 <ipEepromGetConfig>:

  return;
}

void ipEepromGetConfig(ipAddress_t * ip, ipAddress_t * nm, ipAddress_t * gw)
{
    1074:	8f 92       	push	r8
    1076:	9f 92       	push	r9
    1078:	af 92       	push	r10
    107a:	bf 92       	push	r11
    107c:	cf 92       	push	r12
    107e:	df 92       	push	r13
    1080:	ef 92       	push	r14
    1082:	ff 92       	push	r15
    1084:	0f 93       	push	r16
    1086:	1f 93       	push	r17
    1088:	df 93       	push	r29
    108a:	cf 93       	push	r28
    108c:	cd b7       	in	r28, 0x3d	; 61
    108e:	de b7       	in	r29, 0x3e	; 62
    1090:	2c 97       	sbiw	r28, 0x0c	; 12
    1092:	0f b6       	in	r0, 0x3f	; 63
    1094:	f8 94       	cli
    1096:	de bf       	out	0x3e, r29	; 62
    1098:	0f be       	out	0x3f, r0	; 63
    109a:	cd bf       	out	0x3d, r28	; 61
    109c:	6c 01       	movw	r12, r24
    109e:	5b 01       	movw	r10, r22
    10a0:	4a 01       	movw	r8, r20
  netIPv4Eeprom_t buf;
  if ( !EepromReadConfig((void*)IP4_EEPROM, &buf, sizeof(buf)) ) {
    10a2:	80 e0       	ldi	r24, 0x00	; 0
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	be 01       	movw	r22, r28
    10a8:	6f 5f       	subi	r22, 0xFF	; 255
    10aa:	7f 4f       	sbci	r23, 0xFF	; 255
    10ac:	4c e0       	ldi	r20, 0x0C	; 12
    10ae:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
    10b2:	88 23       	and	r24, r24
    10b4:	21 f5       	brne	.+72     	; 0x10fe <ipEepromGetConfig+0x8a>
    // return fallback settings, if eeprom data is invalid
    buf.host = hIPv4.host;
    10b6:	80 91 1e 01 	lds	r24, 0x011E
    10ba:	90 91 1f 01 	lds	r25, 0x011F
    10be:	a0 91 20 01 	lds	r26, 0x0120
    10c2:	b0 91 21 01 	lds	r27, 0x0121
    10c6:	89 83       	std	Y+1, r24	; 0x01
    10c8:	9a 83       	std	Y+2, r25	; 0x02
    10ca:	ab 83       	std	Y+3, r26	; 0x03
    10cc:	bc 83       	std	Y+4, r27	; 0x04
    buf.subnet = hIPv4.subnet;
    10ce:	80 91 26 01 	lds	r24, 0x0126
    10d2:	90 91 27 01 	lds	r25, 0x0127
    10d6:	a0 91 28 01 	lds	r26, 0x0128
    10da:	b0 91 29 01 	lds	r27, 0x0129
    10de:	8d 83       	std	Y+5, r24	; 0x05
    10e0:	9e 83       	std	Y+6, r25	; 0x06
    10e2:	af 83       	std	Y+7, r26	; 0x07
    10e4:	b8 87       	std	Y+8, r27	; 0x08
    buf.gateway = hIPv4.gateway;
    10e6:	80 91 22 01 	lds	r24, 0x0122
    10ea:	90 91 23 01 	lds	r25, 0x0123
    10ee:	a0 91 24 01 	lds	r26, 0x0124
    10f2:	b0 91 25 01 	lds	r27, 0x0125
    10f6:	89 87       	std	Y+9, r24	; 0x09
    10f8:	9a 87       	std	Y+10, r25	; 0x0a
    10fa:	ab 87       	std	Y+11, r26	; 0x0b
    10fc:	bc 87       	std	Y+12, r27	; 0x0c
  }

  // convert to host-byte-order and only assign values
  // if pointer != NULL
  if (ip)
    10fe:	c1 14       	cp	r12, r1
    1100:	d1 04       	cpc	r13, r1
    1102:	69 f1       	breq	.+90     	; 0x115e <__stack+0x5f>
  	*ip = ntohl(buf.host);
    1104:	29 81       	ldd	r18, Y+1	; 0x01
    1106:	3a 81       	ldd	r19, Y+2	; 0x02
    1108:	4b 81       	ldd	r20, Y+3	; 0x03
    110a:	5c 81       	ldd	r21, Y+4	; 0x04
    110c:	12 2f       	mov	r17, r18
    110e:	00 27       	eor	r16, r16
    1110:	ff 24       	eor	r15, r15
    1112:	ee 24       	eor	r14, r14
    1114:	85 2f       	mov	r24, r21
    1116:	99 27       	eor	r25, r25
    1118:	aa 27       	eor	r26, r26
    111a:	bb 27       	eor	r27, r27
    111c:	e8 2a       	or	r14, r24
    111e:	f9 2a       	or	r15, r25
    1120:	0a 2b       	or	r16, r26
    1122:	1b 2b       	or	r17, r27
    1124:	da 01       	movw	r26, r20
    1126:	c9 01       	movw	r24, r18
    1128:	80 70       	andi	r24, 0x00	; 0
    112a:	90 70       	andi	r25, 0x00	; 0
    112c:	b0 70       	andi	r27, 0x00	; 0
    112e:	89 2f       	mov	r24, r25
    1130:	9a 2f       	mov	r25, r26
    1132:	ab 2f       	mov	r26, r27
    1134:	bb 27       	eor	r27, r27
    1136:	e8 2a       	or	r14, r24
    1138:	f9 2a       	or	r15, r25
    113a:	0a 2b       	or	r16, r26
    113c:	1b 2b       	or	r17, r27
    113e:	20 70       	andi	r18, 0x00	; 0
    1140:	40 70       	andi	r20, 0x00	; 0
    1142:	50 70       	andi	r21, 0x00	; 0
    1144:	54 2f       	mov	r21, r20
    1146:	43 2f       	mov	r20, r19
    1148:	32 2f       	mov	r19, r18
    114a:	22 27       	eor	r18, r18
    114c:	e2 2a       	or	r14, r18
    114e:	f3 2a       	or	r15, r19
    1150:	04 2b       	or	r16, r20
    1152:	15 2b       	or	r17, r21
    1154:	f6 01       	movw	r30, r12
    1156:	e0 82       	st	Z, r14
    1158:	f1 82       	std	Z+1, r15	; 0x01
    115a:	02 83       	std	Z+2, r16	; 0x02
    115c:	13 83       	std	Z+3, r17	; 0x03
  if (nm)
    115e:	a1 14       	cp	r10, r1
    1160:	b1 04       	cpc	r11, r1
    1162:	69 f1       	breq	.+90     	; 0x11be <__stack+0xbf>
    *nm = ntohl(buf.subnet);
    1164:	2d 81       	ldd	r18, Y+5	; 0x05
    1166:	3e 81       	ldd	r19, Y+6	; 0x06
    1168:	4f 81       	ldd	r20, Y+7	; 0x07
    116a:	58 85       	ldd	r21, Y+8	; 0x08
    116c:	12 2f       	mov	r17, r18
    116e:	00 27       	eor	r16, r16
    1170:	ff 24       	eor	r15, r15
    1172:	ee 24       	eor	r14, r14
    1174:	85 2f       	mov	r24, r21
    1176:	99 27       	eor	r25, r25
    1178:	aa 27       	eor	r26, r26
    117a:	bb 27       	eor	r27, r27
    117c:	e8 2a       	or	r14, r24
    117e:	f9 2a       	or	r15, r25
    1180:	0a 2b       	or	r16, r26
    1182:	1b 2b       	or	r17, r27
    1184:	da 01       	movw	r26, r20
    1186:	c9 01       	movw	r24, r18
    1188:	80 70       	andi	r24, 0x00	; 0
    118a:	90 70       	andi	r25, 0x00	; 0
    118c:	b0 70       	andi	r27, 0x00	; 0
    118e:	89 2f       	mov	r24, r25
    1190:	9a 2f       	mov	r25, r26
    1192:	ab 2f       	mov	r26, r27
    1194:	bb 27       	eor	r27, r27
    1196:	e8 2a       	or	r14, r24
    1198:	f9 2a       	or	r15, r25
    119a:	0a 2b       	or	r16, r26
    119c:	1b 2b       	or	r17, r27
    119e:	20 70       	andi	r18, 0x00	; 0
    11a0:	40 70       	andi	r20, 0x00	; 0
    11a2:	50 70       	andi	r21, 0x00	; 0
    11a4:	54 2f       	mov	r21, r20
    11a6:	43 2f       	mov	r20, r19
    11a8:	32 2f       	mov	r19, r18
    11aa:	22 27       	eor	r18, r18
    11ac:	e2 2a       	or	r14, r18
    11ae:	f3 2a       	or	r15, r19
    11b0:	04 2b       	or	r16, r20
    11b2:	15 2b       	or	r17, r21
    11b4:	f5 01       	movw	r30, r10
    11b6:	e0 82       	st	Z, r14
    11b8:	f1 82       	std	Z+1, r15	; 0x01
    11ba:	02 83       	std	Z+2, r16	; 0x02
    11bc:	13 83       	std	Z+3, r17	; 0x03
  if (gw)
    11be:	81 14       	cp	r8, r1
    11c0:	91 04       	cpc	r9, r1
    11c2:	69 f1       	breq	.+90     	; 0x121e <__stack+0x11f>
  	*gw = ntohl(buf.gateway);
    11c4:	29 85       	ldd	r18, Y+9	; 0x09
    11c6:	3a 85       	ldd	r19, Y+10	; 0x0a
    11c8:	4b 85       	ldd	r20, Y+11	; 0x0b
    11ca:	5c 85       	ldd	r21, Y+12	; 0x0c
    11cc:	12 2f       	mov	r17, r18
    11ce:	00 27       	eor	r16, r16
    11d0:	ff 24       	eor	r15, r15
    11d2:	ee 24       	eor	r14, r14
    11d4:	85 2f       	mov	r24, r21
    11d6:	99 27       	eor	r25, r25
    11d8:	aa 27       	eor	r26, r26
    11da:	bb 27       	eor	r27, r27
    11dc:	e8 2a       	or	r14, r24
    11de:	f9 2a       	or	r15, r25
    11e0:	0a 2b       	or	r16, r26
    11e2:	1b 2b       	or	r17, r27
    11e4:	da 01       	movw	r26, r20
    11e6:	c9 01       	movw	r24, r18
    11e8:	80 70       	andi	r24, 0x00	; 0
    11ea:	90 70       	andi	r25, 0x00	; 0
    11ec:	b0 70       	andi	r27, 0x00	; 0
    11ee:	89 2f       	mov	r24, r25
    11f0:	9a 2f       	mov	r25, r26
    11f2:	ab 2f       	mov	r26, r27
    11f4:	bb 27       	eor	r27, r27
    11f6:	e8 2a       	or	r14, r24
    11f8:	f9 2a       	or	r15, r25
    11fa:	0a 2b       	or	r16, r26
    11fc:	1b 2b       	or	r17, r27
    11fe:	20 70       	andi	r18, 0x00	; 0
    1200:	40 70       	andi	r20, 0x00	; 0
    1202:	50 70       	andi	r21, 0x00	; 0
    1204:	54 2f       	mov	r21, r20
    1206:	43 2f       	mov	r20, r19
    1208:	32 2f       	mov	r19, r18
    120a:	22 27       	eor	r18, r18
    120c:	e2 2a       	or	r14, r18
    120e:	f3 2a       	or	r15, r19
    1210:	04 2b       	or	r16, r20
    1212:	15 2b       	or	r17, r21
    1214:	f4 01       	movw	r30, r8
    1216:	e0 82       	st	Z, r14
    1218:	f1 82       	std	Z+1, r15	; 0x01
    121a:	02 83       	std	Z+2, r16	; 0x02
    121c:	13 83       	std	Z+3, r17	; 0x03

  return;
}
    121e:	2c 96       	adiw	r28, 0x0c	; 12
    1220:	0f b6       	in	r0, 0x3f	; 63
    1222:	f8 94       	cli
    1224:	de bf       	out	0x3e, r29	; 62
    1226:	0f be       	out	0x3f, r0	; 63
    1228:	cd bf       	out	0x3d, r28	; 61
    122a:	cf 91       	pop	r28
    122c:	df 91       	pop	r29
    122e:	1f 91       	pop	r17
    1230:	0f 91       	pop	r16
    1232:	ff 90       	pop	r15
    1234:	ef 90       	pop	r14
    1236:	df 90       	pop	r13
    1238:	cf 90       	pop	r12
    123a:	bf 90       	pop	r11
    123c:	af 90       	pop	r10
    123e:	9f 90       	pop	r9
    1240:	8f 90       	pop	r8
    1242:	08 95       	ret

00001244 <onInitIPv4>:
{
  return &(hIPv4.host);
}

void onInitIPv4()
{
    1244:	df 93       	push	r29
    1246:	cf 93       	push	r28
    1248:	cd b7       	in	r28, 0x3d	; 61
    124a:	de b7       	in	r29, 0x3e	; 62
    124c:	2c 97       	sbiw	r28, 0x0c	; 12
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	f8 94       	cli
    1252:	de bf       	out	0x3e, r29	; 62
    1254:	0f be       	out	0x3f, r0	; 63
    1256:	cd bf       	out	0x3d, r28	; 61
  // define a struct for the configuration...
  netIPv4Eeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)IP4_EEPROM, &buf, sizeof(buf)) ) { 
    1258:	80 e0       	ldi	r24, 0x00	; 0
    125a:	91 e0       	ldi	r25, 0x01	; 1
    125c:	be 01       	movw	r22, r28
    125e:	6f 5f       	subi	r22, 0xFF	; 255
    1260:	7f 4f       	sbci	r23, 0xFF	; 255
    1262:	4c e0       	ldi	r20, 0x0C	; 12
    1264:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
    1268:	88 23       	and	r24, r24
    126a:	21 f1       	breq	.+72     	; 0x12b4 <onInitIPv4+0x70>
    hIPv4.host    = buf.host;
    126c:	89 81       	ldd	r24, Y+1	; 0x01
    126e:	9a 81       	ldd	r25, Y+2	; 0x02
    1270:	ab 81       	ldd	r26, Y+3	; 0x03
    1272:	bc 81       	ldd	r27, Y+4	; 0x04
    1274:	80 93 1e 01 	sts	0x011E, r24
    1278:	90 93 1f 01 	sts	0x011F, r25
    127c:	a0 93 20 01 	sts	0x0120, r26
    1280:	b0 93 21 01 	sts	0x0121, r27
    hIPv4.gateway = buf.gateway;
    1284:	89 85       	ldd	r24, Y+9	; 0x09
    1286:	9a 85       	ldd	r25, Y+10	; 0x0a
    1288:	ab 85       	ldd	r26, Y+11	; 0x0b
    128a:	bc 85       	ldd	r27, Y+12	; 0x0c
    128c:	80 93 22 01 	sts	0x0122, r24
    1290:	90 93 23 01 	sts	0x0123, r25
    1294:	a0 93 24 01 	sts	0x0124, r26
    1298:	b0 93 25 01 	sts	0x0125, r27
    hIPv4.subnet  = buf.subnet;
    129c:	8d 81       	ldd	r24, Y+5	; 0x05
    129e:	9e 81       	ldd	r25, Y+6	; 0x06
    12a0:	af 81       	ldd	r26, Y+7	; 0x07
    12a2:	b8 85       	ldd	r27, Y+8	; 0x08
    12a4:	80 93 26 01 	sts	0x0126, r24
    12a8:	90 93 27 01 	sts	0x0127, r25
    12ac:	a0 93 28 01 	sts	0x0128, r26
    12b0:	b0 93 29 01 	sts	0x0129, r27
  }
  // else hIPv4 keeps the fallback settings
    
  return;
}
    12b4:	2c 96       	adiw	r28, 0x0c	; 12
    12b6:	0f b6       	in	r0, 0x3f	; 63
    12b8:	f8 94       	cli
    12ba:	de bf       	out	0x3e, r29	; 62
    12bc:	0f be       	out	0x3f, r0	; 63
    12be:	cd bf       	out	0x3d, r28	; 61
    12c0:	cf 91       	pop	r28
    12c2:	df 91       	pop	r29
    12c4:	08 95       	ret

000012c6 <ipEepromSetConfig>:

#ifdef REQUIRES_RCFG

void ipEepromSetConfig(ipAddress_t ip, ipAddress_t nm, ipAddress_t gw)
{
    12c6:	4f 92       	push	r4
    12c8:	5f 92       	push	r5
    12ca:	6f 92       	push	r6
    12cc:	7f 92       	push	r7
    12ce:	8f 92       	push	r8
    12d0:	9f 92       	push	r9
    12d2:	af 92       	push	r10
    12d4:	bf 92       	push	r11
    12d6:	cf 92       	push	r12
    12d8:	df 92       	push	r13
    12da:	ef 92       	push	r14
    12dc:	ff 92       	push	r15
    12de:	0f 93       	push	r16
    12e0:	1f 93       	push	r17
    12e2:	df 93       	push	r29
    12e4:	cf 93       	push	r28
    12e6:	cd b7       	in	r28, 0x3d	; 61
    12e8:	de b7       	in	r29, 0x3e	; 62
    12ea:	2c 97       	sbiw	r28, 0x0c	; 12
    12ec:	0f b6       	in	r0, 0x3f	; 63
    12ee:	f8 94       	cli
    12f0:	de bf       	out	0x3e, r29	; 62
    12f2:	0f be       	out	0x3f, r0	; 63
    12f4:	cd bf       	out	0x3d, r28	; 61
    12f6:	5b 01       	movw	r10, r22
    12f8:	6c 01       	movw	r12, r24
    12fa:	39 01       	movw	r6, r18
    12fc:	4a 01       	movw	r8, r20
  netIPv4Eeprom_t buf;
  if ( !EepromReadConfig((void*)IP4_EEPROM, &buf, sizeof(buf)) )
    12fe:	80 e0       	ldi	r24, 0x00	; 0
    1300:	91 e0       	ldi	r25, 0x01	; 1
    1302:	2e 01       	movw	r4, r28
    1304:	08 94       	sec
    1306:	41 1c       	adc	r4, r1
    1308:	51 1c       	adc	r5, r1
    130a:	b2 01       	movw	r22, r4
    130c:	4c e0       	ldi	r20, 0x0C	; 12
    130e:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
    1312:	88 23       	and	r24, r24
    1314:	21 f5       	brne	.+72     	; 0x135e <ipEepromSetConfig+0x98>
  {
    // if eeprom data is invalid,
    // create new configuration based upon the fallback settings
    buf.host = hIPv4.host;
    1316:	80 91 1e 01 	lds	r24, 0x011E
    131a:	90 91 1f 01 	lds	r25, 0x011F
    131e:	a0 91 20 01 	lds	r26, 0x0120
    1322:	b0 91 21 01 	lds	r27, 0x0121
    1326:	89 83       	std	Y+1, r24	; 0x01
    1328:	9a 83       	std	Y+2, r25	; 0x02
    132a:	ab 83       	std	Y+3, r26	; 0x03
    132c:	bc 83       	std	Y+4, r27	; 0x04
    buf.subnet = hIPv4.subnet;
    132e:	80 91 26 01 	lds	r24, 0x0126
    1332:	90 91 27 01 	lds	r25, 0x0127
    1336:	a0 91 28 01 	lds	r26, 0x0128
    133a:	b0 91 29 01 	lds	r27, 0x0129
    133e:	8d 83       	std	Y+5, r24	; 0x05
    1340:	9e 83       	std	Y+6, r25	; 0x06
    1342:	af 83       	std	Y+7, r26	; 0x07
    1344:	b8 87       	std	Y+8, r27	; 0x08
    buf.gateway = hIPv4.gateway;
    1346:	80 91 22 01 	lds	r24, 0x0122
    134a:	90 91 23 01 	lds	r25, 0x0123
    134e:	a0 91 24 01 	lds	r26, 0x0124
    1352:	b0 91 25 01 	lds	r27, 0x0125
    1356:	89 87       	std	Y+9, r24	; 0x09
    1358:	9a 87       	std	Y+10, r25	; 0x0a
    135a:	ab 87       	std	Y+11, r26	; 0x0b
    135c:	bc 87       	std	Y+12, r27	; 0x0c
  }

  // set new values (network-byte-order!)
  if (ip != 0)
    135e:	a1 14       	cp	r10, r1
    1360:	b1 04       	cpc	r11, r1
    1362:	c1 04       	cpc	r12, r1
    1364:	d1 04       	cpc	r13, r1
    1366:	69 f1       	breq	.+90     	; 0x13c2 <ipEepromSetConfig+0xfc>
    buf.host = htonl(ip);
    1368:	5a 2d       	mov	r21, r10
    136a:	44 27       	eor	r20, r20
    136c:	33 27       	eor	r19, r19
    136e:	22 27       	eor	r18, r18
    1370:	8d 2d       	mov	r24, r13
    1372:	99 27       	eor	r25, r25
    1374:	aa 27       	eor	r26, r26
    1376:	bb 27       	eor	r27, r27
    1378:	28 2b       	or	r18, r24
    137a:	39 2b       	or	r19, r25
    137c:	4a 2b       	or	r20, r26
    137e:	5b 2b       	or	r21, r27
    1380:	d6 01       	movw	r26, r12
    1382:	c5 01       	movw	r24, r10
    1384:	80 70       	andi	r24, 0x00	; 0
    1386:	90 70       	andi	r25, 0x00	; 0
    1388:	b0 70       	andi	r27, 0x00	; 0
    138a:	89 2f       	mov	r24, r25
    138c:	9a 2f       	mov	r25, r26
    138e:	ab 2f       	mov	r26, r27
    1390:	bb 27       	eor	r27, r27
    1392:	28 2b       	or	r18, r24
    1394:	39 2b       	or	r19, r25
    1396:	4a 2b       	or	r20, r26
    1398:	5b 2b       	or	r21, r27
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	9f ef       	ldi	r25, 0xFF	; 255
    139e:	a0 e0       	ldi	r26, 0x00	; 0
    13a0:	b0 e0       	ldi	r27, 0x00	; 0
    13a2:	a8 22       	and	r10, r24
    13a4:	b9 22       	and	r11, r25
    13a6:	ca 22       	and	r12, r26
    13a8:	db 22       	and	r13, r27
    13aa:	bc 2d       	mov	r27, r12
    13ac:	ab 2d       	mov	r26, r11
    13ae:	9a 2d       	mov	r25, r10
    13b0:	88 27       	eor	r24, r24
    13b2:	28 2b       	or	r18, r24
    13b4:	39 2b       	or	r19, r25
    13b6:	4a 2b       	or	r20, r26
    13b8:	5b 2b       	or	r21, r27
    13ba:	29 83       	std	Y+1, r18	; 0x01
    13bc:	3a 83       	std	Y+2, r19	; 0x02
    13be:	4b 83       	std	Y+3, r20	; 0x03
    13c0:	5c 83       	std	Y+4, r21	; 0x04

  if (nm != 0)
    13c2:	61 14       	cp	r6, r1
    13c4:	71 04       	cpc	r7, r1
    13c6:	81 04       	cpc	r8, r1
    13c8:	91 04       	cpc	r9, r1
    13ca:	69 f1       	breq	.+90     	; 0x1426 <ipEepromSetConfig+0x160>
    buf.subnet = htonl(nm);
    13cc:	56 2d       	mov	r21, r6
    13ce:	44 27       	eor	r20, r20
    13d0:	33 27       	eor	r19, r19
    13d2:	22 27       	eor	r18, r18
    13d4:	89 2d       	mov	r24, r9
    13d6:	99 27       	eor	r25, r25
    13d8:	aa 27       	eor	r26, r26
    13da:	bb 27       	eor	r27, r27
    13dc:	28 2b       	or	r18, r24
    13de:	39 2b       	or	r19, r25
    13e0:	4a 2b       	or	r20, r26
    13e2:	5b 2b       	or	r21, r27
    13e4:	d4 01       	movw	r26, r8
    13e6:	c3 01       	movw	r24, r6
    13e8:	80 70       	andi	r24, 0x00	; 0
    13ea:	90 70       	andi	r25, 0x00	; 0
    13ec:	b0 70       	andi	r27, 0x00	; 0
    13ee:	89 2f       	mov	r24, r25
    13f0:	9a 2f       	mov	r25, r26
    13f2:	ab 2f       	mov	r26, r27
    13f4:	bb 27       	eor	r27, r27
    13f6:	28 2b       	or	r18, r24
    13f8:	39 2b       	or	r19, r25
    13fa:	4a 2b       	or	r20, r26
    13fc:	5b 2b       	or	r21, r27
    13fe:	80 e0       	ldi	r24, 0x00	; 0
    1400:	9f ef       	ldi	r25, 0xFF	; 255
    1402:	a0 e0       	ldi	r26, 0x00	; 0
    1404:	b0 e0       	ldi	r27, 0x00	; 0
    1406:	68 22       	and	r6, r24
    1408:	79 22       	and	r7, r25
    140a:	8a 22       	and	r8, r26
    140c:	9b 22       	and	r9, r27
    140e:	b8 2d       	mov	r27, r8
    1410:	a7 2d       	mov	r26, r7
    1412:	96 2d       	mov	r25, r6
    1414:	88 27       	eor	r24, r24
    1416:	28 2b       	or	r18, r24
    1418:	39 2b       	or	r19, r25
    141a:	4a 2b       	or	r20, r26
    141c:	5b 2b       	or	r21, r27
    141e:	2d 83       	std	Y+5, r18	; 0x05
    1420:	3e 83       	std	Y+6, r19	; 0x06
    1422:	4f 83       	std	Y+7, r20	; 0x07
    1424:	58 87       	std	Y+8, r21	; 0x08

  if (gw != 0)
    1426:	e1 14       	cp	r14, r1
    1428:	f1 04       	cpc	r15, r1
    142a:	01 05       	cpc	r16, r1
    142c:	11 05       	cpc	r17, r1
    142e:	69 f1       	breq	.+90     	; 0x148a <ipEepromSetConfig+0x1c4>
    buf.gateway = htonl(gw);
    1430:	5e 2d       	mov	r21, r14
    1432:	44 27       	eor	r20, r20
    1434:	33 27       	eor	r19, r19
    1436:	22 27       	eor	r18, r18
    1438:	81 2f       	mov	r24, r17
    143a:	99 27       	eor	r25, r25
    143c:	aa 27       	eor	r26, r26
    143e:	bb 27       	eor	r27, r27
    1440:	28 2b       	or	r18, r24
    1442:	39 2b       	or	r19, r25
    1444:	4a 2b       	or	r20, r26
    1446:	5b 2b       	or	r21, r27
    1448:	d8 01       	movw	r26, r16
    144a:	c7 01       	movw	r24, r14
    144c:	80 70       	andi	r24, 0x00	; 0
    144e:	90 70       	andi	r25, 0x00	; 0
    1450:	b0 70       	andi	r27, 0x00	; 0
    1452:	89 2f       	mov	r24, r25
    1454:	9a 2f       	mov	r25, r26
    1456:	ab 2f       	mov	r26, r27
    1458:	bb 27       	eor	r27, r27
    145a:	28 2b       	or	r18, r24
    145c:	39 2b       	or	r19, r25
    145e:	4a 2b       	or	r20, r26
    1460:	5b 2b       	or	r21, r27
    1462:	80 e0       	ldi	r24, 0x00	; 0
    1464:	9f ef       	ldi	r25, 0xFF	; 255
    1466:	a0 e0       	ldi	r26, 0x00	; 0
    1468:	b0 e0       	ldi	r27, 0x00	; 0
    146a:	e8 22       	and	r14, r24
    146c:	f9 22       	and	r15, r25
    146e:	0a 23       	and	r16, r26
    1470:	1b 23       	and	r17, r27
    1472:	b0 2f       	mov	r27, r16
    1474:	af 2d       	mov	r26, r15
    1476:	9e 2d       	mov	r25, r14
    1478:	88 27       	eor	r24, r24
    147a:	28 2b       	or	r18, r24
    147c:	39 2b       	or	r19, r25
    147e:	4a 2b       	or	r20, r26
    1480:	5b 2b       	or	r21, r27
    1482:	29 87       	std	Y+9, r18	; 0x09
    1484:	3a 87       	std	Y+10, r19	; 0x0a
    1486:	4b 87       	std	Y+11, r20	; 0x0b
    1488:	5c 87       	std	Y+12, r21	; 0x0c

  EepromWriteConfig((void*)IP4_EEPROM, &buf, sizeof(buf));
    148a:	80 e0       	ldi	r24, 0x00	; 0
    148c:	91 e0       	ldi	r25, 0x01	; 1
    148e:	b2 01       	movw	r22, r4
    1490:	4c e0       	ldi	r20, 0x0C	; 12
    1492:	0e 94 49 2a 	call	0x5492	; 0x5492 <EepromWriteConfig>

  return;
}
    1496:	2c 96       	adiw	r28, 0x0c	; 12
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	cf 91       	pop	r28
    14a4:	df 91       	pop	r29
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	ff 90       	pop	r15
    14ac:	ef 90       	pop	r14
    14ae:	df 90       	pop	r13
    14b0:	cf 90       	pop	r12
    14b2:	bf 90       	pop	r11
    14b4:	af 90       	pop	r10
    14b6:	9f 90       	pop	r9
    14b8:	8f 90       	pop	r8
    14ba:	7f 90       	pop	r7
    14bc:	6f 90       	pop	r6
    14be:	5f 90       	pop	r5
    14c0:	4f 90       	pop	r4
    14c2:	08 95       	ret

000014c4 <onIPv4Request>:
  
  return;
}

uint8_t onIPv4Request(struct nicRequestHandle_t* handle, ipAddress_t* destIP, uint8_t protocol)
{
    14c4:	8f 92       	push	r8
    14c6:	9f 92       	push	r9
    14c8:	af 92       	push	r10
    14ca:	bf 92       	push	r11
    14cc:	cf 92       	push	r12
    14ce:	df 92       	push	r13
    14d0:	ef 92       	push	r14
    14d2:	ff 92       	push	r15
    14d4:	0f 93       	push	r16
    14d6:	1f 93       	push	r17
    14d8:	df 93       	push	r29
    14da:	cf 93       	push	r28
    14dc:	00 d0       	rcall	.+0      	; 0x14de <onIPv4Request+0x1a>
    14de:	00 d0       	rcall	.+0      	; 0x14e0 <onIPv4Request+0x1c>
    14e0:	00 d0       	rcall	.+0      	; 0x14e2 <onIPv4Request+0x1e>
    14e2:	cd b7       	in	r28, 0x3d	; 61
    14e4:	de b7       	in	r29, 0x3e	; 62
    14e6:	5c 01       	movw	r10, r24
    14e8:	6b 01       	movw	r12, r22
    14ea:	e4 2e       	mov	r14, r20
  
  
  // check if destination address is within the subnet...
  // ... in case it is not, we have to send the packet to the gateway ...
  // ... yes this nested if is nasty, but we need the performance.
  if (arpLookupMacByIPv4(
    14ec:	fb 01       	movw	r30, r22
    14ee:	80 81       	ld	r24, Z
    14f0:	91 81       	ldd	r25, Z+1	; 0x01
    14f2:	a2 81       	ldd	r26, Z+2	; 0x02
    14f4:	b3 81       	ldd	r27, Z+3	; 0x03
    14f6:	20 91 22 01 	lds	r18, 0x0122
    14fa:	30 91 23 01 	lds	r19, 0x0123
    14fe:	40 91 24 01 	lds	r20, 0x0124
    1502:	50 91 25 01 	lds	r21, 0x0125
    1506:	82 27       	eor	r24, r18
    1508:	93 27       	eor	r25, r19
    150a:	a4 27       	eor	r26, r20
    150c:	b5 27       	eor	r27, r21
    150e:	20 91 26 01 	lds	r18, 0x0126
    1512:	30 91 27 01 	lds	r19, 0x0127
    1516:	40 91 28 01 	lds	r20, 0x0128
    151a:	50 91 29 01 	lds	r21, 0x0129
    151e:	82 23       	and	r24, r18
    1520:	93 23       	and	r25, r19
    1522:	a4 23       	and	r26, r20
    1524:	b5 23       	and	r27, r21
    1526:	00 97       	sbiw	r24, 0x00	; 0
    1528:	a1 05       	cpc	r26, r1
    152a:	b1 05       	cpc	r27, r1
    152c:	09 f0       	breq	.+2      	; 0x1530 <onIPv4Request+0x6c>
    152e:	74 c0       	rjmp	.+232    	; 0x1618 <onIPv4Request+0x154>
    1530:	cb 01       	movw	r24, r22
    1532:	4e 01       	movw	r8, r28
    1534:	08 94       	sec
    1536:	81 1c       	adc	r8, r1
    1538:	91 1c       	adc	r9, r1
    153a:	b4 01       	movw	r22, r8
    153c:	0e 94 6f 03 	call	0x6de	; 0x6de <arpLookupMacByIPv4>
    1540:	88 23       	and	r24, r24
    1542:	09 f0       	breq	.+2      	; 0x1546 <onIPv4Request+0x82>
    1544:	6c c0       	rjmp	.+216    	; 0x161e <onIPv4Request+0x15a>
    return 1;    
  }

  // we passed the lookup, so it is save to assemble the IP header... 
  struct netIPv4Header_t* header
    = (struct netIPv4Header_t*) nicAddPacketHeader(handle,sizeof(struct netIPv4Header_t));
    1546:	c5 01       	movw	r24, r10
    1548:	64 e1       	ldi	r22, 0x14	; 20
    154a:	70 e0       	ldi	r23, 0x00	; 0
    154c:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
    1550:	8c 01       	movw	r16, r24

  //putString_com1("Fkt : onIPv4Request 2\r\n");
  
  
    // generate the IP Header...
  header->version        = ((0x4 << 4) & 0xF0 )| ( sizeof(struct netIPv4Header_t) >> 2 );
    1552:	85 e4       	ldi	r24, 0x45	; 69
    1554:	f8 01       	movw	r30, r16
    1556:	80 83       	st	Z, r24
  header->typeOfService  = 0x00;
    1558:	11 82       	std	Z+1, r1	; 0x01
  header->totalLength    = htons(nicGetPacketSize(handle));
    155a:	c5 01       	movw	r24, r10
    155c:	0e 94 a8 18 	call	0x3150	; 0x3150 <nicGetPacketSize>
    1560:	f9 2e       	mov	r15, r25
    1562:	c5 01       	movw	r24, r10
    1564:	0e 94 a8 18 	call	0x3150	; 0x3150 <nicGetPacketSize>
    1568:	38 2f       	mov	r19, r24
    156a:	20 e0       	ldi	r18, 0x00	; 0
    156c:	8f 2d       	mov	r24, r15
    156e:	90 e0       	ldi	r25, 0x00	; 0
    1570:	28 2b       	or	r18, r24
    1572:	39 2b       	or	r19, r25
    1574:	f8 01       	movw	r30, r16
    1576:	33 83       	std	Z+3, r19	; 0x03
    1578:	22 83       	std	Z+2, r18	; 0x02
  header->identification = htons(hIPv4.identification);
    157a:	90 91 2a 01 	lds	r25, 0x012A
    157e:	80 91 2b 01 	lds	r24, 0x012B
    1582:	84 83       	std	Z+4, r24	; 0x04
    1584:	95 83       	std	Z+5, r25	; 0x05
  
  header->destIP = *destIP;
    1586:	f6 01       	movw	r30, r12
    1588:	80 81       	ld	r24, Z
    158a:	91 81       	ldd	r25, Z+1	; 0x01
    158c:	a2 81       	ldd	r26, Z+2	; 0x02
    158e:	b3 81       	ldd	r27, Z+3	; 0x03
    1590:	f8 01       	movw	r30, r16
    1592:	80 8b       	std	Z+16, r24	; 0x10
    1594:	91 8b       	std	Z+17, r25	; 0x11
    1596:	a2 8b       	std	Z+18, r26	; 0x12
    1598:	b3 8b       	std	Z+19, r27	; 0x13
  header->srcIP  = *ipGetAddress();
    159a:	80 91 1e 01 	lds	r24, 0x011E
    159e:	90 91 1f 01 	lds	r25, 0x011F
    15a2:	a0 91 20 01 	lds	r26, 0x0120
    15a6:	b0 91 21 01 	lds	r27, 0x0121
    15aa:	84 87       	std	Z+12, r24	; 0x0c
    15ac:	95 87       	std	Z+13, r25	; 0x0d
    15ae:	a6 87       	std	Z+14, r26	; 0x0e
    15b0:	b7 87       	std	Z+15, r27	; 0x0f
  
  hIPv4.identification++;
    15b2:	80 91 2a 01 	lds	r24, 0x012A
    15b6:	90 91 2b 01 	lds	r25, 0x012B
    15ba:	01 96       	adiw	r24, 0x01	; 1
    15bc:	90 93 2b 01 	sts	0x012B, r25
    15c0:	80 93 2a 01 	sts	0x012A, r24
  
  header->fragmentation  = htons(0x4000);
    15c4:	80 e4       	ldi	r24, 0x40	; 64
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	97 83       	std	Z+7, r25	; 0x07
    15ca:	86 83       	std	Z+6, r24	; 0x06
  header->timeToLive     = 128;
    15cc:	80 e8       	ldi	r24, 0x80	; 128
    15ce:	80 87       	std	Z+8, r24	; 0x08
  header->protocol       = protocol;
    15d0:	e1 86       	std	Z+9, r14	; 0x09
 
  // when calculation the header checksum, it is assumed, that... 
  // ... the checksum itself is set to 0x00 
  header->headerCheckSum = 0x00;
    15d2:	13 86       	std	Z+11, r1	; 0x0b
    15d4:	12 86       	std	Z+10, r1	; 0x0a
  header->headerCheckSum 
    15d6:	c8 01       	movw	r24, r16
    15d8:	64 e1       	ldi	r22, 0x14	; 20
    15da:	70 e0       	ldi	r23, 0x00	; 0
    15dc:	0e 94 bd 1a 	call	0x357a	; 0x357a <calculateCheckSum>
    15e0:	f8 01       	movw	r30, r16
    15e2:	93 87       	std	Z+11, r25	; 0x0b
    15e4:	82 87       	std	Z+10, r24	; 0x0a
      = calculateCheckSum(header,sizeof(struct netIPv4Header_t));
    
  return onEthernetRequest(handle,ETHERTYPE_IP4, &mac);
    15e6:	c5 01       	movw	r24, r10
    15e8:	68 e0       	ldi	r22, 0x08	; 8
    15ea:	70 e0       	ldi	r23, 0x00	; 0
    15ec:	a4 01       	movw	r20, r8
    15ee:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
}
    15f2:	26 96       	adiw	r28, 0x06	; 6
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	f8 94       	cli
    15f8:	de bf       	out	0x3e, r29	; 62
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	cd bf       	out	0x3d, r28	; 61
    15fe:	cf 91       	pop	r28
    1600:	df 91       	pop	r29
    1602:	1f 91       	pop	r17
    1604:	0f 91       	pop	r16
    1606:	ff 90       	pop	r15
    1608:	ef 90       	pop	r14
    160a:	df 90       	pop	r13
    160c:	cf 90       	pop	r12
    160e:	bf 90       	pop	r11
    1610:	af 90       	pop	r10
    1612:	9f 90       	pop	r9
    1614:	8f 90       	pop	r8
    1616:	08 95       	ret
  
  
  // check if destination address is within the subnet...
  // ... in case it is not, we have to send the packet to the gateway ...
  // ... yes this nested if is nasty, but we need the performance.
  if (arpLookupMacByIPv4(
    1618:	82 e2       	ldi	r24, 0x22	; 34
    161a:	91 e0       	ldi	r25, 0x01	; 1
    161c:	8a cf       	rjmp	.-236    	; 0x1532 <onIPv4Request+0x6e>
      ((((*destIP) & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))?destIP:&hIPv4.gateway),
      &mac) != 0)
  {
    nicFreeRequest(handle);
    161e:	c5 01       	movw	r24, r10
    1620:	0e 94 03 19 	call	0x3206	; 0x3206 <nicFreeRequest>
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	e5 cf       	rjmp	.-54     	; 0x15f2 <onIPv4Request+0x12e>

00001628 <onIPv4Response>:
  ipAddress_t subnet;
  ipAddress_t gateway;
} netIPv4Eeprom_t;

void onIPv4Response(struct nicResponseHandle_t* handle, struct macAddress_t* source)
{
    1628:	ef 92       	push	r14
    162a:	ff 92       	push	r15
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	df 93       	push	r29
    1632:	cf 93       	push	r28
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
    1638:	64 97       	sbiw	r28, 0x14	; 20
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	de bf       	out	0x3e, r29	; 62
    1640:	0f be       	out	0x3f, r0	; 63
    1642:	cd bf       	out	0x3d, r28	; 61
    1644:	8c 01       	movw	r16, r24
    1646:	7b 01       	movw	r14, r22



  // if the packet length beyond expectation, drop it...
  if (nicResponseSize(handle) < sizeof(struct netIPv4Header_t))
    1648:	0e 94 b7 18 	call	0x316e	; 0x316e <nicResponseSize>
    164c:	44 97       	sbiw	r24, 0x14	; 20
    164e:	68 f4       	brcc	.+26     	; 0x166a <onIPv4Response+0x42>
      onUdpResponse(handle, &header.srcIP);
      break;
  }
  
  return;
}
    1650:	64 96       	adiw	r28, 0x14	; 20
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	f8 94       	cli
    1656:	de bf       	out	0x3e, r29	; 62
    1658:	0f be       	out	0x3f, r0	; 63
    165a:	cd bf       	out	0x3d, r28	; 61
    165c:	cf 91       	pop	r28
    165e:	df 91       	pop	r29
    1660:	1f 91       	pop	r17
    1662:	0f 91       	pop	r16
    1664:	ff 90       	pop	r15
    1666:	ef 90       	pop	r14
    1668:	08 95       	ret
  if (nicResponseSize(handle) < sizeof(struct netIPv4Header_t))
    return;
  
  struct netIPv4Header_t header;
  
  nicResponseRead(handle,(char*)(&header),sizeof(struct netIPv4Header_t));
    166a:	c8 01       	movw	r24, r16
    166c:	be 01       	movw	r22, r28
    166e:	6f 5f       	subi	r22, 0xFF	; 255
    1670:	7f 4f       	sbci	r23, 0xFF	; 255
    1672:	44 e1       	ldi	r20, 0x14	; 20
    1674:	50 e0       	ldi	r21, 0x00	; 0
    1676:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
  
  // if the sender thinks, we have a different IP address...
  // ... we should definitivly drop the packet.
  if (header.destIP != *ipGetAddress())
    167a:	29 89       	ldd	r18, Y+17	; 0x11
    167c:	3a 89       	ldd	r19, Y+18	; 0x12
    167e:	4b 89       	ldd	r20, Y+19	; 0x13
    1680:	5c 89       	ldd	r21, Y+20	; 0x14
    1682:	80 91 1e 01 	lds	r24, 0x011E
    1686:	90 91 1f 01 	lds	r25, 0x011F
    168a:	a0 91 20 01 	lds	r26, 0x0120
    168e:	b0 91 21 01 	lds	r27, 0x0121
    1692:	28 17       	cp	r18, r24
    1694:	39 07       	cpc	r19, r25
    1696:	4a 07       	cpc	r20, r26
    1698:	5b 07       	cpc	r21, r27
    169a:	d1 f6       	brne	.-76     	; 0x1650 <onIPv4Response+0x28>
    return;
    
  // if knows our IP we should add him to our Arp Cache...
  // ... but ignore all MAC Multi-/Boradcasts Packets...
  // ... otherwise we could poisen our Arp Cache.  
  if ( ! (source->octet1 & (1 << 0)))
    169c:	f7 01       	movw	r30, r14
    169e:	80 81       	ld	r24, Z
    16a0:	80 fd       	sbrc	r24, 0
    16a2:	25 c0       	rjmp	.+74     	; 0x16ee <onIPv4Response+0xc6>
  {
    // we should not lean the ip address if, its not within our subnet... 
    // ... instead we should update the arp entry for the gateway
    if ((header.srcIP & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))
    16a4:	80 91 22 01 	lds	r24, 0x0122
    16a8:	90 91 23 01 	lds	r25, 0x0123
    16ac:	a0 91 24 01 	lds	r26, 0x0124
    16b0:	b0 91 25 01 	lds	r27, 0x0125
    16b4:	2d 85       	ldd	r18, Y+13	; 0x0d
    16b6:	3e 85       	ldd	r19, Y+14	; 0x0e
    16b8:	4f 85       	ldd	r20, Y+15	; 0x0f
    16ba:	58 89       	ldd	r21, Y+16	; 0x10
    16bc:	82 27       	eor	r24, r18
    16be:	93 27       	eor	r25, r19
    16c0:	a4 27       	eor	r26, r20
    16c2:	b5 27       	eor	r27, r21
    16c4:	20 91 26 01 	lds	r18, 0x0126
    16c8:	30 91 27 01 	lds	r19, 0x0127
    16cc:	40 91 28 01 	lds	r20, 0x0128
    16d0:	50 91 29 01 	lds	r21, 0x0129
    16d4:	82 23       	and	r24, r18
    16d6:	93 23       	and	r25, r19
    16d8:	a4 23       	and	r26, r20
    16da:	b5 23       	and	r27, r21
    16dc:	00 97       	sbiw	r24, 0x00	; 0
    16de:	a1 05       	cpc	r26, r1
    16e0:	b1 05       	cpc	r27, r1
    16e2:	81 f4       	brne	.+32     	; 0x1704 <onIPv4Response+0xdc>
      arpAddMacByIPv4(&header.srcIP,source);
    16e4:	ce 01       	movw	r24, r28
    16e6:	0d 96       	adiw	r24, 0x0d	; 13
    16e8:	b7 01       	movw	r22, r14
    16ea:	0e 94 93 00 	call	0x126	; 0x126 <arpAddMacByIPv4>
      arpAddMacByIPv4(&hIPv4.gateway,source);
  }
     

     
  switch (header.protocol)
    16ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    16f0:	81 31       	cpi	r24, 0x11	; 17
    16f2:	09 f0       	breq	.+2      	; 0x16f6 <onIPv4Response+0xce>
    16f4:	ad cf       	rjmp	.-166    	; 0x1650 <onIPv4Response+0x28>
  {
    case 0x11:      
	
      onUdpResponse(handle, &header.srcIP);
    16f6:	c8 01       	movw	r24, r16
    16f8:	be 01       	movw	r22, r28
    16fa:	63 5f       	subi	r22, 0xF3	; 243
    16fc:	7f 4f       	sbci	r23, 0xFF	; 255
    16fe:	0e 94 88 0b 	call	0x1710	; 0x1710 <onUdpResponse>
    1702:	a6 cf       	rjmp	.-180    	; 0x1650 <onIPv4Response+0x28>
    // we should not lean the ip address if, its not within our subnet... 
    // ... instead we should update the arp entry for the gateway
    if ((header.srcIP & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))
      arpAddMacByIPv4(&header.srcIP,source);
    else
      arpAddMacByIPv4(&hIPv4.gateway,source);
    1704:	82 e2       	ldi	r24, 0x22	; 34
    1706:	91 e0       	ldi	r25, 0x01	; 1
    1708:	b7 01       	movw	r22, r14
    170a:	0e 94 93 00 	call	0x126	; 0x126 <arpAddMacByIPv4>
    170e:	ef cf       	rjmp	.-34     	; 0x16ee <onIPv4Response+0xc6>

00001710 <onUdpResponse>:
  onIPv4Request(handle,&(dest->ip),0x11);
  return;
}

void onUdpResponse(struct nicResponseHandle_t* handle, ipAddress_t* ipAddress)
{
    1710:	ef 92       	push	r14
    1712:	ff 92       	push	r15
    1714:	0f 93       	push	r16
    1716:	1f 93       	push	r17
    1718:	df 93       	push	r29
    171a:	cf 93       	push	r28
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	2e 97       	sbiw	r28, 0x0e	; 14
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	8c 01       	movw	r16, r24
    172e:	7b 01       	movw	r14, r22
  // drop if header invalid...
  if (nicResponseSize(handle) < sizeof(struct soUdpHeader_t))
    1730:	0e 94 b7 18 	call	0x316e	; 0x316e <nicResponseSize>
    1734:	08 97       	sbiw	r24, 0x08	; 8
    1736:	68 f4       	brcc	.+26     	; 0x1752 <onUdpResponse+0x42>
      onTftpResponse(handle, &netAdr);
      break;
    #endif
  } 
  return;
}
    1738:	2e 96       	adiw	r28, 0x0e	; 14
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	de bf       	out	0x3e, r29	; 62
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	cd bf       	out	0x3d, r28	; 61
    1744:	cf 91       	pop	r28
    1746:	df 91       	pop	r29
    1748:	1f 91       	pop	r17
    174a:	0f 91       	pop	r16
    174c:	ff 90       	pop	r15
    174e:	ef 90       	pop	r14
    1750:	08 95       	ret
  // drop if header invalid...
  if (nicResponseSize(handle) < sizeof(struct soUdpHeader_t))
    return;  
  
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
    1752:	c8 01       	movw	r24, r16
    1754:	be 01       	movw	r22, r28
    1756:	69 5f       	subi	r22, 0xF9	; 249
    1758:	7f 4f       	sbci	r23, 0xFF	; 255
    175a:	48 e0       	ldi	r20, 0x08	; 8
    175c:	50 e0       	ldi	r21, 0x00	; 0
    175e:	0e 94 c2 18 	call	0x3184	; 0x3184 <nicResponseRead>
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
    1762:	f7 01       	movw	r30, r14
    1764:	20 81       	ld	r18, Z
    1766:	31 81       	ldd	r19, Z+1	; 0x01
    1768:	42 81       	ldd	r20, Z+2	; 0x02
    176a:	53 81       	ldd	r21, Z+3	; 0x03
  netAdr.port = ntohs(header.srcPort); 
    176c:	7f 81       	ldd	r23, Y+7	; 0x07
    176e:	68 85       	ldd	r22, Y+8	; 0x08


  
  switch (ntohs(header.destPort))
    1770:	99 85       	ldd	r25, Y+9	; 0x09
    1772:	8a 85       	ldd	r24, Y+10	; 0x0a
    1774:	81 56       	subi	r24, 0x61	; 97
    1776:	9e 41       	sbci	r25, 0x1E	; 30
    1778:	f9 f6       	brne	.-66     	; 0x1738 <onUdpResponse+0x28>
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
  netAdr.port = ntohs(header.srcPort); 
    177a:	6d 83       	std	Y+5, r22	; 0x05
    177c:	7e 83       	std	Y+6, r23	; 0x06
  
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
    177e:	29 83       	std	Y+1, r18	; 0x01
    1780:	3a 83       	std	Y+2, r19	; 0x02
    1782:	4b 83       	std	Y+3, r20	; 0x03
    1784:	5c 83       	std	Y+4, r21	; 0x04
  {
	

    #ifdef REQUIRES_RTP
    case RTP_SERVER_PORT  : 
      onRtpResponse(handle, &netAdr);
    1786:	c8 01       	movw	r24, r16
    1788:	be 01       	movw	r22, r28
    178a:	6f 5f       	subi	r22, 0xFF	; 255
    178c:	7f 4f       	sbci	r23, 0xFF	; 255
    178e:	0e 94 5d 04 	call	0x8ba	; 0x8ba <onRtpResponse>
    1792:	d2 cf       	rjmp	.-92     	; 0x1738 <onUdpResponse+0x28>

00001794 <onUdpRequest>:



void onUdpRequest(struct nicRequestHandle_t* handle,
    struct netAddress_t* dest, portAddress_t* srcPort)
{
    1794:	af 92       	push	r10
    1796:	bf 92       	push	r11
    1798:	cf 92       	push	r12
    179a:	df 92       	push	r13
    179c:	ef 92       	push	r14
    179e:	ff 92       	push	r15
    17a0:	0f 93       	push	r16
    17a2:	1f 93       	push	r17
    17a4:	6c 01       	movw	r12, r24
    17a6:	5b 01       	movw	r10, r22
    17a8:	7a 01       	movw	r14, r20



  // ...generate the UDP Header...
  struct soUdpHeader_t* header 
     = (struct soUdpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soUdpHeader_t));
    17aa:	68 e0       	ldi	r22, 0x08	; 8
    17ac:	70 e0       	ldi	r23, 0x00	; 0
    17ae:	0e 94 26 19 	call	0x324c	; 0x324c <nicAddPacketHeader>
    17b2:	8c 01       	movw	r16, r24
  
  header->srcPort  = htons(*srcPort);  
    17b4:	f7 01       	movw	r30, r14
    17b6:	90 81       	ld	r25, Z
    17b8:	81 81       	ldd	r24, Z+1	; 0x01
    17ba:	f8 01       	movw	r30, r16
    17bc:	80 83       	st	Z, r24
    17be:	91 83       	std	Z+1, r25	; 0x01
  header->destPort = htons(dest->port);
    17c0:	f5 01       	movw	r30, r10
    17c2:	94 81       	ldd	r25, Z+4	; 0x04
    17c4:	85 81       	ldd	r24, Z+5	; 0x05
    17c6:	f8 01       	movw	r30, r16
    17c8:	82 83       	std	Z+2, r24	; 0x02
    17ca:	93 83       	std	Z+3, r25	; 0x03
  header->checksum = 0x00;
    17cc:	17 82       	std	Z+7, r1	; 0x07
    17ce:	16 82       	std	Z+6, r1	; 0x06
  header->length   = htons(nicGetPacketSize(handle));
    17d0:	c6 01       	movw	r24, r12
    17d2:	0e 94 a8 18 	call	0x3150	; 0x3150 <nicGetPacketSize>
    17d6:	f9 2e       	mov	r15, r25
    17d8:	c6 01       	movw	r24, r12
    17da:	0e 94 a8 18 	call	0x3150	; 0x3150 <nicGetPacketSize>
    17de:	38 2f       	mov	r19, r24
    17e0:	20 e0       	ldi	r18, 0x00	; 0
    17e2:	8f 2d       	mov	r24, r15
    17e4:	90 e0       	ldi	r25, 0x00	; 0
    17e6:	28 2b       	or	r18, r24
    17e8:	39 2b       	or	r19, r25
    17ea:	f8 01       	movw	r30, r16
    17ec:	35 83       	std	Z+5, r19	; 0x05
    17ee:	24 83       	std	Z+4, r18	; 0x04


  
  onIPv4Request(handle,&(dest->ip),0x11);
    17f0:	c6 01       	movw	r24, r12
    17f2:	b5 01       	movw	r22, r10
    17f4:	41 e1       	ldi	r20, 0x11	; 17
    17f6:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <onIPv4Request>
  return;
}
    17fa:	1f 91       	pop	r17
    17fc:	0f 91       	pop	r16
    17fe:	ff 90       	pop	r15
    1800:	ef 90       	pop	r14
    1802:	df 90       	pop	r13
    1804:	cf 90       	pop	r12
    1806:	bf 90       	pop	r11
    1808:	af 90       	pop	r10
    180a:	08 95       	ret

0000180c <serialEepromGetConfig>:

  return;
}

void serialEepromGetConfig(uint16_t * prescaler, uint8_t * parity, uint8_t * stop_bits, uint8_t * data_bits, uint8_t * SendBufferSizeLimit)
{
    180c:	8f 92       	push	r8
    180e:	9f 92       	push	r9
    1810:	af 92       	push	r10
    1812:	bf 92       	push	r11
    1814:	cf 92       	push	r12
    1816:	df 92       	push	r13
    1818:	ef 92       	push	r14
    181a:	ff 92       	push	r15
    181c:	0f 93       	push	r16
    181e:	1f 93       	push	r17
    1820:	df 93       	push	r29
    1822:	cf 93       	push	r28
    1824:	00 d0       	rcall	.+0      	; 0x1826 <serialEepromGetConfig+0x1a>
    1826:	00 d0       	rcall	.+0      	; 0x1828 <serialEepromGetConfig+0x1c>
    1828:	00 d0       	rcall	.+0      	; 0x182a <serialEepromGetConfig+0x1e>
    182a:	cd b7       	in	r28, 0x3d	; 61
    182c:	de b7       	in	r29, 0x3e	; 62
    182e:	7c 01       	movw	r14, r24
    1830:	6b 01       	movw	r12, r22
    1832:	5a 01       	movw	r10, r20
    1834:	49 01       	movw	r8, r18
  serialEeprom_t buf;
  if ( !EepromReadConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf)) ) {
    1836:	80 e0       	ldi	r24, 0x00	; 0
    1838:	93 e0       	ldi	r25, 0x03	; 3
    183a:	be 01       	movw	r22, r28
    183c:	6f 5f       	subi	r22, 0xFF	; 255
    183e:	7f 4f       	sbci	r23, 0xFF	; 255
    1840:	46 e0       	ldi	r20, 0x06	; 6
    1842:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
    1846:	88 23       	and	r24, r24
    1848:	91 f4       	brne	.+36     	; 0x186e <serialEepromGetConfig+0x62>
    // return fallback settings, if eeprom data is invalid
    buf.prescaler 	= serialSettings.prescaler;
    184a:	80 91 2c 01 	lds	r24, 0x012C
    184e:	90 91 2d 01 	lds	r25, 0x012D
    1852:	9a 83       	std	Y+2, r25	; 0x02
    1854:	89 83       	std	Y+1, r24	; 0x01
   	buf.parity  	= serialSettings.parity;
    1856:	80 91 2e 01 	lds	r24, 0x012E
    185a:	8b 83       	std	Y+3, r24	; 0x03
	buf.stop_bits 	= serialSettings.stop_bits;
    185c:	80 91 2f 01 	lds	r24, 0x012F
    1860:	8c 83       	std	Y+4, r24	; 0x04
    buf.data_bits  	= serialSettings.data_bits;
    1862:	80 91 30 01 	lds	r24, 0x0130
    1866:	8d 83       	std	Y+5, r24	; 0x05
	buf.SendBufferSizeLimit= serialSettings.SendBufferSizeLimit;
    1868:	80 91 31 01 	lds	r24, 0x0131
    186c:	8e 83       	std	Y+6, r24	; 0x06
  }

  // BAUD = CLOCK_FREQUENCY / (16 * (UBBR + 1))
  //      = (CLOCK_FREQUENCY / 16) / (UBBR + 1)
  *prescaler=buf.prescaler;
    186e:	89 81       	ldd	r24, Y+1	; 0x01
    1870:	9a 81       	ldd	r25, Y+2	; 0x02
    1872:	f7 01       	movw	r30, r14
    1874:	91 83       	std	Z+1, r25	; 0x01
    1876:	80 83       	st	Z, r24
  *parity=buf.parity;
    1878:	8b 81       	ldd	r24, Y+3	; 0x03
    187a:	f6 01       	movw	r30, r12
    187c:	80 83       	st	Z, r24
  *stop_bits=buf.stop_bits;
    187e:	8c 81       	ldd	r24, Y+4	; 0x04
    1880:	f5 01       	movw	r30, r10
    1882:	80 83       	st	Z, r24
  *data_bits=buf.data_bits;
    1884:	8d 81       	ldd	r24, Y+5	; 0x05
    1886:	f4 01       	movw	r30, r8
    1888:	80 83       	st	Z, r24
  *SendBufferSizeLimit=buf.SendBufferSizeLimit;
    188a:	8e 81       	ldd	r24, Y+6	; 0x06
    188c:	f8 01       	movw	r30, r16
    188e:	80 83       	st	Z, r24

}
    1890:	26 96       	adiw	r28, 0x06	; 6
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	de bf       	out	0x3e, r29	; 62
    1898:	0f be       	out	0x3f, r0	; 63
    189a:	cd bf       	out	0x3d, r28	; 61
    189c:	cf 91       	pop	r28
    189e:	df 91       	pop	r29
    18a0:	1f 91       	pop	r17
    18a2:	0f 91       	pop	r16
    18a4:	ff 90       	pop	r15
    18a6:	ef 90       	pop	r14
    18a8:	df 90       	pop	r13
    18aa:	cf 90       	pop	r12
    18ac:	bf 90       	pop	r11
    18ae:	af 90       	pop	r10
    18b0:	9f 90       	pop	r9
    18b2:	8f 90       	pop	r8
    18b4:	08 95       	ret

000018b6 <serialEepromSetConfig>:
}

#ifdef REQUIRES_RCFG

void serialEepromSetConfig(uint16_t prescaler, uint8_t parity, uint8_t stop_bits, uint8_t data_bits,uint8_t SendBufferSizeLimit)
{
    18b6:	af 92       	push	r10
    18b8:	bf 92       	push	r11
    18ba:	cf 92       	push	r12
    18bc:	df 92       	push	r13
    18be:	ef 92       	push	r14
    18c0:	ff 92       	push	r15
    18c2:	0f 93       	push	r16
    18c4:	1f 93       	push	r17
    18c6:	df 93       	push	r29
    18c8:	cf 93       	push	r28
    18ca:	00 d0       	rcall	.+0      	; 0x18cc <serialEepromSetConfig+0x16>
    18cc:	00 d0       	rcall	.+0      	; 0x18ce <serialEepromSetConfig+0x18>
    18ce:	00 d0       	rcall	.+0      	; 0x18d0 <serialEepromSetConfig+0x1a>
    18d0:	cd b7       	in	r28, 0x3d	; 61
    18d2:	de b7       	in	r29, 0x3e	; 62
    18d4:	7c 01       	movw	r14, r24
    18d6:	d6 2e       	mov	r13, r22
    18d8:	c4 2e       	mov	r12, r20
    18da:	b2 2e       	mov	r11, r18
    18dc:	a0 2e       	mov	r10, r16
  serialEeprom_t buf;
  if ( !EepromReadConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf)) ) {
    18de:	80 e0       	ldi	r24, 0x00	; 0
    18e0:	93 e0       	ldi	r25, 0x03	; 3
    18e2:	8e 01       	movw	r16, r28
    18e4:	0f 5f       	subi	r16, 0xFF	; 255
    18e6:	1f 4f       	sbci	r17, 0xFF	; 255
    18e8:	b8 01       	movw	r22, r16
    18ea:	46 e0       	ldi	r20, 0x06	; 6
    18ec:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
    buf.data_bits  	= serialSettings.data_bits;
	buf.SendBufferSizeLimit= serialSettings.SendBufferSizeLimit;
  }


	buf.prescaler 	= prescaler;
    18f0:	fa 82       	std	Y+2, r15	; 0x02
    18f2:	e9 82       	std	Y+1, r14	; 0x01
	buf.parity  	= parity;
    18f4:	db 82       	std	Y+3, r13	; 0x03
	buf.stop_bits 	= stop_bits;
    18f6:	cc 82       	std	Y+4, r12	; 0x04
	buf.data_bits  	= data_bits;
    18f8:	bd 82       	std	Y+5, r11	; 0x05
	buf.SendBufferSizeLimit= SendBufferSizeLimit;
    18fa:	ae 82       	std	Y+6, r10	; 0x06

  EepromWriteConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf));
    18fc:	80 e0       	ldi	r24, 0x00	; 0
    18fe:	93 e0       	ldi	r25, 0x03	; 3
    1900:	b8 01       	movw	r22, r16
    1902:	46 e0       	ldi	r20, 0x06	; 6
    1904:	0e 94 49 2a 	call	0x5492	; 0x5492 <EepromWriteConfig>

  return;
}
    1908:	26 96       	adiw	r28, 0x06	; 6
    190a:	0f b6       	in	r0, 0x3f	; 63
    190c:	f8 94       	cli
    190e:	de bf       	out	0x3e, r29	; 62
    1910:	0f be       	out	0x3f, r0	; 63
    1912:	cd bf       	out	0x3d, r28	; 61
    1914:	cf 91       	pop	r28
    1916:	df 91       	pop	r29
    1918:	1f 91       	pop	r17
    191a:	0f 91       	pop	r16
    191c:	ff 90       	pop	r15
    191e:	ef 90       	pop	r14
    1920:	df 90       	pop	r13
    1922:	cf 90       	pop	r12
    1924:	bf 90       	pop	r11
    1926:	af 90       	pop	r10
    1928:	08 95       	ret

0000192a <onSerial>:


}
  
void onSerial()
{ 
    192a:	df 93       	push	r29
    192c:	cf 93       	push	r28
    192e:	00 d0       	rcall	.+0      	; 0x1930 <onSerial+0x6>
    1930:	0f 92       	push	r0
    1932:	cd b7       	in	r28, 0x3d	; 61
    1934:	de b7       	in	r29, 0x3e	; 62





  if(CommandBuffer.NewCommand==1)
    1936:	80 91 b5 09 	lds	r24, 0x09B5
    193a:	81 30       	cpi	r24, 0x01	; 1
    193c:	e9 f0       	breq	.+58     	; 0x1978 <onSerial+0x4e>
  }




  if (com0HasBytes() == 0)
    193e:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <com0HasBytes>
    1942:	88 23       	and	r24, r24
    1944:	99 f0       	breq	.+38     	; 0x196c <onSerial+0x42>
    return;
       
  
  char* buf = NULL;
    1946:	1b 82       	std	Y+3, r1	; 0x03
    1948:	1a 82       	std	Y+2, r1	; 0x02
  uint8_t len = 0;
    194a:	19 82       	std	Y+1, r1	; 0x01


    
  com0RecvBytes(&buf,&len); 
    194c:	ce 01       	movw	r24, r28
    194e:	02 96       	adiw	r24, 0x02	; 2
    1950:	be 01       	movw	r22, r28
    1952:	6f 5f       	subi	r22, 0xFF	; 255
    1954:	7f 4f       	sbci	r23, 0xFF	; 255
    1956:	0e 94 23 11 	call	0x2246	; 0x2246 <com0RecvBytes>

   
  onSerialData(buf,len);
    195a:	8a 81       	ldd	r24, Y+2	; 0x02
    195c:	9b 81       	ldd	r25, Y+3	; 0x03
    195e:	69 81       	ldd	r22, Y+1	; 0x01
    1960:	0e 94 ad 1a 	call	0x355a	; 0x355a <onSerialData>
    
  free(buf);
    1964:	8a 81       	ldd	r24, Y+2	; 0x02
    1966:	9b 81       	ldd	r25, Y+3	; 0x03
    1968:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>


  return;
}
    196c:	0f 90       	pop	r0
    196e:	0f 90       	pop	r0
    1970:	0f 90       	pop	r0
    1972:	cf 91       	pop	r28
    1974:	df 91       	pop	r29
    1976:	08 95       	ret



  if(CommandBuffer.NewCommand==1)
  {
  	CommandBuffer.NewCommand=0;
    1978:	10 92 b5 09 	sts	0x09B5, r1
	onRtpControl(CommandBuffer.recvCommand, CommandBuffer.len);	
    197c:	8d e8       	ldi	r24, 0x8D	; 141
    197e:	99 e0       	ldi	r25, 0x09	; 9
    1980:	60 91 b6 09 	lds	r22, 0x09B6
    1984:	0e 94 54 29 	call	0x52a8	; 0x52a8 <onRtpControl>
    1988:	da cf       	rjmp	.-76     	; 0x193e <onSerial+0x14>

0000198a <serialSendBytes>:
void serialSendBytes(char* buf, uint8_t len)
{


  //com0SendBytes(buf,len);
  com0putBuffer(buf, len);
    198a:	0e 94 cf 10 	call	0x219e	; 0x219e <com0putBuffer>


}
    198e:	08 95       	ret

00001990 <onInitSerial>:




void onInitSerial()
{
    1990:	0f 93       	push	r16
    1992:	df 93       	push	r29
    1994:	cf 93       	push	r28
    1996:	00 d0       	rcall	.+0      	; 0x1998 <onInitSerial+0x8>
    1998:	00 d0       	rcall	.+0      	; 0x199a <onInitSerial+0xa>
    199a:	00 d0       	rcall	.+0      	; 0x199c <onInitSerial+0xc>
    199c:	cd b7       	in	r28, 0x3d	; 61
    199e:	de b7       	in	r29, 0x3e	; 62
  // define a struct for the configuration...
  serialEeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf)) ) {
    19a0:	80 e0       	ldi	r24, 0x00	; 0
    19a2:	93 e0       	ldi	r25, 0x03	; 3
    19a4:	be 01       	movw	r22, r28
    19a6:	6f 5f       	subi	r22, 0xFF	; 255
    19a8:	7f 4f       	sbci	r23, 0xFF	; 255
    19aa:	46 e0       	ldi	r20, 0x06	; 6
    19ac:	0e 94 88 2a 	call	0x5510	; 0x5510 <EepromReadConfig>
    19b0:	88 23       	and	r24, r24
    19b2:	91 f0       	breq	.+36     	; 0x19d8 <onInitSerial+0x48>
    serialSettings.prescaler 		= buf.prescaler;
    19b4:	89 81       	ldd	r24, Y+1	; 0x01
    19b6:	9a 81       	ldd	r25, Y+2	; 0x02
    19b8:	90 93 2d 01 	sts	0x012D, r25
    19bc:	80 93 2c 01 	sts	0x012C, r24
    serialSettings.parity  			= buf.parity;
    19c0:	8b 81       	ldd	r24, Y+3	; 0x03
    19c2:	80 93 2e 01 	sts	0x012E, r24
	serialSettings.stop_bits 		= buf.stop_bits;
    19c6:	8c 81       	ldd	r24, Y+4	; 0x04
    19c8:	80 93 2f 01 	sts	0x012F, r24
    serialSettings.data_bits  		= buf.data_bits;
    19cc:	8d 81       	ldd	r24, Y+5	; 0x05
    19ce:	80 93 30 01 	sts	0x0130, r24
	serialSettings.SendBufferSizeLimit  = buf.SendBufferSizeLimit;
    19d2:	8e 81       	ldd	r24, Y+6	; 0x06
    19d4:	80 93 31 01 	sts	0x0131, r24
  }
  // else serialSettings keeps the fallback settings

  // bitrate parity stop bits
  //com0Initialize(serialSettings.prescaler,serialSettings.settings);  //old one
  com0Initialize(serialSettings.prescaler,serialSettings.parity,serialSettings.stop_bits,serialSettings.data_bits,serialSettings.SendBufferSizeLimit);
    19d8:	80 91 2c 01 	lds	r24, 0x012C
    19dc:	90 91 2d 01 	lds	r25, 0x012D
    19e0:	60 91 2e 01 	lds	r22, 0x012E
    19e4:	40 91 2f 01 	lds	r20, 0x012F
    19e8:	20 91 30 01 	lds	r18, 0x0130
    19ec:	00 91 31 01 	lds	r16, 0x0131
    19f0:	0e 94 4e 11 	call	0x229c	; 0x229c <com0Initialize>
  com1Initialize(0,0);
    19f4:	80 e0       	ldi	r24, 0x00	; 0
    19f6:	90 e0       	ldi	r25, 0x00	; 0
    19f8:	60 e0       	ldi	r22, 0x00	; 0
    19fa:	0e 94 10 2d 	call	0x5a20	; 0x5a20 <com1Initialize>
  return;
}
    19fe:	26 96       	adiw	r28, 0x06	; 6
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	f8 94       	cli
    1a04:	de bf       	out	0x3e, r29	; 62
    1a06:	0f be       	out	0x3f, r0	; 63
    1a08:	cd bf       	out	0x3d, r28	; 61
    1a0a:	cf 91       	pop	r28
    1a0c:	df 91       	pop	r29
    1a0e:	0f 91       	pop	r16
    1a10:	08 95       	ret

00001a12 <onInitClock>:
    1a12:	0e 94 64 10 	call	0x20c8	; 0x20c8 <rtcInitialize>
    1a16:	08 95       	ret

00001a18 <clockGetShortTimeStamp>:
    1a18:	0e 94 a8 10 	call	0x2150	; 0x2150 <rtcGetTime32>
    1a1c:	08 95       	ret

00001a1e <clockGetTimeStamp>:
    1a1e:	0e 94 80 10 	call	0x2100	; 0x2100 <rtcGetTime64>
    1a22:	08 95       	ret

00001a24 <onInitTimer>:
}

void onInitTimer()
{
  // Initalize Scheduler
  timerList.firstNode = NULL;
    1a24:	10 92 76 08 	sts	0x0876, r1
    1a28:	10 92 75 08 	sts	0x0875, r1
  timerList.lastNode = NULL;
    1a2c:	10 92 78 08 	sts	0x0878, r1
    1a30:	10 92 77 08 	sts	0x0877, r1
}
    1a34:	08 95       	ret

00001a36 <timerClearTimeout>:


// after any timeout or calling this function it is essential to NULL 
// the element variable
void timerClearTimeout(struct timerElement_t* element)
{
    1a36:	0f 93       	push	r16
    1a38:	1f 93       	push	r17
    1a3a:	8c 01       	movw	r16, r24
    
  removeDlNode(&timerList,(struct dlNode_t*)element);
    1a3c:	85 e7       	ldi	r24, 0x75	; 117
    1a3e:	98 e0       	ldi	r25, 0x08	; 8
    1a40:	b8 01       	movw	r22, r16
    1a42:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <removeDlNode>
  free(element);
    1a46:	c8 01       	movw	r24, r16
    1a48:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
}
    1a4c:	1f 91       	pop	r17
    1a4e:	0f 91       	pop	r16
    1a50:	08 95       	ret

00001a52 <timerAddTimeout>:
// which is damm close to 1000ms


struct timerElement_t* timerAddTimeout(uint16_t delay, 
    void (*callback)())
{
    1a52:	8f 92       	push	r8
    1a54:	9f 92       	push	r9
    1a56:	af 92       	push	r10
    1a58:	bf 92       	push	r11
    1a5a:	cf 92       	push	r12
    1a5c:	df 92       	push	r13
    1a5e:	ef 92       	push	r14
    1a60:	ff 92       	push	r15
    1a62:	0f 93       	push	r16
    1a64:	1f 93       	push	r17
    1a66:	cf 93       	push	r28
    1a68:	df 93       	push	r29
    1a6a:	8c 01       	movw	r16, r24
    1a6c:	4b 01       	movw	r8, r22


  struct timerElement_t* newNode
    = (struct timerElement_t*) malloc(sizeof(struct timerElement_t));
    1a6e:	8e e0       	ldi	r24, 0x0E	; 14
    1a70:	90 e0       	ldi	r25, 0x00	; 0
    1a72:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    1a76:	ec 01       	movw	r28, r24


	//alx free --> timerClearTimeout
  
  // timestamp = now(in ms) + delay
  newNode->timebomb = clockGetTimeStamp()+delay;
    1a78:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <clockGetTimeStamp>
    1a7c:	f4 2e       	mov	r15, r20
    1a7e:	e5 2e       	mov	r14, r21
    1a80:	d6 2e       	mov	r13, r22
    1a82:	c7 2e       	mov	r12, r23
    1a84:	b8 2e       	mov	r11, r24
    1a86:	a9 2e       	mov	r10, r25
    1a88:	a8 01       	movw	r20, r16
    1a8a:	12 2f       	mov	r17, r18
    1a8c:	14 0f       	add	r17, r20
    1a8e:	f1 e0       	ldi	r31, 0x01	; 1
    1a90:	12 17       	cp	r17, r18
    1a92:	08 f0       	brcs	.+2      	; 0x1a96 <timerAddTimeout+0x44>
    1a94:	f0 e0       	ldi	r31, 0x00	; 0
    1a96:	03 2f       	mov	r16, r19
    1a98:	05 0f       	add	r16, r21
    1a9a:	e1 e0       	ldi	r30, 0x01	; 1
    1a9c:	03 17       	cp	r16, r19
    1a9e:	08 f0       	brcs	.+2      	; 0x1aa2 <timerAddTimeout+0x50>
    1aa0:	e0 e0       	ldi	r30, 0x00	; 0
    1aa2:	7f 2f       	mov	r23, r31
    1aa4:	70 0f       	add	r23, r16
    1aa6:	21 e0       	ldi	r18, 0x01	; 1
    1aa8:	70 17       	cp	r23, r16
    1aaa:	08 f0       	brcs	.+2      	; 0x1aae <timerAddTimeout+0x5c>
    1aac:	20 e0       	ldi	r18, 0x00	; 0
    1aae:	3e 2f       	mov	r19, r30
    1ab0:	32 2b       	or	r19, r18
    1ab2:	3f 0d       	add	r19, r15
    1ab4:	21 e0       	ldi	r18, 0x01	; 1
    1ab6:	3f 15       	cp	r19, r15
    1ab8:	08 f0       	brcs	.+2      	; 0x1abc <timerAddTimeout+0x6a>
    1aba:	20 e0       	ldi	r18, 0x00	; 0
    1abc:	62 2f       	mov	r22, r18
    1abe:	6e 0d       	add	r22, r14
    1ac0:	21 e0       	ldi	r18, 0x01	; 1
    1ac2:	6e 15       	cp	r22, r14
    1ac4:	08 f0       	brcs	.+2      	; 0x1ac8 <timerAddTimeout+0x76>
    1ac6:	20 e0       	ldi	r18, 0x00	; 0
    1ac8:	52 2f       	mov	r21, r18
    1aca:	5d 0d       	add	r21, r13
    1acc:	21 e0       	ldi	r18, 0x01	; 1
    1ace:	5d 15       	cp	r21, r13
    1ad0:	08 f0       	brcs	.+2      	; 0x1ad4 <timerAddTimeout+0x82>
    1ad2:	20 e0       	ldi	r18, 0x00	; 0
    1ad4:	42 2f       	mov	r20, r18
    1ad6:	4c 0d       	add	r20, r12
    1ad8:	21 e0       	ldi	r18, 0x01	; 1
    1ada:	4c 15       	cp	r20, r12
    1adc:	08 f0       	brcs	.+2      	; 0x1ae0 <timerAddTimeout+0x8e>
    1ade:	20 e0       	ldi	r18, 0x00	; 0
    1ae0:	2b 0d       	add	r18, r11
    1ae2:	91 e0       	ldi	r25, 0x01	; 1
    1ae4:	2b 15       	cp	r18, r11
    1ae6:	08 f0       	brcs	.+2      	; 0x1aea <timerAddTimeout+0x98>
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	9a 0d       	add	r25, r10
    1aec:	1c 83       	std	Y+4, r17	; 0x04
    1aee:	7d 83       	std	Y+5, r23	; 0x05
    1af0:	3e 83       	std	Y+6, r19	; 0x06
    1af2:	6f 83       	std	Y+7, r22	; 0x07
    1af4:	58 87       	std	Y+8, r21	; 0x08
    1af6:	49 87       	std	Y+9, r20	; 0x09
    1af8:	2a 87       	std	Y+10, r18	; 0x0a
    1afa:	9b 87       	std	Y+11, r25	; 0x0b
  newNode->callback = callback;
    1afc:	9d 86       	std	Y+13, r9	; 0x0d
    1afe:	8c 86       	std	Y+12, r8	; 0x0c
 
  // If the list is empty, we can do a shortcut...
  if (timerList.firstNode == NULL)
    1b00:	e0 91 75 08 	lds	r30, 0x0875
    1b04:	f0 91 76 08 	lds	r31, 0x0876
    1b08:	30 97       	sbiw	r30, 0x00	; 0
    1b0a:	09 f4       	brne	.+2      	; 0x1b0e <timerAddTimeout+0xbc>
    1b0c:	47 c0       	rjmp	.+142    	; 0x1b9c <timerAddTimeout+0x14a>
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
  {
    if (((struct timerElement_t*)node)->timebomb > newNode->timebomb)
    1b0e:	83 85       	ldd	r24, Z+11	; 0x0b
    1b10:	98 17       	cp	r25, r24
    1b12:	a0 f4       	brcc	.+40     	; 0x1b3c <timerAddTimeout+0xea>
    return newNode;
  }
  


  insertDlNodeBefore(&timerList,node,(struct dlNode_t*)newNode);
    1b14:	85 e7       	ldi	r24, 0x75	; 117
    1b16:	98 e0       	ldi	r25, 0x08	; 8
    1b18:	bf 01       	movw	r22, r30
    1b1a:	ae 01       	movw	r20, r28
    1b1c:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <insertDlNodeBefore>

 
  return newNode;  
  
    
}
    1b20:	ce 01       	movw	r24, r28
    1b22:	df 91       	pop	r29
    1b24:	cf 91       	pop	r28
    1b26:	1f 91       	pop	r17
    1b28:	0f 91       	pop	r16
    1b2a:	ff 90       	pop	r15
    1b2c:	ef 90       	pop	r14
    1b2e:	df 90       	pop	r13
    1b30:	cf 90       	pop	r12
    1b32:	bf 90       	pop	r11
    1b34:	af 90       	pop	r10
    1b36:	9f 90       	pop	r9
    1b38:	8f 90       	pop	r8
    1b3a:	08 95       	ret
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
  {
    if (((struct timerElement_t*)node)->timebomb > newNode->timebomb)
    1b3c:	89 17       	cp	r24, r25
    1b3e:	59 f0       	breq	.+22     	; 0x1b56 <timerAddTimeout+0x104>
      break;
    node = node->next;
    1b40:	02 80       	ldd	r0, Z+2	; 0x02
    1b42:	f3 81       	ldd	r31, Z+3	; 0x03
    1b44:	e0 2d       	mov	r30, r0

  // ... otherise we have to add the entry into the sorted list
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
    1b46:	30 97       	sbiw	r30, 0x00	; 0
    1b48:	11 f7       	brne	.-60     	; 0x1b0e <timerAddTimeout+0xbc>

  
  // We reached the end of the list without a hit?
  if (node == NULL)
  {
    insertDlNodeLast(&timerList,(struct dlNode_t*)newNode);    
    1b4a:	85 e7       	ldi	r24, 0x75	; 117
    1b4c:	98 e0       	ldi	r25, 0x08	; 8
    1b4e:	be 01       	movw	r22, r28
    1b50:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <insertDlNodeLast>
    1b54:	e5 cf       	rjmp	.-54     	; 0x1b20 <timerAddTimeout+0xce>
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
  {
    if (((struct timerElement_t*)node)->timebomb > newNode->timebomb)
    1b56:	82 85       	ldd	r24, Z+10	; 0x0a
    1b58:	28 17       	cp	r18, r24
    1b5a:	e0 f2       	brcs	.-72     	; 0x1b14 <timerAddTimeout+0xc2>
    1b5c:	82 17       	cp	r24, r18
    1b5e:	81 f7       	brne	.-32     	; 0x1b40 <timerAddTimeout+0xee>
    1b60:	81 85       	ldd	r24, Z+9	; 0x09
    1b62:	48 17       	cp	r20, r24
    1b64:	b8 f2       	brcs	.-82     	; 0x1b14 <timerAddTimeout+0xc2>
    1b66:	84 17       	cp	r24, r20
    1b68:	59 f7       	brne	.-42     	; 0x1b40 <timerAddTimeout+0xee>
    1b6a:	80 85       	ldd	r24, Z+8	; 0x08
    1b6c:	58 17       	cp	r21, r24
    1b6e:	90 f2       	brcs	.-92     	; 0x1b14 <timerAddTimeout+0xc2>
    1b70:	85 17       	cp	r24, r21
    1b72:	31 f7       	brne	.-52     	; 0x1b40 <timerAddTimeout+0xee>
    1b74:	87 81       	ldd	r24, Z+7	; 0x07
    1b76:	68 17       	cp	r22, r24
    1b78:	68 f2       	brcs	.-102    	; 0x1b14 <timerAddTimeout+0xc2>
    1b7a:	86 17       	cp	r24, r22
    1b7c:	09 f7       	brne	.-62     	; 0x1b40 <timerAddTimeout+0xee>
    1b7e:	86 81       	ldd	r24, Z+6	; 0x06
    1b80:	38 17       	cp	r19, r24
    1b82:	40 f2       	brcs	.-112    	; 0x1b14 <timerAddTimeout+0xc2>
    1b84:	83 17       	cp	r24, r19
    1b86:	e1 f6       	brne	.-72     	; 0x1b40 <timerAddTimeout+0xee>
    1b88:	85 81       	ldd	r24, Z+5	; 0x05
    1b8a:	78 17       	cp	r23, r24
    1b8c:	18 f2       	brcs	.-122    	; 0x1b14 <timerAddTimeout+0xc2>
    1b8e:	87 17       	cp	r24, r23
    1b90:	b9 f6       	brne	.-82     	; 0x1b40 <timerAddTimeout+0xee>
    1b92:	84 81       	ldd	r24, Z+4	; 0x04
    1b94:	18 17       	cp	r17, r24
    1b96:	08 f4       	brcc	.+2      	; 0x1b9a <timerAddTimeout+0x148>
    1b98:	bd cf       	rjmp	.-134    	; 0x1b14 <timerAddTimeout+0xc2>
    1b9a:	d2 cf       	rjmp	.-92     	; 0x1b40 <timerAddTimeout+0xee>
  newNode->callback = callback;
 
  // If the list is empty, we can do a shortcut...
  if (timerList.firstNode == NULL)
  {
    insertDlNodeBeginning(&timerList,(struct dlNode_t*)newNode);    
    1b9c:	85 e7       	ldi	r24, 0x75	; 117
    1b9e:	98 e0       	ldi	r25, 0x08	; 8
    1ba0:	be 01       	movw	r22, r28
    1ba2:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <insertDlNodeBeginning>
    1ba6:	bc cf       	rjmp	.-136    	; 0x1b20 <timerAddTimeout+0xce>

00001ba8 <onTimer>:
  free(element);
}


void onTimer()
{
    1ba8:	af 92       	push	r10
    1baa:	bf 92       	push	r11
    1bac:	cf 92       	push	r12
    1bae:	df 92       	push	r13
    1bb0:	ef 92       	push	r14
    1bb2:	ff 92       	push	r15
    1bb4:	0f 93       	push	r16
    1bb6:	1f 93       	push	r17
  if (timerList.firstNode == NULL)
    1bb8:	e0 91 75 08 	lds	r30, 0x0875
    1bbc:	f0 91 76 08 	lds	r31, 0x0876
    1bc0:	30 97       	sbiw	r30, 0x00	; 0
    1bc2:	f9 f0       	breq	.+62     	; 0x1c02 <onTimer+0x5a>
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1bc4:	a4 80       	ldd	r10, Z+4	; 0x04
    1bc6:	b5 80       	ldd	r11, Z+5	; 0x05
    1bc8:	c6 80       	ldd	r12, Z+6	; 0x06
    1bca:	d7 80       	ldd	r13, Z+7	; 0x07
    1bcc:	f0 84       	ldd	r15, Z+8	; 0x08
    1bce:	11 85       	ldd	r17, Z+9	; 0x09
    1bd0:	e2 84       	ldd	r14, Z+10	; 0x0a
    1bd2:	03 85       	ldd	r16, Z+11	; 0x0b
    1bd4:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <clockGetTimeStamp>
    1bd8:	90 17       	cp	r25, r16
    1bda:	98 f0       	brcs	.+38     	; 0x1c02 <onTimer+0x5a>
    1bdc:	09 17       	cp	r16, r25
    1bde:	d1 f0       	breq	.+52     	; 0x1c14 <onTimer+0x6c>
//	putString_com1("\r\nAUSGELOESSSST:");
  
  
  // we need to remove the obsolete timer entry...
  // ... before we do the callback!
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
    1be0:	60 91 75 08 	lds	r22, 0x0875
    1be4:	70 91 76 08 	lds	r23, 0x0876
    1be8:	8b 01       	movw	r16, r22
    1bea:	f8 01       	movw	r30, r16
    1bec:	e4 84       	ldd	r14, Z+12	; 0x0c
    1bee:	f5 84       	ldd	r15, Z+13	; 0x0d
// after any timeout or calling this function it is essential to NULL 
// the element variable
void timerClearTimeout(struct timerElement_t* element)
{
    
  removeDlNode(&timerList,(struct dlNode_t*)element);
    1bf0:	85 e7       	ldi	r24, 0x75	; 117
    1bf2:	98 e0       	ldi	r25, 0x08	; 8
    1bf4:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <removeDlNode>
  free(element);
    1bf8:	c8 01       	movw	r24, r16
    1bfa:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
  timerClearTimeout(((struct timerElement_t*)(timerList.firstNode)));
  
  // as the entry is removed, we have to use...
  // ...our temporary variable to do the callback
  ((void(*) ()) (callback)) ();
    1bfe:	f7 01       	movw	r30, r14
    1c00:	09 95       	icall
  
  return; 
}
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	ff 90       	pop	r15
    1c08:	ef 90       	pop	r14
    1c0a:	df 90       	pop	r13
    1c0c:	cf 90       	pop	r12
    1c0e:	bf 90       	pop	r11
    1c10:	af 90       	pop	r10
    1c12:	08 95       	ret
void onTimer()
{
  if (timerList.firstNode == NULL)
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1c14:	8e 15       	cp	r24, r14
    1c16:	a8 f3       	brcs	.-22     	; 0x1c02 <onTimer+0x5a>
    1c18:	e8 16       	cp	r14, r24
    1c1a:	11 f7       	brne	.-60     	; 0x1be0 <onTimer+0x38>
    1c1c:	71 17       	cp	r23, r17
    1c1e:	88 f3       	brcs	.-30     	; 0x1c02 <onTimer+0x5a>
    1c20:	17 17       	cp	r17, r23
    1c22:	f1 f6       	brne	.-68     	; 0x1be0 <onTimer+0x38>
    1c24:	6f 15       	cp	r22, r15
    1c26:	68 f3       	brcs	.-38     	; 0x1c02 <onTimer+0x5a>
    1c28:	f6 16       	cp	r15, r22
    1c2a:	d1 f6       	brne	.-76     	; 0x1be0 <onTimer+0x38>
    1c2c:	5d 15       	cp	r21, r13
    1c2e:	48 f3       	brcs	.-46     	; 0x1c02 <onTimer+0x5a>
    1c30:	d5 16       	cp	r13, r21
    1c32:	b1 f6       	brne	.-84     	; 0x1be0 <onTimer+0x38>
    1c34:	4c 15       	cp	r20, r12
    1c36:	28 f3       	brcs	.-54     	; 0x1c02 <onTimer+0x5a>
    1c38:	c4 16       	cp	r12, r20
    1c3a:	91 f6       	brne	.-92     	; 0x1be0 <onTimer+0x38>
    1c3c:	3b 15       	cp	r19, r11
    1c3e:	08 f3       	brcs	.-62     	; 0x1c02 <onTimer+0x5a>
    1c40:	b3 16       	cp	r11, r19
    1c42:	71 f6       	brne	.-100    	; 0x1be0 <onTimer+0x38>
    1c44:	2a 15       	cp	r18, r10
    1c46:	e8 f2       	brcs	.-70     	; 0x1c02 <onTimer+0x5a>
    1c48:	cb cf       	rjmp	.-106    	; 0x1be0 <onTimer+0x38>

00001c4a <DebugTimerList>:
    
}


void DebugTimerList()
{
    1c4a:	9f 92       	push	r9
    1c4c:	af 92       	push	r10
    1c4e:	bf 92       	push	r11
    1c50:	cf 92       	push	r12
    1c52:	df 92       	push	r13
    1c54:	ef 92       	push	r14
    1c56:	ff 92       	push	r15
    1c58:	0f 93       	push	r16
    1c5a:	1f 93       	push	r17
    1c5c:	cf 93       	push	r28
    1c5e:	df 93       	push	r29


// If the list is empty, we can do a shortcut...
	if (timerList.firstNode == NULL)
    1c60:	c0 91 75 08 	lds	r28, 0x0875
    1c64:	d0 91 76 08 	lds	r29, 0x0876
    1c68:	20 97       	sbiw	r28, 0x00	; 0
    1c6a:	09 f4       	brne	.+2      	; 0x1c6e <DebugTimerList+0x24>
    1c6c:	8b c0       	rjmp	.+278    	; 0x1d84 <DebugTimerList+0x13a>

	else
	{
		struct dlNode_t* node = timerList.firstNode;
		uint8_t anzahlTimer=0;
		char *x1=malloc(16);
    1c6e:	80 e1       	ldi	r24, 0x10	; 16
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    1c76:	8c 01       	movw	r16, r24
		itoa(clockGetTimeStamp(),x1,10);
    1c78:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <clockGetTimeStamp>
    1c7c:	c9 01       	movw	r24, r18
    1c7e:	b8 01       	movw	r22, r16
    1c80:	4a e0       	ldi	r20, 0x0A	; 10
    1c82:	50 e0       	ldi	r21, 0x00	; 0
    1c84:	0e 94 98 2f 	call	0x5f30	; 0x5f30 <itoa>

		putString_com1("\r\nclockGetTimeStamp:");
    1c88:	87 e4       	ldi	r24, 0x47	; 71
    1c8a:	91 e0       	ldi	r25, 0x01	; 1
    1c8c:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
		putString_com1(x1);
    1c90:	c8 01       	movw	r24, r16
    1c92:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    1c96:	dd 24       	eor	r13, r13
 
		while (node != NULL)
		{	    
			anzahlTimer+=1;
    1c98:	d3 94       	inc	r13

			
			itoa(((struct timerElement_t*)node)->timebomb,x1,10);
    1c9a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c9c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c9e:	b8 01       	movw	r22, r16
    1ca0:	4a e0       	ldi	r20, 0x0A	; 10
    1ca2:	50 e0       	ldi	r21, 0x00	; 0
    1ca4:	0e 94 98 2f 	call	0x5f30	; 0x5f30 <itoa>
			putString_com1("\r\nTB:");
    1ca8:	8c e5       	ldi	r24, 0x5C	; 92
    1caa:	91 e0       	ldi	r25, 0x01	; 1
    1cac:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
			putString_com1(x1);
    1cb0:	c8 01       	movw	r24, r16
    1cb2:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
			node = node->next;
    1cb6:	0a 80       	ldd	r0, Y+2	; 0x02
    1cb8:	db 81       	ldd	r29, Y+3	; 0x03
    1cba:	c0 2d       	mov	r28, r0
		itoa(clockGetTimeStamp(),x1,10);

		putString_com1("\r\nclockGetTimeStamp:");
		putString_com1(x1);
 
		while (node != NULL)
    1cbc:	20 97       	sbiw	r28, 0x00	; 0
    1cbe:	61 f7       	brne	.-40     	; 0x1c98 <DebugTimerList+0x4e>
			putString_com1(x1);
			node = node->next;
			
		}

		if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1cc0:	e0 91 75 08 	lds	r30, 0x0875
    1cc4:	f0 91 76 08 	lds	r31, 0x0876
    1cc8:	94 80       	ldd	r9, Z+4	; 0x04
    1cca:	a5 80       	ldd	r10, Z+5	; 0x05
    1ccc:	b6 80       	ldd	r11, Z+6	; 0x06
    1cce:	c7 80       	ldd	r12, Z+7	; 0x07
    1cd0:	f0 84       	ldd	r15, Z+8	; 0x08
    1cd2:	e1 84       	ldd	r14, Z+9	; 0x09
    1cd4:	02 85       	ldd	r16, Z+10	; 0x0a
    1cd6:	13 85       	ldd	r17, Z+11	; 0x0b
    1cd8:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <clockGetTimeStamp>
    1cdc:	91 17       	cp	r25, r17
    1cde:	30 f5       	brcc	.+76     	; 0x1d2c <DebugTimerList+0xe2>
			putString_com1("\r\ntimebomp groesser noch net erreicht:");
    1ce0:	82 e6       	ldi	r24, 0x62	; 98
    1ce2:	91 e0       	ldi	r25, 0x01	; 1
    1ce4:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
		}

    	

		
		char *x2=malloc(2);
    1ce8:	82 e0       	ldi	r24, 0x02	; 2
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    1cf0:	18 2f       	mov	r17, r24
    1cf2:	09 2f       	mov	r16, r25

		itoa(anzahlTimer,x2,10);
    1cf4:	8d 2d       	mov	r24, r13
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	61 2f       	mov	r22, r17
    1cfa:	70 2f       	mov	r23, r16
    1cfc:	4a e0       	ldi	r20, 0x0A	; 10
    1cfe:	50 e0       	ldi	r21, 0x00	; 0
    1d00:	0e 94 98 2f 	call	0x5f30	; 0x5f30 <itoa>
		

		putString_com1("\r\nAnzahlTimer:");
    1d04:	88 ea       	ldi	r24, 0xA8	; 168
    1d06:	91 e0       	ldi	r25, 0x01	; 1
    1d08:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
		putString_com1(x2);
    1d0c:	81 2f       	mov	r24, r17
    1d0e:	90 2f       	mov	r25, r16
    1d10:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	}

}
    1d14:	df 91       	pop	r29
    1d16:	cf 91       	pop	r28
    1d18:	1f 91       	pop	r17
    1d1a:	0f 91       	pop	r16
    1d1c:	ff 90       	pop	r15
    1d1e:	ef 90       	pop	r14
    1d20:	df 90       	pop	r13
    1d22:	cf 90       	pop	r12
    1d24:	bf 90       	pop	r11
    1d26:	af 90       	pop	r10
    1d28:	9f 90       	pop	r9
    1d2a:	08 95       	ret
			putString_com1(x1);
			node = node->next;
			
		}

		if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1d2c:	19 17       	cp	r17, r25
    1d2e:	79 f1       	breq	.+94     	; 0x1d8e <DebugTimerList+0x144>
			putString_com1("\r\ntimebomp groesser noch net erreicht:");
		else
		{
			putString_com1("\r\ntimebomp kleiner AUSSloesen:");
    1d30:	89 e8       	ldi	r24, 0x89	; 137
    1d32:	91 e0       	ldi	r25, 0x01	; 1
    1d34:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
}


void onTimer()
{
  if (timerList.firstNode == NULL)
    1d38:	e0 91 75 08 	lds	r30, 0x0875
    1d3c:	f0 91 76 08 	lds	r31, 0x0876
    1d40:	30 97       	sbiw	r30, 0x00	; 0
    1d42:	91 f2       	breq	.-92     	; 0x1ce8 <DebugTimerList+0x9e>
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1d44:	94 80       	ldd	r9, Z+4	; 0x04
    1d46:	a5 80       	ldd	r10, Z+5	; 0x05
    1d48:	b6 80       	ldd	r11, Z+6	; 0x06
    1d4a:	c7 80       	ldd	r12, Z+7	; 0x07
    1d4c:	e0 84       	ldd	r14, Z+8	; 0x08
    1d4e:	f1 84       	ldd	r15, Z+9	; 0x09
    1d50:	02 85       	ldd	r16, Z+10	; 0x0a
    1d52:	13 85       	ldd	r17, Z+11	; 0x0b
    1d54:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <clockGetTimeStamp>
    1d58:	91 17       	cp	r25, r17
    1d5a:	30 f2       	brcs	.-116    	; 0x1ce8 <DebugTimerList+0x9e>
    1d5c:	19 17       	cp	r17, r25
    1d5e:	e1 f1       	breq	.+120    	; 0x1dd8 <DebugTimerList+0x18e>
//	putString_com1("\r\nAUSGELOESSSST:");
  
  
  // we need to remove the obsolete timer entry...
  // ... before we do the callback!
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
    1d60:	60 91 75 08 	lds	r22, 0x0875
    1d64:	70 91 76 08 	lds	r23, 0x0876
    1d68:	8b 01       	movw	r16, r22
    1d6a:	f8 01       	movw	r30, r16
    1d6c:	e4 84       	ldd	r14, Z+12	; 0x0c
    1d6e:	f5 84       	ldd	r15, Z+13	; 0x0d
// after any timeout or calling this function it is essential to NULL 
// the element variable
void timerClearTimeout(struct timerElement_t* element)
{
    
  removeDlNode(&timerList,(struct dlNode_t*)element);
    1d70:	85 e7       	ldi	r24, 0x75	; 117
    1d72:	98 e0       	ldi	r25, 0x08	; 8
    1d74:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <removeDlNode>
  free(element);
    1d78:	c8 01       	movw	r24, r16
    1d7a:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
  timerClearTimeout(((struct timerElement_t*)(timerList.firstNode)));
  
  // as the entry is removed, we have to use...
  // ...our temporary variable to do the callback
  ((void(*) ()) (callback)) ();
    1d7e:	f7 01       	movw	r30, r14
    1d80:	09 95       	icall
    1d82:	b2 cf       	rjmp	.-156    	; 0x1ce8 <DebugTimerList+0x9e>


// If the list is empty, we can do a shortcut...
	if (timerList.firstNode == NULL)
	{
		putString_com1("\r\nTimer-Liste leer!!");
    1d84:	82 e3       	ldi	r24, 0x32	; 50
    1d86:	91 e0       	ldi	r25, 0x01	; 1
    1d88:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    1d8c:	c3 cf       	rjmp	.-122    	; 0x1d14 <DebugTimerList+0xca>
			putString_com1(x1);
			node = node->next;
			
		}

		if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1d8e:	80 17       	cp	r24, r16
    1d90:	08 f4       	brcc	.+2      	; 0x1d94 <DebugTimerList+0x14a>
    1d92:	a6 cf       	rjmp	.-180    	; 0x1ce0 <DebugTimerList+0x96>
    1d94:	08 17       	cp	r16, r24
    1d96:	61 f6       	brne	.-104    	; 0x1d30 <DebugTimerList+0xe6>
    1d98:	7e 15       	cp	r23, r14
    1d9a:	08 f4       	brcc	.+2      	; 0x1d9e <DebugTimerList+0x154>
    1d9c:	a1 cf       	rjmp	.-190    	; 0x1ce0 <DebugTimerList+0x96>
    1d9e:	e7 16       	cp	r14, r23
    1da0:	39 f6       	brne	.-114    	; 0x1d30 <DebugTimerList+0xe6>
    1da2:	6f 15       	cp	r22, r15
    1da4:	08 f4       	brcc	.+2      	; 0x1da8 <DebugTimerList+0x15e>
    1da6:	9c cf       	rjmp	.-200    	; 0x1ce0 <DebugTimerList+0x96>
    1da8:	f6 16       	cp	r15, r22
    1daa:	11 f6       	brne	.-124    	; 0x1d30 <DebugTimerList+0xe6>
    1dac:	5c 15       	cp	r21, r12
    1dae:	08 f4       	brcc	.+2      	; 0x1db2 <DebugTimerList+0x168>
    1db0:	97 cf       	rjmp	.-210    	; 0x1ce0 <DebugTimerList+0x96>
    1db2:	c5 16       	cp	r12, r21
    1db4:	09 f0       	breq	.+2      	; 0x1db8 <DebugTimerList+0x16e>
    1db6:	bc cf       	rjmp	.-136    	; 0x1d30 <DebugTimerList+0xe6>
    1db8:	4b 15       	cp	r20, r11
    1dba:	08 f4       	brcc	.+2      	; 0x1dbe <DebugTimerList+0x174>
    1dbc:	91 cf       	rjmp	.-222    	; 0x1ce0 <DebugTimerList+0x96>
    1dbe:	b4 16       	cp	r11, r20
    1dc0:	09 f0       	breq	.+2      	; 0x1dc4 <DebugTimerList+0x17a>
    1dc2:	b6 cf       	rjmp	.-148    	; 0x1d30 <DebugTimerList+0xe6>
    1dc4:	3a 15       	cp	r19, r10
    1dc6:	08 f4       	brcc	.+2      	; 0x1dca <DebugTimerList+0x180>
    1dc8:	8b cf       	rjmp	.-234    	; 0x1ce0 <DebugTimerList+0x96>
    1dca:	a3 16       	cp	r10, r19
    1dcc:	09 f0       	breq	.+2      	; 0x1dd0 <DebugTimerList+0x186>
    1dce:	b0 cf       	rjmp	.-160    	; 0x1d30 <DebugTimerList+0xe6>
    1dd0:	29 15       	cp	r18, r9
    1dd2:	08 f0       	brcs	.+2      	; 0x1dd6 <DebugTimerList+0x18c>
    1dd4:	ad cf       	rjmp	.-166    	; 0x1d30 <DebugTimerList+0xe6>
    1dd6:	84 cf       	rjmp	.-248    	; 0x1ce0 <DebugTimerList+0x96>
void onTimer()
{
  if (timerList.firstNode == NULL)
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1dd8:	80 17       	cp	r24, r16
    1dda:	08 f4       	brcc	.+2      	; 0x1dde <DebugTimerList+0x194>
    1ddc:	85 cf       	rjmp	.-246    	; 0x1ce8 <DebugTimerList+0x9e>
    1dde:	08 17       	cp	r16, r24
    1de0:	09 f0       	breq	.+2      	; 0x1de4 <DebugTimerList+0x19a>
    1de2:	be cf       	rjmp	.-132    	; 0x1d60 <DebugTimerList+0x116>
    1de4:	7f 15       	cp	r23, r15
    1de6:	08 f4       	brcc	.+2      	; 0x1dea <DebugTimerList+0x1a0>
    1de8:	7f cf       	rjmp	.-258    	; 0x1ce8 <DebugTimerList+0x9e>
    1dea:	f7 16       	cp	r15, r23
    1dec:	09 f0       	breq	.+2      	; 0x1df0 <DebugTimerList+0x1a6>
    1dee:	b8 cf       	rjmp	.-144    	; 0x1d60 <DebugTimerList+0x116>
    1df0:	6e 15       	cp	r22, r14
    1df2:	08 f4       	brcc	.+2      	; 0x1df6 <DebugTimerList+0x1ac>
    1df4:	79 cf       	rjmp	.-270    	; 0x1ce8 <DebugTimerList+0x9e>
    1df6:	e6 16       	cp	r14, r22
    1df8:	09 f0       	breq	.+2      	; 0x1dfc <DebugTimerList+0x1b2>
    1dfa:	b2 cf       	rjmp	.-156    	; 0x1d60 <DebugTimerList+0x116>
    1dfc:	5c 15       	cp	r21, r12
    1dfe:	08 f4       	brcc	.+2      	; 0x1e02 <DebugTimerList+0x1b8>
    1e00:	73 cf       	rjmp	.-282    	; 0x1ce8 <DebugTimerList+0x9e>
    1e02:	c5 16       	cp	r12, r21
    1e04:	09 f0       	breq	.+2      	; 0x1e08 <DebugTimerList+0x1be>
    1e06:	ac cf       	rjmp	.-168    	; 0x1d60 <DebugTimerList+0x116>
    1e08:	4b 15       	cp	r20, r11
    1e0a:	08 f4       	brcc	.+2      	; 0x1e0e <DebugTimerList+0x1c4>
    1e0c:	6d cf       	rjmp	.-294    	; 0x1ce8 <DebugTimerList+0x9e>
    1e0e:	b4 16       	cp	r11, r20
    1e10:	09 f0       	breq	.+2      	; 0x1e14 <DebugTimerList+0x1ca>
    1e12:	a6 cf       	rjmp	.-180    	; 0x1d60 <DebugTimerList+0x116>
    1e14:	3a 15       	cp	r19, r10
    1e16:	08 f4       	brcc	.+2      	; 0x1e1a <DebugTimerList+0x1d0>
    1e18:	67 cf       	rjmp	.-306    	; 0x1ce8 <DebugTimerList+0x9e>
    1e1a:	a3 16       	cp	r10, r19
    1e1c:	09 f0       	breq	.+2      	; 0x1e20 <DebugTimerList+0x1d6>
    1e1e:	a0 cf       	rjmp	.-192    	; 0x1d60 <DebugTimerList+0x116>
    1e20:	29 15       	cp	r18, r9
    1e22:	08 f4       	brcc	.+2      	; 0x1e26 <DebugTimerList+0x1dc>
    1e24:	61 cf       	rjmp	.-318    	; 0x1ce8 <DebugTimerList+0x9e>
    1e26:	9c cf       	rjmp	.-200    	; 0x1d60 <DebugTimerList+0x116>

00001e28 <insertDlNodeAfter>:
    1e28:	cf 93       	push	r28
    1e2a:	df 93       	push	r29
    1e2c:	9c 01       	movw	r18, r24
    1e2e:	db 01       	movw	r26, r22
    1e30:	fa 01       	movw	r30, r20
    1e32:	71 83       	std	Z+1, r23	; 0x01
    1e34:	60 83       	st	Z, r22
    1e36:	12 96       	adiw	r26, 0x02	; 2
    1e38:	8d 91       	ld	r24, X+
    1e3a:	9c 91       	ld	r25, X
    1e3c:	13 97       	sbiw	r26, 0x03	; 3
    1e3e:	93 83       	std	Z+3, r25	; 0x03
    1e40:	82 83       	std	Z+2, r24	; 0x02
    1e42:	12 96       	adiw	r26, 0x02	; 2
    1e44:	cd 91       	ld	r28, X+
    1e46:	dc 91       	ld	r29, X
    1e48:	13 97       	sbiw	r26, 0x03	; 3
    1e4a:	20 97       	sbiw	r28, 0x00	; 0
    1e4c:	49 f0       	breq	.+18     	; 0x1e60 <insertDlNodeAfter+0x38>
    1e4e:	59 83       	std	Y+1, r21	; 0x01
    1e50:	48 83       	st	Y, r20
    1e52:	13 96       	adiw	r26, 0x03	; 3
    1e54:	fc 93       	st	X, r31
    1e56:	ee 93       	st	-X, r30
    1e58:	12 97       	sbiw	r26, 0x02	; 2
    1e5a:	df 91       	pop	r29
    1e5c:	cf 91       	pop	r28
    1e5e:	08 95       	ret
    1e60:	e9 01       	movw	r28, r18
    1e62:	5b 83       	std	Y+3, r21	; 0x03
    1e64:	4a 83       	std	Y+2, r20	; 0x02
    1e66:	13 96       	adiw	r26, 0x03	; 3
    1e68:	fc 93       	st	X, r31
    1e6a:	ee 93       	st	-X, r30
    1e6c:	12 97       	sbiw	r26, 0x02	; 2
    1e6e:	df 91       	pop	r29
    1e70:	cf 91       	pop	r28
    1e72:	08 95       	ret

00001e74 <insertDlNodeBefore>:
    1e74:	cf 93       	push	r28
    1e76:	df 93       	push	r29
    1e78:	9c 01       	movw	r18, r24
    1e7a:	db 01       	movw	r26, r22
    1e7c:	fa 01       	movw	r30, r20
    1e7e:	8d 91       	ld	r24, X+
    1e80:	9c 91       	ld	r25, X
    1e82:	11 97       	sbiw	r26, 0x01	; 1
    1e84:	91 83       	std	Z+1, r25	; 0x01
    1e86:	80 83       	st	Z, r24
    1e88:	73 83       	std	Z+3, r23	; 0x03
    1e8a:	62 83       	std	Z+2, r22	; 0x02
    1e8c:	cd 91       	ld	r28, X+
    1e8e:	dc 91       	ld	r29, X
    1e90:	11 97       	sbiw	r26, 0x01	; 1
    1e92:	20 97       	sbiw	r28, 0x00	; 0
    1e94:	39 f0       	breq	.+14     	; 0x1ea4 <insertDlNodeBefore+0x30>
    1e96:	5b 83       	std	Y+3, r21	; 0x03
    1e98:	4a 83       	std	Y+2, r20	; 0x02
    1e9a:	ed 93       	st	X+, r30
    1e9c:	fc 93       	st	X, r31
    1e9e:	df 91       	pop	r29
    1ea0:	cf 91       	pop	r28
    1ea2:	08 95       	ret
    1ea4:	e9 01       	movw	r28, r18
    1ea6:	59 83       	std	Y+1, r21	; 0x01
    1ea8:	48 83       	st	Y, r20
    1eaa:	ed 93       	st	X+, r30
    1eac:	fc 93       	st	X, r31
    1eae:	df 91       	pop	r29
    1eb0:	cf 91       	pop	r28
    1eb2:	08 95       	ret

00001eb4 <insertDlNodeBeginning>:
    1eb4:	cf 93       	push	r28
    1eb6:	df 93       	push	r29
    1eb8:	9c 01       	movw	r18, r24
    1eba:	db 01       	movw	r26, r22
    1ebc:	ec 01       	movw	r28, r24
    1ebe:	e8 81       	ld	r30, Y
    1ec0:	f9 81       	ldd	r31, Y+1	; 0x01
    1ec2:	30 97       	sbiw	r30, 0x00	; 0
    1ec4:	a1 f0       	breq	.+40     	; 0x1eee <insertDlNodeBeginning+0x3a>
    1ec6:	80 81       	ld	r24, Z
    1ec8:	91 81       	ldd	r25, Z+1	; 0x01
    1eca:	11 96       	adiw	r26, 0x01	; 1
    1ecc:	9c 93       	st	X, r25
    1ece:	8e 93       	st	-X, r24
    1ed0:	13 96       	adiw	r26, 0x03	; 3
    1ed2:	fc 93       	st	X, r31
    1ed4:	ee 93       	st	-X, r30
    1ed6:	12 97       	sbiw	r26, 0x02	; 2
    1ed8:	c0 81       	ld	r28, Z
    1eda:	d1 81       	ldd	r29, Z+1	; 0x01
    1edc:	20 97       	sbiw	r28, 0x00	; 0
    1ede:	a9 f0       	breq	.+42     	; 0x1f0a <insertDlNodeBeginning+0x56>
    1ee0:	7b 83       	std	Y+3, r23	; 0x03
    1ee2:	6a 83       	std	Y+2, r22	; 0x02
    1ee4:	b1 83       	std	Z+1, r27	; 0x01
    1ee6:	a0 83       	st	Z, r26
    1ee8:	df 91       	pop	r29
    1eea:	cf 91       	pop	r28
    1eec:	08 95       	ret
    1eee:	79 83       	std	Y+1, r23	; 0x01
    1ef0:	68 83       	st	Y, r22
    1ef2:	7b 83       	std	Y+3, r23	; 0x03
    1ef4:	6a 83       	std	Y+2, r22	; 0x02
    1ef6:	11 96       	adiw	r26, 0x01	; 1
    1ef8:	1c 92       	st	X, r1
    1efa:	1e 92       	st	-X, r1
    1efc:	13 96       	adiw	r26, 0x03	; 3
    1efe:	1c 92       	st	X, r1
    1f00:	1e 92       	st	-X, r1
    1f02:	12 97       	sbiw	r26, 0x02	; 2
    1f04:	df 91       	pop	r29
    1f06:	cf 91       	pop	r28
    1f08:	08 95       	ret
    1f0a:	e9 01       	movw	r28, r18
    1f0c:	79 83       	std	Y+1, r23	; 0x01
    1f0e:	68 83       	st	Y, r22
    1f10:	e9 cf       	rjmp	.-46     	; 0x1ee4 <insertDlNodeBeginning+0x30>

00001f12 <insertDlNodeLast>:
    1f12:	cf 93       	push	r28
    1f14:	df 93       	push	r29
    1f16:	9c 01       	movw	r18, r24
    1f18:	eb 01       	movw	r28, r22
    1f1a:	dc 01       	movw	r26, r24
    1f1c:	12 96       	adiw	r26, 0x02	; 2
    1f1e:	ed 91       	ld	r30, X+
    1f20:	fc 91       	ld	r31, X
    1f22:	13 97       	sbiw	r26, 0x03	; 3
    1f24:	30 97       	sbiw	r30, 0x00	; 0
    1f26:	89 f0       	breq	.+34     	; 0x1f4a <insertDlNodeLast+0x38>
    1f28:	f9 83       	std	Y+1, r31	; 0x01
    1f2a:	e8 83       	st	Y, r30
    1f2c:	82 81       	ldd	r24, Z+2	; 0x02
    1f2e:	93 81       	ldd	r25, Z+3	; 0x03
    1f30:	9b 83       	std	Y+3, r25	; 0x03
    1f32:	8a 83       	std	Y+2, r24	; 0x02
    1f34:	a2 81       	ldd	r26, Z+2	; 0x02
    1f36:	b3 81       	ldd	r27, Z+3	; 0x03
    1f38:	10 97       	sbiw	r26, 0x00	; 0
    1f3a:	f9 f0       	breq	.+62     	; 0x1f7a <insertDlNodeLast+0x68>
    1f3c:	6d 93       	st	X+, r22
    1f3e:	7c 93       	st	X, r23
    1f40:	d3 83       	std	Z+3, r29	; 0x03
    1f42:	c2 83       	std	Z+2, r28	; 0x02
    1f44:	df 91       	pop	r29
    1f46:	cf 91       	pop	r28
    1f48:	08 95       	ret
    1f4a:	ed 91       	ld	r30, X+
    1f4c:	fc 91       	ld	r31, X
    1f4e:	11 97       	sbiw	r26, 0x01	; 1
    1f50:	30 97       	sbiw	r30, 0x00	; 0
    1f52:	c9 f0       	breq	.+50     	; 0x1f86 <insertDlNodeLast+0x74>
    1f54:	80 81       	ld	r24, Z
    1f56:	91 81       	ldd	r25, Z+1	; 0x01
    1f58:	99 83       	std	Y+1, r25	; 0x01
    1f5a:	88 83       	st	Y, r24
    1f5c:	fb 83       	std	Y+3, r31	; 0x03
    1f5e:	ea 83       	std	Y+2, r30	; 0x02
    1f60:	a0 81       	ld	r26, Z
    1f62:	b1 81       	ldd	r27, Z+1	; 0x01
    1f64:	10 97       	sbiw	r26, 0x00	; 0
    1f66:	d9 f0       	breq	.+54     	; 0x1f9e <insertDlNodeLast+0x8c>
    1f68:	13 96       	adiw	r26, 0x03	; 3
    1f6a:	7c 93       	st	X, r23
    1f6c:	6e 93       	st	-X, r22
    1f6e:	12 97       	sbiw	r26, 0x02	; 2
    1f70:	d1 83       	std	Z+1, r29	; 0x01
    1f72:	c0 83       	st	Z, r28
    1f74:	df 91       	pop	r29
    1f76:	cf 91       	pop	r28
    1f78:	08 95       	ret
    1f7a:	d9 01       	movw	r26, r18
    1f7c:	13 96       	adiw	r26, 0x03	; 3
    1f7e:	7c 93       	st	X, r23
    1f80:	6e 93       	st	-X, r22
    1f82:	12 97       	sbiw	r26, 0x02	; 2
    1f84:	dd cf       	rjmp	.-70     	; 0x1f40 <insertDlNodeLast+0x2e>
    1f86:	11 96       	adiw	r26, 0x01	; 1
    1f88:	7c 93       	st	X, r23
    1f8a:	6e 93       	st	-X, r22
    1f8c:	13 96       	adiw	r26, 0x03	; 3
    1f8e:	7c 93       	st	X, r23
    1f90:	6e 93       	st	-X, r22
    1f92:	12 97       	sbiw	r26, 0x02	; 2
    1f94:	19 82       	std	Y+1, r1	; 0x01
    1f96:	18 82       	st	Y, r1
    1f98:	1b 82       	std	Y+3, r1	; 0x03
    1f9a:	1a 82       	std	Y+2, r1	; 0x02
    1f9c:	d3 cf       	rjmp	.-90     	; 0x1f44 <insertDlNodeLast+0x32>
    1f9e:	d9 01       	movw	r26, r18
    1fa0:	6d 93       	st	X+, r22
    1fa2:	7c 93       	st	X, r23
    1fa4:	e5 cf       	rjmp	.-54     	; 0x1f70 <insertDlNodeLast+0x5e>

00001fa6 <removeDlNode>:
    1fa6:	cf 93       	push	r28
    1fa8:	df 93       	push	r29
    1faa:	ec 01       	movw	r28, r24
    1fac:	fb 01       	movw	r30, r22
    1fae:	a0 81       	ld	r26, Z
    1fb0:	b1 81       	ldd	r27, Z+1	; 0x01
    1fb2:	10 97       	sbiw	r26, 0x00	; 0
    1fb4:	81 f0       	breq	.+32     	; 0x1fd6 <removeDlNode+0x30>
    1fb6:	82 81       	ldd	r24, Z+2	; 0x02
    1fb8:	93 81       	ldd	r25, Z+3	; 0x03
    1fba:	13 96       	adiw	r26, 0x03	; 3
    1fbc:	9c 93       	st	X, r25
    1fbe:	8e 93       	st	-X, r24
    1fc0:	12 97       	sbiw	r26, 0x02	; 2
    1fc2:	02 80       	ldd	r0, Z+2	; 0x02
    1fc4:	f3 81       	ldd	r31, Z+3	; 0x03
    1fc6:	e0 2d       	mov	r30, r0
    1fc8:	30 97       	sbiw	r30, 0x00	; 0
    1fca:	71 f0       	breq	.+28     	; 0x1fe8 <removeDlNode+0x42>
    1fcc:	b1 83       	std	Z+1, r27	; 0x01
    1fce:	a0 83       	st	Z, r26
    1fd0:	df 91       	pop	r29
    1fd2:	cf 91       	pop	r28
    1fd4:	08 95       	ret
    1fd6:	82 81       	ldd	r24, Z+2	; 0x02
    1fd8:	93 81       	ldd	r25, Z+3	; 0x03
    1fda:	99 83       	std	Y+1, r25	; 0x01
    1fdc:	88 83       	st	Y, r24
    1fde:	02 80       	ldd	r0, Z+2	; 0x02
    1fe0:	f3 81       	ldd	r31, Z+3	; 0x03
    1fe2:	e0 2d       	mov	r30, r0
    1fe4:	30 97       	sbiw	r30, 0x00	; 0
    1fe6:	91 f7       	brne	.-28     	; 0x1fcc <removeDlNode+0x26>
    1fe8:	bb 83       	std	Y+3, r27	; 0x03
    1fea:	aa 83       	std	Y+2, r26	; 0x02
    1fec:	df 91       	pop	r29
    1fee:	cf 91       	pop	r28
    1ff0:	08 95       	ret

00001ff2 <pushQueueEntry>:
    1ff2:	cf 93       	push	r28
    1ff4:	df 93       	push	r29
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	db 01       	movw	r26, r22
    1ffa:	84 81       	ldd	r24, Z+4	; 0x04
    1ffc:	88 23       	and	r24, r24
    1ffe:	91 f0       	breq	.+36     	; 0x2024 <pushQueueEntry+0x32>
    2000:	11 96       	adiw	r26, 0x01	; 1
    2002:	1c 92       	st	X, r1
    2004:	1e 92       	st	-X, r1
    2006:	c0 81       	ld	r28, Z
    2008:	d1 81       	ldd	r29, Z+1	; 0x01
    200a:	20 97       	sbiw	r28, 0x00	; 0
    200c:	79 f0       	breq	.+30     	; 0x202c <pushQueueEntry+0x3a>
    200e:	79 83       	std	Y+1, r23	; 0x01
    2010:	68 83       	st	Y, r22
    2012:	b1 83       	std	Z+1, r27	; 0x01
    2014:	a0 83       	st	Z, r26
    2016:	84 81       	ldd	r24, Z+4	; 0x04
    2018:	81 50       	subi	r24, 0x01	; 1
    201a:	84 83       	std	Z+4, r24	; 0x04
    201c:	80 e0       	ldi	r24, 0x00	; 0
    201e:	df 91       	pop	r29
    2020:	cf 91       	pop	r28
    2022:	08 95       	ret
    2024:	81 e0       	ldi	r24, 0x01	; 1
    2026:	df 91       	pop	r29
    2028:	cf 91       	pop	r28
    202a:	08 95       	ret
    202c:	73 83       	std	Z+3, r23	; 0x03
    202e:	62 83       	std	Z+2, r22	; 0x02
    2030:	f0 cf       	rjmp	.-32     	; 0x2012 <pushQueueEntry+0x20>

00002032 <queueIsEmpty>:
    2032:	20 e0       	ldi	r18, 0x00	; 0
    2034:	fc 01       	movw	r30, r24
    2036:	82 81       	ldd	r24, Z+2	; 0x02
    2038:	93 81       	ldd	r25, Z+3	; 0x03
    203a:	89 2b       	or	r24, r25
    203c:	09 f0       	breq	.+2      	; 0x2040 <queueIsEmpty+0xe>
    203e:	21 e0       	ldi	r18, 0x01	; 1
    2040:	82 2f       	mov	r24, r18
    2042:	08 95       	ret

00002044 <queueIsFull>:
    2044:	20 e0       	ldi	r18, 0x00	; 0
    2046:	fc 01       	movw	r30, r24
    2048:	84 81       	ldd	r24, Z+4	; 0x04
    204a:	88 23       	and	r24, r24
    204c:	09 f4       	brne	.+2      	; 0x2050 <queueIsFull+0xc>
    204e:	21 e0       	ldi	r18, 0x01	; 1
    2050:	82 2f       	mov	r24, r18
    2052:	08 95       	ret

00002054 <popQueueEntry>:
    2054:	fc 01       	movw	r30, r24
    2056:	a2 81       	ldd	r26, Z+2	; 0x02
    2058:	b3 81       	ldd	r27, Z+3	; 0x03
    205a:	10 97       	sbiw	r26, 0x00	; 0
    205c:	51 f0       	breq	.+20     	; 0x2072 <popQueueEntry+0x1e>
    205e:	8d 91       	ld	r24, X+
    2060:	9c 91       	ld	r25, X
    2062:	11 97       	sbiw	r26, 0x01	; 1
    2064:	93 83       	std	Z+3, r25	; 0x03
    2066:	82 83       	std	Z+2, r24	; 0x02
    2068:	89 2b       	or	r24, r25
    206a:	29 f0       	breq	.+10     	; 0x2076 <popQueueEntry+0x22>
    206c:	84 81       	ldd	r24, Z+4	; 0x04
    206e:	8f 5f       	subi	r24, 0xFF	; 255
    2070:	84 83       	std	Z+4, r24	; 0x04
    2072:	cd 01       	movw	r24, r26
    2074:	08 95       	ret
    2076:	11 82       	std	Z+1, r1	; 0x01
    2078:	10 82       	st	Z, r1
    207a:	f8 cf       	rjmp	.-16     	; 0x206c <popQueueEntry+0x18>

0000207c <__vector_16>:




ISR(TIMER0_OVF_vect)
{
    207c:	1f 92       	push	r1
    207e:	0f 92       	push	r0
    2080:	0f b6       	in	r0, 0x3f	; 63
    2082:	0f 92       	push	r0
    2084:	11 24       	eor	r1, r1
    2086:	8f 93       	push	r24
    2088:	9f 93       	push	r25
    208a:	af 93       	push	r26
    208c:	bf 93       	push	r27
  // we should get 4 interrupts per Second... 
  TCNT0 = 0;
    208e:	12 be       	out	0x32, r1	; 50
  overflows++;
    2090:	80 91 79 08 	lds	r24, 0x0879
    2094:	90 91 7a 08 	lds	r25, 0x087A
    2098:	a0 91 7b 08 	lds	r26, 0x087B
    209c:	b0 91 7c 08 	lds	r27, 0x087C
    20a0:	01 96       	adiw	r24, 0x01	; 1
    20a2:	a1 1d       	adc	r26, r1
    20a4:	b1 1d       	adc	r27, r1
    20a6:	80 93 79 08 	sts	0x0879, r24
    20aa:	90 93 7a 08 	sts	0x087A, r25
    20ae:	a0 93 7b 08 	sts	0x087B, r26
    20b2:	b0 93 7c 08 	sts	0x087C, r27
}
    20b6:	bf 91       	pop	r27
    20b8:	af 91       	pop	r26
    20ba:	9f 91       	pop	r25
    20bc:	8f 91       	pop	r24
    20be:	0f 90       	pop	r0
    20c0:	0f be       	out	0x3f, r0	; 63
    20c2:	0f 90       	pop	r0
    20c4:	1f 90       	pop	r1
    20c6:	18 95       	reti

000020c8 <rtcInitialize>:
void rtcInitialize()
{



  overflows = 0;
    20c8:	10 92 79 08 	sts	0x0879, r1
    20cc:	10 92 7a 08 	sts	0x087A, r1
    20d0:	10 92 7b 08 	sts	0x087B, r1
    20d4:	10 92 7c 08 	sts	0x087C, r1
  // ...the timer is asynchronous to out system clock...
  // ... according to the ATMega manual, the following...
  // ... precausions are mandatory.
  
  // Disable interrputs OCIE0 and TOIE0...
  TIMSK &= ~( (1<<OCIE0) | (1<<TOIE0) );
    20d8:	87 b7       	in	r24, 0x37	; 55
    20da:	8c 7f       	andi	r24, 0xFC	; 252
    20dc:	87 bf       	out	0x37, r24	; 55
  // ... switch to asynchronous mode...
  ASSR |= (1 << AS0);
    20de:	80 b7       	in	r24, 0x30	; 48
    20e0:	88 60       	ori	r24, 0x08	; 8
    20e2:	80 bf       	out	0x30, r24	; 48
  // ... clear TCNT0, OCR0 ...
  TCNT0 = 0;
    20e4:	12 be       	out	0x32, r1	; 50
  OCR0 = 0;
    20e6:	11 be       	out	0x31, r1	; 49
  // ... clear and set TCCR0 to the 32 prescal divider
  TCCR0 = (1 << CS00) |  (1<<CS01);
    20e8:	83 e0       	ldi	r24, 0x03	; 3
    20ea:	83 bf       	out	0x33, r24	; 51
  
  // now wait for TCN0UB
  while (!(ASSR & (1<< TCN0UB)));
    20ec:	00 b6       	in	r0, 0x30	; 48
    20ee:	02 fe       	sbrs	r0, 2
    20f0:	fd cf       	rjmp	.-6      	; 0x20ec <rtcInitialize+0x24>
  
  // Clear Timer Infterrput flags...
  TIFR &= ~( (1<<OCF0) | (1<<TOV0));  
    20f2:	86 b7       	in	r24, 0x36	; 54
    20f4:	8c 7f       	andi	r24, 0xFC	; 252
    20f6:	86 bf       	out	0x36, r24	; 54
  
  // Enable Overflow Interrupt 
  TIMSK |= (1 << TOIE0); 
    20f8:	87 b7       	in	r24, 0x37	; 55
    20fa:	81 60       	ori	r24, 0x01	; 1
    20fc:	87 bf       	out	0x37, r24	; 55


  
}
    20fe:	08 95       	ret

00002100 <rtcGetTime64>:

uint64_t rtcGetTime64()
{
    2100:	af 92       	push	r10
    2102:	bf 92       	push	r11
    2104:	cf 92       	push	r12
    2106:	df 92       	push	r13
    2108:	ef 92       	push	r14
    210a:	ff 92       	push	r15
    210c:	0f 93       	push	r16
    210e:	1f 93       	push	r17
  return (overflows << 8) + TCNT0;
    2110:	a0 90 79 08 	lds	r10, 0x0879
    2114:	b0 90 7a 08 	lds	r11, 0x087A
    2118:	c0 90 7b 08 	lds	r12, 0x087B
    211c:	d0 90 7c 08 	lds	r13, 0x087C
    2120:	82 b7       	in	r24, 0x32	; 50
    2122:	dc 2c       	mov	r13, r12
    2124:	cb 2c       	mov	r12, r11
    2126:	ba 2c       	mov	r11, r10
    2128:	aa 24       	eor	r10, r10
    212a:	a8 0e       	add	r10, r24
    212c:	b1 1c       	adc	r11, r1
    212e:	c1 1c       	adc	r12, r1
    2130:	d1 1c       	adc	r13, r1
}
    2132:	95 01       	movw	r18, r10
    2134:	a6 01       	movw	r20, r12
    2136:	60 e0       	ldi	r22, 0x00	; 0
    2138:	70 e0       	ldi	r23, 0x00	; 0
    213a:	80 e0       	ldi	r24, 0x00	; 0
    213c:	90 e0       	ldi	r25, 0x00	; 0
    213e:	1f 91       	pop	r17
    2140:	0f 91       	pop	r16
    2142:	ff 90       	pop	r15
    2144:	ef 90       	pop	r14
    2146:	df 90       	pop	r13
    2148:	cf 90       	pop	r12
    214a:	bf 90       	pop	r11
    214c:	af 90       	pop	r10
    214e:	08 95       	ret

00002150 <rtcGetTime32>:

uint32_t rtcGetTime32()
{
  // will cut of the upper 8 bits...
  return (overflows << 8) + TCNT0;
    2150:	20 91 79 08 	lds	r18, 0x0879
    2154:	30 91 7a 08 	lds	r19, 0x087A
    2158:	40 91 7b 08 	lds	r20, 0x087B
    215c:	50 91 7c 08 	lds	r21, 0x087C
    2160:	82 b7       	in	r24, 0x32	; 50
    2162:	54 2f       	mov	r21, r20
    2164:	43 2f       	mov	r20, r19
    2166:	32 2f       	mov	r19, r18
    2168:	22 27       	eor	r18, r18
    216a:	28 0f       	add	r18, r24
    216c:	31 1d       	adc	r19, r1
    216e:	41 1d       	adc	r20, r1
    2170:	51 1d       	adc	r21, r1
}
    2172:	b9 01       	movw	r22, r18
    2174:	ca 01       	movw	r24, r20
    2176:	08 95       	ret

00002178 <rtcGetTime16>:

uint16_t rtcGetTime16()
{
  // will cut of the upper 8 bits...
  return (overflows << 8) + TCNT0;
    2178:	20 91 79 08 	lds	r18, 0x0879
    217c:	30 91 7a 08 	lds	r19, 0x087A
    2180:	40 91 7b 08 	lds	r20, 0x087B
    2184:	50 91 7c 08 	lds	r21, 0x087C
    2188:	82 b7       	in	r24, 0x32	; 50
    218a:	32 2f       	mov	r19, r18
    218c:	22 27       	eor	r18, r18
    218e:	28 0f       	add	r18, r24
    2190:	31 1d       	adc	r19, r1
}
    2192:	c9 01       	movw	r24, r18
    2194:	08 95       	ret

00002196 <com0putChar>:
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR0A&32));
    2196:	5d 9b       	sbis	0x0b, 5	; 11
    2198:	fe cf       	rjmp	.-4      	; 0x2196 <com0putChar>
	//sende
	UDR0=data;
    219a:	8c b9       	out	0x0c, r24	; 12
}
    219c:	08 95       	ret

0000219e <com0putBuffer>:
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putBuffer(char *buffer,uint8_t len)
{
int i=0;
	for (i=0; i<len ;i++) com0putChar (buffer[i]);
    219e:	70 e0       	ldi	r23, 0x00	; 0
    21a0:	61 15       	cp	r22, r1
    21a2:	71 05       	cpc	r23, r1
    21a4:	71 f0       	breq	.+28     	; 0x21c2 <com0putBuffer+0x24>
    21a6:	20 e0       	ldi	r18, 0x00	; 0
    21a8:	30 e0       	ldi	r19, 0x00	; 0
    21aa:	fc 01       	movw	r30, r24
    21ac:	e2 0f       	add	r30, r18
    21ae:	f3 1f       	adc	r31, r19
    21b0:	e0 81       	ld	r30, Z
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR0A&32));
    21b2:	5d 9b       	sbis	0x0b, 5	; 11
    21b4:	fe cf       	rjmp	.-4      	; 0x21b2 <com0putBuffer+0x14>
	//sende
	UDR0=data;
    21b6:	ec b9       	out	0x0c, r30	; 12
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putBuffer(char *buffer,uint8_t len)
{
int i=0;
	for (i=0; i<len ;i++) com0putChar (buffer[i]);
    21b8:	2f 5f       	subi	r18, 0xFF	; 255
    21ba:	3f 4f       	sbci	r19, 0xFF	; 255
    21bc:	26 17       	cp	r18, r22
    21be:	37 07       	cpc	r19, r23
    21c0:	a4 f3       	brlt	.-24     	; 0x21aa <com0putBuffer+0xc>
    21c2:	08 95       	ret

000021c4 <com0SendBytes>:
    UCSR0B |= (1 << UDRIE0);

	*/
      
    return;
  }
    21c4:	08 95       	ret

000021c6 <com0HasBytes>:
    return;
  }
  
  uint8_t com0HasBytes()
  {
    return queueIsEmpty(&hUsart0.recvFiFo);
    21c6:	82 e7       	ldi	r24, 0x72	; 114
    21c8:	99 e0       	ldi	r25, 0x09	; 9
    21ca:	0e 94 19 10 	call	0x2032	; 0x2032 <queueIsEmpty>
  }
    21ce:	08 95       	ret

000021d0 <com0RotateSendBuffer>:
    UCSR0B |= (1 << RXCIE0);

  }
  
  void com0RotateSendBuffer()
  {
    21d0:	cf 93       	push	r28
    21d2:	df 93       	push	r29
    
    /* !!! IF YOU MOFIFY THIS BLOCK ALWAYS SYNC IT WITH THE CODE !!! */ 
    /* !!! IN com0SendBytes()                                    !!! */
    
    // in order to ayoid timing issues, disable TX Interrupt
    UCSR0B &= ~ (1 << UDRIE0);
    21d4:	55 98       	cbi	0x0a, 5	; 10
   
    struct queueElement_t* node
      = (struct queueElement_t*) popQueueEntry(&hUsart0.sendFiFo);
    21d6:	87 e7       	ldi	r24, 0x77	; 119
    21d8:	99 e0       	ldi	r25, 0x09	; 9
    21da:	0e 94 2a 10 	call	0x2054	; 0x2054 <popQueueEntry>
    21de:	ec 01       	movw	r28, r24
    
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    21e0:	8c 81       	ldd	r24, Y+4	; 0x04
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    21e2:	48 e7       	ldi	r20, 0x78	; 120
    21e4:	50 e0       	ldi	r21, 0x00	; 0
    21e6:	48 1b       	sub	r20, r24
    21e8:	51 09       	sbc	r21, r1
    21ea:	49 50       	subi	r20, 0x09	; 9
    21ec:	57 4f       	sbci	r21, 0xF7	; 247
    
    while (len--)
    21ee:	88 23       	and	r24, r24
    21f0:	19 f1       	breq	.+70     	; 0x2238 <com0RotateSendBuffer+0x68>
    21f2:	28 2f       	mov	r18, r24
    21f4:	21 50       	subi	r18, 0x01	; 1
    {
      worker[len] = node->buffer[len];
    21f6:	82 2f       	mov	r24, r18
    21f8:	90 e0       	ldi	r25, 0x00	; 0
    21fa:	da 01       	movw	r26, r20
    21fc:	a8 0f       	add	r26, r24
    21fe:	b9 1f       	adc	r27, r25
    2200:	ea 81       	ldd	r30, Y+2	; 0x02
    2202:	fb 81       	ldd	r31, Y+3	; 0x03
    2204:	e8 0f       	add	r30, r24
    2206:	f9 1f       	adc	r31, r25
    2208:	80 81       	ld	r24, Z
    220a:	8c 93       	st	X, r24
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    
    while (len--)
    220c:	21 50       	subi	r18, 0x01	; 1
    220e:	98 f7       	brcc	.-26     	; 0x21f6 <com0RotateSendBuffer+0x26>
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    2210:	80 e7       	ldi	r24, 0x70	; 112
    2212:	98 e0       	ldi	r25, 0x08	; 8
    2214:	90 93 70 09 	sts	0x0970, r25
    2218:	80 93 6f 09 	sts	0x096F, r24
    
    if (node->len > 0) 
    221c:	8c 81       	ldd	r24, Y+4	; 0x04
    221e:	88 23       	and	r24, r24
    2220:	21 f0       	breq	.+8      	; 0x222a <com0RotateSendBuffer+0x5a>
      free(node->buffer);
    2222:	8a 81       	ldd	r24, Y+2	; 0x02
    2224:	9b 81       	ldd	r25, Y+3	; 0x03
    2226:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
    free(node);
    222a:	ce 01       	movw	r24, r28
    222c:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
  
    // reenable TX Interrupts...
    UCSR0B |= (1 << UDRIE0);
    2230:	55 9a       	sbi	0x0a, 5	; 10
  }
    2232:	df 91       	pop	r29
    2234:	cf 91       	pop	r28
    2236:	08 95       	ret
    while (len--)
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    2238:	80 e7       	ldi	r24, 0x70	; 112
    223a:	98 e0       	ldi	r25, 0x08	; 8
    223c:	90 93 70 09 	sts	0x0970, r25
    2240:	80 93 6f 09 	sts	0x096F, r24
    2244:	f2 cf       	rjmp	.-28     	; 0x222a <com0RotateSendBuffer+0x5a>

00002246 <com0RecvBytes>:
  
  // reveives bytes, any reveived bytes will be written to the buffer...
  // ... memory will be automatially allocated memory, therefore make sure
  // that your free it!;
  void com0RecvBytes(char** buffer, uint8_t* len)
  {
    2246:	ef 92       	push	r14
    2248:	ff 92       	push	r15
    224a:	0f 93       	push	r16
    224c:	1f 93       	push	r17
    224e:	7c 01       	movw	r14, r24
    2250:	8b 01       	movw	r16, r22
	


    struct queueElement_t* node
      = (struct queueElement_t*) popQueueEntry(&hUsart0.recvFiFo);
    2252:	82 e7       	ldi	r24, 0x72	; 114
    2254:	99 e0       	ldi	r25, 0x09	; 9
    2256:	0e 94 2a 10 	call	0x2054	; 0x2054 <popQueueEntry>
    225a:	fc 01       	movw	r30, r24


    *len = node->len;   
    225c:	84 81       	ldd	r24, Z+4	; 0x04
    225e:	d8 01       	movw	r26, r16
    2260:	8c 93       	st	X, r24
    *buffer = node->buffer;     
    2262:	82 81       	ldd	r24, Z+2	; 0x02
    2264:	93 81       	ldd	r25, Z+3	; 0x03
    2266:	d7 01       	movw	r26, r14
    2268:	8d 93       	st	X+, r24
    226a:	9c 93       	st	X, r25
    
    free(node);
    226c:	cf 01       	movw	r24, r30
    226e:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
    // TODO: Etwas suboptimal, in onCom0Timeout wird der timer auch
    // neu gesetzt. Und auf einen onCom0Timeout wird in den meisten
    // fllen auch ein com0RecvBytes aufruf folgen...


    timerClearTimeout(hUsart0.timeout); //alx EINGEFGT	
    2272:	80 91 7c 09 	lds	r24, 0x097C
    2276:	90 91 7d 09 	lds	r25, 0x097D
    227a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <timerClearTimeout>


    hUsart0.timeout = timerAddTimeout(COM0_TIMEOUT,onCom0Timeout); 
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	92 e0       	ldi	r25, 0x02	; 2
    2282:	69 ef       	ldi	r22, 0xF9	; 249
    2284:	71 e1       	ldi	r23, 0x11	; 17
    2286:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <timerAddTimeout>
    228a:	90 93 7d 09 	sts	0x097D, r25
    228e:	80 93 7c 09 	sts	0x097C, r24



	
    return;
  }
    2292:	1f 91       	pop	r17
    2294:	0f 91       	pop	r16
    2296:	ff 90       	pop	r15
    2298:	ef 90       	pop	r14
    229a:	08 95       	ret

0000229c <com0Initialize>:
    hUsart0.timeout = timerAddTimeout(COM0_TIMEOUT,onCom0Timeout);
	
  }
  
  void com0Initialize(uint16_t prescaler, uint8_t parity, uint8_t stop_bits, uint8_t data_bits,uint8_t SendBufferSizeLimit)
  {
    229c:	0f 93       	push	r16
    
	//init USART0 ( for data)

   	    // TX0 = OUT;
    DDRE = (1<<PE1 );
    229e:	32 e0       	ldi	r19, 0x02	; 2
    22a0:	32 b9       	out	0x02, r19	; 2
  
    // RX0 = IN
    DDRE &= ~(1<<PE0);
    22a2:	10 98       	cbi	0x02, 0	; 2

    /* Set baud rate */
    UBRR0H = (unsigned char)(prescaler>>8);
    22a4:	90 93 90 00 	sts	0x0090, r25
    UBRR0L = (unsigned char)prescaler;
    22a8:	89 b9       	out	0x09, r24	; 9
    
    // disable double speed, as we don't need it 
    UCSR0A &= ~(1 << U2X0);
    22aa:	59 98       	cbi	0x0b, 1	; 11
    // Enable receiver and transmitter module, as well as RX Interrupt..
    // ... tx interrupt will be activated when needed.    
    UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1 << RXCIE0) /*| (1 << UDRIE0)*/;
    22ac:	88 e9       	ldi	r24, 0x98	; 152
    22ae:	8a b9       	out	0x0a, r24	; 10

	//das muss gendert werden
    /* Set frame format: 8data, 2stop bit */


	UCSR0C |= (parity<<UPM0);
    22b0:	e5 e9       	ldi	r30, 0x95	; 149
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
    22b4:	80 81       	ld	r24, Z
    22b6:	62 95       	swap	r22
    22b8:	60 7f       	andi	r22, 0xF0	; 240
    22ba:	86 2b       	or	r24, r22
    22bc:	80 83       	st	Z, r24
    UCSR0C |= (stop_bits<<USBS0);
    22be:	80 81       	ld	r24, Z
    22c0:	44 0f       	add	r20, r20
    22c2:	44 0f       	add	r20, r20
    22c4:	44 0f       	add	r20, r20
    22c6:	84 2b       	or	r24, r20
    22c8:	80 83       	st	Z, r24
	UCSR0C |= (data_bits<<UCSZ0);
    22ca:	80 81       	ld	r24, Z
    22cc:	22 0f       	add	r18, r18
    22ce:	82 2b       	or	r24, r18
    22d0:	80 83       	st	Z, r24
    

    
    hUsart0.recvFiFo.first = NULL;
    22d2:	10 92 73 09 	sts	0x0973, r1
    22d6:	10 92 72 09 	sts	0x0972, r1
    hUsart0.recvFiFo.last  = NULL;
    22da:	10 92 75 09 	sts	0x0975, r1
    22de:	10 92 74 09 	sts	0x0974, r1
    hUsart0.recvFiFo.elements = 5;    
    22e2:	25 e0       	ldi	r18, 0x05	; 5
    22e4:	20 93 76 09 	sts	0x0976, r18
    hUsart0.recvCount  = hUsart0.recvBuffer;
    22e8:	8d e7       	ldi	r24, 0x7D	; 125
    22ea:	98 e0       	ldi	r25, 0x08	; 8
    22ec:	90 93 f6 08 	sts	0x08F6, r25
    22f0:	80 93 f5 08 	sts	0x08F5, r24
    
    hUsart0.sendFiFo.first = NULL;
    22f4:	10 92 78 09 	sts	0x0978, r1
    22f8:	10 92 77 09 	sts	0x0977, r1
    hUsart0.sendFiFo.last  = NULL;
    22fc:	10 92 7a 09 	sts	0x097A, r1
    2300:	10 92 79 09 	sts	0x0979, r1
    hUsart0.sendFiFo.elements = 5;
    2304:	20 93 7b 09 	sts	0x097B, r18
    hUsart0.sendCount  = hUsart0.sendBuffer+COM0_MAX_TX_BUF;
    2308:	8f e6       	ldi	r24, 0x6F	; 111
    230a:	99 e0       	ldi	r25, 0x09	; 9
    230c:	90 93 70 09 	sts	0x0970, r25
    2310:	80 93 6f 09 	sts	0x096F, r24

	hUsart0.SendBufferSizeLimit=SendBufferSizeLimit;
    2314:	00 93 71 09 	sts	0x0971, r16
    
    hUsart0.timeout = timerAddTimeout(COM0_TIMEOUT,onCom0Timeout);
    2318:	80 e0       	ldi	r24, 0x00	; 0
    231a:	92 e0       	ldi	r25, 0x02	; 2
    231c:	69 ef       	ldi	r22, 0xF9	; 249
    231e:	71 e1       	ldi	r23, 0x11	; 17
    2320:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <timerAddTimeout>
    2324:	90 93 7d 09 	sts	0x097D, r25
    2328:	80 93 7c 09 	sts	0x097C, r24
    
    return;
  }
    232c:	0f 91       	pop	r16
    232e:	08 95       	ret

00002330 <com0RotateRecvBuffer>:




  void com0RotateRecvBuffer()
  {
    2330:	ef 92       	push	r14
    2332:	ff 92       	push	r15
    2334:	1f 93       	push	r17
    2336:	cf 93       	push	r28
    2338:	df 93       	push	r29
    // We should rotate the Recv Buffers, therefore we have to disable...
    // ...the RX interrupt. If a interrupt would fire, while we rotate the
    // ... Buffer, we would mostlikely endup in a crash due to illeagal... 
    // ... memory allocations.
    UCSR0B &= ~(1 << RXCIE0);
    233a:	57 98       	cbi	0x0a, 7	; 10


    
    // Reject adding to queue, if it is full..
    if (queueIsFull(&hUsart0.recvFiFo) == 0)
    233c:	82 e7       	ldi	r24, 0x72	; 114
    233e:	99 e0       	ldi	r25, 0x09	; 9
    2340:	0e 94 22 10 	call	0x2044	; 0x2044 <queueIsFull>
    2344:	88 23       	and	r24, r24
    2346:	81 f5       	brne	.+96     	; 0x23a8 <com0RotateRecvBuffer+0x78>
    {


      // create a new queue element
      struct queueElement_t* node 
        = (struct queueElement_t*) malloc(sizeof(struct queueElement_t));
    2348:	85 e0       	ldi	r24, 0x05	; 5
    234a:	90 e0       	ldi	r25, 0x00	; 0
    234c:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    2350:	ec 01       	movw	r28, r24

    
      // ... if the buffer is empty we can do a short cut...
      if (hUsart0.recvCount != hUsart0.recvBuffer)
    2352:	80 91 f5 08 	lds	r24, 0x08F5
    2356:	90 91 f6 08 	lds	r25, 0x08F6
    235a:	2d e7       	ldi	r18, 0x7D	; 125
    235c:	e2 2e       	mov	r14, r18
    235e:	28 e0       	ldi	r18, 0x08	; 8
    2360:	f2 2e       	mov	r15, r18
    2362:	8e 15       	cp	r24, r14
    2364:	9f 05       	cpc	r25, r15
    2366:	99 f1       	breq	.+102    	; 0x23ce <com0RotateRecvBuffer+0x9e>
      {
        // calculate the length
        uint8_t len = hUsart0.recvCount-hUsart0.recvBuffer;
    2368:	18 2f       	mov	r17, r24
    236a:	1e 19       	sub	r17, r14
      
        node->len = len;
    236c:	1c 83       	std	Y+4, r17	; 0x04
        node->buffer = (char*) malloc(len);
    236e:	81 2f       	mov	r24, r17
    2370:	90 e0       	ldi	r25, 0x00	; 0
    2372:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    2376:	8a 83       	std	Y+2, r24	; 0x02
    2378:	9b 83       	std	Y+3, r25	; 0x03
      
        // copy buffer
        while (len--)
    237a:	11 23       	and	r17, r17
    237c:	79 f0       	breq	.+30     	; 0x239c <com0RotateRecvBuffer+0x6c>
    237e:	31 2f       	mov	r19, r17
    2380:	31 50       	subi	r19, 0x01	; 1
        {
          node->buffer[len] = hUsart0.recvBuffer[len];
    2382:	83 2f       	mov	r24, r19
    2384:	90 e0       	ldi	r25, 0x00	; 0
    2386:	fc 01       	movw	r30, r24
    2388:	e3 58       	subi	r30, 0x83	; 131
    238a:	f7 4f       	sbci	r31, 0xF7	; 247
    238c:	20 81       	ld	r18, Z
    238e:	ea 81       	ldd	r30, Y+2	; 0x02
    2390:	fb 81       	ldd	r31, Y+3	; 0x03
    2392:	e8 0f       	add	r30, r24
    2394:	f9 1f       	adc	r31, r25
    2396:	20 83       	st	Z, r18
      
        node->len = len;
        node->buffer = (char*) malloc(len);
      
        // copy buffer
        while (len--)
    2398:	31 50       	subi	r19, 0x01	; 1
    239a:	98 f7       	brcc	.-26     	; 0x2382 <com0RotateRecvBuffer+0x52>
      }
     
    	
    
      // enqueue the recevived data
      pushQueueEntry(&hUsart0.recvFiFo,(struct queueNode_t*)node);
    239c:	82 e7       	ldi	r24, 0x72	; 114
    239e:	99 e0       	ldi	r25, 0x09	; 9
    23a0:	be 01       	movw	r22, r28
    23a2:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <pushQueueEntry>
    23a6:	08 c0       	rjmp	.+16     	; 0x23b8 <com0RotateRecvBuffer+0x88>

	  
    }//if(queu is full)
	else
	{
		putString_com1("achtung zu vile daten");
    23a8:	80 ec       	ldi	r24, 0xC0	; 192
    23aa:	91 e0       	ldi	r25, 0x01	; 1
    23ac:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    23b0:	8d e7       	ldi	r24, 0x7D	; 125
    23b2:	e8 2e       	mov	r14, r24
    23b4:	88 e0       	ldi	r24, 0x08	; 8
    23b6:	f8 2e       	mov	r15, r24
	}
      
      // ... finally don't forget to reset our helper to the base address
    hUsart0.recvCount = hUsart0.recvBuffer;
    23b8:	f0 92 f6 08 	sts	0x08F6, r15
    23bc:	e0 92 f5 08 	sts	0x08F5, r14
    
    // As we are done with the RX Buffer it's now save to reenable the interrupt
    UCSR0B |= (1 << RXCIE0);
    23c0:	57 9a       	sbi	0x0a, 7	; 10

  }
    23c2:	df 91       	pop	r29
    23c4:	cf 91       	pop	r28
    23c6:	1f 91       	pop	r17
    23c8:	ff 90       	pop	r15
    23ca:	ef 90       	pop	r14
    23cc:	08 95       	ret

      }
      else
      {
        // thats the short cut for empty buffers
        node->len = 0;
    23ce:	1c 82       	std	Y+4, r1	; 0x04
        node->buffer = NULL;
    23d0:	1b 82       	std	Y+3, r1	; 0x03
    23d2:	1a 82       	std	Y+2, r1	; 0x02

		//here we send an iamalive paket over config channel too
		//but only if there is not stored an commandanswer already

		if(CommandBuffer.NewCommand==0)
    23d4:	80 91 b5 09 	lds	r24, 0x09B5
    23d8:	88 23       	and	r24, r24
    23da:	01 f7       	brne	.-64     	; 0x239c <com0RotateRecvBuffer+0x6c>
		{
			rtpSendCommand("iamalive", 0, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    23dc:	87 eb       	ldi	r24, 0xB7	; 183
    23de:	91 e0       	ldi	r25, 0x01	; 1
    23e0:	60 e0       	ldi	r22, 0x00	; 0
    23e2:	70 e0       	ldi	r23, 0x00	; 0
    23e4:	45 e8       	ldi	r20, 0x85	; 133
    23e6:	59 e0       	ldi	r21, 0x09	; 9
    23e8:	2b e8       	ldi	r18, 0x8B	; 139
    23ea:	39 e0       	ldi	r19, 0x09	; 9
    23ec:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
    23f0:	d5 cf       	rjmp	.-86     	; 0x239c <com0RotateRecvBuffer+0x6c>

000023f2 <onCom0Timeout>:


    // If we are here, we obviously have to rotate the buffers.

	
    com0RotateRecvBuffer();
    23f2:	0e 94 98 11 	call	0x2330	; 0x2330 <com0RotateRecvBuffer>


        
    //Keep the timer up and running...
    hUsart0.timeout = timerAddTimeout(COM0_TIMEOUT,onCom0Timeout);
    23f6:	80 e0       	ldi	r24, 0x00	; 0
    23f8:	92 e0       	ldi	r25, 0x02	; 2
    23fa:	69 ef       	ldi	r22, 0xF9	; 249
    23fc:	71 e1       	ldi	r23, 0x11	; 17
    23fe:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <timerAddTimeout>
    2402:	90 93 7d 09 	sts	0x097D, r25
    2406:	80 93 7c 09 	sts	0x097C, r24
	
  }
    240a:	08 95       	ret

0000240c <__vector_18>:
    UCSR0B |= (1 << UDRIE0);
  }
  
  
  ISR (USART0_RX_vect)
  {
    240c:	1f 92       	push	r1
    240e:	0f 92       	push	r0
    2410:	0f b6       	in	r0, 0x3f	; 63
    2412:	0f 92       	push	r0
    2414:	0b b6       	in	r0, 0x3b	; 59
    2416:	0f 92       	push	r0
    2418:	11 24       	eor	r1, r1
    241a:	2f 93       	push	r18
    241c:	3f 93       	push	r19
    241e:	4f 93       	push	r20
    2420:	5f 93       	push	r21
    2422:	6f 93       	push	r22
    2424:	7f 93       	push	r23
    2426:	8f 93       	push	r24
    2428:	9f 93       	push	r25
    242a:	af 93       	push	r26
    242c:	bf 93       	push	r27
    242e:	ef 93       	push	r30
    2430:	ff 93       	push	r31

	

	while (!(UCSR0A&32));
    2432:	5d 9b       	sbis	0x0b, 5	; 11
    2434:	fe cf       	rjmp	.-4      	; 0x2432 <__vector_18+0x26>
	char x=UDR0;
    2436:	8c b1       	in	r24, 0x0c	; 12
    // Save the received byte...
    hUsart0.recvCount[0] = x;
    2438:	e0 91 f5 08 	lds	r30, 0x08F5
    243c:	f0 91 f6 08 	lds	r31, 0x08F6
    2440:	80 83       	st	Z, r24


    // increase our helper...
    hUsart0.recvCount++;
    2442:	20 91 f5 08 	lds	r18, 0x08F5
    2446:	30 91 f6 08 	lds	r19, 0x08F6
    244a:	2f 5f       	subi	r18, 0xFF	; 255
    244c:	3f 4f       	sbci	r19, 0xFF	; 255
    244e:	30 93 f6 08 	sts	0x08F6, r19
    2452:	20 93 f5 08 	sts	0x08F5, r18
    
    // ... and check, if we need to rotate the buffer
    if (hUsart0.recvCount < (hUsart0.recvBuffer+hUsart0.SendBufferSizeLimit))
    2456:	80 91 71 09 	lds	r24, 0x0971
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	83 58       	subi	r24, 0x83	; 131
    245e:	97 4f       	sbci	r25, 0xF7	; 247
    2460:	28 17       	cp	r18, r24
    2462:	39 07       	cpc	r19, r25
    2464:	30 f0       	brcs	.+12     	; 0x2472 <__vector_18+0x66>
      return;
  

   putString_com1("rot");
    2466:	86 ed       	ldi	r24, 0xD6	; 214
    2468:	91 e0       	ldi	r25, 0x01	; 1
    246a:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    com0RotateRecvBuffer();
    246e:	0e 94 98 11 	call	0x2330	; 0x2330 <com0RotateRecvBuffer>
    
    return;
  }
    2472:	ff 91       	pop	r31
    2474:	ef 91       	pop	r30
    2476:	bf 91       	pop	r27
    2478:	af 91       	pop	r26
    247a:	9f 91       	pop	r25
    247c:	8f 91       	pop	r24
    247e:	7f 91       	pop	r23
    2480:	6f 91       	pop	r22
    2482:	5f 91       	pop	r21
    2484:	4f 91       	pop	r20
    2486:	3f 91       	pop	r19
    2488:	2f 91       	pop	r18
    248a:	0f 90       	pop	r0
    248c:	0b be       	out	0x3b, r0	; 59
    248e:	0f 90       	pop	r0
    2490:	0f be       	out	0x3f, r0	; 63
    2492:	0f 90       	pop	r0
    2494:	1f 90       	pop	r1
    2496:	18 95       	reti

00002498 <__vector_19>:

  ISR (USART0_UDRE_vect )
  {
    2498:	1f 92       	push	r1
    249a:	0f 92       	push	r0
    249c:	0f b6       	in	r0, 0x3f	; 63
    249e:	0f 92       	push	r0
    24a0:	0b b6       	in	r0, 0x3b	; 59
    24a2:	0f 92       	push	r0
    24a4:	11 24       	eor	r1, r1
    24a6:	2f 93       	push	r18
    24a8:	3f 93       	push	r19
    24aa:	4f 93       	push	r20
    24ac:	5f 93       	push	r21
    24ae:	6f 93       	push	r22
    24b0:	7f 93       	push	r23
    24b2:	8f 93       	push	r24
    24b4:	9f 93       	push	r25
    24b6:	af 93       	push	r26
    24b8:	bf 93       	push	r27
    24ba:	cf 93       	push	r28
    24bc:	df 93       	push	r29
    24be:	ef 93       	push	r30
    24c0:	ff 93       	push	r31
    // we actually do here something nasty...
    // ... we are referencing against the top address instead of the base address
    UDR0 = hUsart0.sendCount[0];
    24c2:	e0 91 6f 09 	lds	r30, 0x096F
    24c6:	f0 91 70 09 	lds	r31, 0x0970
    24ca:	80 81       	ld	r24, Z
    24cc:	8c b9       	out	0x0c, r24	; 12
    
    // check if we need to rotate buffers...
    if (hUsart0.sendCount < (hUsart0.sendBuffer+COM0_MAX_TX_BUF-1))
    24ce:	89 e0       	ldi	r24, 0x09	; 9
    24d0:	ee 36       	cpi	r30, 0x6E	; 110
    24d2:	f8 07       	cpc	r31, r24
    24d4:	d0 f4       	brcc	.+52     	; 0x250a <__vector_19+0x72>
    {
      
      hUsart0.sendCount++;
    24d6:	31 96       	adiw	r30, 0x01	; 1
    24d8:	f0 93 70 09 	sts	0x0970, r31
    24dc:	e0 93 6f 09 	sts	0x096F, r30
   
    
    com0RotateSendBuffer();
        
    return;
  }    
    24e0:	ff 91       	pop	r31
    24e2:	ef 91       	pop	r30
    24e4:	df 91       	pop	r29
    24e6:	cf 91       	pop	r28
    24e8:	bf 91       	pop	r27
    24ea:	af 91       	pop	r26
    24ec:	9f 91       	pop	r25
    24ee:	8f 91       	pop	r24
    24f0:	7f 91       	pop	r23
    24f2:	6f 91       	pop	r22
    24f4:	5f 91       	pop	r21
    24f6:	4f 91       	pop	r20
    24f8:	3f 91       	pop	r19
    24fa:	2f 91       	pop	r18
    24fc:	0f 90       	pop	r0
    24fe:	0b be       	out	0x3b, r0	; 59
    2500:	0f 90       	pop	r0
    2502:	0f be       	out	0x3f, r0	; 63
    2504:	0f 90       	pop	r0
    2506:	1f 90       	pop	r1
    2508:	18 95       	reti
      hUsart0.sendCount++;
      return;
    }
      
    // nothing to rotate?
    if (queueIsEmpty(&hUsart0.sendFiFo))    
    250a:	87 e7       	ldi	r24, 0x77	; 119
    250c:	99 e0       	ldi	r25, 0x09	; 9
    250e:	0e 94 19 10 	call	0x2032	; 0x2032 <queueIsEmpty>
    2512:	88 23       	and	r24, r24
    2514:	11 f0       	breq	.+4      	; 0x251a <__vector_19+0x82>
    {
      // so disable the send interrupt...
      UCSR0B &= ~ (1 << UDRIE0);
    2516:	55 98       	cbi	0x0a, 5	; 10
    2518:	e3 cf       	rjmp	.-58     	; 0x24e0 <__vector_19+0x48>
    
    /* !!! IF YOU MOFIFY THIS BLOCK ALWAYS SYNC IT WITH THE CODE !!! */ 
    /* !!! IN com0SendBytes()                                    !!! */
    
    // in order to ayoid timing issues, disable TX Interrupt
    UCSR0B &= ~ (1 << UDRIE0);
    251a:	55 98       	cbi	0x0a, 5	; 10
   
    struct queueElement_t* node
      = (struct queueElement_t*) popQueueEntry(&hUsart0.sendFiFo);
    251c:	87 e7       	ldi	r24, 0x77	; 119
    251e:	99 e0       	ldi	r25, 0x09	; 9
    2520:	0e 94 2a 10 	call	0x2054	; 0x2054 <popQueueEntry>
    2524:	ec 01       	movw	r28, r24
    
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    2526:	8c 81       	ldd	r24, Y+4	; 0x04
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    2528:	48 e7       	ldi	r20, 0x78	; 120
    252a:	50 e0       	ldi	r21, 0x00	; 0
    252c:	48 1b       	sub	r20, r24
    252e:	51 09       	sbc	r21, r1
    2530:	49 50       	subi	r20, 0x09	; 9
    2532:	57 4f       	sbci	r21, 0xF7	; 247
    
    while (len--)
    2534:	88 23       	and	r24, r24
    2536:	09 f1       	breq	.+66     	; 0x257a <__vector_19+0xe2>
    2538:	28 2f       	mov	r18, r24
    253a:	21 50       	subi	r18, 0x01	; 1
    {
      worker[len] = node->buffer[len];
    253c:	82 2f       	mov	r24, r18
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	da 01       	movw	r26, r20
    2542:	a8 0f       	add	r26, r24
    2544:	b9 1f       	adc	r27, r25
    2546:	ea 81       	ldd	r30, Y+2	; 0x02
    2548:	fb 81       	ldd	r31, Y+3	; 0x03
    254a:	e8 0f       	add	r30, r24
    254c:	f9 1f       	adc	r31, r25
    254e:	80 81       	ld	r24, Z
    2550:	8c 93       	st	X, r24
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    
    while (len--)
    2552:	21 50       	subi	r18, 0x01	; 1
    2554:	98 f7       	brcc	.-26     	; 0x253c <__vector_19+0xa4>
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    2556:	80 e7       	ldi	r24, 0x70	; 112
    2558:	98 e0       	ldi	r25, 0x08	; 8
    255a:	90 93 70 09 	sts	0x0970, r25
    255e:	80 93 6f 09 	sts	0x096F, r24
    
    if (node->len > 0) 
    2562:	8c 81       	ldd	r24, Y+4	; 0x04
    2564:	88 23       	and	r24, r24
    2566:	21 f0       	breq	.+8      	; 0x2570 <__vector_19+0xd8>
      free(node->buffer);
    2568:	8a 81       	ldd	r24, Y+2	; 0x02
    256a:	9b 81       	ldd	r25, Y+3	; 0x03
    256c:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
    free(node);
    2570:	ce 01       	movw	r24, r28
    2572:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
  
    // reenable TX Interrupts...
    UCSR0B |= (1 << UDRIE0);
    2576:	55 9a       	sbi	0x0a, 5	; 10
    2578:	b3 cf       	rjmp	.-154    	; 0x24e0 <__vector_19+0x48>
    while (len--)
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    257a:	80 e7       	ldi	r24, 0x70	; 112
    257c:	98 e0       	ldi	r25, 0x08	; 8
    257e:	90 93 70 09 	sts	0x0970, r25
    2582:	80 93 6f 09 	sts	0x096F, r24
    2586:	f4 cf       	rjmp	.-24     	; 0x2570 <__vector_19+0xd8>

00002588 <enc28j60_write>:
    2588:	fb 01       	movw	r30, r22
    258a:	c0 98       	cbi	0x18, 0	; 24
    258c:	8f b9       	out	0x0f, r24	; 15
    258e:	77 9b       	sbis	0x0e, 7	; 14
    2590:	fe cf       	rjmp	.-4      	; 0x258e <enc28j60_write+0x6>
    2592:	41 15       	cp	r20, r1
    2594:	51 05       	cpc	r21, r1
    2596:	41 f0       	breq	.+16     	; 0x25a8 <enc28j60_write+0x20>
    2598:	80 81       	ld	r24, Z
    259a:	8f b9       	out	0x0f, r24	; 15
    259c:	77 9b       	sbis	0x0e, 7	; 14
    259e:	fe cf       	rjmp	.-4      	; 0x259c <enc28j60_write+0x14>
    25a0:	31 96       	adiw	r30, 0x01	; 1
    25a2:	41 50       	subi	r20, 0x01	; 1
    25a4:	50 40       	sbci	r21, 0x00	; 0
    25a6:	c1 f7       	brne	.-16     	; 0x2598 <enc28j60_write+0x10>
    25a8:	c0 9a       	sbi	0x18, 0	; 24
    25aa:	08 95       	ret

000025ac <enc28j60_write_byte>:
    25ac:	df 93       	push	r29
    25ae:	cf 93       	push	r28
    25b0:	0f 92       	push	r0
    25b2:	cd b7       	in	r28, 0x3d	; 61
    25b4:	de b7       	in	r29, 0x3e	; 62
    25b6:	69 83       	std	Y+1, r22	; 0x01
    25b8:	c0 98       	cbi	0x18, 0	; 24
    25ba:	8f b9       	out	0x0f, r24	; 15
    25bc:	77 9b       	sbis	0x0e, 7	; 14
    25be:	fe cf       	rjmp	.-4      	; 0x25bc <enc28j60_write_byte+0x10>
    25c0:	fe 01       	movw	r30, r28
    25c2:	31 96       	adiw	r30, 0x01	; 1
    25c4:	9e 01       	movw	r18, r28
    25c6:	2e 5f       	subi	r18, 0xFE	; 254
    25c8:	3f 4f       	sbci	r19, 0xFF	; 255
    25ca:	81 91       	ld	r24, Z+
    25cc:	8f b9       	out	0x0f, r24	; 15
    25ce:	77 9b       	sbis	0x0e, 7	; 14
    25d0:	fe cf       	rjmp	.-4      	; 0x25ce <enc28j60_write_byte+0x22>
    25d2:	e2 17       	cp	r30, r18
    25d4:	f3 07       	cpc	r31, r19
    25d6:	c9 f7       	brne	.-14     	; 0x25ca <enc28j60_write_byte+0x1e>
    25d8:	c0 9a       	sbi	0x18, 0	; 24
    25da:	0f 90       	pop	r0
    25dc:	cf 91       	pop	r28
    25de:	df 91       	pop	r29
    25e0:	08 95       	ret

000025e2 <enc28j60_read>:
    25e2:	fb 01       	movw	r30, r22
    25e4:	c0 98       	cbi	0x18, 0	; 24
    25e6:	8f b9       	out	0x0f, r24	; 15
    25e8:	77 9b       	sbis	0x0e, 7	; 14
    25ea:	fe cf       	rjmp	.-4      	; 0x25e8 <enc28j60_read+0x6>
    25ec:	22 23       	and	r18, r18
    25ee:	29 f0       	breq	.+10     	; 0x25fa <enc28j60_read+0x18>
    25f0:	1f b8       	out	0x0f, r1	; 15
    25f2:	77 9b       	sbis	0x0e, 7	; 14
    25f4:	fe cf       	rjmp	.-4      	; 0x25f2 <enc28j60_read+0x10>
    25f6:	21 50       	subi	r18, 0x01	; 1
    25f8:	d9 f7       	brne	.-10     	; 0x25f0 <enc28j60_read+0xe>
    25fa:	41 15       	cp	r20, r1
    25fc:	51 05       	cpc	r21, r1
    25fe:	51 f0       	breq	.+20     	; 0x2614 <enc28j60_read+0x32>
    2600:	1f b8       	out	0x0f, r1	; 15
    2602:	77 9b       	sbis	0x0e, 7	; 14
    2604:	fe cf       	rjmp	.-4      	; 0x2602 <enc28j60_read+0x20>
    2606:	8f b1       	in	r24, 0x0f	; 15
    2608:	80 83       	st	Z, r24
    260a:	41 50       	subi	r20, 0x01	; 1
    260c:	50 40       	sbci	r21, 0x00	; 0
    260e:	11 f0       	breq	.+4      	; 0x2614 <enc28j60_read+0x32>
    2610:	31 96       	adiw	r30, 0x01	; 1
    2612:	f6 cf       	rjmp	.-20     	; 0x2600 <enc28j60_read+0x1e>
    2614:	c0 9a       	sbi	0x18, 0	; 24
    2616:	08 95       	ret

00002618 <enc28j60_select_bank>:
    2618:	df 93       	push	r29
    261a:	cf 93       	push	r28
    261c:	0f 92       	push	r0
    261e:	cd b7       	in	r28, 0x3d	; 61
    2620:	de b7       	in	r29, 0x3e	; 62
    2622:	48 2f       	mov	r20, r24
    2624:	87 fd       	sbrc	r24, 7
    2626:	3b c0       	rjmp	.+118    	; 0x269e <enc28j60_select_bank+0x86>
    2628:	28 2f       	mov	r18, r24
    262a:	30 e0       	ldi	r19, 0x00	; 0
    262c:	20 76       	andi	r18, 0x60	; 96
    262e:	30 70       	andi	r19, 0x00	; 0
    2630:	80 91 7e 09 	lds	r24, 0x097E
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	82 17       	cp	r24, r18
    2638:	93 07       	cpc	r25, r19
    263a:	89 f1       	breq	.+98     	; 0x269e <enc28j60_select_bank+0x86>
    263c:	83 e0       	ldi	r24, 0x03	; 3
    263e:	89 83       	std	Y+1, r24	; 0x01
    2640:	c0 98       	cbi	0x18, 0	; 24
    2642:	8f eb       	ldi	r24, 0xBF	; 191
    2644:	8f b9       	out	0x0f, r24	; 15
    2646:	77 9b       	sbis	0x0e, 7	; 14
    2648:	fe cf       	rjmp	.-4      	; 0x2646 <enc28j60_select_bank+0x2e>
    264a:	be 01       	movw	r22, r28
    264c:	6f 5f       	subi	r22, 0xFF	; 255
    264e:	7f 4f       	sbci	r23, 0xFF	; 255
    2650:	fb 01       	movw	r30, r22
    2652:	de 01       	movw	r26, r28
    2654:	12 96       	adiw	r26, 0x02	; 2
    2656:	81 91       	ld	r24, Z+
    2658:	8f b9       	out	0x0f, r24	; 15
    265a:	77 9b       	sbis	0x0e, 7	; 14
    265c:	fe cf       	rjmp	.-4      	; 0x265a <enc28j60_select_bank+0x42>
    265e:	ea 17       	cp	r30, r26
    2660:	fb 07       	cpc	r31, r27
    2662:	c9 f7       	brne	.-14     	; 0x2656 <enc28j60_select_bank+0x3e>
    2664:	c0 9a       	sbi	0x18, 0	; 24
    2666:	35 95       	asr	r19
    2668:	27 95       	ror	r18
    266a:	35 95       	asr	r19
    266c:	27 95       	ror	r18
    266e:	35 95       	asr	r19
    2670:	27 95       	ror	r18
    2672:	35 95       	asr	r19
    2674:	27 95       	ror	r18
    2676:	35 95       	asr	r19
    2678:	27 95       	ror	r18
    267a:	29 83       	std	Y+1, r18	; 0x01
    267c:	c0 98       	cbi	0x18, 0	; 24
    267e:	8f e9       	ldi	r24, 0x9F	; 159
    2680:	8f b9       	out	0x0f, r24	; 15
    2682:	77 9b       	sbis	0x0e, 7	; 14
    2684:	fe cf       	rjmp	.-4      	; 0x2682 <enc28j60_select_bank+0x6a>
    2686:	fb 01       	movw	r30, r22
    2688:	81 91       	ld	r24, Z+
    268a:	8f b9       	out	0x0f, r24	; 15
    268c:	77 9b       	sbis	0x0e, 7	; 14
    268e:	fe cf       	rjmp	.-4      	; 0x268c <enc28j60_select_bank+0x74>
    2690:	ea 17       	cp	r30, r26
    2692:	fb 07       	cpc	r31, r27
    2694:	c9 f7       	brne	.-14     	; 0x2688 <enc28j60_select_bank+0x70>
    2696:	c0 9a       	sbi	0x18, 0	; 24
    2698:	40 76       	andi	r20, 0x60	; 96
    269a:	40 93 7e 09 	sts	0x097E, r20
    269e:	0f 90       	pop	r0
    26a0:	cf 91       	pop	r28
    26a2:	df 91       	pop	r29
    26a4:	08 95       	ret

000026a6 <enc28j60_init>:
    26a6:	87 e0       	ldi	r24, 0x07	; 7
    26a8:	87 bb       	out	0x17, r24	; 23
    26aa:	bb 98       	cbi	0x17, 3	; 23
    26ac:	c0 9a       	sbi	0x18, 0	; 24
    26ae:	80 e5       	ldi	r24, 0x50	; 80
    26b0:	8d b9       	out	0x0d, r24	; 13
    26b2:	81 e0       	ldi	r24, 0x01	; 1
    26b4:	8e b9       	out	0x0e, r24	; 14
    26b6:	10 92 7e 09 	sts	0x097E, r1
    26ba:	08 95       	ret

000026bc <enc28j60_calcOffset>:
    26bc:	90 e0       	ldi	r25, 0x00	; 0
    26be:	80 76       	andi	r24, 0x60	; 96
    26c0:	90 70       	andi	r25, 0x00	; 0
    26c2:	80 34       	cpi	r24, 0x40	; 64
    26c4:	91 05       	cpc	r25, r1
    26c6:	31 f0       	breq	.+12     	; 0x26d4 <enc28j60_calcOffset+0x18>
    26c8:	20 e0       	ldi	r18, 0x00	; 0
    26ca:	80 36       	cpi	r24, 0x60	; 96
    26cc:	91 05       	cpc	r25, r1
    26ce:	11 f0       	breq	.+4      	; 0x26d4 <enc28j60_calcOffset+0x18>
    26d0:	82 2f       	mov	r24, r18
    26d2:	08 95       	ret
    26d4:	21 e0       	ldi	r18, 0x01	; 1
    26d6:	82 2f       	mov	r24, r18
    26d8:	08 95       	ret

000026da <enc28j60_bmputs>:
    26da:	fc 01       	movw	r30, r24
    26dc:	c0 98       	cbi	0x18, 0	; 24
    26de:	8a e7       	ldi	r24, 0x7A	; 122
    26e0:	8f b9       	out	0x0f, r24	; 15
    26e2:	77 9b       	sbis	0x0e, 7	; 14
    26e4:	fe cf       	rjmp	.-4      	; 0x26e2 <enc28j60_bmputs+0x8>
    26e6:	61 15       	cp	r22, r1
    26e8:	71 05       	cpc	r23, r1
    26ea:	41 f0       	breq	.+16     	; 0x26fc <enc28j60_bmputs+0x22>
    26ec:	80 81       	ld	r24, Z
    26ee:	8f b9       	out	0x0f, r24	; 15
    26f0:	77 9b       	sbis	0x0e, 7	; 14
    26f2:	fe cf       	rjmp	.-4      	; 0x26f0 <enc28j60_bmputs+0x16>
    26f4:	31 96       	adiw	r30, 0x01	; 1
    26f6:	61 50       	subi	r22, 0x01	; 1
    26f8:	70 40       	sbci	r23, 0x00	; 0
    26fa:	c1 f7       	brne	.-16     	; 0x26ec <enc28j60_bmputs+0x12>
    26fc:	c0 9a       	sbi	0x18, 0	; 24
    26fe:	08 95       	ret

00002700 <enc28j60_reset>:
    2700:	c0 98       	cbi	0x18, 0	; 24
    2702:	8f ef       	ldi	r24, 0xFF	; 255
    2704:	8f b9       	out	0x0f, r24	; 15
    2706:	77 9b       	sbis	0x0e, 7	; 14
    2708:	fe cf       	rjmp	.-4      	; 0x2706 <enc28j60_reset+0x6>
    270a:	c0 9a       	sbi	0x18, 0	; 24
    270c:	08 95       	ret

0000270e <enc28j60_bmgetc>:
    270e:	df 93       	push	r29
    2710:	cf 93       	push	r28
    2712:	0f 92       	push	r0
    2714:	cd b7       	in	r28, 0x3d	; 61
    2716:	de b7       	in	r29, 0x3e	; 62
    2718:	c0 98       	cbi	0x18, 0	; 24
    271a:	8a e3       	ldi	r24, 0x3A	; 58
    271c:	8f b9       	out	0x0f, r24	; 15
    271e:	77 9b       	sbis	0x0e, 7	; 14
    2720:	fe cf       	rjmp	.-4      	; 0x271e <enc28j60_bmgetc+0x10>
    2722:	1f b8       	out	0x0f, r1	; 15
    2724:	77 9b       	sbis	0x0e, 7	; 14
    2726:	fe cf       	rjmp	.-4      	; 0x2724 <enc28j60_bmgetc+0x16>
    2728:	8f b1       	in	r24, 0x0f	; 15
    272a:	89 83       	std	Y+1, r24	; 0x01
    272c:	c0 9a       	sbi	0x18, 0	; 24
    272e:	89 81       	ldd	r24, Y+1	; 0x01
    2730:	0f 90       	pop	r0
    2732:	cf 91       	pop	r28
    2734:	df 91       	pop	r29
    2736:	08 95       	ret

00002738 <enc28j60_bmgetw>:
    2738:	df 93       	push	r29
    273a:	cf 93       	push	r28
    273c:	00 d0       	rcall	.+0      	; 0x273e <enc28j60_bmgetw+0x6>
    273e:	cd b7       	in	r28, 0x3d	; 61
    2740:	de b7       	in	r29, 0x3e	; 62
    2742:	c0 98       	cbi	0x18, 0	; 24
    2744:	8a e3       	ldi	r24, 0x3A	; 58
    2746:	8f b9       	out	0x0f, r24	; 15
    2748:	77 9b       	sbis	0x0e, 7	; 14
    274a:	fe cf       	rjmp	.-4      	; 0x2748 <enc28j60_bmgetw+0x10>
    274c:	fe 01       	movw	r30, r28
    274e:	31 96       	adiw	r30, 0x01	; 1
    2750:	9e 01       	movw	r18, r28
    2752:	2e 5f       	subi	r18, 0xFE	; 254
    2754:	3f 4f       	sbci	r19, 0xFF	; 255
    2756:	1f b8       	out	0x0f, r1	; 15
    2758:	77 9b       	sbis	0x0e, 7	; 14
    275a:	fe cf       	rjmp	.-4      	; 0x2758 <enc28j60_bmgetw+0x20>
    275c:	8f b1       	in	r24, 0x0f	; 15
    275e:	80 83       	st	Z, r24
    2760:	e2 17       	cp	r30, r18
    2762:	f3 07       	cpc	r31, r19
    2764:	11 f0       	breq	.+4      	; 0x276a <enc28j60_bmgetw+0x32>
    2766:	31 96       	adiw	r30, 0x01	; 1
    2768:	f6 cf       	rjmp	.-20     	; 0x2756 <enc28j60_bmgetw+0x1e>
    276a:	c0 9a       	sbi	0x18, 0	; 24
    276c:	89 81       	ldd	r24, Y+1	; 0x01
    276e:	9a 81       	ldd	r25, Y+2	; 0x02
    2770:	0f 90       	pop	r0
    2772:	0f 90       	pop	r0
    2774:	cf 91       	pop	r28
    2776:	df 91       	pop	r29
    2778:	08 95       	ret

0000277a <enc28j60_bmgets>:
    277a:	ac 01       	movw	r20, r24
    277c:	c0 98       	cbi	0x18, 0	; 24
    277e:	8a e3       	ldi	r24, 0x3A	; 58
    2780:	8f b9       	out	0x0f, r24	; 15
    2782:	77 9b       	sbis	0x0e, 7	; 14
    2784:	fe cf       	rjmp	.-4      	; 0x2782 <enc28j60_bmgets+0x8>
    2786:	61 15       	cp	r22, r1
    2788:	71 05       	cpc	r23, r1
    278a:	59 f0       	breq	.+22     	; 0x27a2 <enc28j60_bmgets+0x28>
    278c:	fa 01       	movw	r30, r20
    278e:	1f b8       	out	0x0f, r1	; 15
    2790:	77 9b       	sbis	0x0e, 7	; 14
    2792:	fe cf       	rjmp	.-4      	; 0x2790 <enc28j60_bmgets+0x16>
    2794:	8f b1       	in	r24, 0x0f	; 15
    2796:	80 83       	st	Z, r24
    2798:	61 50       	subi	r22, 0x01	; 1
    279a:	70 40       	sbci	r23, 0x00	; 0
    279c:	11 f0       	breq	.+4      	; 0x27a2 <enc28j60_bmgets+0x28>
    279e:	31 96       	adiw	r30, 0x01	; 1
    27a0:	f6 cf       	rjmp	.-20     	; 0x278e <enc28j60_bmgets+0x14>
    27a2:	c0 9a       	sbi	0x18, 0	; 24
    27a4:	ca 01       	movw	r24, r20
    27a6:	08 95       	ret

000027a8 <enc28j60_rcr2>:
    27a8:	ff 92       	push	r15
    27aa:	0f 93       	push	r16
    27ac:	1f 93       	push	r17
    27ae:	df 93       	push	r29
    27b0:	cf 93       	push	r28
    27b2:	0f 92       	push	r0
    27b4:	cd b7       	in	r28, 0x3d	; 61
    27b6:	de b7       	in	r29, 0x3e	; 62
    27b8:	a8 2f       	mov	r26, r24
    27ba:	b6 2f       	mov	r27, r22
    27bc:	f7 2e       	mov	r15, r23
    27be:	87 fd       	sbrc	r24, 7
    27c0:	6c c0       	rjmp	.+216    	; 0x289a <enc28j60_rcr2+0xf2>
    27c2:	28 2f       	mov	r18, r24
    27c4:	30 e0       	ldi	r19, 0x00	; 0
    27c6:	20 76       	andi	r18, 0x60	; 96
    27c8:	30 70       	andi	r19, 0x00	; 0
    27ca:	80 91 7e 09 	lds	r24, 0x097E
    27ce:	90 e0       	ldi	r25, 0x00	; 0
    27d0:	82 17       	cp	r24, r18
    27d2:	93 07       	cpc	r25, r19
    27d4:	a1 f1       	breq	.+104    	; 0x283e <enc28j60_rcr2+0x96>
    27d6:	83 e0       	ldi	r24, 0x03	; 3
    27d8:	89 83       	std	Y+1, r24	; 0x01
    27da:	c0 98       	cbi	0x18, 0	; 24
    27dc:	8f eb       	ldi	r24, 0xBF	; 191
    27de:	8f b9       	out	0x0f, r24	; 15
    27e0:	77 9b       	sbis	0x0e, 7	; 14
    27e2:	fe cf       	rjmp	.-4      	; 0x27e0 <enc28j60_rcr2+0x38>
    27e4:	be 01       	movw	r22, r28
    27e6:	6f 5f       	subi	r22, 0xFF	; 255
    27e8:	7f 4f       	sbci	r23, 0xFF	; 255
    27ea:	fb 01       	movw	r30, r22
    27ec:	8e 01       	movw	r16, r28
    27ee:	0e 5f       	subi	r16, 0xFE	; 254
    27f0:	1f 4f       	sbci	r17, 0xFF	; 255
    27f2:	81 91       	ld	r24, Z+
    27f4:	8f b9       	out	0x0f, r24	; 15
    27f6:	77 9b       	sbis	0x0e, 7	; 14
    27f8:	fe cf       	rjmp	.-4      	; 0x27f6 <enc28j60_rcr2+0x4e>
    27fa:	e0 17       	cp	r30, r16
    27fc:	f1 07       	cpc	r31, r17
    27fe:	c9 f7       	brne	.-14     	; 0x27f2 <enc28j60_rcr2+0x4a>
    2800:	c0 9a       	sbi	0x18, 0	; 24
    2802:	c9 01       	movw	r24, r18
    2804:	95 95       	asr	r25
    2806:	87 95       	ror	r24
    2808:	95 95       	asr	r25
    280a:	87 95       	ror	r24
    280c:	95 95       	asr	r25
    280e:	87 95       	ror	r24
    2810:	95 95       	asr	r25
    2812:	87 95       	ror	r24
    2814:	95 95       	asr	r25
    2816:	87 95       	ror	r24
    2818:	89 83       	std	Y+1, r24	; 0x01
    281a:	c0 98       	cbi	0x18, 0	; 24
    281c:	8f e9       	ldi	r24, 0x9F	; 159
    281e:	8f b9       	out	0x0f, r24	; 15
    2820:	77 9b       	sbis	0x0e, 7	; 14
    2822:	fe cf       	rjmp	.-4      	; 0x2820 <enc28j60_rcr2+0x78>
    2824:	fb 01       	movw	r30, r22
    2826:	81 91       	ld	r24, Z+
    2828:	8f b9       	out	0x0f, r24	; 15
    282a:	77 9b       	sbis	0x0e, 7	; 14
    282c:	fe cf       	rjmp	.-4      	; 0x282a <enc28j60_rcr2+0x82>
    282e:	e0 17       	cp	r30, r16
    2830:	f1 07       	cpc	r31, r17
    2832:	c9 f7       	brne	.-14     	; 0x2826 <enc28j60_rcr2+0x7e>
    2834:	c0 9a       	sbi	0x18, 0	; 24
    2836:	8a 2f       	mov	r24, r26
    2838:	80 76       	andi	r24, 0x60	; 96
    283a:	80 93 7e 09 	sts	0x097E, r24
    283e:	20 34       	cpi	r18, 0x40	; 64
    2840:	31 05       	cpc	r19, r1
    2842:	f9 f0       	breq	.+62     	; 0x2882 <enc28j60_rcr2+0xda>
    2844:	80 e0       	ldi	r24, 0x00	; 0
    2846:	20 36       	cpi	r18, 0x60	; 96
    2848:	31 05       	cpc	r19, r1
    284a:	d9 f0       	breq	.+54     	; 0x2882 <enc28j60_rcr2+0xda>
    284c:	c0 98       	cbi	0x18, 0	; 24
    284e:	af 71       	andi	r26, 0x1F	; 31
    2850:	af b9       	out	0x0f, r26	; 15
    2852:	77 9b       	sbis	0x0e, 7	; 14
    2854:	fe cf       	rjmp	.-4      	; 0x2852 <enc28j60_rcr2+0xaa>
    2856:	88 23       	and	r24, r24
    2858:	19 f0       	breq	.+6      	; 0x2860 <enc28j60_rcr2+0xb8>
    285a:	1f b8       	out	0x0f, r1	; 15
    285c:	77 9b       	sbis	0x0e, 7	; 14
    285e:	fe cf       	rjmp	.-4      	; 0x285c <enc28j60_rcr2+0xb4>
    2860:	41 15       	cp	r20, r1
    2862:	51 05       	cpc	r21, r1
    2864:	81 f0       	breq	.+32     	; 0x2886 <enc28j60_rcr2+0xde>
    2866:	8b 2f       	mov	r24, r27
    2868:	9f 2d       	mov	r25, r15
    286a:	9c 01       	movw	r18, r24
    286c:	f9 01       	movw	r30, r18
    286e:	1f b8       	out	0x0f, r1	; 15
    2870:	77 9b       	sbis	0x0e, 7	; 14
    2872:	fe cf       	rjmp	.-4      	; 0x2870 <enc28j60_rcr2+0xc8>
    2874:	8f b1       	in	r24, 0x0f	; 15
    2876:	80 83       	st	Z, r24
    2878:	41 50       	subi	r20, 0x01	; 1
    287a:	50 40       	sbci	r21, 0x00	; 0
    287c:	21 f0       	breq	.+8      	; 0x2886 <enc28j60_rcr2+0xde>
    287e:	31 96       	adiw	r30, 0x01	; 1
    2880:	f6 cf       	rjmp	.-20     	; 0x286e <enc28j60_rcr2+0xc6>
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	e3 cf       	rjmp	.-58     	; 0x284c <enc28j60_rcr2+0xa4>
    2886:	c0 9a       	sbi	0x18, 0	; 24
    2888:	8b 2f       	mov	r24, r27
    288a:	9f 2d       	mov	r25, r15
    288c:	0f 90       	pop	r0
    288e:	cf 91       	pop	r28
    2890:	df 91       	pop	r29
    2892:	1f 91       	pop	r17
    2894:	0f 91       	pop	r16
    2896:	ff 90       	pop	r15
    2898:	08 95       	ret
    289a:	28 2f       	mov	r18, r24
    289c:	30 e0       	ldi	r19, 0x00	; 0
    289e:	20 76       	andi	r18, 0x60	; 96
    28a0:	30 70       	andi	r19, 0x00	; 0
    28a2:	cd cf       	rjmp	.-102    	; 0x283e <enc28j60_rcr2+0x96>

000028a4 <enc28j60_crbfs>:
    28a4:	df 93       	push	r29
    28a6:	cf 93       	push	r28
    28a8:	00 d0       	rcall	.+0      	; 0x28aa <enc28j60_crbfs+0x6>
    28aa:	cd b7       	in	r28, 0x3d	; 61
    28ac:	de b7       	in	r29, 0x3e	; 62
    28ae:	48 2f       	mov	r20, r24
    28b0:	6a 83       	std	Y+2, r22	; 0x02
    28b2:	87 fd       	sbrc	r24, 7
    28b4:	54 c0       	rjmp	.+168    	; 0x295e <enc28j60_crbfs+0xba>
    28b6:	28 2f       	mov	r18, r24
    28b8:	30 e0       	ldi	r19, 0x00	; 0
    28ba:	20 76       	andi	r18, 0x60	; 96
    28bc:	30 70       	andi	r19, 0x00	; 0
    28be:	80 91 7e 09 	lds	r24, 0x097E
    28c2:	90 e0       	ldi	r25, 0x00	; 0
    28c4:	82 17       	cp	r24, r18
    28c6:	93 07       	cpc	r25, r19
    28c8:	09 f4       	brne	.+2      	; 0x28cc <enc28j60_crbfs+0x28>
    28ca:	49 c0       	rjmp	.+146    	; 0x295e <enc28j60_crbfs+0xba>
    28cc:	83 e0       	ldi	r24, 0x03	; 3
    28ce:	89 83       	std	Y+1, r24	; 0x01
    28d0:	c0 98       	cbi	0x18, 0	; 24
    28d2:	8f eb       	ldi	r24, 0xBF	; 191
    28d4:	8f b9       	out	0x0f, r24	; 15
    28d6:	77 9b       	sbis	0x0e, 7	; 14
    28d8:	fe cf       	rjmp	.-4      	; 0x28d6 <enc28j60_crbfs+0x32>
    28da:	de 01       	movw	r26, r28
    28dc:	11 96       	adiw	r26, 0x01	; 1
    28de:	fd 01       	movw	r30, r26
    28e0:	be 01       	movw	r22, r28
    28e2:	6e 5f       	subi	r22, 0xFE	; 254
    28e4:	7f 4f       	sbci	r23, 0xFF	; 255
    28e6:	81 91       	ld	r24, Z+
    28e8:	8f b9       	out	0x0f, r24	; 15
    28ea:	77 9b       	sbis	0x0e, 7	; 14
    28ec:	fe cf       	rjmp	.-4      	; 0x28ea <enc28j60_crbfs+0x46>
    28ee:	e6 17       	cp	r30, r22
    28f0:	f7 07       	cpc	r31, r23
    28f2:	c9 f7       	brne	.-14     	; 0x28e6 <enc28j60_crbfs+0x42>
    28f4:	c0 9a       	sbi	0x18, 0	; 24
    28f6:	35 95       	asr	r19
    28f8:	27 95       	ror	r18
    28fa:	35 95       	asr	r19
    28fc:	27 95       	ror	r18
    28fe:	35 95       	asr	r19
    2900:	27 95       	ror	r18
    2902:	35 95       	asr	r19
    2904:	27 95       	ror	r18
    2906:	35 95       	asr	r19
    2908:	27 95       	ror	r18
    290a:	29 83       	std	Y+1, r18	; 0x01
    290c:	c0 98       	cbi	0x18, 0	; 24
    290e:	8f e9       	ldi	r24, 0x9F	; 159
    2910:	8f b9       	out	0x0f, r24	; 15
    2912:	77 9b       	sbis	0x0e, 7	; 14
    2914:	fe cf       	rjmp	.-4      	; 0x2912 <enc28j60_crbfs+0x6e>
    2916:	fd 01       	movw	r30, r26
    2918:	81 91       	ld	r24, Z+
    291a:	8f b9       	out	0x0f, r24	; 15
    291c:	77 9b       	sbis	0x0e, 7	; 14
    291e:	fe cf       	rjmp	.-4      	; 0x291c <enc28j60_crbfs+0x78>
    2920:	e6 17       	cp	r30, r22
    2922:	f7 07       	cpc	r31, r23
    2924:	c9 f7       	brne	.-14     	; 0x2918 <enc28j60_crbfs+0x74>
    2926:	c0 9a       	sbi	0x18, 0	; 24
    2928:	84 2f       	mov	r24, r20
    292a:	80 76       	andi	r24, 0x60	; 96
    292c:	80 93 7e 09 	sts	0x097E, r24
    2930:	4f 71       	andi	r20, 0x1F	; 31
    2932:	40 68       	ori	r20, 0x80	; 128
    2934:	c0 98       	cbi	0x18, 0	; 24
    2936:	4f b9       	out	0x0f, r20	; 15
    2938:	77 9b       	sbis	0x0e, 7	; 14
    293a:	fe cf       	rjmp	.-4      	; 0x2938 <enc28j60_crbfs+0x94>
    293c:	fb 01       	movw	r30, r22
    293e:	9e 01       	movw	r18, r28
    2940:	2d 5f       	subi	r18, 0xFD	; 253
    2942:	3f 4f       	sbci	r19, 0xFF	; 255
    2944:	81 91       	ld	r24, Z+
    2946:	8f b9       	out	0x0f, r24	; 15
    2948:	77 9b       	sbis	0x0e, 7	; 14
    294a:	fe cf       	rjmp	.-4      	; 0x2948 <enc28j60_crbfs+0xa4>
    294c:	e2 17       	cp	r30, r18
    294e:	f3 07       	cpc	r31, r19
    2950:	c9 f7       	brne	.-14     	; 0x2944 <enc28j60_crbfs+0xa0>
    2952:	c0 9a       	sbi	0x18, 0	; 24
    2954:	0f 90       	pop	r0
    2956:	0f 90       	pop	r0
    2958:	cf 91       	pop	r28
    295a:	df 91       	pop	r29
    295c:	08 95       	ret
    295e:	be 01       	movw	r22, r28
    2960:	6e 5f       	subi	r22, 0xFE	; 254
    2962:	7f 4f       	sbci	r23, 0xFF	; 255
    2964:	e5 cf       	rjmp	.-54     	; 0x2930 <enc28j60_crbfs+0x8c>

00002966 <enc28j60_crbfc>:
    2966:	df 93       	push	r29
    2968:	cf 93       	push	r28
    296a:	00 d0       	rcall	.+0      	; 0x296c <enc28j60_crbfc+0x6>
    296c:	cd b7       	in	r28, 0x3d	; 61
    296e:	de b7       	in	r29, 0x3e	; 62
    2970:	48 2f       	mov	r20, r24
    2972:	6a 83       	std	Y+2, r22	; 0x02
    2974:	87 fd       	sbrc	r24, 7
    2976:	54 c0       	rjmp	.+168    	; 0x2a20 <enc28j60_crbfc+0xba>
    2978:	28 2f       	mov	r18, r24
    297a:	30 e0       	ldi	r19, 0x00	; 0
    297c:	20 76       	andi	r18, 0x60	; 96
    297e:	30 70       	andi	r19, 0x00	; 0
    2980:	80 91 7e 09 	lds	r24, 0x097E
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	82 17       	cp	r24, r18
    2988:	93 07       	cpc	r25, r19
    298a:	09 f4       	brne	.+2      	; 0x298e <enc28j60_crbfc+0x28>
    298c:	49 c0       	rjmp	.+146    	; 0x2a20 <enc28j60_crbfc+0xba>
    298e:	83 e0       	ldi	r24, 0x03	; 3
    2990:	89 83       	std	Y+1, r24	; 0x01
    2992:	c0 98       	cbi	0x18, 0	; 24
    2994:	8f eb       	ldi	r24, 0xBF	; 191
    2996:	8f b9       	out	0x0f, r24	; 15
    2998:	77 9b       	sbis	0x0e, 7	; 14
    299a:	fe cf       	rjmp	.-4      	; 0x2998 <enc28j60_crbfc+0x32>
    299c:	de 01       	movw	r26, r28
    299e:	11 96       	adiw	r26, 0x01	; 1
    29a0:	fd 01       	movw	r30, r26
    29a2:	be 01       	movw	r22, r28
    29a4:	6e 5f       	subi	r22, 0xFE	; 254
    29a6:	7f 4f       	sbci	r23, 0xFF	; 255
    29a8:	81 91       	ld	r24, Z+
    29aa:	8f b9       	out	0x0f, r24	; 15
    29ac:	77 9b       	sbis	0x0e, 7	; 14
    29ae:	fe cf       	rjmp	.-4      	; 0x29ac <enc28j60_crbfc+0x46>
    29b0:	e6 17       	cp	r30, r22
    29b2:	f7 07       	cpc	r31, r23
    29b4:	c9 f7       	brne	.-14     	; 0x29a8 <enc28j60_crbfc+0x42>
    29b6:	c0 9a       	sbi	0x18, 0	; 24
    29b8:	35 95       	asr	r19
    29ba:	27 95       	ror	r18
    29bc:	35 95       	asr	r19
    29be:	27 95       	ror	r18
    29c0:	35 95       	asr	r19
    29c2:	27 95       	ror	r18
    29c4:	35 95       	asr	r19
    29c6:	27 95       	ror	r18
    29c8:	35 95       	asr	r19
    29ca:	27 95       	ror	r18
    29cc:	29 83       	std	Y+1, r18	; 0x01
    29ce:	c0 98       	cbi	0x18, 0	; 24
    29d0:	8f e9       	ldi	r24, 0x9F	; 159
    29d2:	8f b9       	out	0x0f, r24	; 15
    29d4:	77 9b       	sbis	0x0e, 7	; 14
    29d6:	fe cf       	rjmp	.-4      	; 0x29d4 <enc28j60_crbfc+0x6e>
    29d8:	fd 01       	movw	r30, r26
    29da:	81 91       	ld	r24, Z+
    29dc:	8f b9       	out	0x0f, r24	; 15
    29de:	77 9b       	sbis	0x0e, 7	; 14
    29e0:	fe cf       	rjmp	.-4      	; 0x29de <enc28j60_crbfc+0x78>
    29e2:	e6 17       	cp	r30, r22
    29e4:	f7 07       	cpc	r31, r23
    29e6:	c9 f7       	brne	.-14     	; 0x29da <enc28j60_crbfc+0x74>
    29e8:	c0 9a       	sbi	0x18, 0	; 24
    29ea:	84 2f       	mov	r24, r20
    29ec:	80 76       	andi	r24, 0x60	; 96
    29ee:	80 93 7e 09 	sts	0x097E, r24
    29f2:	4f 71       	andi	r20, 0x1F	; 31
    29f4:	40 6a       	ori	r20, 0xA0	; 160
    29f6:	c0 98       	cbi	0x18, 0	; 24
    29f8:	4f b9       	out	0x0f, r20	; 15
    29fa:	77 9b       	sbis	0x0e, 7	; 14
    29fc:	fe cf       	rjmp	.-4      	; 0x29fa <enc28j60_crbfc+0x94>
    29fe:	fb 01       	movw	r30, r22
    2a00:	9e 01       	movw	r18, r28
    2a02:	2d 5f       	subi	r18, 0xFD	; 253
    2a04:	3f 4f       	sbci	r19, 0xFF	; 255
    2a06:	81 91       	ld	r24, Z+
    2a08:	8f b9       	out	0x0f, r24	; 15
    2a0a:	77 9b       	sbis	0x0e, 7	; 14
    2a0c:	fe cf       	rjmp	.-4      	; 0x2a0a <enc28j60_crbfc+0xa4>
    2a0e:	e2 17       	cp	r30, r18
    2a10:	f3 07       	cpc	r31, r19
    2a12:	c9 f7       	brne	.-14     	; 0x2a06 <enc28j60_crbfc+0xa0>
    2a14:	c0 9a       	sbi	0x18, 0	; 24
    2a16:	0f 90       	pop	r0
    2a18:	0f 90       	pop	r0
    2a1a:	cf 91       	pop	r28
    2a1c:	df 91       	pop	r29
    2a1e:	08 95       	ret
    2a20:	be 01       	movw	r22, r28
    2a22:	6e 5f       	subi	r22, 0xFE	; 254
    2a24:	7f 4f       	sbci	r23, 0xFF	; 255
    2a26:	e5 cf       	rjmp	.-54     	; 0x29f2 <enc28j60_crbfc+0x8c>

00002a28 <enc28j60_wcr>:
    2a28:	ef 92       	push	r14
    2a2a:	ff 92       	push	r15
    2a2c:	1f 93       	push	r17
    2a2e:	df 93       	push	r29
    2a30:	cf 93       	push	r28
    2a32:	0f 92       	push	r0
    2a34:	cd b7       	in	r28, 0x3d	; 61
    2a36:	de b7       	in	r29, 0x3e	; 62
    2a38:	18 2f       	mov	r17, r24
    2a3a:	fb 01       	movw	r30, r22
    2a3c:	87 fd       	sbrc	r24, 7
    2a3e:	3f c0       	rjmp	.+126    	; 0x2abe <enc28j60_wcr+0x96>
    2a40:	28 2f       	mov	r18, r24
    2a42:	30 e0       	ldi	r19, 0x00	; 0
    2a44:	20 76       	andi	r18, 0x60	; 96
    2a46:	30 70       	andi	r19, 0x00	; 0
    2a48:	80 91 7e 09 	lds	r24, 0x097E
    2a4c:	90 e0       	ldi	r25, 0x00	; 0
    2a4e:	82 17       	cp	r24, r18
    2a50:	93 07       	cpc	r25, r19
    2a52:	a9 f1       	breq	.+106    	; 0x2abe <enc28j60_wcr+0x96>
    2a54:	83 e0       	ldi	r24, 0x03	; 3
    2a56:	89 83       	std	Y+1, r24	; 0x01
    2a58:	c0 98       	cbi	0x18, 0	; 24
    2a5a:	8f eb       	ldi	r24, 0xBF	; 191
    2a5c:	8f b9       	out	0x0f, r24	; 15
    2a5e:	77 9b       	sbis	0x0e, 7	; 14
    2a60:	fe cf       	rjmp	.-4      	; 0x2a5e <enc28j60_wcr+0x36>
    2a62:	be 01       	movw	r22, r28
    2a64:	6f 5f       	subi	r22, 0xFF	; 255
    2a66:	7f 4f       	sbci	r23, 0xFF	; 255
    2a68:	db 01       	movw	r26, r22
    2a6a:	82 e0       	ldi	r24, 0x02	; 2
    2a6c:	e8 2e       	mov	r14, r24
    2a6e:	f1 2c       	mov	r15, r1
    2a70:	ec 0e       	add	r14, r28
    2a72:	fd 1e       	adc	r15, r29
    2a74:	8d 91       	ld	r24, X+
    2a76:	8f b9       	out	0x0f, r24	; 15
    2a78:	77 9b       	sbis	0x0e, 7	; 14
    2a7a:	fe cf       	rjmp	.-4      	; 0x2a78 <enc28j60_wcr+0x50>
    2a7c:	ae 15       	cp	r26, r14
    2a7e:	bf 05       	cpc	r27, r15
    2a80:	c9 f7       	brne	.-14     	; 0x2a74 <enc28j60_wcr+0x4c>
    2a82:	c0 9a       	sbi	0x18, 0	; 24
    2a84:	35 95       	asr	r19
    2a86:	27 95       	ror	r18
    2a88:	35 95       	asr	r19
    2a8a:	27 95       	ror	r18
    2a8c:	35 95       	asr	r19
    2a8e:	27 95       	ror	r18
    2a90:	35 95       	asr	r19
    2a92:	27 95       	ror	r18
    2a94:	35 95       	asr	r19
    2a96:	27 95       	ror	r18
    2a98:	29 83       	std	Y+1, r18	; 0x01
    2a9a:	c0 98       	cbi	0x18, 0	; 24
    2a9c:	8f e9       	ldi	r24, 0x9F	; 159
    2a9e:	8f b9       	out	0x0f, r24	; 15
    2aa0:	77 9b       	sbis	0x0e, 7	; 14
    2aa2:	fe cf       	rjmp	.-4      	; 0x2aa0 <enc28j60_wcr+0x78>
    2aa4:	db 01       	movw	r26, r22
    2aa6:	8d 91       	ld	r24, X+
    2aa8:	8f b9       	out	0x0f, r24	; 15
    2aaa:	77 9b       	sbis	0x0e, 7	; 14
    2aac:	fe cf       	rjmp	.-4      	; 0x2aaa <enc28j60_wcr+0x82>
    2aae:	ae 15       	cp	r26, r14
    2ab0:	bf 05       	cpc	r27, r15
    2ab2:	c9 f7       	brne	.-14     	; 0x2aa6 <enc28j60_wcr+0x7e>
    2ab4:	c0 9a       	sbi	0x18, 0	; 24
    2ab6:	81 2f       	mov	r24, r17
    2ab8:	80 76       	andi	r24, 0x60	; 96
    2aba:	80 93 7e 09 	sts	0x097E, r24
    2abe:	1f 71       	andi	r17, 0x1F	; 31
    2ac0:	10 64       	ori	r17, 0x40	; 64
    2ac2:	c0 98       	cbi	0x18, 0	; 24
    2ac4:	1f b9       	out	0x0f, r17	; 15
    2ac6:	77 9b       	sbis	0x0e, 7	; 14
    2ac8:	fe cf       	rjmp	.-4      	; 0x2ac6 <enc28j60_wcr+0x9e>
    2aca:	41 15       	cp	r20, r1
    2acc:	51 05       	cpc	r21, r1
    2ace:	41 f0       	breq	.+16     	; 0x2ae0 <enc28j60_wcr+0xb8>
    2ad0:	80 81       	ld	r24, Z
    2ad2:	8f b9       	out	0x0f, r24	; 15
    2ad4:	77 9b       	sbis	0x0e, 7	; 14
    2ad6:	fe cf       	rjmp	.-4      	; 0x2ad4 <enc28j60_wcr+0xac>
    2ad8:	31 96       	adiw	r30, 0x01	; 1
    2ada:	41 50       	subi	r20, 0x01	; 1
    2adc:	50 40       	sbci	r21, 0x00	; 0
    2ade:	c1 f7       	brne	.-16     	; 0x2ad0 <enc28j60_wcr+0xa8>
    2ae0:	c0 9a       	sbi	0x18, 0	; 24
    2ae2:	0f 90       	pop	r0
    2ae4:	cf 91       	pop	r28
    2ae6:	df 91       	pop	r29
    2ae8:	1f 91       	pop	r17
    2aea:	ff 90       	pop	r15
    2aec:	ef 90       	pop	r14
    2aee:	08 95       	ret

00002af0 <enc28j60_crputc>:
    2af0:	df 93       	push	r29
    2af2:	cf 93       	push	r28
    2af4:	00 d0       	rcall	.+0      	; 0x2af6 <enc28j60_crputc+0x6>
    2af6:	cd b7       	in	r28, 0x3d	; 61
    2af8:	de b7       	in	r29, 0x3e	; 62
    2afa:	48 2f       	mov	r20, r24
    2afc:	6a 83       	std	Y+2, r22	; 0x02
    2afe:	87 fd       	sbrc	r24, 7
    2b00:	54 c0       	rjmp	.+168    	; 0x2baa <enc28j60_crputc+0xba>
    2b02:	28 2f       	mov	r18, r24
    2b04:	30 e0       	ldi	r19, 0x00	; 0
    2b06:	20 76       	andi	r18, 0x60	; 96
    2b08:	30 70       	andi	r19, 0x00	; 0
    2b0a:	80 91 7e 09 	lds	r24, 0x097E
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	82 17       	cp	r24, r18
    2b12:	93 07       	cpc	r25, r19
    2b14:	09 f4       	brne	.+2      	; 0x2b18 <enc28j60_crputc+0x28>
    2b16:	49 c0       	rjmp	.+146    	; 0x2baa <enc28j60_crputc+0xba>
    2b18:	83 e0       	ldi	r24, 0x03	; 3
    2b1a:	89 83       	std	Y+1, r24	; 0x01
    2b1c:	c0 98       	cbi	0x18, 0	; 24
    2b1e:	8f eb       	ldi	r24, 0xBF	; 191
    2b20:	8f b9       	out	0x0f, r24	; 15
    2b22:	77 9b       	sbis	0x0e, 7	; 14
    2b24:	fe cf       	rjmp	.-4      	; 0x2b22 <enc28j60_crputc+0x32>
    2b26:	de 01       	movw	r26, r28
    2b28:	11 96       	adiw	r26, 0x01	; 1
    2b2a:	fd 01       	movw	r30, r26
    2b2c:	be 01       	movw	r22, r28
    2b2e:	6e 5f       	subi	r22, 0xFE	; 254
    2b30:	7f 4f       	sbci	r23, 0xFF	; 255
    2b32:	81 91       	ld	r24, Z+
    2b34:	8f b9       	out	0x0f, r24	; 15
    2b36:	77 9b       	sbis	0x0e, 7	; 14
    2b38:	fe cf       	rjmp	.-4      	; 0x2b36 <enc28j60_crputc+0x46>
    2b3a:	e6 17       	cp	r30, r22
    2b3c:	f7 07       	cpc	r31, r23
    2b3e:	c9 f7       	brne	.-14     	; 0x2b32 <enc28j60_crputc+0x42>
    2b40:	c0 9a       	sbi	0x18, 0	; 24
    2b42:	35 95       	asr	r19
    2b44:	27 95       	ror	r18
    2b46:	35 95       	asr	r19
    2b48:	27 95       	ror	r18
    2b4a:	35 95       	asr	r19
    2b4c:	27 95       	ror	r18
    2b4e:	35 95       	asr	r19
    2b50:	27 95       	ror	r18
    2b52:	35 95       	asr	r19
    2b54:	27 95       	ror	r18
    2b56:	29 83       	std	Y+1, r18	; 0x01
    2b58:	c0 98       	cbi	0x18, 0	; 24
    2b5a:	8f e9       	ldi	r24, 0x9F	; 159
    2b5c:	8f b9       	out	0x0f, r24	; 15
    2b5e:	77 9b       	sbis	0x0e, 7	; 14
    2b60:	fe cf       	rjmp	.-4      	; 0x2b5e <enc28j60_crputc+0x6e>
    2b62:	fd 01       	movw	r30, r26
    2b64:	81 91       	ld	r24, Z+
    2b66:	8f b9       	out	0x0f, r24	; 15
    2b68:	77 9b       	sbis	0x0e, 7	; 14
    2b6a:	fe cf       	rjmp	.-4      	; 0x2b68 <enc28j60_crputc+0x78>
    2b6c:	e6 17       	cp	r30, r22
    2b6e:	f7 07       	cpc	r31, r23
    2b70:	c9 f7       	brne	.-14     	; 0x2b64 <enc28j60_crputc+0x74>
    2b72:	c0 9a       	sbi	0x18, 0	; 24
    2b74:	84 2f       	mov	r24, r20
    2b76:	80 76       	andi	r24, 0x60	; 96
    2b78:	80 93 7e 09 	sts	0x097E, r24
    2b7c:	4f 71       	andi	r20, 0x1F	; 31
    2b7e:	40 64       	ori	r20, 0x40	; 64
    2b80:	c0 98       	cbi	0x18, 0	; 24
    2b82:	4f b9       	out	0x0f, r20	; 15
    2b84:	77 9b       	sbis	0x0e, 7	; 14
    2b86:	fe cf       	rjmp	.-4      	; 0x2b84 <enc28j60_crputc+0x94>
    2b88:	fb 01       	movw	r30, r22
    2b8a:	9e 01       	movw	r18, r28
    2b8c:	2d 5f       	subi	r18, 0xFD	; 253
    2b8e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b90:	81 91       	ld	r24, Z+
    2b92:	8f b9       	out	0x0f, r24	; 15
    2b94:	77 9b       	sbis	0x0e, 7	; 14
    2b96:	fe cf       	rjmp	.-4      	; 0x2b94 <enc28j60_crputc+0xa4>
    2b98:	e2 17       	cp	r30, r18
    2b9a:	f3 07       	cpc	r31, r19
    2b9c:	c9 f7       	brne	.-14     	; 0x2b90 <enc28j60_crputc+0xa0>
    2b9e:	c0 9a       	sbi	0x18, 0	; 24
    2ba0:	0f 90       	pop	r0
    2ba2:	0f 90       	pop	r0
    2ba4:	cf 91       	pop	r28
    2ba6:	df 91       	pop	r29
    2ba8:	08 95       	ret
    2baa:	be 01       	movw	r22, r28
    2bac:	6e 5f       	subi	r22, 0xFE	; 254
    2bae:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb0:	e5 cf       	rjmp	.-54     	; 0x2b7c <enc28j60_crputc+0x8c>

00002bb2 <enc28j60_crputw>:
    2bb2:	df 93       	push	r29
    2bb4:	cf 93       	push	r28
    2bb6:	00 d0       	rcall	.+0      	; 0x2bb8 <enc28j60_crputw+0x6>
    2bb8:	0f 92       	push	r0
    2bba:	cd b7       	in	r28, 0x3d	; 61
    2bbc:	de b7       	in	r29, 0x3e	; 62
    2bbe:	48 2f       	mov	r20, r24
    2bc0:	7b 83       	std	Y+3, r23	; 0x03
    2bc2:	6a 83       	std	Y+2, r22	; 0x02
    2bc4:	87 fd       	sbrc	r24, 7
    2bc6:	55 c0       	rjmp	.+170    	; 0x2c72 <enc28j60_crputw+0xc0>
    2bc8:	28 2f       	mov	r18, r24
    2bca:	30 e0       	ldi	r19, 0x00	; 0
    2bcc:	20 76       	andi	r18, 0x60	; 96
    2bce:	30 70       	andi	r19, 0x00	; 0
    2bd0:	80 91 7e 09 	lds	r24, 0x097E
    2bd4:	90 e0       	ldi	r25, 0x00	; 0
    2bd6:	82 17       	cp	r24, r18
    2bd8:	93 07       	cpc	r25, r19
    2bda:	09 f4       	brne	.+2      	; 0x2bde <enc28j60_crputw+0x2c>
    2bdc:	4a c0       	rjmp	.+148    	; 0x2c72 <enc28j60_crputw+0xc0>
    2bde:	83 e0       	ldi	r24, 0x03	; 3
    2be0:	89 83       	std	Y+1, r24	; 0x01
    2be2:	c0 98       	cbi	0x18, 0	; 24
    2be4:	8f eb       	ldi	r24, 0xBF	; 191
    2be6:	8f b9       	out	0x0f, r24	; 15
    2be8:	77 9b       	sbis	0x0e, 7	; 14
    2bea:	fe cf       	rjmp	.-4      	; 0x2be8 <enc28j60_crputw+0x36>
    2bec:	de 01       	movw	r26, r28
    2bee:	11 96       	adiw	r26, 0x01	; 1
    2bf0:	fd 01       	movw	r30, r26
    2bf2:	be 01       	movw	r22, r28
    2bf4:	6e 5f       	subi	r22, 0xFE	; 254
    2bf6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bf8:	81 91       	ld	r24, Z+
    2bfa:	8f b9       	out	0x0f, r24	; 15
    2bfc:	77 9b       	sbis	0x0e, 7	; 14
    2bfe:	fe cf       	rjmp	.-4      	; 0x2bfc <enc28j60_crputw+0x4a>
    2c00:	e6 17       	cp	r30, r22
    2c02:	f7 07       	cpc	r31, r23
    2c04:	c9 f7       	brne	.-14     	; 0x2bf8 <enc28j60_crputw+0x46>
    2c06:	c0 9a       	sbi	0x18, 0	; 24
    2c08:	35 95       	asr	r19
    2c0a:	27 95       	ror	r18
    2c0c:	35 95       	asr	r19
    2c0e:	27 95       	ror	r18
    2c10:	35 95       	asr	r19
    2c12:	27 95       	ror	r18
    2c14:	35 95       	asr	r19
    2c16:	27 95       	ror	r18
    2c18:	35 95       	asr	r19
    2c1a:	27 95       	ror	r18
    2c1c:	29 83       	std	Y+1, r18	; 0x01
    2c1e:	c0 98       	cbi	0x18, 0	; 24
    2c20:	8f e9       	ldi	r24, 0x9F	; 159
    2c22:	8f b9       	out	0x0f, r24	; 15
    2c24:	77 9b       	sbis	0x0e, 7	; 14
    2c26:	fe cf       	rjmp	.-4      	; 0x2c24 <enc28j60_crputw+0x72>
    2c28:	fd 01       	movw	r30, r26
    2c2a:	81 91       	ld	r24, Z+
    2c2c:	8f b9       	out	0x0f, r24	; 15
    2c2e:	77 9b       	sbis	0x0e, 7	; 14
    2c30:	fe cf       	rjmp	.-4      	; 0x2c2e <enc28j60_crputw+0x7c>
    2c32:	e6 17       	cp	r30, r22
    2c34:	f7 07       	cpc	r31, r23
    2c36:	c9 f7       	brne	.-14     	; 0x2c2a <enc28j60_crputw+0x78>
    2c38:	c0 9a       	sbi	0x18, 0	; 24
    2c3a:	84 2f       	mov	r24, r20
    2c3c:	80 76       	andi	r24, 0x60	; 96
    2c3e:	80 93 7e 09 	sts	0x097E, r24
    2c42:	4f 71       	andi	r20, 0x1F	; 31
    2c44:	40 64       	ori	r20, 0x40	; 64
    2c46:	c0 98       	cbi	0x18, 0	; 24
    2c48:	4f b9       	out	0x0f, r20	; 15
    2c4a:	77 9b       	sbis	0x0e, 7	; 14
    2c4c:	fe cf       	rjmp	.-4      	; 0x2c4a <enc28j60_crputw+0x98>
    2c4e:	fb 01       	movw	r30, r22
    2c50:	9b 01       	movw	r18, r22
    2c52:	2e 5f       	subi	r18, 0xFE	; 254
    2c54:	3f 4f       	sbci	r19, 0xFF	; 255
    2c56:	81 91       	ld	r24, Z+
    2c58:	8f b9       	out	0x0f, r24	; 15
    2c5a:	77 9b       	sbis	0x0e, 7	; 14
    2c5c:	fe cf       	rjmp	.-4      	; 0x2c5a <enc28j60_crputw+0xa8>
    2c5e:	e2 17       	cp	r30, r18
    2c60:	f3 07       	cpc	r31, r19
    2c62:	c9 f7       	brne	.-14     	; 0x2c56 <enc28j60_crputw+0xa4>
    2c64:	c0 9a       	sbi	0x18, 0	; 24
    2c66:	0f 90       	pop	r0
    2c68:	0f 90       	pop	r0
    2c6a:	0f 90       	pop	r0
    2c6c:	cf 91       	pop	r28
    2c6e:	df 91       	pop	r29
    2c70:	08 95       	ret
    2c72:	be 01       	movw	r22, r28
    2c74:	6e 5f       	subi	r22, 0xFE	; 254
    2c76:	7f 4f       	sbci	r23, 0xFF	; 255
    2c78:	e4 cf       	rjmp	.-56     	; 0x2c42 <enc28j60_crputw+0x90>

00002c7a <enc28j60_crputs>:
    2c7a:	ef 92       	push	r14
    2c7c:	ff 92       	push	r15
    2c7e:	1f 93       	push	r17
    2c80:	df 93       	push	r29
    2c82:	cf 93       	push	r28
    2c84:	0f 92       	push	r0
    2c86:	cd b7       	in	r28, 0x3d	; 61
    2c88:	de b7       	in	r29, 0x3e	; 62
    2c8a:	18 2f       	mov	r17, r24
    2c8c:	fb 01       	movw	r30, r22
    2c8e:	87 fd       	sbrc	r24, 7
    2c90:	3f c0       	rjmp	.+126    	; 0x2d10 <enc28j60_crputs+0x96>
    2c92:	28 2f       	mov	r18, r24
    2c94:	30 e0       	ldi	r19, 0x00	; 0
    2c96:	20 76       	andi	r18, 0x60	; 96
    2c98:	30 70       	andi	r19, 0x00	; 0
    2c9a:	80 91 7e 09 	lds	r24, 0x097E
    2c9e:	90 e0       	ldi	r25, 0x00	; 0
    2ca0:	82 17       	cp	r24, r18
    2ca2:	93 07       	cpc	r25, r19
    2ca4:	a9 f1       	breq	.+106    	; 0x2d10 <enc28j60_crputs+0x96>
    2ca6:	83 e0       	ldi	r24, 0x03	; 3
    2ca8:	89 83       	std	Y+1, r24	; 0x01
    2caa:	c0 98       	cbi	0x18, 0	; 24
    2cac:	8f eb       	ldi	r24, 0xBF	; 191
    2cae:	8f b9       	out	0x0f, r24	; 15
    2cb0:	77 9b       	sbis	0x0e, 7	; 14
    2cb2:	fe cf       	rjmp	.-4      	; 0x2cb0 <enc28j60_crputs+0x36>
    2cb4:	be 01       	movw	r22, r28
    2cb6:	6f 5f       	subi	r22, 0xFF	; 255
    2cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2cba:	db 01       	movw	r26, r22
    2cbc:	82 e0       	ldi	r24, 0x02	; 2
    2cbe:	e8 2e       	mov	r14, r24
    2cc0:	f1 2c       	mov	r15, r1
    2cc2:	ec 0e       	add	r14, r28
    2cc4:	fd 1e       	adc	r15, r29
    2cc6:	8d 91       	ld	r24, X+
    2cc8:	8f b9       	out	0x0f, r24	; 15
    2cca:	77 9b       	sbis	0x0e, 7	; 14
    2ccc:	fe cf       	rjmp	.-4      	; 0x2cca <enc28j60_crputs+0x50>
    2cce:	ae 15       	cp	r26, r14
    2cd0:	bf 05       	cpc	r27, r15
    2cd2:	c9 f7       	brne	.-14     	; 0x2cc6 <enc28j60_crputs+0x4c>
    2cd4:	c0 9a       	sbi	0x18, 0	; 24
    2cd6:	35 95       	asr	r19
    2cd8:	27 95       	ror	r18
    2cda:	35 95       	asr	r19
    2cdc:	27 95       	ror	r18
    2cde:	35 95       	asr	r19
    2ce0:	27 95       	ror	r18
    2ce2:	35 95       	asr	r19
    2ce4:	27 95       	ror	r18
    2ce6:	35 95       	asr	r19
    2ce8:	27 95       	ror	r18
    2cea:	29 83       	std	Y+1, r18	; 0x01
    2cec:	c0 98       	cbi	0x18, 0	; 24
    2cee:	8f e9       	ldi	r24, 0x9F	; 159
    2cf0:	8f b9       	out	0x0f, r24	; 15
    2cf2:	77 9b       	sbis	0x0e, 7	; 14
    2cf4:	fe cf       	rjmp	.-4      	; 0x2cf2 <enc28j60_crputs+0x78>
    2cf6:	db 01       	movw	r26, r22
    2cf8:	8d 91       	ld	r24, X+
    2cfa:	8f b9       	out	0x0f, r24	; 15
    2cfc:	77 9b       	sbis	0x0e, 7	; 14
    2cfe:	fe cf       	rjmp	.-4      	; 0x2cfc <enc28j60_crputs+0x82>
    2d00:	ae 15       	cp	r26, r14
    2d02:	bf 05       	cpc	r27, r15
    2d04:	c9 f7       	brne	.-14     	; 0x2cf8 <enc28j60_crputs+0x7e>
    2d06:	c0 9a       	sbi	0x18, 0	; 24
    2d08:	81 2f       	mov	r24, r17
    2d0a:	80 76       	andi	r24, 0x60	; 96
    2d0c:	80 93 7e 09 	sts	0x097E, r24
    2d10:	1f 71       	andi	r17, 0x1F	; 31
    2d12:	10 64       	ori	r17, 0x40	; 64
    2d14:	c0 98       	cbi	0x18, 0	; 24
    2d16:	1f b9       	out	0x0f, r17	; 15
    2d18:	77 9b       	sbis	0x0e, 7	; 14
    2d1a:	fe cf       	rjmp	.-4      	; 0x2d18 <enc28j60_crputs+0x9e>
    2d1c:	41 15       	cp	r20, r1
    2d1e:	51 05       	cpc	r21, r1
    2d20:	41 f0       	breq	.+16     	; 0x2d32 <enc28j60_crputs+0xb8>
    2d22:	80 81       	ld	r24, Z
    2d24:	8f b9       	out	0x0f, r24	; 15
    2d26:	77 9b       	sbis	0x0e, 7	; 14
    2d28:	fe cf       	rjmp	.-4      	; 0x2d26 <enc28j60_crputs+0xac>
    2d2a:	31 96       	adiw	r30, 0x01	; 1
    2d2c:	41 50       	subi	r20, 0x01	; 1
    2d2e:	50 40       	sbci	r21, 0x00	; 0
    2d30:	c1 f7       	brne	.-16     	; 0x2d22 <enc28j60_crputs+0xa8>
    2d32:	c0 9a       	sbi	0x18, 0	; 24
    2d34:	0f 90       	pop	r0
    2d36:	cf 91       	pop	r28
    2d38:	df 91       	pop	r29
    2d3a:	1f 91       	pop	r17
    2d3c:	ff 90       	pop	r15
    2d3e:	ef 90       	pop	r14
    2d40:	08 95       	ret

00002d42 <enc28j60_prputw>:
    2d42:	df 93       	push	r29
    2d44:	cf 93       	push	r28
    2d46:	00 d0       	rcall	.+0      	; 0x2d48 <enc28j60_prputw+0x6>
    2d48:	cd b7       	in	r28, 0x3d	; 61
    2d4a:	de b7       	in	r29, 0x3e	; 62
    2d4c:	8a 83       	std	Y+2, r24	; 0x02
    2d4e:	80 91 7e 09 	lds	r24, 0x097E
    2d52:	80 34       	cpi	r24, 0x40	; 64
    2d54:	09 f4       	brne	.+2      	; 0x2d58 <enc28j60_prputw+0x16>
    2d56:	92 c0       	rjmp	.+292    	; 0x2e7c <enc28j60_prputw+0x13a>
    2d58:	83 e0       	ldi	r24, 0x03	; 3
    2d5a:	89 83       	std	Y+1, r24	; 0x01
    2d5c:	c0 98       	cbi	0x18, 0	; 24
    2d5e:	8f eb       	ldi	r24, 0xBF	; 191
    2d60:	8f b9       	out	0x0f, r24	; 15
    2d62:	77 9b       	sbis	0x0e, 7	; 14
    2d64:	fe cf       	rjmp	.-4      	; 0x2d62 <enc28j60_prputw+0x20>
    2d66:	de 01       	movw	r26, r28
    2d68:	11 96       	adiw	r26, 0x01	; 1
    2d6a:	fd 01       	movw	r30, r26
    2d6c:	9e 01       	movw	r18, r28
    2d6e:	2e 5f       	subi	r18, 0xFE	; 254
    2d70:	3f 4f       	sbci	r19, 0xFF	; 255
    2d72:	81 91       	ld	r24, Z+
    2d74:	8f b9       	out	0x0f, r24	; 15
    2d76:	77 9b       	sbis	0x0e, 7	; 14
    2d78:	fe cf       	rjmp	.-4      	; 0x2d76 <enc28j60_prputw+0x34>
    2d7a:	e2 17       	cp	r30, r18
    2d7c:	f3 07       	cpc	r31, r19
    2d7e:	c9 f7       	brne	.-14     	; 0x2d72 <enc28j60_prputw+0x30>
    2d80:	c0 9a       	sbi	0x18, 0	; 24
    2d82:	82 e0       	ldi	r24, 0x02	; 2
    2d84:	89 83       	std	Y+1, r24	; 0x01
    2d86:	c0 98       	cbi	0x18, 0	; 24
    2d88:	8f e9       	ldi	r24, 0x9F	; 159
    2d8a:	8f b9       	out	0x0f, r24	; 15
    2d8c:	77 9b       	sbis	0x0e, 7	; 14
    2d8e:	fe cf       	rjmp	.-4      	; 0x2d8c <enc28j60_prputw+0x4a>
    2d90:	fd 01       	movw	r30, r26
    2d92:	81 91       	ld	r24, Z+
    2d94:	8f b9       	out	0x0f, r24	; 15
    2d96:	77 9b       	sbis	0x0e, 7	; 14
    2d98:	fe cf       	rjmp	.-4      	; 0x2d96 <enc28j60_prputw+0x54>
    2d9a:	e2 17       	cp	r30, r18
    2d9c:	f3 07       	cpc	r31, r19
    2d9e:	c9 f7       	brne	.-14     	; 0x2d92 <enc28j60_prputw+0x50>
    2da0:	c0 9a       	sbi	0x18, 0	; 24
    2da2:	80 e4       	ldi	r24, 0x40	; 64
    2da4:	80 93 7e 09 	sts	0x097E, r24
    2da8:	c0 98       	cbi	0x18, 0	; 24
    2daa:	84 e5       	ldi	r24, 0x54	; 84
    2dac:	8f b9       	out	0x0f, r24	; 15
    2dae:	77 9b       	sbis	0x0e, 7	; 14
    2db0:	fe cf       	rjmp	.-4      	; 0x2dae <enc28j60_prputw+0x6c>
    2db2:	f9 01       	movw	r30, r18
    2db4:	ae 01       	movw	r20, r28
    2db6:	4d 5f       	subi	r20, 0xFD	; 253
    2db8:	5f 4f       	sbci	r21, 0xFF	; 255
    2dba:	81 91       	ld	r24, Z+
    2dbc:	8f b9       	out	0x0f, r24	; 15
    2dbe:	77 9b       	sbis	0x0e, 7	; 14
    2dc0:	fe cf       	rjmp	.-4      	; 0x2dbe <enc28j60_prputw+0x7c>
    2dc2:	e4 17       	cp	r30, r20
    2dc4:	f5 07       	cpc	r31, r21
    2dc6:	c9 f7       	brne	.-14     	; 0x2dba <enc28j60_prputw+0x78>
    2dc8:	c0 9a       	sbi	0x18, 0	; 24
    2dca:	69 83       	std	Y+1, r22	; 0x01
    2dcc:	c0 98       	cbi	0x18, 0	; 24
    2dce:	86 e5       	ldi	r24, 0x56	; 86
    2dd0:	8f b9       	out	0x0f, r24	; 15
    2dd2:	77 9b       	sbis	0x0e, 7	; 14
    2dd4:	fe cf       	rjmp	.-4      	; 0x2dd2 <enc28j60_prputw+0x90>
    2dd6:	fd 01       	movw	r30, r26
    2dd8:	81 91       	ld	r24, Z+
    2dda:	8f b9       	out	0x0f, r24	; 15
    2ddc:	77 9b       	sbis	0x0e, 7	; 14
    2dde:	fe cf       	rjmp	.-4      	; 0x2ddc <enc28j60_prputw+0x9a>
    2de0:	e2 17       	cp	r30, r18
    2de2:	f3 07       	cpc	r31, r19
    2de4:	c9 f7       	brne	.-14     	; 0x2dd8 <enc28j60_prputw+0x96>
    2de6:	c0 9a       	sbi	0x18, 0	; 24
    2de8:	79 83       	std	Y+1, r23	; 0x01
    2dea:	c0 98       	cbi	0x18, 0	; 24
    2dec:	87 e5       	ldi	r24, 0x57	; 87
    2dee:	8f b9       	out	0x0f, r24	; 15
    2df0:	77 9b       	sbis	0x0e, 7	; 14
    2df2:	fe cf       	rjmp	.-4      	; 0x2df0 <enc28j60_prputw+0xae>
    2df4:	fd 01       	movw	r30, r26
    2df6:	81 91       	ld	r24, Z+
    2df8:	8f b9       	out	0x0f, r24	; 15
    2dfa:	77 9b       	sbis	0x0e, 7	; 14
    2dfc:	fe cf       	rjmp	.-4      	; 0x2dfa <enc28j60_prputw+0xb8>
    2dfe:	e2 17       	cp	r30, r18
    2e00:	f3 07       	cpc	r31, r19
    2e02:	c9 f7       	brne	.-14     	; 0x2df6 <enc28j60_prputw+0xb4>
    2e04:	c0 9a       	sbi	0x18, 0	; 24
    2e06:	90 e4       	ldi	r25, 0x40	; 64
    2e08:	63 e0       	ldi	r22, 0x03	; 3
    2e0a:	7f eb       	ldi	r23, 0xBF	; 191
    2e0c:	af e9       	ldi	r26, 0x9F	; 159
    2e0e:	ba e0       	ldi	r27, 0x0A	; 10
    2e10:	90 36       	cpi	r25, 0x60	; 96
    2e12:	e9 f0       	breq	.+58     	; 0x2e4e <enc28j60_prputw+0x10c>
    2e14:	6a 83       	std	Y+2, r22	; 0x02
    2e16:	c0 98       	cbi	0x18, 0	; 24
    2e18:	7f b9       	out	0x0f, r23	; 15
    2e1a:	77 9b       	sbis	0x0e, 7	; 14
    2e1c:	fe cf       	rjmp	.-4      	; 0x2e1a <enc28j60_prputw+0xd8>
    2e1e:	f9 01       	movw	r30, r18
    2e20:	81 91       	ld	r24, Z+
    2e22:	8f b9       	out	0x0f, r24	; 15
    2e24:	77 9b       	sbis	0x0e, 7	; 14
    2e26:	fe cf       	rjmp	.-4      	; 0x2e24 <enc28j60_prputw+0xe2>
    2e28:	e4 17       	cp	r30, r20
    2e2a:	f5 07       	cpc	r31, r21
    2e2c:	c9 f7       	brne	.-14     	; 0x2e20 <enc28j60_prputw+0xde>
    2e2e:	c0 9a       	sbi	0x18, 0	; 24
    2e30:	6a 83       	std	Y+2, r22	; 0x02
    2e32:	c0 98       	cbi	0x18, 0	; 24
    2e34:	af b9       	out	0x0f, r26	; 15
    2e36:	77 9b       	sbis	0x0e, 7	; 14
    2e38:	fe cf       	rjmp	.-4      	; 0x2e36 <enc28j60_prputw+0xf4>
    2e3a:	f9 01       	movw	r30, r18
    2e3c:	81 91       	ld	r24, Z+
    2e3e:	8f b9       	out	0x0f, r24	; 15
    2e40:	77 9b       	sbis	0x0e, 7	; 14
    2e42:	fe cf       	rjmp	.-4      	; 0x2e40 <enc28j60_prputw+0xfe>
    2e44:	e4 17       	cp	r30, r20
    2e46:	f5 07       	cpc	r31, r21
    2e48:	c9 f7       	brne	.-14     	; 0x2e3c <enc28j60_prputw+0xfa>
    2e4a:	c0 9a       	sbi	0x18, 0	; 24
    2e4c:	90 e6       	ldi	r25, 0x60	; 96
    2e4e:	c0 98       	cbi	0x18, 0	; 24
    2e50:	bf b9       	out	0x0f, r27	; 15
    2e52:	77 9b       	sbis	0x0e, 7	; 14
    2e54:	fe cf       	rjmp	.-4      	; 0x2e52 <enc28j60_prputw+0x110>
    2e56:	1f b8       	out	0x0f, r1	; 15
    2e58:	77 9b       	sbis	0x0e, 7	; 14
    2e5a:	fe cf       	rjmp	.-4      	; 0x2e58 <enc28j60_prputw+0x116>
    2e5c:	1f b8       	out	0x0f, r1	; 15
    2e5e:	77 9b       	sbis	0x0e, 7	; 14
    2e60:	fe cf       	rjmp	.-4      	; 0x2e5e <enc28j60_prputw+0x11c>
    2e62:	8f b1       	in	r24, 0x0f	; 15
    2e64:	89 83       	std	Y+1, r24	; 0x01
    2e66:	c0 9a       	sbi	0x18, 0	; 24
    2e68:	89 81       	ldd	r24, Y+1	; 0x01
    2e6a:	80 fd       	sbrc	r24, 0
    2e6c:	d1 cf       	rjmp	.-94     	; 0x2e10 <enc28j60_prputw+0xce>
    2e6e:	90 93 7e 09 	sts	0x097E, r25
    2e72:	0f 90       	pop	r0
    2e74:	0f 90       	pop	r0
    2e76:	cf 91       	pop	r28
    2e78:	df 91       	pop	r29
    2e7a:	08 95       	ret
    2e7c:	de 01       	movw	r26, r28
    2e7e:	11 96       	adiw	r26, 0x01	; 1
    2e80:	9e 01       	movw	r18, r28
    2e82:	2e 5f       	subi	r18, 0xFE	; 254
    2e84:	3f 4f       	sbci	r19, 0xFF	; 255
    2e86:	90 cf       	rjmp	.-224    	; 0x2da8 <enc28j60_prputw+0x66>

00002e88 <enc28j60_crgetw>:
    2e88:	df 93       	push	r29
    2e8a:	cf 93       	push	r28
    2e8c:	00 d0       	rcall	.+0      	; 0x2e8e <enc28j60_crgetw+0x6>
    2e8e:	0f 92       	push	r0
    2e90:	cd b7       	in	r28, 0x3d	; 61
    2e92:	de b7       	in	r29, 0x3e	; 62
    2e94:	48 2f       	mov	r20, r24
    2e96:	87 fd       	sbrc	r24, 7
    2e98:	68 c0       	rjmp	.+208    	; 0x2f6a <enc28j60_crgetw+0xe2>
    2e9a:	28 2f       	mov	r18, r24
    2e9c:	30 e0       	ldi	r19, 0x00	; 0
    2e9e:	20 76       	andi	r18, 0x60	; 96
    2ea0:	30 70       	andi	r19, 0x00	; 0
    2ea2:	80 91 7e 09 	lds	r24, 0x097E
    2ea6:	90 e0       	ldi	r25, 0x00	; 0
    2ea8:	82 17       	cp	r24, r18
    2eaa:	93 07       	cpc	r25, r19
    2eac:	09 f4       	brne	.+2      	; 0x2eb0 <enc28j60_crgetw+0x28>
    2eae:	65 c0       	rjmp	.+202    	; 0x2f7a <enc28j60_crgetw+0xf2>
    2eb0:	83 e0       	ldi	r24, 0x03	; 3
    2eb2:	89 83       	std	Y+1, r24	; 0x01
    2eb4:	c0 98       	cbi	0x18, 0	; 24
    2eb6:	8f eb       	ldi	r24, 0xBF	; 191
    2eb8:	8f b9       	out	0x0f, r24	; 15
    2eba:	77 9b       	sbis	0x0e, 7	; 14
    2ebc:	fe cf       	rjmp	.-4      	; 0x2eba <enc28j60_crgetw+0x32>
    2ebe:	de 01       	movw	r26, r28
    2ec0:	11 96       	adiw	r26, 0x01	; 1
    2ec2:	fd 01       	movw	r30, r26
    2ec4:	be 01       	movw	r22, r28
    2ec6:	6e 5f       	subi	r22, 0xFE	; 254
    2ec8:	7f 4f       	sbci	r23, 0xFF	; 255
    2eca:	81 91       	ld	r24, Z+
    2ecc:	8f b9       	out	0x0f, r24	; 15
    2ece:	77 9b       	sbis	0x0e, 7	; 14
    2ed0:	fe cf       	rjmp	.-4      	; 0x2ece <enc28j60_crgetw+0x46>
    2ed2:	e6 17       	cp	r30, r22
    2ed4:	f7 07       	cpc	r31, r23
    2ed6:	c9 f7       	brne	.-14     	; 0x2eca <enc28j60_crgetw+0x42>
    2ed8:	c0 9a       	sbi	0x18, 0	; 24
    2eda:	c9 01       	movw	r24, r18
    2edc:	95 95       	asr	r25
    2ede:	87 95       	ror	r24
    2ee0:	95 95       	asr	r25
    2ee2:	87 95       	ror	r24
    2ee4:	95 95       	asr	r25
    2ee6:	87 95       	ror	r24
    2ee8:	95 95       	asr	r25
    2eea:	87 95       	ror	r24
    2eec:	95 95       	asr	r25
    2eee:	87 95       	ror	r24
    2ef0:	89 83       	std	Y+1, r24	; 0x01
    2ef2:	c0 98       	cbi	0x18, 0	; 24
    2ef4:	8f e9       	ldi	r24, 0x9F	; 159
    2ef6:	8f b9       	out	0x0f, r24	; 15
    2ef8:	77 9b       	sbis	0x0e, 7	; 14
    2efa:	fe cf       	rjmp	.-4      	; 0x2ef8 <enc28j60_crgetw+0x70>
    2efc:	fd 01       	movw	r30, r26
    2efe:	81 91       	ld	r24, Z+
    2f00:	8f b9       	out	0x0f, r24	; 15
    2f02:	77 9b       	sbis	0x0e, 7	; 14
    2f04:	fe cf       	rjmp	.-4      	; 0x2f02 <enc28j60_crgetw+0x7a>
    2f06:	e6 17       	cp	r30, r22
    2f08:	f7 07       	cpc	r31, r23
    2f0a:	c9 f7       	brne	.-14     	; 0x2efe <enc28j60_crgetw+0x76>
    2f0c:	c0 9a       	sbi	0x18, 0	; 24
    2f0e:	84 2f       	mov	r24, r20
    2f10:	80 76       	andi	r24, 0x60	; 96
    2f12:	80 93 7e 09 	sts	0x097E, r24
    2f16:	20 34       	cpi	r18, 0x40	; 64
    2f18:	31 05       	cpc	r19, r1
    2f1a:	e1 f0       	breq	.+56     	; 0x2f54 <enc28j60_crgetw+0xcc>
    2f1c:	80 e0       	ldi	r24, 0x00	; 0
    2f1e:	20 36       	cpi	r18, 0x60	; 96
    2f20:	31 05       	cpc	r19, r1
    2f22:	c1 f0       	breq	.+48     	; 0x2f54 <enc28j60_crgetw+0xcc>
    2f24:	c0 98       	cbi	0x18, 0	; 24
    2f26:	4f 71       	andi	r20, 0x1F	; 31
    2f28:	4f b9       	out	0x0f, r20	; 15
    2f2a:	77 9b       	sbis	0x0e, 7	; 14
    2f2c:	fe cf       	rjmp	.-4      	; 0x2f2a <enc28j60_crgetw+0xa2>
    2f2e:	88 23       	and	r24, r24
    2f30:	19 f0       	breq	.+6      	; 0x2f38 <enc28j60_crgetw+0xb0>
    2f32:	1f b8       	out	0x0f, r1	; 15
    2f34:	77 9b       	sbis	0x0e, 7	; 14
    2f36:	fe cf       	rjmp	.-4      	; 0x2f34 <enc28j60_crgetw+0xac>
    2f38:	fb 01       	movw	r30, r22
    2f3a:	9e 01       	movw	r18, r28
    2f3c:	2d 5f       	subi	r18, 0xFD	; 253
    2f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f40:	1f b8       	out	0x0f, r1	; 15
    2f42:	77 9b       	sbis	0x0e, 7	; 14
    2f44:	fe cf       	rjmp	.-4      	; 0x2f42 <enc28j60_crgetw+0xba>
    2f46:	8f b1       	in	r24, 0x0f	; 15
    2f48:	80 83       	st	Z, r24
    2f4a:	e2 17       	cp	r30, r18
    2f4c:	f3 07       	cpc	r31, r19
    2f4e:	21 f0       	breq	.+8      	; 0x2f58 <enc28j60_crgetw+0xd0>
    2f50:	31 96       	adiw	r30, 0x01	; 1
    2f52:	f6 cf       	rjmp	.-20     	; 0x2f40 <enc28j60_crgetw+0xb8>
    2f54:	81 e0       	ldi	r24, 0x01	; 1
    2f56:	e6 cf       	rjmp	.-52     	; 0x2f24 <enc28j60_crgetw+0x9c>
    2f58:	c0 9a       	sbi	0x18, 0	; 24
    2f5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f5e:	0f 90       	pop	r0
    2f60:	0f 90       	pop	r0
    2f62:	0f 90       	pop	r0
    2f64:	cf 91       	pop	r28
    2f66:	df 91       	pop	r29
    2f68:	08 95       	ret
    2f6a:	28 2f       	mov	r18, r24
    2f6c:	30 e0       	ldi	r19, 0x00	; 0
    2f6e:	20 76       	andi	r18, 0x60	; 96
    2f70:	30 70       	andi	r19, 0x00	; 0
    2f72:	be 01       	movw	r22, r28
    2f74:	6e 5f       	subi	r22, 0xFE	; 254
    2f76:	7f 4f       	sbci	r23, 0xFF	; 255
    2f78:	ce cf       	rjmp	.-100    	; 0x2f16 <enc28j60_crgetw+0x8e>
    2f7a:	be 01       	movw	r22, r28
    2f7c:	6e 5f       	subi	r22, 0xFE	; 254
    2f7e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f80:	ca cf       	rjmp	.-108    	; 0x2f16 <enc28j60_crgetw+0x8e>

00002f82 <enc28j60_crgetc>:
    2f82:	df 93       	push	r29
    2f84:	cf 93       	push	r28
    2f86:	00 d0       	rcall	.+0      	; 0x2f88 <enc28j60_crgetc+0x6>
    2f88:	cd b7       	in	r28, 0x3d	; 61
    2f8a:	de b7       	in	r29, 0x3e	; 62
    2f8c:	48 2f       	mov	r20, r24
    2f8e:	87 fd       	sbrc	r24, 7
    2f90:	5c c0       	rjmp	.+184    	; 0x304a <enc28j60_crgetc+0xc8>
    2f92:	28 2f       	mov	r18, r24
    2f94:	30 e0       	ldi	r19, 0x00	; 0
    2f96:	20 76       	andi	r18, 0x60	; 96
    2f98:	30 70       	andi	r19, 0x00	; 0
    2f9a:	80 91 7e 09 	lds	r24, 0x097E
    2f9e:	90 e0       	ldi	r25, 0x00	; 0
    2fa0:	82 17       	cp	r24, r18
    2fa2:	93 07       	cpc	r25, r19
    2fa4:	99 f1       	breq	.+102    	; 0x300c <enc28j60_crgetc+0x8a>
    2fa6:	83 e0       	ldi	r24, 0x03	; 3
    2fa8:	8a 83       	std	Y+2, r24	; 0x02
    2faa:	c0 98       	cbi	0x18, 0	; 24
    2fac:	8f eb       	ldi	r24, 0xBF	; 191
    2fae:	8f b9       	out	0x0f, r24	; 15
    2fb0:	77 9b       	sbis	0x0e, 7	; 14
    2fb2:	fe cf       	rjmp	.-4      	; 0x2fb0 <enc28j60_crgetc+0x2e>
    2fb4:	be 01       	movw	r22, r28
    2fb6:	6e 5f       	subi	r22, 0xFE	; 254
    2fb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2fba:	fb 01       	movw	r30, r22
    2fbc:	de 01       	movw	r26, r28
    2fbe:	13 96       	adiw	r26, 0x03	; 3
    2fc0:	81 91       	ld	r24, Z+
    2fc2:	8f b9       	out	0x0f, r24	; 15
    2fc4:	77 9b       	sbis	0x0e, 7	; 14
    2fc6:	fe cf       	rjmp	.-4      	; 0x2fc4 <enc28j60_crgetc+0x42>
    2fc8:	ea 17       	cp	r30, r26
    2fca:	fb 07       	cpc	r31, r27
    2fcc:	c9 f7       	brne	.-14     	; 0x2fc0 <enc28j60_crgetc+0x3e>
    2fce:	c0 9a       	sbi	0x18, 0	; 24
    2fd0:	c9 01       	movw	r24, r18
    2fd2:	95 95       	asr	r25
    2fd4:	87 95       	ror	r24
    2fd6:	95 95       	asr	r25
    2fd8:	87 95       	ror	r24
    2fda:	95 95       	asr	r25
    2fdc:	87 95       	ror	r24
    2fde:	95 95       	asr	r25
    2fe0:	87 95       	ror	r24
    2fe2:	95 95       	asr	r25
    2fe4:	87 95       	ror	r24
    2fe6:	8a 83       	std	Y+2, r24	; 0x02
    2fe8:	c0 98       	cbi	0x18, 0	; 24
    2fea:	8f e9       	ldi	r24, 0x9F	; 159
    2fec:	8f b9       	out	0x0f, r24	; 15
    2fee:	77 9b       	sbis	0x0e, 7	; 14
    2ff0:	fe cf       	rjmp	.-4      	; 0x2fee <enc28j60_crgetc+0x6c>
    2ff2:	fb 01       	movw	r30, r22
    2ff4:	81 91       	ld	r24, Z+
    2ff6:	8f b9       	out	0x0f, r24	; 15
    2ff8:	77 9b       	sbis	0x0e, 7	; 14
    2ffa:	fe cf       	rjmp	.-4      	; 0x2ff8 <enc28j60_crgetc+0x76>
    2ffc:	ea 17       	cp	r30, r26
    2ffe:	fb 07       	cpc	r31, r27
    3000:	c9 f7       	brne	.-14     	; 0x2ff4 <enc28j60_crgetc+0x72>
    3002:	c0 9a       	sbi	0x18, 0	; 24
    3004:	84 2f       	mov	r24, r20
    3006:	80 76       	andi	r24, 0x60	; 96
    3008:	80 93 7e 09 	sts	0x097E, r24
    300c:	20 34       	cpi	r18, 0x40	; 64
    300e:	31 05       	cpc	r19, r1
    3010:	d1 f0       	breq	.+52     	; 0x3046 <enc28j60_crgetc+0xc4>
    3012:	80 e0       	ldi	r24, 0x00	; 0
    3014:	20 36       	cpi	r18, 0x60	; 96
    3016:	31 05       	cpc	r19, r1
    3018:	b1 f0       	breq	.+44     	; 0x3046 <enc28j60_crgetc+0xc4>
    301a:	c0 98       	cbi	0x18, 0	; 24
    301c:	4f 71       	andi	r20, 0x1F	; 31
    301e:	4f b9       	out	0x0f, r20	; 15
    3020:	77 9b       	sbis	0x0e, 7	; 14
    3022:	fe cf       	rjmp	.-4      	; 0x3020 <enc28j60_crgetc+0x9e>
    3024:	88 23       	and	r24, r24
    3026:	19 f0       	breq	.+6      	; 0x302e <enc28j60_crgetc+0xac>
    3028:	1f b8       	out	0x0f, r1	; 15
    302a:	77 9b       	sbis	0x0e, 7	; 14
    302c:	fe cf       	rjmp	.-4      	; 0x302a <enc28j60_crgetc+0xa8>
    302e:	1f b8       	out	0x0f, r1	; 15
    3030:	77 9b       	sbis	0x0e, 7	; 14
    3032:	fe cf       	rjmp	.-4      	; 0x3030 <enc28j60_crgetc+0xae>
    3034:	8f b1       	in	r24, 0x0f	; 15
    3036:	89 83       	std	Y+1, r24	; 0x01
    3038:	c0 9a       	sbi	0x18, 0	; 24
    303a:	89 81       	ldd	r24, Y+1	; 0x01
    303c:	0f 90       	pop	r0
    303e:	0f 90       	pop	r0
    3040:	cf 91       	pop	r28
    3042:	df 91       	pop	r29
    3044:	08 95       	ret
    3046:	81 e0       	ldi	r24, 0x01	; 1
    3048:	e8 cf       	rjmp	.-48     	; 0x301a <enc28j60_crgetc+0x98>
    304a:	28 2f       	mov	r18, r24
    304c:	30 e0       	ldi	r19, 0x00	; 0
    304e:	20 76       	andi	r18, 0x60	; 96
    3050:	30 70       	andi	r19, 0x00	; 0
    3052:	dc cf       	rjmp	.-72     	; 0x300c <enc28j60_crgetc+0x8a>

00003054 <enc28j60_crgets>:
    3054:	ff 92       	push	r15
    3056:	0f 93       	push	r16
    3058:	1f 93       	push	r17
    305a:	df 93       	push	r29
    305c:	cf 93       	push	r28
    305e:	0f 92       	push	r0
    3060:	cd b7       	in	r28, 0x3d	; 61
    3062:	de b7       	in	r29, 0x3e	; 62
    3064:	a8 2f       	mov	r26, r24
    3066:	b6 2f       	mov	r27, r22
    3068:	f7 2e       	mov	r15, r23
    306a:	87 fd       	sbrc	r24, 7
    306c:	6c c0       	rjmp	.+216    	; 0x3146 <enc28j60_crgets+0xf2>
    306e:	28 2f       	mov	r18, r24
    3070:	30 e0       	ldi	r19, 0x00	; 0
    3072:	20 76       	andi	r18, 0x60	; 96
    3074:	30 70       	andi	r19, 0x00	; 0
    3076:	80 91 7e 09 	lds	r24, 0x097E
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	82 17       	cp	r24, r18
    307e:	93 07       	cpc	r25, r19
    3080:	a1 f1       	breq	.+104    	; 0x30ea <enc28j60_crgets+0x96>
    3082:	83 e0       	ldi	r24, 0x03	; 3
    3084:	89 83       	std	Y+1, r24	; 0x01
    3086:	c0 98       	cbi	0x18, 0	; 24
    3088:	8f eb       	ldi	r24, 0xBF	; 191
    308a:	8f b9       	out	0x0f, r24	; 15
    308c:	77 9b       	sbis	0x0e, 7	; 14
    308e:	fe cf       	rjmp	.-4      	; 0x308c <enc28j60_crgets+0x38>
    3090:	be 01       	movw	r22, r28
    3092:	6f 5f       	subi	r22, 0xFF	; 255
    3094:	7f 4f       	sbci	r23, 0xFF	; 255
    3096:	fb 01       	movw	r30, r22
    3098:	8e 01       	movw	r16, r28
    309a:	0e 5f       	subi	r16, 0xFE	; 254
    309c:	1f 4f       	sbci	r17, 0xFF	; 255
    309e:	81 91       	ld	r24, Z+
    30a0:	8f b9       	out	0x0f, r24	; 15
    30a2:	77 9b       	sbis	0x0e, 7	; 14
    30a4:	fe cf       	rjmp	.-4      	; 0x30a2 <enc28j60_crgets+0x4e>
    30a6:	e0 17       	cp	r30, r16
    30a8:	f1 07       	cpc	r31, r17
    30aa:	c9 f7       	brne	.-14     	; 0x309e <enc28j60_crgets+0x4a>
    30ac:	c0 9a       	sbi	0x18, 0	; 24
    30ae:	c9 01       	movw	r24, r18
    30b0:	95 95       	asr	r25
    30b2:	87 95       	ror	r24
    30b4:	95 95       	asr	r25
    30b6:	87 95       	ror	r24
    30b8:	95 95       	asr	r25
    30ba:	87 95       	ror	r24
    30bc:	95 95       	asr	r25
    30be:	87 95       	ror	r24
    30c0:	95 95       	asr	r25
    30c2:	87 95       	ror	r24
    30c4:	89 83       	std	Y+1, r24	; 0x01
    30c6:	c0 98       	cbi	0x18, 0	; 24
    30c8:	8f e9       	ldi	r24, 0x9F	; 159
    30ca:	8f b9       	out	0x0f, r24	; 15
    30cc:	77 9b       	sbis	0x0e, 7	; 14
    30ce:	fe cf       	rjmp	.-4      	; 0x30cc <enc28j60_crgets+0x78>
    30d0:	fb 01       	movw	r30, r22
    30d2:	81 91       	ld	r24, Z+
    30d4:	8f b9       	out	0x0f, r24	; 15
    30d6:	77 9b       	sbis	0x0e, 7	; 14
    30d8:	fe cf       	rjmp	.-4      	; 0x30d6 <enc28j60_crgets+0x82>
    30da:	e0 17       	cp	r30, r16
    30dc:	f1 07       	cpc	r31, r17
    30de:	c9 f7       	brne	.-14     	; 0x30d2 <enc28j60_crgets+0x7e>
    30e0:	c0 9a       	sbi	0x18, 0	; 24
    30e2:	8a 2f       	mov	r24, r26
    30e4:	80 76       	andi	r24, 0x60	; 96
    30e6:	80 93 7e 09 	sts	0x097E, r24
    30ea:	20 34       	cpi	r18, 0x40	; 64
    30ec:	31 05       	cpc	r19, r1
    30ee:	f9 f0       	breq	.+62     	; 0x312e <enc28j60_crgets+0xda>
    30f0:	80 e0       	ldi	r24, 0x00	; 0
    30f2:	20 36       	cpi	r18, 0x60	; 96
    30f4:	31 05       	cpc	r19, r1
    30f6:	d9 f0       	breq	.+54     	; 0x312e <enc28j60_crgets+0xda>
    30f8:	c0 98       	cbi	0x18, 0	; 24
    30fa:	af 71       	andi	r26, 0x1F	; 31
    30fc:	af b9       	out	0x0f, r26	; 15
    30fe:	77 9b       	sbis	0x0e, 7	; 14
    3100:	fe cf       	rjmp	.-4      	; 0x30fe <enc28j60_crgets+0xaa>
    3102:	88 23       	and	r24, r24
    3104:	19 f0       	breq	.+6      	; 0x310c <enc28j60_crgets+0xb8>
    3106:	1f b8       	out	0x0f, r1	; 15
    3108:	77 9b       	sbis	0x0e, 7	; 14
    310a:	fe cf       	rjmp	.-4      	; 0x3108 <enc28j60_crgets+0xb4>
    310c:	41 15       	cp	r20, r1
    310e:	51 05       	cpc	r21, r1
    3110:	81 f0       	breq	.+32     	; 0x3132 <enc28j60_crgets+0xde>
    3112:	8b 2f       	mov	r24, r27
    3114:	9f 2d       	mov	r25, r15
    3116:	9c 01       	movw	r18, r24
    3118:	f9 01       	movw	r30, r18
    311a:	1f b8       	out	0x0f, r1	; 15
    311c:	77 9b       	sbis	0x0e, 7	; 14
    311e:	fe cf       	rjmp	.-4      	; 0x311c <enc28j60_crgets+0xc8>
    3120:	8f b1       	in	r24, 0x0f	; 15
    3122:	80 83       	st	Z, r24
    3124:	41 50       	subi	r20, 0x01	; 1
    3126:	50 40       	sbci	r21, 0x00	; 0
    3128:	21 f0       	breq	.+8      	; 0x3132 <enc28j60_crgets+0xde>
    312a:	31 96       	adiw	r30, 0x01	; 1
    312c:	f6 cf       	rjmp	.-20     	; 0x311a <enc28j60_crgets+0xc6>
    312e:	81 e0       	ldi	r24, 0x01	; 1
    3130:	e3 cf       	rjmp	.-58     	; 0x30f8 <enc28j60_crgets+0xa4>
    3132:	c0 9a       	sbi	0x18, 0	; 24
    3134:	8b 2f       	mov	r24, r27
    3136:	9f 2d       	mov	r25, r15
    3138:	0f 90       	pop	r0
    313a:	cf 91       	pop	r28
    313c:	df 91       	pop	r29
    313e:	1f 91       	pop	r17
    3140:	0f 91       	pop	r16
    3142:	ff 90       	pop	r15
    3144:	08 95       	ret
    3146:	28 2f       	mov	r18, r24
    3148:	30 e0       	ldi	r19, 0x00	; 0
    314a:	20 76       	andi	r18, 0x60	; 96
    314c:	30 70       	andi	r19, 0x00	; 0
    314e:	cd cf       	rjmp	.-102    	; 0x30ea <enc28j60_crgets+0x96>

00003150 <nicGetPacketSize>:
}



uint16_t nicGetPacketSize(const struct nicRequestHandle_t* handle)
{
    3150:	fc 01       	movw	r30, r24
  if (handle->packet == NULL)
    3152:	01 90       	ld	r0, Z+
    3154:	f0 81       	ld	r31, Z
    3156:	e0 2d       	mov	r30, r0
    3158:	30 97       	sbiw	r30, 0x00	; 0
    315a:	29 f0       	breq	.+10     	; 0x3166 <nicGetPacketSize+0x16>
    return 0;

  return handle->packet->length;
    315c:	06 80       	ldd	r0, Z+6	; 0x06
    315e:	f7 81       	ldd	r31, Z+7	; 0x07
    3160:	e0 2d       	mov	r30, r0
}
    3162:	cf 01       	movw	r24, r30
    3164:	08 95       	ret



uint16_t nicGetPacketSize(const struct nicRequestHandle_t* handle)
{
  if (handle->packet == NULL)
    3166:	e0 e0       	ldi	r30, 0x00	; 0
    3168:	f0 e0       	ldi	r31, 0x00	; 0
    return 0;

  return handle->packet->length;
}
    316a:	cf 01       	movw	r24, r30
    316c:	08 95       	ret

0000316e <nicResponseSize>:

  return len;  
}

uint16_t nicResponseSize(struct nicResponseHandle_t* response)
{
    316e:	fc 01       	movw	r30, r24
  if (response == 0)
    3170:	00 97       	sbiw	r24, 0x00	; 0
    3172:	21 f0       	breq	.+8      	; 0x317c <nicResponseSize+0xe>
    return 0;
   
  return response->length;
    3174:	20 81       	ld	r18, Z
    3176:	31 81       	ldd	r19, Z+1	; 0x01
}
    3178:	c9 01       	movw	r24, r18
    317a:	08 95       	ret
  return len;  
}

uint16_t nicResponseSize(struct nicResponseHandle_t* response)
{
  if (response == 0)
    317c:	20 e0       	ldi	r18, 0x00	; 0
    317e:	30 e0       	ldi	r19, 0x00	; 0
    return 0;
   
  return response->length;
}
    3180:	c9 01       	movw	r24, r18
    3182:	08 95       	ret

00003184 <nicResponseRead>:
  
  return;
}

uint16_t nicResponseRead(struct nicResponseHandle_t* response, char* buffer, uint16_t len)
{
    3184:	0f 93       	push	r16
    3186:	1f 93       	push	r17
    3188:	cf 93       	push	r28
    318a:	df 93       	push	r29
    318c:	8c 01       	movw	r16, r24
    318e:	dc 01       	movw	r26, r24
    3190:	ed 91       	ld	r30, X+
    3192:	fc 91       	ld	r31, X
    3194:	ea 01       	movw	r28, r20
    3196:	e4 17       	cp	r30, r20
    3198:	f5 07       	cpc	r31, r21
    319a:	08 f4       	brcc	.+2      	; 0x319e <nicResponseRead+0x1a>
    319c:	ef 01       	movw	r28, r30
  // adjust the length, if it is bigger than the received packet...
  if (response->length < len)
    len = response->length;
         
  // read enc packet...
  enc28j60_bmgets(buffer,len);
    319e:	cb 01       	movw	r24, r22
    31a0:	be 01       	movw	r22, r28
    31a2:	0e 94 bd 13 	call	0x277a	; 0x277a <enc28j60_bmgets>
  
  // ...decrement length
  response->length -= len;
    31a6:	f8 01       	movw	r30, r16
    31a8:	80 81       	ld	r24, Z
    31aa:	91 81       	ldd	r25, Z+1	; 0x01
    31ac:	8c 1b       	sub	r24, r28
    31ae:	9d 0b       	sbc	r25, r29
    31b0:	91 83       	std	Z+1, r25	; 0x01
    31b2:	80 83       	st	Z, r24

  return len;  
}
    31b4:	ce 01       	movw	r24, r28
    31b6:	df 91       	pop	r29
    31b8:	cf 91       	pop	r28
    31ba:	1f 91       	pop	r17
    31bc:	0f 91       	pop	r16
    31be:	08 95       	ret

000031c0 <nicFreeResponse>:
  
  return handle;  
}

void nicFreeResponse(struct nicResponseHandle_t* response)
{
    31c0:	cf 93       	push	r28
    31c2:	df 93       	push	r29
    31c4:	ec 01       	movw	r28, r24
  
  //fix Packet Pointer (see Errata)
  if (((response->nextPacketPtr)-1 < ENC_ERXST) || ((response->nextPacketPtr)-1 > ENC_ERXND)) 
    31c6:	6a 81       	ldd	r22, Y+2	; 0x02
    31c8:	7b 81       	ldd	r23, Y+3	; 0x03
    31ca:	61 50       	subi	r22, 0x01	; 1
    31cc:	70 40       	sbci	r23, 0x00	; 0
    31ce:	8a e1       	ldi	r24, 0x1A	; 26
    31d0:	60 30       	cpi	r22, 0x00	; 0
    31d2:	78 07       	cpc	r23, r24
    31d4:	90 f4       	brcc	.+36     	; 0x31fa <nicFreeResponse+0x3a>
    // TODO: WIRKLICH ENC_ERXND?
    enc28j60_crputw(ENC_REG_ERXRDPTL,ENC_ERXND);
  else
    enc28j60_crputw(ENC_REG_ERXRDPTL,(response->nextPacketPtr)-1); 
    31d6:	8c e0       	ldi	r24, 0x0C	; 12
    31d8:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>

  //decrement packet counter:
  enc28j60_crbfs(ENC_REG_ECON2,ENC_REG_ECON2_PKTDEC);
    31dc:	8e e9       	ldi	r24, 0x9E	; 158
    31de:	60 e4       	ldi	r22, 0x40	; 64
    31e0:	0e 94 52 14 	call	0x28a4	; 0x28a4 <enc28j60_crbfs>
  
  //update the next packet pointer
  enc28j60_crputw(ENC_REG_ERDPTL,(response->nextPacketPtr));  
    31e4:	6a 81       	ldd	r22, Y+2	; 0x02
    31e6:	7b 81       	ldd	r23, Y+3	; 0x03
    31e8:	80 e0       	ldi	r24, 0x00	; 0
    31ea:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>
  
  free(response);
    31ee:	ce 01       	movw	r24, r28
    31f0:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
  
  return;
}
    31f4:	df 91       	pop	r29
    31f6:	cf 91       	pop	r28
    31f8:	08 95       	ret
{
  
  //fix Packet Pointer (see Errata)
  if (((response->nextPacketPtr)-1 < ENC_ERXST) || ((response->nextPacketPtr)-1 > ENC_ERXND)) 
    // TODO: WIRKLICH ENC_ERXND?
    enc28j60_crputw(ENC_REG_ERXRDPTL,ENC_ERXND);
    31fa:	8c e0       	ldi	r24, 0x0C	; 12
    31fc:	6f ef       	ldi	r22, 0xFF	; 255
    31fe:	79 e1       	ldi	r23, 0x19	; 25
    3200:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>
    3204:	eb cf       	rjmp	.-42     	; 0x31dc <nicFreeResponse+0x1c>

00003206 <nicFreeRequest>:
  return 1;  
}


void nicFreeRequest(struct nicRequestHandle_t* handle)
{
    3206:	0f 93       	push	r16
    3208:	1f 93       	push	r17
    320a:	cf 93       	push	r28
    320c:	df 93       	push	r29
    320e:	8c 01       	movw	r16, r24
  if (handle == NULL)
    3210:	00 97       	sbiw	r24, 0x00	; 0
    3212:	79 f4       	brne	.+30     	; 0x3232 <nicFreeRequest+0x2c>
    3214:	16 c0       	rjmp	.+44     	; 0x3242 <nicFreeRequest+0x3c>
      = handle->packet; 
       
  while(packet != NULL)
  {
    // free header if applicable
    if (packet->header.data != NULL)
    3216:	88 81       	ld	r24, Y
    3218:	99 81       	ldd	r25, Y+1	; 0x01
    321a:	00 97       	sbiw	r24, 0x00	; 0
    321c:	11 f0       	breq	.+4      	; 0x3222 <nicFreeRequest+0x1c>
      free(packet->header.data);
    321e:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
    
    // update the handle...
    handle->packet = packet->payload;
    3222:	8c 81       	ldd	r24, Y+4	; 0x04
    3224:	9d 81       	ldd	r25, Y+5	; 0x05
    3226:	f8 01       	movw	r30, r16
    3228:	91 83       	std	Z+1, r25	; 0x01
    322a:	80 83       	st	Z, r24
    // then free the packet...
    free(packet);
    322c:	ce 01       	movw	r24, r28
    322e:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
    packet = handle->packet;             
    3232:	f8 01       	movw	r30, r16
    3234:	c0 81       	ld	r28, Z
    3236:	d1 81       	ldd	r29, Z+1	; 0x01
    return;
	  
  struct soPacket_t *packet
      = handle->packet; 
       
  while(packet != NULL)
    3238:	20 97       	sbiw	r28, 0x00	; 0
    323a:	69 f7       	brne	.-38     	; 0x3216 <nicFreeRequest+0x10>
    free(packet);
    packet = handle->packet;             
  }  

  // finally free the handle itself...
  free(handle); 
    323c:	c8 01       	movw	r24, r16
    323e:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <free>
  
  return;
}
    3242:	df 91       	pop	r29
    3244:	cf 91       	pop	r28
    3246:	1f 91       	pop	r17
    3248:	0f 91       	pop	r16
    324a:	08 95       	ret

0000324c <nicAddPacketHeader>:
  return handle;  
}


void* nicAddPacketHeader(struct nicRequestHandle_t* handle, uint16_t len)
{
    324c:	ef 92       	push	r14
    324e:	ff 92       	push	r15
    3250:	0f 93       	push	r16
    3252:	1f 93       	push	r17
    3254:	cf 93       	push	r28
    3256:	df 93       	push	r29
    3258:	7c 01       	movw	r14, r24
    325a:	8b 01       	movw	r16, r22

  // construct the encapsulating packet/frame
  
  // first get memory for the packet/frame...
  struct soPacket_t *packet;
  packet = (struct soPacket_t*) malloc(sizeof(struct soPacket_t));
    325c:	88 e0       	ldi	r24, 0x08	; 8
    325e:	90 e0       	ldi	r25, 0x00	; 0
    3260:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    3264:	ec 01       	movw	r28, r24

  // ... then for the nested header
  packet->header.length = len; 
    3266:	1b 83       	std	Y+3, r17	; 0x03
    3268:	0a 83       	std	Y+2, r16	; 0x02
  if (len == 0 )
    326a:	01 15       	cp	r16, r1
    326c:	11 05       	cpc	r17, r1
    326e:	e9 f4       	brne	.+58     	; 0x32aa <nicAddPacketHeader+0x5e>
    packet->header.data = NULL;
    3270:	19 82       	std	Y+1, r1	; 0x01
    3272:	18 82       	st	Y, r1
  else 
    packet->header.data = (char*)malloc(len);
  

  // now set and/or update the payload...
  packet->payload = handle->packet;
    3274:	d7 01       	movw	r26, r14
    3276:	ed 91       	ld	r30, X+
    3278:	fc 91       	ld	r31, X
    327a:	fd 83       	std	Y+5, r31	; 0x05
    327c:	ec 83       	std	Y+4, r30	; 0x04
   
  if (packet->payload == NULL)
    327e:	30 97       	sbiw	r30, 0x00	; 0
    3280:	01 f1       	breq	.+64     	; 0x32c2 <nicAddPacketHeader+0x76>
    packet->length = packet->header.length;
  else
  	packet->length  = packet->header.length + packet->payload->length;
    3282:	86 81       	ldd	r24, Z+6	; 0x06
    3284:	97 81       	ldd	r25, Z+7	; 0x07
    3286:	2a 81       	ldd	r18, Y+2	; 0x02
    3288:	3b 81       	ldd	r19, Y+3	; 0x03
    328a:	82 0f       	add	r24, r18
    328c:	93 1f       	adc	r25, r19
    328e:	9f 83       	std	Y+7, r25	; 0x07
    3290:	8e 83       	std	Y+6, r24	; 0x06
  
  // now update the packet handle
  handle->packet = packet;
    3292:	f7 01       	movw	r30, r14
    3294:	d1 83       	std	Z+1, r29	; 0x01
    3296:	c0 83       	st	Z, r28
  
  // everything done, so return the header 
  return packet->header.data;  
}
    3298:	88 81       	ld	r24, Y
    329a:	99 81       	ldd	r25, Y+1	; 0x01
    329c:	df 91       	pop	r29
    329e:	cf 91       	pop	r28
    32a0:	1f 91       	pop	r17
    32a2:	0f 91       	pop	r16
    32a4:	ff 90       	pop	r15
    32a6:	ef 90       	pop	r14
    32a8:	08 95       	ret
  // ... then for the nested header
  packet->header.length = len; 
  if (len == 0 )
    packet->header.data = NULL;
  else 
    packet->header.data = (char*)malloc(len);
    32aa:	c8 01       	movw	r24, r16
    32ac:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    32b0:	88 83       	st	Y, r24
    32b2:	99 83       	std	Y+1, r25	; 0x01
  

  // now set and/or update the payload...
  packet->payload = handle->packet;
    32b4:	d7 01       	movw	r26, r14
    32b6:	ed 91       	ld	r30, X+
    32b8:	fc 91       	ld	r31, X
    32ba:	fd 83       	std	Y+5, r31	; 0x05
    32bc:	ec 83       	std	Y+4, r30	; 0x04
   
  if (packet->payload == NULL)
    32be:	30 97       	sbiw	r30, 0x00	; 0
    32c0:	01 f7       	brne	.-64     	; 0x3282 <nicAddPacketHeader+0x36>
    packet->length = packet->header.length;
    32c2:	8a 81       	ldd	r24, Y+2	; 0x02
    32c4:	9b 81       	ldd	r25, Y+3	; 0x03
    32c6:	9f 83       	std	Y+7, r25	; 0x07
    32c8:	8e 83       	std	Y+6, r24	; 0x06
    32ca:	e3 cf       	rjmp	.-58     	; 0x3292 <nicAddPacketHeader+0x46>

000032cc <nicNewRequest>:
};

struct nicRequestHandle_t* nicNewRequest()
{
  struct nicRequestHandle_t* handle;
  handle = (struct nicRequestHandle_t*) malloc(sizeof(struct nicRequestHandle_t));
    32cc:	82 e0       	ldi	r24, 0x02	; 2
    32ce:	90 e0       	ldi	r25, 0x00	; 0
    32d0:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    32d4:	fc 01       	movw	r30, r24
  
  handle->packet = NULL;
    32d6:	11 82       	std	Z+1, r1	; 0x01
    32d8:	10 82       	st	Z, r1

  return handle;  
}
    32da:	08 95       	ret

000032dc <nicReceiveResponse>:

  return;
}

struct nicResponseHandle_t* nicReceiveResponse()
{  
    32dc:	cf 93       	push	r28
    32de:	df 93       	push	r29

  // Check the Interruptflags for new Packkets...
  if ((enc28j60_crgetc(ENC_REG_EIR) & ENC_REG_EIR_PKTIF ) == 0)
    32e0:	8c e9       	ldi	r24, 0x9C	; 156
    32e2:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <enc28j60_crgetc>
    32e6:	86 ff       	sbrs	r24, 6
    32e8:	13 c0       	rjmp	.+38     	; 0x3310 <nicReceiveResponse+0x34>
      return NULL;
 
  // ... generate a handle with a dummy Packet header...
  
  struct nicResponseHandle_t* handle 
      = (struct nicResponseHandle_t*) malloc(sizeof(struct nicResponseHandle_t));
    32ea:	84 e0       	ldi	r24, 0x04	; 4
    32ec:	90 e0       	ldi	r25, 0x00	; 0
    32ee:	0e 94 4e 2e 	call	0x5c9c	; 0x5c9c <malloc>
    32f2:	ec 01       	movw	r28, r24
  
  // ...now set and update the readpointer  
  handle->nextPacketPtr = enc28j60_bmgetw();  
    32f4:	0e 94 9c 13 	call	0x2738	; 0x2738 <enc28j60_bmgetw>
    32f8:	9b 83       	std	Y+3, r25	; 0x03
    32fa:	8a 83       	std	Y+2, r24	; 0x02
  
  //update the length...
  handle->length = enc28j60_bmgetw();
    32fc:	0e 94 9c 13 	call	0x2738	; 0x2738 <enc28j60_bmgetw>
    3300:	99 83       	std	Y+1, r25	; 0x01
    3302:	88 83       	st	Y, r24

  // ignore the receive Vector   
  enc28j60_bmgetw();
    3304:	0e 94 9c 13 	call	0x2738	; 0x2738 <enc28j60_bmgetw>
  
  return handle;  
}
    3308:	ce 01       	movw	r24, r28
    330a:	df 91       	pop	r29
    330c:	cf 91       	pop	r28
    330e:	08 95       	ret
{  

  // Check the Interruptflags for new Packkets...
  if ((enc28j60_crgetc(ENC_REG_EIR) & ENC_REG_EIR_PKTIF ) == 0)
    //... and then consult the packet counter (due to bad silicon) 
    if (enc28j60_crgetc(ENC_REG_EPKTCNT) == 0)
    3310:	89 e3       	ldi	r24, 0x39	; 57
    3312:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <enc28j60_crgetc>
    3316:	88 23       	and	r24, r24
    3318:	41 f7       	brne	.-48     	; 0x32ea <nicReceiveResponse+0xe>
    331a:	c0 e0       	ldi	r28, 0x00	; 0
    331c:	d0 e0       	ldi	r29, 0x00	; 0
    331e:	f4 cf       	rjmp	.-24     	; 0x3308 <nicReceiveResponse+0x2c>

00003320 <nicInitialize>:
  
  return;
}

void nicInitialize(struct macAddress_t* mac)
{
    3320:	cf 93       	push	r28
    3322:	df 93       	push	r29
    3324:	ec 01       	movw	r28, r24
  //TODO Change to Full Duplex Settings...
  enc28j60_init();
    3326:	0e 94 53 13 	call	0x26a6	; 0x26a6 <enc28j60_init>
  
  enc28j60_reset();
    332a:	0e 94 80 13 	call	0x2700	; 0x2700 <enc28j60_reset>
    332e:	20 e0       	ldi	r18, 0x00	; 0
    3330:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3332:	40 e7       	ldi	r20, 0x70	; 112
    3334:	51 e0       	ldi	r21, 0x01	; 1
    3336:	ca 01       	movw	r24, r20
    3338:	01 97       	sbiw	r24, 0x01	; 1
    333a:	f1 f7       	brne	.-4      	; 0x3338 <nicInitialize+0x18>
    333c:	2f 5f       	subi	r18, 0xFF	; 255
    333e:	3f 4f       	sbci	r19, 0xFF	; 255
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3340:	81 e0       	ldi	r24, 0x01	; 1
    3342:	24 3f       	cpi	r18, 0xF4	; 244
    3344:	38 07       	cpc	r19, r24
    3346:	b9 f7       	brne	.-18     	; 0x3336 <nicInitialize+0x16>
  _delay_ms(50);

  // Let's wait until the ENC28J60 is ready...
  while( (enc28j60_crgetc(ENC_REG_ESTAT) & ENC_REG_ESTAT_CLKRDY) == 0 );
    3348:	8d e9       	ldi	r24, 0x9D	; 157
    334a:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <enc28j60_crgetc>
    334e:	80 ff       	sbrs	r24, 0
    3350:	fb cf       	rjmp	.-10     	; 0x3348 <nicInitialize+0x28>
  
  // Setup RX buffers...
  enc28j60_crputc(ENC_REG_ERXSTL, 0x00);
    3352:	88 e0       	ldi	r24, 0x08	; 8
    3354:	60 e0       	ldi	r22, 0x00	; 0
    3356:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_ERXSTH, 0x00);
    335a:	89 e0       	ldi	r24, 0x09	; 9
    335c:	60 e0       	ldi	r22, 0x00	; 0
    335e:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  enc28j60_crputc(ENC_REG_ERXNDL, 0xFF);
    3362:	8a e0       	ldi	r24, 0x0A	; 10
    3364:	6f ef       	ldi	r22, 0xFF	; 255
    3366:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_ERXNDH, 0x19);
    336a:	8b e0       	ldi	r24, 0x0B	; 11
    336c:	69 e1       	ldi	r22, 0x19	; 25
    336e:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  // Setup TX Buffers...
  enc28j60_crputw(ENC_REG_ETXSTL, ENC_ETXST);
    3372:	84 e0       	ldi	r24, 0x04	; 4
    3374:	60 e0       	ldi	r22, 0x00	; 0
    3376:	7a e1       	ldi	r23, 0x1A	; 26
    3378:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXSTL, 0x00);
  //enc28j60_crputc(ENC_REG_ETXSTH, 0x1A);

  enc28j60_crputw(ENC_REG_ETXNDL, ENC_ETXND);
    337c:	86 e0       	ldi	r24, 0x06	; 6
    337e:	6f ef       	ldi	r22, 0xFF	; 255
    3380:	7f e1       	ldi	r23, 0x1F	; 31
    3382:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXNDL, 0xFF);
  //enc28j60_crputc(ENC_REG_ETXNDH, 0x1F);

  // Clear MARST in MACON2 to start Mac Module 
  enc28j60_crputc(ENC_REG_MACON2, 0x00);
    3386:	81 e4       	ldi	r24, 0x41	; 65
    3388:	60 e0       	ldi	r22, 0x00	; 0
    338a:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  // enabled MARXEN in MACON1 to enable receive ...
  // ...TXPAUS and RXPAUS for FullDuplex with FlowControl
  enc28j60_crputc(
    338e:	80 e4       	ldi	r24, 0x40	; 64
    3390:	6d e0       	ldi	r22, 0x0D	; 13
    3392:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
      ENC_REG_MACON1, 
      ENC_REG_MACON1_MARXEN | ENC_REG_MACON1_RXPAUS | ENC_REG_MACON1_TXPAUS);

  // enable automatic Padding (PADCFG) automatic CRC ...
  // .. (TXCRCEN) and Framelength Check in MACON3
  enc28j60_crputc(
    3396:	82 e4       	ldi	r24, 0x42	; 66
    3398:	62 e3       	ldi	r22, 0x32	; 50
    339a:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
      ENC_REG_MACON3,
      ENC_REG_MACON3_PADCFG0 | ENC_REG_MACON3_TXCRCEN  | ENC_REG_MACON3_FRMLEN);

  // set Maximum frame length
  // Programm MAMXFL regiserts to set maximum framelength. 1518 (0x5EE) are normal
  enc28j60_crputc(ENC_REG_MAMXFLL,0xEE);
    339e:	8a e4       	ldi	r24, 0x4A	; 74
    33a0:	6e ee       	ldi	r22, 0xEE	; 238
    33a2:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAMXFLH,0x05);
    33a6:	8b e4       	ldi	r24, 0x4B	; 75
    33a8:	65 e0       	ldi	r22, 0x05	; 5
    33aa:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  // TODO ENC auf Full duplex setzen...
  // Set MABBIPG with 15h (recommended for Full Duplex)
  enc28j60_crputc(ENC_REG_MABBIPG, 0x12);
    33ae:	84 e4       	ldi	r24, 0x44	; 68
    33b0:	62 e1       	ldi	r22, 0x12	; 18
    33b2:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  // set MAIPGL to 12h
  enc28j60_crputc(ENC_REG_MAIPGL, 0x12);
    33b6:	86 e4       	ldi	r24, 0x46	; 70
    33b8:	62 e1       	ldi	r22, 0x12	; 18
    33ba:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  // set HAIPGH to 0h
  enc28j60_crputc(ENC_REG_MAIPGH, 0x0C);
    33be:	87 e4       	ldi	r24, 0x47	; 71
    33c0:	6c e0       	ldi	r22, 0x0C	; 12
    33c2:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  
  //10.) programm mac address: BYTE BACKWARD !
  enc28j60_crputc(ENC_REG_MAADR0,mac->octet6);
    33c6:	81 e6       	ldi	r24, 0x61	; 97
    33c8:	6d 81       	ldd	r22, Y+5	; 0x05
    33ca:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR1,mac->octet5);
    33ce:	80 e6       	ldi	r24, 0x60	; 96
    33d0:	6c 81       	ldd	r22, Y+4	; 0x04
    33d2:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR2,mac->octet4);
    33d6:	83 e6       	ldi	r24, 0x63	; 99
    33d8:	6b 81       	ldd	r22, Y+3	; 0x03
    33da:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR3,mac->octet3);
    33de:	82 e6       	ldi	r24, 0x62	; 98
    33e0:	6a 81       	ldd	r22, Y+2	; 0x02
    33e2:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR4,mac->octet2);
    33e6:	85 e6       	ldi	r24, 0x65	; 101
    33e8:	69 81       	ldd	r22, Y+1	; 0x01
    33ea:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR5,mac->octet1);
    33ee:	84 e6       	ldi	r24, 0x64	; 100
    33f0:	68 81       	ld	r22, Y
    33f2:	0e 94 78 15 	call	0x2af0	; 0x2af0 <enc28j60_crputc>

  // Initialize Phy
  // TODO PHY flags ber define festlegen...
  // disable loopback
  enc28j60_prputw(0x10,(1 << 8));
    33f6:	80 e1       	ldi	r24, 0x10	; 16
    33f8:	60 e0       	ldi	r22, 0x00	; 0
    33fa:	71 e0       	ldi	r23, 0x01	; 1
    33fc:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <enc28j60_prputw>

  // enable LEDs
  enc28j60_prputw(0x14,0x0472);
    3400:	84 e1       	ldi	r24, 0x14	; 20
    3402:	62 e7       	ldi	r22, 0x72	; 114
    3404:	74 e0       	ldi	r23, 0x04	; 4
    3406:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <enc28j60_prputw>

  // enable receive
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_RXEN);
    340a:	8f e9       	ldi	r24, 0x9F	; 159
    340c:	64 e0       	ldi	r22, 0x04	; 4
    340e:	0e 94 52 14 	call	0x28a4	; 0x28a4 <enc28j60_crbfs>
  
  // set next packet pointer to 0
  enc28j60_crputw(ENC_REG_ERDPTL,0);
    3412:	80 e0       	ldi	r24, 0x00	; 0
    3414:	60 e0       	ldi	r22, 0x00	; 0
    3416:	70 e0       	ldi	r23, 0x00	; 0
    3418:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>

  return;
}
    341c:	df 91       	pop	r29
    341e:	cf 91       	pop	r28
    3420:	08 95       	ret

00003422 <nicWaitForSend>:

  return handle->packet->length;
}

void nicWaitForSend()
{
    3422:	1f 93       	push	r17
    3424:	cf 93       	push	r28
    3426:	df 93       	push	r29
    3428:	11 e3       	ldi	r17, 0x31	; 49
    342a:	c0 e0       	ldi	r28, 0x00	; 0
    342c:	d0 e9       	ldi	r29, 0x90	; 144
    342e:	06 c0       	rjmp	.+12     	; 0x343c <nicWaitForSend+0x1a>
    3430:	ce 01       	movw	r24, r28
    3432:	01 97       	sbiw	r24, 0x01	; 1
    3434:	f1 f7       	brne	.-4      	; 0x3432 <nicWaitForSend+0x10>
    3436:	11 50       	subi	r17, 0x01	; 1
  //still sending ?
  uint8_t i = 50;
  while( i-- )
    3438:	1f 3f       	cpi	r17, 0xFF	; 255
    343a:	49 f0       	breq	.+18     	; 0x344e <nicWaitForSend+0x2c>
  {
    // finished sending?
    if ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS))
    343c:	8f e9       	ldi	r24, 0x9F	; 159
    343e:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <enc28j60_crgetc>
    3442:	83 fd       	sbrc	r24, 3
    3444:	f5 cf       	rjmp	.-22     	; 0x3430 <nicWaitForSend+0xe>

  putString_com1("Waitedlong enough");
  
  // ...we waited long enough, continue anyway
  return;
}
    3446:	df 91       	pop	r29
    3448:	cf 91       	pop	r28
    344a:	1f 91       	pop	r17
    344c:	08 95       	ret
        
    // ... no - let's wait some more ms...  
    _delay_ms(10);    
  }

  putString_com1("Waitedlong enough");
    344e:	8a ed       	ldi	r24, 0xDA	; 218
    3450:	91 e0       	ldi	r25, 0x01	; 1
    3452:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  
  // ...we waited long enough, continue anyway
  return;
}
    3456:	df 91       	pop	r29
    3458:	cf 91       	pop	r28
    345a:	1f 91       	pop	r17
    345c:	08 95       	ret

0000345e <nicSendPacket>:

uint8_t nicSendPacket(const struct nicRequestHandle_t* handle, uint8_t flags)
{
    345e:	bf 92       	push	r11
    3460:	cf 92       	push	r12
    3462:	df 92       	push	r13
    3464:	ef 92       	push	r14
    3466:	ff 92       	push	r15
    3468:	0f 93       	push	r16
    346a:	1f 93       	push	r17
    346c:	df 93       	push	r29
    346e:	cf 93       	push	r28
    3470:	0f 92       	push	r0
    3472:	cd b7       	in	r28, 0x3d	; 61
    3474:	de b7       	in	r29, 0x3e	; 62
    3476:	6c 01       	movw	r12, r24
    3478:	b6 2e       	mov	r11, r22
    347a:	12 e3       	ldi	r17, 0x32	; 50
    347c:	e1 2c       	mov	r14, r1
    347e:	80 e9       	ldi	r24, 0x90	; 144
    3480:	f8 2e       	mov	r15, r24
    3482:	06 c0       	rjmp	.+12     	; 0x3490 <nicSendPacket+0x32>
    3484:	c7 01       	movw	r24, r14
    3486:	01 97       	sbiw	r24, 0x01	; 1
    3488:	f1 f7       	brne	.-4      	; 0x3486 <nicSendPacket+0x28>
    348a:	11 50       	subi	r17, 0x01	; 1

void nicWaitForSend()
{
  //still sending ?
  uint8_t i = 50;
  while( i-- )
    348c:	09 f4       	brne	.+2      	; 0x3490 <nicSendPacket+0x32>
    348e:	57 c0       	rjmp	.+174    	; 0x353e <nicSendPacket+0xe0>
  {
    // finished sending?
    if ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS))
    3490:	8f e9       	ldi	r24, 0x9F	; 159
    3492:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <enc28j60_crgetc>
    3496:	83 fd       	sbrc	r24, 3
    3498:	f5 cf       	rjmp	.-22     	; 0x3484 <nicSendPacket+0x26>
{
  // Wait until we are ready to send...
  nicWaitForSend();

  // setup tx buffer start
  enc28j60_crputw(ENC_REG_ETXSTL,ENC_ETXST);
    349a:	84 e0       	ldi	r24, 0x04	; 4
    349c:	60 e0       	ldi	r22, 0x00	; 0
    349e:	7a e1       	ldi	r23, 0x1A	; 26
    34a0:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXSTL,0x00);
  //enc28j60_crputc(ENC_REG_ETXSTH,0x1A);

  //setup write pointer
  enc28j60_crputw(ENC_REG_EWRPTL,ENC_ETXST);
    34a4:	82 e0       	ldi	r24, 0x02	; 2
    34a6:	60 e0       	ldi	r22, 0x00	; 0
    34a8:	7a e1       	ldi	r23, 0x1A	; 26
    34aa:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_EWRPTL,0x00);
  //enc28j60_crputc(ENC_REG_EWRPTH,0x1A);

  // write control block
  uint8_t dummy = 0;
    34ae:	19 82       	std	Y+1, r1	; 0x01
  enc28j60_bmputs(&dummy,1);
    34b0:	ce 01       	movw	r24, r28
    34b2:	01 96       	adiw	r24, 0x01	; 1
    34b4:	61 e0       	ldi	r22, 0x01	; 1
    34b6:	70 e0       	ldi	r23, 0x00	; 0
    34b8:	0e 94 6d 13 	call	0x26da	; 0x26da <enc28j60_bmputs>
  
  // now start building the packet...
  
  struct soPacket_t* packet = handle->packet;
    34bc:	f6 01       	movw	r30, r12
    34be:	00 81       	ld	r16, Z
    34c0:	11 81       	ldd	r17, Z+1	; 0x01
 
       
  while( packet != NULL)
    34c2:	01 15       	cp	r16, r1
    34c4:	11 05       	cpc	r17, r1
    34c6:	81 f0       	breq	.+32     	; 0x34e8 <nicSendPacket+0x8a>
  {    
    enc28j60_bmputs(packet->header.data,packet->header.length);   
    34c8:	f8 01       	movw	r30, r16
    34ca:	62 81       	ldd	r22, Z+2	; 0x02
    34cc:	73 81       	ldd	r23, Z+3	; 0x03
    34ce:	80 81       	ld	r24, Z
    34d0:	91 81       	ldd	r25, Z+1	; 0x01
    34d2:	0e 94 6d 13 	call	0x26da	; 0x26da <enc28j60_bmputs>
    packet = packet->payload;
    34d6:	f8 01       	movw	r30, r16
    34d8:	04 81       	ldd	r16, Z+4	; 0x04
    34da:	15 81       	ldd	r17, Z+5	; 0x05
  // now start building the packet...
  
  struct soPacket_t* packet = handle->packet;
 
       
  while( packet != NULL)
    34dc:	01 15       	cp	r16, r1
    34de:	11 05       	cpc	r17, r1
    34e0:	99 f7       	brne	.-26     	; 0x34c8 <nicSendPacket+0x6a>
    34e2:	f6 01       	movw	r30, r12
    34e4:	00 81       	ld	r16, Z
    34e6:	11 81       	ldd	r17, Z+1	; 0x01
    enc28j60_bmputs(packet->header.data,packet->header.length);   
    packet = packet->payload;
  }
  
  // calculate the Packet length...
  enc28j60_crputw(ENC_REG_ETXNDL, ENC_ETXST + handle->packet->length);
    34e8:	f8 01       	movw	r30, r16
    34ea:	66 81       	ldd	r22, Z+6	; 0x06
    34ec:	77 81       	ldd	r23, Z+7	; 0x07
    34ee:	60 50       	subi	r22, 0x00	; 0
    34f0:	76 4e       	sbci	r23, 0xE6	; 230
    34f2:	86 e0       	ldi	r24, 0x06	; 6
    34f4:	0e 94 d9 15 	call	0x2bb2	; 0x2bb2 <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXNDL,0x4E);  
  //enc28j60_crputc(ENC_REG_ETXNDH,0x1A);
  
	// according to the Silicon Errata Document (10. Transmit Logic) ...
  // .. we need to reset the transmit logic...
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_TXRST); 
    34f8:	8f e9       	ldi	r24, 0x9F	; 159
    34fa:	60 e8       	ldi	r22, 0x80	; 128
    34fc:	0e 94 52 14 	call	0x28a4	; 0x28a4 <enc28j60_crbfs>
  enc28j60_crbfc(ENC_REG_ECON1,ENC_REG_ECON1_TXRST);
    3500:	8f e9       	ldi	r24, 0x9F	; 159
    3502:	60 e8       	ldi	r22, 0x80	; 128
    3504:	0e 94 b3 14 	call	0x2966	; 0x2966 <enc28j60_crbfc>
  
  // transmit request...
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_TXRTS | ENC_REG_ECON1_RXEN);
    3508:	8f e9       	ldi	r24, 0x9F	; 159
    350a:	6c e0       	ldi	r22, 0x0C	; 12
    350c:	0e 94 52 14 	call	0x28a4	; 0x28a4 <enc28j60_crbfs>

  // this is now debug only...
  // ... 
  
  if (flags & NIC_PACKET_SEND_NOWAIT)
    3510:	1b 2d       	mov	r17, r11
    3512:	b0 fc       	sbrc	r11, 0
    3514:	07 c0       	rjmp	.+14     	; 0x3524 <nicSendPacket+0xc6>
    return 0;
  
  // wait until transmit is completed...
  while ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS) );
    3516:	8f e9       	ldi	r24, 0x9F	; 159
    3518:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <enc28j60_crgetc>
    351c:	83 ff       	sbrs	r24, 3
    351e:	fb cf       	rjmp	.-10     	; 0x3516 <nicSendPacket+0xb8>
  
  if (flags & NIC_PACKET_SEND_NOERRCHK)
    3520:	11 ff       	sbrs	r17, 1
    3522:	12 c0       	rjmp	.+36     	; 0x3548 <nicSendPacket+0xea>
    return 0;

  // check ESTAT for send Errors...
  if ((enc28j60_crgetc(ENC_REG_ESTAT) 
    3524:	90 e0       	ldi	r25, 0x00	; 0
  
  // parse Vector...
  
  
  return 1;  
}
    3526:	89 2f       	mov	r24, r25
    3528:	0f 90       	pop	r0
    352a:	cf 91       	pop	r28
    352c:	df 91       	pop	r29
    352e:	1f 91       	pop	r17
    3530:	0f 91       	pop	r16
    3532:	ff 90       	pop	r15
    3534:	ef 90       	pop	r14
    3536:	df 90       	pop	r13
    3538:	cf 90       	pop	r12
    353a:	bf 90       	pop	r11
    353c:	08 95       	ret
        
    // ... no - let's wait some more ms...  
    _delay_ms(10);    
  }

  putString_com1("Waitedlong enough");
    353e:	8a ed       	ldi	r24, 0xDA	; 218
    3540:	91 e0       	ldi	r25, 0x01	; 1
    3542:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    3546:	a9 cf       	rjmp	.-174    	; 0x349a <nicSendPacket+0x3c>
  
  if (flags & NIC_PACKET_SEND_NOERRCHK)
    return 0;

  // check ESTAT for send Errors...
  if ((enc28j60_crgetc(ENC_REG_ESTAT) 
    3548:	8d e9       	ldi	r24, 0x9D	; 157
    354a:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <enc28j60_crgetc>
    354e:	90 e0       	ldi	r25, 0x00	; 0
    3550:	82 71       	andi	r24, 0x12	; 18
    3552:	49 f3       	breq	.-46     	; 0x3526 <nicSendPacket+0xc8>
    3554:	91 e0       	ldi	r25, 0x01	; 1
    3556:	e7 cf       	rjmp	.-50     	; 0x3526 <nicSendPacket+0xc8>

00003558 <onInitApplication>:
  #include "./../../hal/com/com1_debug.h"

  void onInitApplication()
  {
      return;
  }
    3558:	08 95       	ret

0000355a <onSerialData>:
	//rtpSendCommand("egal\n", 6, &Config.IPv4.remoteAdrData, &Config.IPv4.localSrcPort);  


  

    rtpSendCDPData(buf, len, &Config.IPv4.remoteAdrData, &Config.IPv4.localSrcPort);  
    355a:	2f e7       	ldi	r18, 0x7F	; 127
    355c:	39 e0       	ldi	r19, 0x09	; 9
    355e:	70 e0       	ldi	r23, 0x00	; 0
    3560:	a9 01       	movw	r20, r18
    3562:	24 5f       	subi	r18, 0xF4	; 244
    3564:	3f 4f       	sbci	r19, 0xFF	; 255
    3566:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <rtpSendCDPData>
	//putString_com1("\r\nSP");

    return 0;
  }
    356a:	80 e0       	ldi	r24, 0x00	; 0
    356c:	08 95       	ret

0000356e <onRtpData>:
  }


  void onRtpData(char* buf, uint8_t len)
  {    
    if (len > 0)
    356e:	66 23       	and	r22, r22
    3570:	09 f4       	brne	.+2      	; 0x3574 <onRtpData+0x6>
    3572:	08 95       	ret
      serialSendBytes(buf,len);
    3574:	0e 94 c5 0c 	call	0x198a	; 0x198a <serialSendBytes>
    3578:	08 95       	ret

0000357a <calculateCheckSum>:
    357a:	dc 01       	movw	r26, r24
    357c:	60 fd       	sbrc	r22, 0
    357e:	34 c0       	rjmp	.+104    	; 0x35e8 <calculateCheckSum+0x6e>
    3580:	20 e0       	ldi	r18, 0x00	; 0
    3582:	30 e0       	ldi	r19, 0x00	; 0
    3584:	40 e0       	ldi	r20, 0x00	; 0
    3586:	50 e0       	ldi	r21, 0x00	; 0
    3588:	76 95       	lsr	r23
    358a:	67 95       	ror	r22
    358c:	61 15       	cp	r22, r1
    358e:	71 05       	cpc	r23, r1
    3590:	01 f1       	breq	.+64     	; 0x35d2 <calculateCheckSum+0x58>
    3592:	fb 01       	movw	r30, r22
    3594:	e1 50       	subi	r30, 0x01	; 1
    3596:	f0 48       	sbci	r31, 0x80	; 128
    3598:	ee 0f       	add	r30, r30
    359a:	ff 1f       	adc	r31, r31
    359c:	ea 0f       	add	r30, r26
    359e:	fb 1f       	adc	r31, r27
    35a0:	80 81       	ld	r24, Z
    35a2:	91 81       	ldd	r25, Z+1	; 0x01
    35a4:	a0 e0       	ldi	r26, 0x00	; 0
    35a6:	b0 e0       	ldi	r27, 0x00	; 0
    35a8:	28 0f       	add	r18, r24
    35aa:	39 1f       	adc	r19, r25
    35ac:	4a 1f       	adc	r20, r26
    35ae:	5b 1f       	adc	r21, r27
    35b0:	32 97       	sbiw	r30, 0x02	; 2
    35b2:	61 50       	subi	r22, 0x01	; 1
    35b4:	70 40       	sbci	r23, 0x00	; 0
    35b6:	a1 f7       	brne	.-24     	; 0x35a0 <calculateCheckSum+0x26>
    35b8:	ca 01       	movw	r24, r20
    35ba:	aa 27       	eor	r26, r26
    35bc:	bb 27       	eor	r27, r27
    35be:	00 97       	sbiw	r24, 0x00	; 0
    35c0:	a1 05       	cpc	r26, r1
    35c2:	b1 05       	cpc	r27, r1
    35c4:	69 f0       	breq	.+26     	; 0x35e0 <calculateCheckSum+0x66>
    35c6:	40 70       	andi	r20, 0x00	; 0
    35c8:	50 70       	andi	r21, 0x00	; 0
    35ca:	28 0f       	add	r18, r24
    35cc:	39 1f       	adc	r19, r25
    35ce:	4a 1f       	adc	r20, r26
    35d0:	5b 1f       	adc	r21, r27
    35d2:	ca 01       	movw	r24, r20
    35d4:	aa 27       	eor	r26, r26
    35d6:	bb 27       	eor	r27, r27
    35d8:	00 97       	sbiw	r24, 0x00	; 0
    35da:	a1 05       	cpc	r26, r1
    35dc:	b1 05       	cpc	r27, r1
    35de:	99 f7       	brne	.-26     	; 0x35c6 <calculateCheckSum+0x4c>
    35e0:	20 95       	com	r18
    35e2:	30 95       	com	r19
    35e4:	c9 01       	movw	r24, r18
    35e6:	08 95       	ret
    35e8:	fc 01       	movw	r30, r24
    35ea:	e6 0f       	add	r30, r22
    35ec:	f7 1f       	adc	r31, r23
    35ee:	80 81       	ld	r24, Z
    35f0:	28 2f       	mov	r18, r24
    35f2:	30 e0       	ldi	r19, 0x00	; 0
    35f4:	40 e0       	ldi	r20, 0x00	; 0
    35f6:	50 e0       	ldi	r21, 0x00	; 0
    35f8:	c7 cf       	rjmp	.-114    	; 0x3588 <calculateCheckSum+0xe>

000035fa <stringLength>:
extern void serialEepromGetConfig(uint16_t * prescaler, uint8_t * parity, uint8_t * stop_bits, uint8_t * data_bits, uint8_t * BufferSizeLimit);

static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
    35fa:	fc 01       	movw	r30, r24
  uint8_t len = 0;
  while (*buf++)
    35fc:	80 81       	ld	r24, Z
    35fe:	88 23       	and	r24, r24
    3600:	41 f0       	breq	.+16     	; 0x3612 <stringLength+0x18>
    3602:	90 e0       	ldi	r25, 0x00	; 0
    len++;
    3604:	9f 5f       	subi	r25, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3606:	81 81       	ldd	r24, Z+1	; 0x01
    3608:	31 96       	adiw	r30, 0x01	; 1
    360a:	88 23       	and	r24, r24
    360c:	d9 f7       	brne	.-10     	; 0x3604 <stringLength+0xa>
    len++;
  return len;
}
    360e:	89 2f       	mov	r24, r25
    3610:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	fc cf       	rjmp	.-8      	; 0x360e <stringLength+0x14>

00003616 <rcfg_Reboot>:


uint8_t rcfg_Reboot(char * buf)
{
  // disable interrupts
  cli();
    3616:	f8 94       	cli

  // jump into bootloader
  asm volatile ("jmp 0x1e000");
    3618:	0c 94 00 f0 	jmp	0x1e000	; 0x1e000 <__data_load_end+0x177a8>

  return RCFG_SUCCESS;
}
    361c:	80 e0       	ldi	r24, 0x00	; 0
    361e:	08 95       	ret

00003620 <rcfg_Disable>:

uint8_t rcfg_Disable(char * buf)
{
  isDisabled = 1;
    3620:	81 e0       	ldi	r24, 0x01	; 1
    3622:	80 93 34 08 	sts	0x0834, r24
  return RCFG_SUCCESS;
}
    3626:	80 e0       	ldi	r24, 0x00	; 0
    3628:	08 95       	ret

0000362a <Config_is_Disabled>:

uint8_t Config_is_Disabled()
{
  return isDisabled;
}
    362a:	80 91 34 08 	lds	r24, 0x0834
    362e:	08 95       	ret

00003630 <rcfg_getBufferSizeLimit>:
		return RCFG_FAIL;

  	
}
uint8_t rcfg_getBufferSizeLimit(char * buf)
{
    3630:	ef 92       	push	r14
    3632:	ff 92       	push	r15
    3634:	0f 93       	push	r16
    3636:	1f 93       	push	r17
    3638:	df 93       	push	r29
    363a:	cf 93       	push	r28
    363c:	cd b7       	in	r28, 0x3d	; 61
    363e:	de b7       	in	r29, 0x3e	; 62
    3640:	2b 97       	sbiw	r28, 0x0b	; 11
    3642:	0f b6       	in	r0, 0x3f	; 63
    3644:	f8 94       	cli
    3646:	de bf       	out	0x3e, r29	; 62
    3648:	0f be       	out	0x3f, r0	; 63
    364a:	cd bf       	out	0x3d, r28	; 61

	uint8_t BufferSizeLimit=0;
    364c:	19 82       	std	Y+1, r1	; 0x01
	char sendbuf[10] = {0}; // clear buffer;
    364e:	82 e0       	ldi	r24, 0x02	; 2
    3650:	e8 2e       	mov	r14, r24
    3652:	f1 2c       	mov	r15, r1
    3654:	ec 0e       	add	r14, r28
    3656:	fd 1e       	adc	r15, r29
    3658:	8a e0       	ldi	r24, 0x0A	; 10
    365a:	f7 01       	movw	r30, r14
    365c:	11 92       	st	Z+, r1
    365e:	8a 95       	dec	r24
    3660:	e9 f7       	brne	.-6      	; 0x365c <rcfg_getBufferSizeLimit+0x2c>

	serialEepromGetConfig(NULL,NULL,NULL,NULL,&BufferSizeLimit);
    3662:	80 e0       	ldi	r24, 0x00	; 0
    3664:	90 e0       	ldi	r25, 0x00	; 0
    3666:	60 e0       	ldi	r22, 0x00	; 0
    3668:	70 e0       	ldi	r23, 0x00	; 0
    366a:	40 e0       	ldi	r20, 0x00	; 0
    366c:	50 e0       	ldi	r21, 0x00	; 0
    366e:	20 e0       	ldi	r18, 0x00	; 0
    3670:	30 e0       	ldi	r19, 0x00	; 0
    3672:	8e 01       	movw	r16, r28
    3674:	0f 5f       	subi	r16, 0xFF	; 255
    3676:	1f 4f       	sbci	r17, 0xFF	; 255
    3678:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>

	ultoa(BufferSizeLimit, sendbuf, 10);
    367c:	69 81       	ldd	r22, Y+1	; 0x01
    367e:	70 e0       	ldi	r23, 0x00	; 0
    3680:	80 e0       	ldi	r24, 0x00	; 0
    3682:	90 e0       	ldi	r25, 0x00	; 0
    3684:	a7 01       	movw	r20, r14
    3686:	2a e0       	ldi	r18, 0x0A	; 10
    3688:	30 e0       	ldi	r19, 0x00	; 0
    368a:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    368e:	8a 81       	ldd	r24, Y+2	; 0x02
    3690:	88 23       	and	r24, r24
    3692:	21 f1       	breq	.+72     	; 0x36dc <rcfg_getBufferSizeLimit+0xac>
    3694:	60 e0       	ldi	r22, 0x00	; 0
    3696:	fe 01       	movw	r30, r28
    3698:	33 96       	adiw	r30, 0x03	; 3
    len++;
    369a:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    369c:	81 91       	ld	r24, Z+
    369e:	88 23       	and	r24, r24
    36a0:	e1 f7       	brne	.-8      	; 0x369a <rcfg_getBufferSizeLimit+0x6a>
    36a2:	70 e0       	ldi	r23, 0x00	; 0
	serialEepromGetConfig(NULL,NULL,NULL,NULL,&BufferSizeLimit);

	ultoa(BufferSizeLimit, sendbuf, 10);
	

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    36a4:	c7 01       	movw	r24, r14
    36a6:	45 e8       	ldi	r20, 0x85	; 133
    36a8:	59 e0       	ldi	r21, 0x09	; 9
    36aa:	2b e8       	ldi	r18, 0x8B	; 139
    36ac:	39 e0       	ldi	r19, 0x09	; 9
    36ae:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString_com1("\r\nBufferSizeLimit: ");
    36b2:	8c ee       	ldi	r24, 0xEC	; 236
    36b4:	91 e0       	ldi	r25, 0x01	; 1
    36b6:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(sendbuf);
    36ba:	c7 01       	movw	r24, r14
    36bc:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

  return RCFG_SUCCESS;
}
    36c0:	80 e0       	ldi	r24, 0x00	; 0
    36c2:	2b 96       	adiw	r28, 0x0b	; 11
    36c4:	0f b6       	in	r0, 0x3f	; 63
    36c6:	f8 94       	cli
    36c8:	de bf       	out	0x3e, r29	; 62
    36ca:	0f be       	out	0x3f, r0	; 63
    36cc:	cd bf       	out	0x3d, r28	; 61
    36ce:	cf 91       	pop	r28
    36d0:	df 91       	pop	r29
    36d2:	1f 91       	pop	r17
    36d4:	0f 91       	pop	r16
    36d6:	ff 90       	pop	r15
    36d8:	ef 90       	pop	r14
    36da:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    36dc:	60 e0       	ldi	r22, 0x00	; 0
    36de:	70 e0       	ldi	r23, 0x00	; 0
    36e0:	e1 cf       	rjmp	.-62     	; 0x36a4 <rcfg_getBufferSizeLimit+0x74>

000036e2 <rcfg_getDataBits>:
		return RCFG_FAIL;

  	
}
uint8_t rcfg_getDataBits(char * buf)
{
    36e2:	ef 92       	push	r14
    36e4:	ff 92       	push	r15
    36e6:	0f 93       	push	r16
    36e8:	1f 93       	push	r17
    36ea:	df 93       	push	r29
    36ec:	cf 93       	push	r28
    36ee:	cd b7       	in	r28, 0x3d	; 61
    36f0:	de b7       	in	r29, 0x3e	; 62
    36f2:	2b 97       	sbiw	r28, 0x0b	; 11
    36f4:	0f b6       	in	r0, 0x3f	; 63
    36f6:	f8 94       	cli
    36f8:	de bf       	out	0x3e, r29	; 62
    36fa:	0f be       	out	0x3f, r0	; 63
    36fc:	cd bf       	out	0x3d, r28	; 61

	uint8_t data_bits=0;
    36fe:	19 82       	std	Y+1, r1	; 0x01
	char sendbuf[10] = {0}; // clear buffer;
    3700:	92 e0       	ldi	r25, 0x02	; 2
    3702:	e9 2e       	mov	r14, r25
    3704:	f1 2c       	mov	r15, r1
    3706:	ec 0e       	add	r14, r28
    3708:	fd 1e       	adc	r15, r29
    370a:	8a e0       	ldi	r24, 0x0A	; 10
    370c:	f7 01       	movw	r30, r14
    370e:	11 92       	st	Z+, r1
    3710:	8a 95       	dec	r24
    3712:	e9 f7       	brne	.-6      	; 0x370e <rcfg_getDataBits+0x2c>

	serialEepromGetConfig(NULL,NULL,NULL,&data_bits,NULL);
    3714:	80 e0       	ldi	r24, 0x00	; 0
    3716:	90 e0       	ldi	r25, 0x00	; 0
    3718:	60 e0       	ldi	r22, 0x00	; 0
    371a:	70 e0       	ldi	r23, 0x00	; 0
    371c:	40 e0       	ldi	r20, 0x00	; 0
    371e:	50 e0       	ldi	r21, 0x00	; 0
    3720:	9e 01       	movw	r18, r28
    3722:	2f 5f       	subi	r18, 0xFF	; 255
    3724:	3f 4f       	sbci	r19, 0xFF	; 255
    3726:	00 e0       	ldi	r16, 0x00	; 0
    3728:	10 e0       	ldi	r17, 0x00	; 0
    372a:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	data_bits+=5;
    372e:	69 81       	ldd	r22, Y+1	; 0x01
    3730:	6b 5f       	subi	r22, 0xFB	; 251
    3732:	69 83       	std	Y+1, r22	; 0x01
	ultoa(data_bits, sendbuf, 10);
    3734:	70 e0       	ldi	r23, 0x00	; 0
    3736:	80 e0       	ldi	r24, 0x00	; 0
    3738:	90 e0       	ldi	r25, 0x00	; 0
    373a:	a7 01       	movw	r20, r14
    373c:	2a e0       	ldi	r18, 0x0A	; 10
    373e:	30 e0       	ldi	r19, 0x00	; 0
    3740:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3744:	8a 81       	ldd	r24, Y+2	; 0x02
    3746:	88 23       	and	r24, r24
    3748:	21 f1       	breq	.+72     	; 0x3792 <rcfg_getDataBits+0xb0>
    374a:	60 e0       	ldi	r22, 0x00	; 0
    374c:	fe 01       	movw	r30, r28
    374e:	33 96       	adiw	r30, 0x03	; 3
    len++;
    3750:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3752:	81 91       	ld	r24, Z+
    3754:	88 23       	and	r24, r24
    3756:	e1 f7       	brne	.-8      	; 0x3750 <rcfg_getDataBits+0x6e>
    3758:	70 e0       	ldi	r23, 0x00	; 0
	serialEepromGetConfig(NULL,NULL,NULL,&data_bits,NULL);
	data_bits+=5;
	ultoa(data_bits, sendbuf, 10);
	

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    375a:	c7 01       	movw	r24, r14
    375c:	45 e8       	ldi	r20, 0x85	; 133
    375e:	59 e0       	ldi	r21, 0x09	; 9
    3760:	2b e8       	ldi	r18, 0x8B	; 139
    3762:	39 e0       	ldi	r19, 0x09	; 9
    3764:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString_com1("\r\nDataBits: ");
    3768:	80 e0       	ldi	r24, 0x00	; 0
    376a:	92 e0       	ldi	r25, 0x02	; 2
    376c:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(sendbuf);
    3770:	c7 01       	movw	r24, r14
    3772:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

  return RCFG_SUCCESS;
}
    3776:	80 e0       	ldi	r24, 0x00	; 0
    3778:	2b 96       	adiw	r28, 0x0b	; 11
    377a:	0f b6       	in	r0, 0x3f	; 63
    377c:	f8 94       	cli
    377e:	de bf       	out	0x3e, r29	; 62
    3780:	0f be       	out	0x3f, r0	; 63
    3782:	cd bf       	out	0x3d, r28	; 61
    3784:	cf 91       	pop	r28
    3786:	df 91       	pop	r29
    3788:	1f 91       	pop	r17
    378a:	0f 91       	pop	r16
    378c:	ff 90       	pop	r15
    378e:	ef 90       	pop	r14
    3790:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3792:	60 e0       	ldi	r22, 0x00	; 0
    3794:	70 e0       	ldi	r23, 0x00	; 0
    3796:	e1 cf       	rjmp	.-62     	; 0x375a <rcfg_getDataBits+0x78>

00003798 <rcfg_getStopBits>:
		return RCFG_FAIL;


}
uint8_t rcfg_getStopBits(char * buf)
{
    3798:	ef 92       	push	r14
    379a:	ff 92       	push	r15
    379c:	0f 93       	push	r16
    379e:	1f 93       	push	r17
    37a0:	df 93       	push	r29
    37a2:	cf 93       	push	r28
    37a4:	cd b7       	in	r28, 0x3d	; 61
    37a6:	de b7       	in	r29, 0x3e	; 62
    37a8:	2b 97       	sbiw	r28, 0x0b	; 11
    37aa:	0f b6       	in	r0, 0x3f	; 63
    37ac:	f8 94       	cli
    37ae:	de bf       	out	0x3e, r29	; 62
    37b0:	0f be       	out	0x3f, r0	; 63
    37b2:	cd bf       	out	0x3d, r28	; 61

	uint8_t stop_bits=0;
    37b4:	19 82       	std	Y+1, r1	; 0x01

	char sendbuf[10] = {0}; // clear buffer;
    37b6:	22 e0       	ldi	r18, 0x02	; 2
    37b8:	e2 2e       	mov	r14, r18
    37ba:	f1 2c       	mov	r15, r1
    37bc:	ec 0e       	add	r14, r28
    37be:	fd 1e       	adc	r15, r29
    37c0:	8a e0       	ldi	r24, 0x0A	; 10
    37c2:	f7 01       	movw	r30, r14
    37c4:	11 92       	st	Z+, r1
    37c6:	8a 95       	dec	r24
    37c8:	e9 f7       	brne	.-6      	; 0x37c4 <rcfg_getStopBits+0x2c>

	serialEepromGetConfig(NULL,NULL,&stop_bits,NULL,NULL);
    37ca:	80 e0       	ldi	r24, 0x00	; 0
    37cc:	90 e0       	ldi	r25, 0x00	; 0
    37ce:	60 e0       	ldi	r22, 0x00	; 0
    37d0:	70 e0       	ldi	r23, 0x00	; 0
    37d2:	ae 01       	movw	r20, r28
    37d4:	4f 5f       	subi	r20, 0xFF	; 255
    37d6:	5f 4f       	sbci	r21, 0xFF	; 255
    37d8:	20 e0       	ldi	r18, 0x00	; 0
    37da:	30 e0       	ldi	r19, 0x00	; 0
    37dc:	00 e0       	ldi	r16, 0x00	; 0
    37de:	10 e0       	ldi	r17, 0x00	; 0
    37e0:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	ultoa(stop_bits+1, sendbuf, 10);
    37e4:	69 81       	ldd	r22, Y+1	; 0x01
    37e6:	70 e0       	ldi	r23, 0x00	; 0
    37e8:	6f 5f       	subi	r22, 0xFF	; 255
    37ea:	7f 4f       	sbci	r23, 0xFF	; 255
    37ec:	88 27       	eor	r24, r24
    37ee:	77 fd       	sbrc	r23, 7
    37f0:	80 95       	com	r24
    37f2:	98 2f       	mov	r25, r24
    37f4:	a7 01       	movw	r20, r14
    37f6:	2a e0       	ldi	r18, 0x0A	; 10
    37f8:	30 e0       	ldi	r19, 0x00	; 0
    37fa:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    37fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3800:	88 23       	and	r24, r24
    3802:	21 f1       	breq	.+72     	; 0x384c <rcfg_getStopBits+0xb4>
    3804:	60 e0       	ldi	r22, 0x00	; 0
    3806:	fe 01       	movw	r30, r28
    3808:	33 96       	adiw	r30, 0x03	; 3
    len++;
    380a:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    380c:	81 91       	ld	r24, Z+
    380e:	88 23       	and	r24, r24
    3810:	e1 f7       	brne	.-8      	; 0x380a <rcfg_getStopBits+0x72>
    3812:	70 e0       	ldi	r23, 0x00	; 0
	char sendbuf[10] = {0}; // clear buffer;

	serialEepromGetConfig(NULL,NULL,&stop_bits,NULL,NULL);
	ultoa(stop_bits+1, sendbuf, 10);

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3814:	c7 01       	movw	r24, r14
    3816:	45 e8       	ldi	r20, 0x85	; 133
    3818:	59 e0       	ldi	r21, 0x09	; 9
    381a:	2b e8       	ldi	r18, 0x8B	; 139
    381c:	39 e0       	ldi	r19, 0x09	; 9
    381e:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString_com1("\r\nStopBits: ");
    3822:	8d e0       	ldi	r24, 0x0D	; 13
    3824:	92 e0       	ldi	r25, 0x02	; 2
    3826:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(sendbuf);
    382a:	c7 01       	movw	r24, r14
    382c:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

  return RCFG_SUCCESS;
}
    3830:	80 e0       	ldi	r24, 0x00	; 0
    3832:	2b 96       	adiw	r28, 0x0b	; 11
    3834:	0f b6       	in	r0, 0x3f	; 63
    3836:	f8 94       	cli
    3838:	de bf       	out	0x3e, r29	; 62
    383a:	0f be       	out	0x3f, r0	; 63
    383c:	cd bf       	out	0x3d, r28	; 61
    383e:	cf 91       	pop	r28
    3840:	df 91       	pop	r29
    3842:	1f 91       	pop	r17
    3844:	0f 91       	pop	r16
    3846:	ff 90       	pop	r15
    3848:	ef 90       	pop	r14
    384a:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    384c:	60 e0       	ldi	r22, 0x00	; 0
    384e:	70 e0       	ldi	r23, 0x00	; 0
    3850:	e1 cf       	rjmp	.-62     	; 0x3814 <rcfg_getStopBits+0x7c>

00003852 <rcfg_getParity>:
	}
	else
		return RCFG_FAIL;
}
uint8_t rcfg_getParity(char * buf)
{
    3852:	ef 92       	push	r14
    3854:	ff 92       	push	r15
    3856:	0f 93       	push	r16
    3858:	1f 93       	push	r17
    385a:	df 93       	push	r29
    385c:	cf 93       	push	r28
    385e:	cd b7       	in	r28, 0x3d	; 61
    3860:	de b7       	in	r29, 0x3e	; 62
    3862:	2b 97       	sbiw	r28, 0x0b	; 11
    3864:	0f b6       	in	r0, 0x3f	; 63
    3866:	f8 94       	cli
    3868:	de bf       	out	0x3e, r29	; 62
    386a:	0f be       	out	0x3f, r0	; 63
    386c:	cd bf       	out	0x3d, r28	; 61

	uint8_t parity=0;
    386e:	19 82       	std	Y+1, r1	; 0x01

	char sendbuf[10] = {0}; // clear buffer;
    3870:	32 e0       	ldi	r19, 0x02	; 2
    3872:	e3 2e       	mov	r14, r19
    3874:	f1 2c       	mov	r15, r1
    3876:	ec 0e       	add	r14, r28
    3878:	fd 1e       	adc	r15, r29
    387a:	8a e0       	ldi	r24, 0x0A	; 10
    387c:	f7 01       	movw	r30, r14
    387e:	11 92       	st	Z+, r1
    3880:	8a 95       	dec	r24
    3882:	e9 f7       	brne	.-6      	; 0x387e <rcfg_getParity+0x2c>

	serialEepromGetConfig(NULL,&parity,NULL,NULL,NULL);
    3884:	80 e0       	ldi	r24, 0x00	; 0
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	be 01       	movw	r22, r28
    388a:	6f 5f       	subi	r22, 0xFF	; 255
    388c:	7f 4f       	sbci	r23, 0xFF	; 255
    388e:	40 e0       	ldi	r20, 0x00	; 0
    3890:	50 e0       	ldi	r21, 0x00	; 0
    3892:	20 e0       	ldi	r18, 0x00	; 0
    3894:	30 e0       	ldi	r19, 0x00	; 0
    3896:	00 e0       	ldi	r16, 0x00	; 0
    3898:	10 e0       	ldi	r17, 0x00	; 0
    389a:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	ultoa(parity, sendbuf, 10);
    389e:	69 81       	ldd	r22, Y+1	; 0x01
    38a0:	70 e0       	ldi	r23, 0x00	; 0
    38a2:	80 e0       	ldi	r24, 0x00	; 0
    38a4:	90 e0       	ldi	r25, 0x00	; 0
    38a6:	a7 01       	movw	r20, r14
    38a8:	2a e0       	ldi	r18, 0x0A	; 10
    38aa:	30 e0       	ldi	r19, 0x00	; 0
    38ac:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    38b0:	8a 81       	ldd	r24, Y+2	; 0x02
    38b2:	88 23       	and	r24, r24
    38b4:	09 f4       	brne	.+2      	; 0x38b8 <rcfg_getParity+0x66>
    38b6:	40 c0       	rjmp	.+128    	; 0x3938 <rcfg_getParity+0xe6>
    38b8:	60 e0       	ldi	r22, 0x00	; 0
    38ba:	fe 01       	movw	r30, r28
    38bc:	33 96       	adiw	r30, 0x03	; 3
    len++;
    38be:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    38c0:	81 91       	ld	r24, Z+
    38c2:	88 23       	and	r24, r24
    38c4:	e1 f7       	brne	.-8      	; 0x38be <rcfg_getParity+0x6c>
    38c6:	70 e0       	ldi	r23, 0x00	; 0
	char sendbuf[10] = {0}; // clear buffer;

	serialEepromGetConfig(NULL,&parity,NULL,NULL,NULL);
	ultoa(parity, sendbuf, 10);

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    38c8:	c7 01       	movw	r24, r14
    38ca:	45 e8       	ldi	r20, 0x85	; 133
    38cc:	59 e0       	ldi	r21, 0x09	; 9
    38ce:	2b e8       	ldi	r18, 0x8B	; 139
    38d0:	39 e0       	ldi	r19, 0x09	; 9
    38d2:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString_com1("\r\n");
    38d6:	8a e1       	ldi	r24, 0x1A	; 26
    38d8:	92 e0       	ldi	r25, 0x02	; 2
    38da:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(sendbuf);
    38de:	c7 01       	movw	r24, r14
    38e0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	switch (parity)
    38e4:	89 81       	ldd	r24, Y+1	; 0x01
    38e6:	81 30       	cpi	r24, 0x01	; 1
    38e8:	11 f1       	breq	.+68     	; 0x392e <rcfg_getParity+0xdc>
    38ea:	81 30       	cpi	r24, 0x01	; 1
    38ec:	90 f4       	brcc	.+36     	; 0x3912 <rcfg_getParity+0xc0>
	{
		case 0:
			putString_com1("\r\nParity Disabled: ");
    38ee:	8d e1       	ldi	r24, 0x1D	; 29
    38f0:	92 e0       	ldi	r25, 0x02	; 2
    38f2:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
		break;
	}
	

  return RCFG_SUCCESS;
}
    38f6:	80 e0       	ldi	r24, 0x00	; 0
    38f8:	2b 96       	adiw	r28, 0x0b	; 11
    38fa:	0f b6       	in	r0, 0x3f	; 63
    38fc:	f8 94       	cli
    38fe:	de bf       	out	0x3e, r29	; 62
    3900:	0f be       	out	0x3f, r0	; 63
    3902:	cd bf       	out	0x3d, r28	; 61
    3904:	cf 91       	pop	r28
    3906:	df 91       	pop	r29
    3908:	1f 91       	pop	r17
    390a:	0f 91       	pop	r16
    390c:	ff 90       	pop	r15
    390e:	ef 90       	pop	r14
    3910:	08 95       	ret
	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);

	putString_com1("\r\n");
	putString_com1(sendbuf);

	switch (parity)
    3912:	82 30       	cpi	r24, 0x02	; 2
    3914:	39 f0       	breq	.+14     	; 0x3924 <rcfg_getParity+0xd2>
    3916:	83 30       	cpi	r24, 0x03	; 3
    3918:	71 f7       	brne	.-36     	; 0x38f6 <rcfg_getParity+0xa4>
		break;
		case 2:
			putString_com1("\r\nParity Enabled, Even Parity: ");
		break;
		case 3:
			putString_com1("\r\nParity Enabled, Odd Parity: ");
    391a:	85 e6       	ldi	r24, 0x65	; 101
    391c:	92 e0       	ldi	r25, 0x02	; 2
    391e:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    3922:	e9 cf       	rjmp	.-46     	; 0x38f6 <rcfg_getParity+0xa4>
		break;
		case 1:
			putString_com1("\r\nParity Reserved: ");
		break;
		case 2:
			putString_com1("\r\nParity Enabled, Even Parity: ");
    3924:	85 e4       	ldi	r24, 0x45	; 69
    3926:	92 e0       	ldi	r25, 0x02	; 2
    3928:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    392c:	e4 cf       	rjmp	.-56     	; 0x38f6 <rcfg_getParity+0xa4>
	{
		case 0:
			putString_com1("\r\nParity Disabled: ");
		break;
		case 1:
			putString_com1("\r\nParity Reserved: ");
    392e:	81 e3       	ldi	r24, 0x31	; 49
    3930:	92 e0       	ldi	r25, 0x02	; 2
    3932:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    3936:	df cf       	rjmp	.-66     	; 0x38f6 <rcfg_getParity+0xa4>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3938:	60 e0       	ldi	r22, 0x00	; 0
    393a:	70 e0       	ldi	r23, 0x00	; 0
    393c:	c5 cf       	rjmp	.-118    	; 0x38c8 <rcfg_getParity+0x76>

0000393e <rcfg_getBaud>:
	serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
	return RCFG_SUCCESS;
}

uint8_t rcfg_getBaud(char * buf)
{
    393e:	0f 93       	push	r16
    3940:	1f 93       	push	r17
    3942:	df 93       	push	r29
    3944:	cf 93       	push	r28
    3946:	cd b7       	in	r28, 0x3d	; 61
    3948:	de b7       	in	r29, 0x3e	; 62
    394a:	2c 97       	sbiw	r28, 0x0c	; 12
    394c:	0f b6       	in	r0, 0x3f	; 63
    394e:	f8 94       	cli
    3950:	de bf       	out	0x3e, r29	; 62
    3952:	0f be       	out	0x3f, r0	; 63
    3954:	cd bf       	out	0x3d, r28	; 61
  uint16_t prescaler;
  serialEepromGetConfig(&prescaler,NULL,NULL,NULL,NULL);
    3956:	ce 01       	movw	r24, r28
    3958:	01 96       	adiw	r24, 0x01	; 1
    395a:	60 e0       	ldi	r22, 0x00	; 0
    395c:	70 e0       	ldi	r23, 0x00	; 0
    395e:	40 e0       	ldi	r20, 0x00	; 0
    3960:	50 e0       	ldi	r21, 0x00	; 0
    3962:	20 e0       	ldi	r18, 0x00	; 0
    3964:	30 e0       	ldi	r19, 0x00	; 0
    3966:	00 e0       	ldi	r16, 0x00	; 0
    3968:	10 e0       	ldi	r17, 0x00	; 0
    396a:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>

  char sendbuf[10] = {0}; // clear buffer;
    396e:	8e 01       	movw	r16, r28
    3970:	0d 5f       	subi	r16, 0xFD	; 253
    3972:	1f 4f       	sbci	r17, 0xFF	; 255
    3974:	8a e0       	ldi	r24, 0x0A	; 10
    3976:	f8 01       	movw	r30, r16
    3978:	11 92       	st	Z+, r1
    397a:	8a 95       	dec	r24
    397c:	e9 f7       	brne	.-6      	; 0x3978 <rcfg_getBaud+0x3a>
// BAUD = CLOCK_FREQUENCY / (16 * (UBBR + 1))
  //      = (CLOCK_FREQUENCY / 16) / (UBBR + 1)

  uint32_t baud=F_CPU  / (16 * (prescaler + 1));

  ultoa(baud, sendbuf, 10);
    397e:	29 81       	ldd	r18, Y+1	; 0x01
    3980:	3a 81       	ldd	r19, Y+2	; 0x02
    3982:	2f 5f       	subi	r18, 0xFF	; 255
    3984:	3f 4f       	sbci	r19, 0xFF	; 255
    3986:	22 95       	swap	r18
    3988:	32 95       	swap	r19
    398a:	30 7f       	andi	r19, 0xF0	; 240
    398c:	32 27       	eor	r19, r18
    398e:	20 7f       	andi	r18, 0xF0	; 240
    3990:	32 27       	eor	r19, r18
    3992:	40 e0       	ldi	r20, 0x00	; 0
    3994:	50 e0       	ldi	r21, 0x00	; 0
    3996:	60 e0       	ldi	r22, 0x00	; 0
    3998:	70 e0       	ldi	r23, 0x00	; 0
    399a:	81 ee       	ldi	r24, 0xE1	; 225
    399c:	90 e0       	ldi	r25, 0x00	; 0
    399e:	0e 94 23 30 	call	0x6046	; 0x6046 <__udivmodsi4>
    39a2:	ca 01       	movw	r24, r20
    39a4:	b9 01       	movw	r22, r18
    39a6:	a8 01       	movw	r20, r16
    39a8:	2a e0       	ldi	r18, 0x0A	; 10
    39aa:	30 e0       	ldi	r19, 0x00	; 0
    39ac:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    39b0:	8b 81       	ldd	r24, Y+3	; 0x03
    39b2:	88 23       	and	r24, r24
    39b4:	11 f1       	breq	.+68     	; 0x39fa <rcfg_getBaud+0xbc>
    39b6:	60 e0       	ldi	r22, 0x00	; 0
    39b8:	fe 01       	movw	r30, r28
    39ba:	34 96       	adiw	r30, 0x04	; 4
    len++;
    39bc:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    39be:	81 91       	ld	r24, Z+
    39c0:	88 23       	and	r24, r24
    39c2:	e1 f7       	brne	.-8      	; 0x39bc <rcfg_getBaud+0x7e>
    39c4:	70 e0       	ldi	r23, 0x00	; 0

  uint32_t baud=F_CPU  / (16 * (prescaler + 1));

  ultoa(baud, sendbuf, 10);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    39c6:	c8 01       	movw	r24, r16
    39c8:	45 e8       	ldi	r20, 0x85	; 133
    39ca:	59 e0       	ldi	r21, 0x09	; 9
    39cc:	2b e8       	ldi	r18, 0x8B	; 139
    39ce:	39 e0       	ldi	r19, 0x09	; 9
    39d0:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nBaudrate for Data: ");
    39d4:	84 e8       	ldi	r24, 0x84	; 132
    39d6:	92 e0       	ldi	r25, 0x02	; 2
    39d8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    39dc:	c8 01       	movw	r24, r16
    39de:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    39e2:	80 e0       	ldi	r24, 0x00	; 0
    39e4:	2c 96       	adiw	r28, 0x0c	; 12
    39e6:	0f b6       	in	r0, 0x3f	; 63
    39e8:	f8 94       	cli
    39ea:	de bf       	out	0x3e, r29	; 62
    39ec:	0f be       	out	0x3f, r0	; 63
    39ee:	cd bf       	out	0x3d, r28	; 61
    39f0:	cf 91       	pop	r28
    39f2:	df 91       	pop	r29
    39f4:	1f 91       	pop	r17
    39f6:	0f 91       	pop	r16
    39f8:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    39fa:	60 e0       	ldi	r22, 0x00	; 0
    39fc:	70 e0       	ldi	r23, 0x00	; 0
    39fe:	e3 cf       	rjmp	.-58     	; 0x39c6 <rcfg_getBaud+0x88>

00003a00 <rcfg_setBufferSizeLimit>:
}



uint8_t rcfg_setBufferSizeLimit(char * buf)
{
    3a00:	0f 93       	push	r16
    3a02:	1f 93       	push	r17
    3a04:	df 93       	push	r29
    3a06:	cf 93       	push	r28
    3a08:	cd b7       	in	r28, 0x3d	; 61
    3a0a:	de b7       	in	r29, 0x3e	; 62
    3a0c:	28 97       	sbiw	r28, 0x08	; 8
    3a0e:	0f b6       	in	r0, 0x3f	; 63
    3a10:	f8 94       	cli
    3a12:	de bf       	out	0x3e, r29	; 62
    3a14:	0f be       	out	0x3f, r0	; 63
    3a16:	cd bf       	out	0x3d, r28	; 61
    3a18:	98 87       	std	Y+8, r25	; 0x08
    3a1a:	8f 83       	std	Y+7, r24	; 0x07
	uint16_t prescaler=0;
    3a1c:	1e 82       	std	Y+6, r1	; 0x06
    3a1e:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t parity=0;
    3a20:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    3a22:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    3a24:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t BufferSizeLimit=0;
    3a26:	1c 82       	std	Y+4, r1	; 0x04

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
    3a28:	ce 01       	movw	r24, r28
    3a2a:	05 96       	adiw	r24, 0x05	; 5
    3a2c:	be 01       	movw	r22, r28
    3a2e:	6f 5f       	subi	r22, 0xFF	; 255
    3a30:	7f 4f       	sbci	r23, 0xFF	; 255
    3a32:	ae 01       	movw	r20, r28
    3a34:	4e 5f       	subi	r20, 0xFE	; 254
    3a36:	5f 4f       	sbci	r21, 0xFF	; 255
    3a38:	9e 01       	movw	r18, r28
    3a3a:	2d 5f       	subi	r18, 0xFD	; 253
    3a3c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a3e:	8e 01       	movw	r16, r28
    3a40:	0c 5f       	subi	r16, 0xFC	; 252
    3a42:	1f 4f       	sbci	r17, 0xFF	; 255
    3a44:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	BufferSizeLimit = rcfg_parseUInt(&buf);
    3a48:	ce 01       	movw	r24, r28
    3a4a:	07 96       	adiw	r24, 0x07	; 7
    3a4c:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <rcfg_parseUInt>
    3a50:	06 2f       	mov	r16, r22
	if((1<=BufferSizeLimit)&&(BufferSizeLimit<=150))
    3a52:	86 2f       	mov	r24, r22
    3a54:	81 50       	subi	r24, 0x01	; 1
    3a56:	86 39       	cpi	r24, 0x96	; 150
    3a58:	60 f0       	brcs	.+24     	; 0x3a72 <rcfg_setBufferSizeLimit+0x72>
    3a5a:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
		return RCFG_FAIL;

  	
}
    3a5c:	28 96       	adiw	r28, 0x08	; 8
    3a5e:	0f b6       	in	r0, 0x3f	; 63
    3a60:	f8 94       	cli
    3a62:	de bf       	out	0x3e, r29	; 62
    3a64:	0f be       	out	0x3f, r0	; 63
    3a66:	cd bf       	out	0x3d, r28	; 61
    3a68:	cf 91       	pop	r28
    3a6a:	df 91       	pop	r29
    3a6c:	1f 91       	pop	r17
    3a6e:	0f 91       	pop	r16
    3a70:	08 95       	ret

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
	BufferSizeLimit = rcfg_parseUInt(&buf);
	if((1<=BufferSizeLimit)&&(BufferSizeLimit<=150))
	{
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
    3a72:	8d 81       	ldd	r24, Y+5	; 0x05
    3a74:	9e 81       	ldd	r25, Y+6	; 0x06
    3a76:	69 81       	ldd	r22, Y+1	; 0x01
    3a78:	4a 81       	ldd	r20, Y+2	; 0x02
    3a7a:	2b 81       	ldd	r18, Y+3	; 0x03
	uint8_t stop_bits=0;
	uint8_t data_bits=0;
	uint8_t BufferSizeLimit=0;

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
	BufferSizeLimit = rcfg_parseUInt(&buf);
    3a7c:	0c 83       	std	Y+4, r16	; 0x04
	if((1<=BufferSizeLimit)&&(BufferSizeLimit<=150))
	{
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
    3a7e:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <serialEepromSetConfig>
    3a82:	80 e0       	ldi	r24, 0x00	; 0
    3a84:	eb cf       	rjmp	.-42     	; 0x3a5c <rcfg_setBufferSizeLimit+0x5c>

00003a86 <rcfg_setDataBits>:
	putString_com1(sendbuf);

  return RCFG_SUCCESS;
}
uint8_t rcfg_setDataBits(char * buf)
{
    3a86:	0f 93       	push	r16
    3a88:	1f 93       	push	r17
    3a8a:	df 93       	push	r29
    3a8c:	cf 93       	push	r28
    3a8e:	cd b7       	in	r28, 0x3d	; 61
    3a90:	de b7       	in	r29, 0x3e	; 62
    3a92:	28 97       	sbiw	r28, 0x08	; 8
    3a94:	0f b6       	in	r0, 0x3f	; 63
    3a96:	f8 94       	cli
    3a98:	de bf       	out	0x3e, r29	; 62
    3a9a:	0f be       	out	0x3f, r0	; 63
    3a9c:	cd bf       	out	0x3d, r28	; 61
    3a9e:	98 87       	std	Y+8, r25	; 0x08
    3aa0:	8f 83       	std	Y+7, r24	; 0x07
	uint16_t prescaler=0;
    3aa2:	1e 82       	std	Y+6, r1	; 0x06
    3aa4:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t parity=0;
    3aa6:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    3aa8:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    3aaa:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t BufferSizeLimit=0;
    3aac:	1c 82       	std	Y+4, r1	; 0x04

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
    3aae:	ce 01       	movw	r24, r28
    3ab0:	05 96       	adiw	r24, 0x05	; 5
    3ab2:	be 01       	movw	r22, r28
    3ab4:	6f 5f       	subi	r22, 0xFF	; 255
    3ab6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ab8:	ae 01       	movw	r20, r28
    3aba:	4e 5f       	subi	r20, 0xFE	; 254
    3abc:	5f 4f       	sbci	r21, 0xFF	; 255
    3abe:	9e 01       	movw	r18, r28
    3ac0:	2d 5f       	subi	r18, 0xFD	; 253
    3ac2:	3f 4f       	sbci	r19, 0xFF	; 255
    3ac4:	8e 01       	movw	r16, r28
    3ac6:	0c 5f       	subi	r16, 0xFC	; 252
    3ac8:	1f 4f       	sbci	r17, 0xFF	; 255
    3aca:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	data_bits = rcfg_parseUInt(&buf);
    3ace:	ce 01       	movw	r24, r28
    3ad0:	07 96       	adiw	r24, 0x07	; 7
    3ad2:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <rcfg_parseUInt>
    3ad6:	26 2f       	mov	r18, r22
	if((5<=data_bits)&&(data_bits<=8))
    3ad8:	25 50       	subi	r18, 0x05	; 5
    3ada:	24 30       	cpi	r18, 0x04	; 4
    3adc:	60 f0       	brcs	.+24     	; 0x3af6 <rcfg_setDataBits+0x70>
    3ade:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
		return RCFG_FAIL;

  	
}
    3ae0:	28 96       	adiw	r28, 0x08	; 8
    3ae2:	0f b6       	in	r0, 0x3f	; 63
    3ae4:	f8 94       	cli
    3ae6:	de bf       	out	0x3e, r29	; 62
    3ae8:	0f be       	out	0x3f, r0	; 63
    3aea:	cd bf       	out	0x3d, r28	; 61
    3aec:	cf 91       	pop	r28
    3aee:	df 91       	pop	r29
    3af0:	1f 91       	pop	r17
    3af2:	0f 91       	pop	r16
    3af4:	08 95       	ret

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
	data_bits = rcfg_parseUInt(&buf);
	if((5<=data_bits)&&(data_bits<=8))
	{
		data_bits-=5;
    3af6:	2b 83       	std	Y+3, r18	; 0x03
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
    3af8:	8d 81       	ldd	r24, Y+5	; 0x05
    3afa:	9e 81       	ldd	r25, Y+6	; 0x06
    3afc:	69 81       	ldd	r22, Y+1	; 0x01
    3afe:	4a 81       	ldd	r20, Y+2	; 0x02
    3b00:	0c 81       	ldd	r16, Y+4	; 0x04
    3b02:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <serialEepromSetConfig>
    3b06:	80 e0       	ldi	r24, 0x00	; 0
    3b08:	eb cf       	rjmp	.-42     	; 0x3ae0 <rcfg_setDataBits+0x5a>

00003b0a <rcfg_setStopBits>:
	

  return RCFG_SUCCESS;
}
uint8_t rcfg_setStopBits(char * buf)
{
    3b0a:	0f 93       	push	r16
    3b0c:	1f 93       	push	r17
    3b0e:	df 93       	push	r29
    3b10:	cf 93       	push	r28
    3b12:	cd b7       	in	r28, 0x3d	; 61
    3b14:	de b7       	in	r29, 0x3e	; 62
    3b16:	28 97       	sbiw	r28, 0x08	; 8
    3b18:	0f b6       	in	r0, 0x3f	; 63
    3b1a:	f8 94       	cli
    3b1c:	de bf       	out	0x3e, r29	; 62
    3b1e:	0f be       	out	0x3f, r0	; 63
    3b20:	cd bf       	out	0x3d, r28	; 61
    3b22:	98 87       	std	Y+8, r25	; 0x08
    3b24:	8f 83       	std	Y+7, r24	; 0x07
	uint16_t prescaler=0;
    3b26:	1e 82       	std	Y+6, r1	; 0x06
    3b28:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t parity=0;
    3b2a:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    3b2c:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    3b2e:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t BufferSizeLimit=0;
    3b30:	1c 82       	std	Y+4, r1	; 0x04

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
    3b32:	ce 01       	movw	r24, r28
    3b34:	05 96       	adiw	r24, 0x05	; 5
    3b36:	be 01       	movw	r22, r28
    3b38:	6f 5f       	subi	r22, 0xFF	; 255
    3b3a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b3c:	ae 01       	movw	r20, r28
    3b3e:	4e 5f       	subi	r20, 0xFE	; 254
    3b40:	5f 4f       	sbci	r21, 0xFF	; 255
    3b42:	9e 01       	movw	r18, r28
    3b44:	2d 5f       	subi	r18, 0xFD	; 253
    3b46:	3f 4f       	sbci	r19, 0xFF	; 255
    3b48:	8e 01       	movw	r16, r28
    3b4a:	0c 5f       	subi	r16, 0xFC	; 252
    3b4c:	1f 4f       	sbci	r17, 0xFF	; 255
    3b4e:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	stop_bits = rcfg_parseUInt(&buf);
    3b52:	ce 01       	movw	r24, r28
    3b54:	07 96       	adiw	r24, 0x07	; 7
    3b56:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <rcfg_parseUInt>
    3b5a:	46 2f       	mov	r20, r22

	if((stop_bits==1)||(stop_bits==2))
    3b5c:	41 50       	subi	r20, 0x01	; 1
    3b5e:	42 30       	cpi	r20, 0x02	; 2
    3b60:	60 f0       	brcs	.+24     	; 0x3b7a <rcfg_setStopBits+0x70>
    3b62:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
		return RCFG_FAIL;


}
    3b64:	28 96       	adiw	r28, 0x08	; 8
    3b66:	0f b6       	in	r0, 0x3f	; 63
    3b68:	f8 94       	cli
    3b6a:	de bf       	out	0x3e, r29	; 62
    3b6c:	0f be       	out	0x3f, r0	; 63
    3b6e:	cd bf       	out	0x3d, r28	; 61
    3b70:	cf 91       	pop	r28
    3b72:	df 91       	pop	r29
    3b74:	1f 91       	pop	r17
    3b76:	0f 91       	pop	r16
    3b78:	08 95       	ret
	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
	stop_bits = rcfg_parseUInt(&buf);

	if((stop_bits==1)||(stop_bits==2))
	{
		stop_bits-=1;
    3b7a:	4a 83       	std	Y+2, r20	; 0x02
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
    3b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    3b7e:	9e 81       	ldd	r25, Y+6	; 0x06
    3b80:	69 81       	ldd	r22, Y+1	; 0x01
    3b82:	2b 81       	ldd	r18, Y+3	; 0x03
    3b84:	0c 81       	ldd	r16, Y+4	; 0x04
    3b86:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <serialEepromSetConfig>
    3b8a:	80 e0       	ldi	r24, 0x00	; 0
    3b8c:	eb cf       	rjmp	.-42     	; 0x3b64 <rcfg_setStopBits+0x5a>

00003b8e <rcfg_setParity>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setParity(char * buf)
{
    3b8e:	0f 93       	push	r16
    3b90:	1f 93       	push	r17
    3b92:	df 93       	push	r29
    3b94:	cf 93       	push	r28
    3b96:	cd b7       	in	r28, 0x3d	; 61
    3b98:	de b7       	in	r29, 0x3e	; 62
    3b9a:	28 97       	sbiw	r28, 0x08	; 8
    3b9c:	0f b6       	in	r0, 0x3f	; 63
    3b9e:	f8 94       	cli
    3ba0:	de bf       	out	0x3e, r29	; 62
    3ba2:	0f be       	out	0x3f, r0	; 63
    3ba4:	cd bf       	out	0x3d, r28	; 61
    3ba6:	98 87       	std	Y+8, r25	; 0x08
    3ba8:	8f 83       	std	Y+7, r24	; 0x07
	uint16_t prescaler=0;
    3baa:	1e 82       	std	Y+6, r1	; 0x06
    3bac:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t parity=0;
    3bae:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    3bb0:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    3bb2:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t BufferSizeLimit=0;
    3bb4:	1c 82       	std	Y+4, r1	; 0x04

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
    3bb6:	ce 01       	movw	r24, r28
    3bb8:	05 96       	adiw	r24, 0x05	; 5
    3bba:	be 01       	movw	r22, r28
    3bbc:	6f 5f       	subi	r22, 0xFF	; 255
    3bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    3bc0:	ae 01       	movw	r20, r28
    3bc2:	4e 5f       	subi	r20, 0xFE	; 254
    3bc4:	5f 4f       	sbci	r21, 0xFF	; 255
    3bc6:	9e 01       	movw	r18, r28
    3bc8:	2d 5f       	subi	r18, 0xFD	; 253
    3bca:	3f 4f       	sbci	r19, 0xFF	; 255
    3bcc:	8e 01       	movw	r16, r28
    3bce:	0c 5f       	subi	r16, 0xFC	; 252
    3bd0:	1f 4f       	sbci	r17, 0xFF	; 255
    3bd2:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	parity = rcfg_parseUInt(&buf);
    3bd6:	ce 01       	movw	r24, r28
    3bd8:	07 96       	adiw	r24, 0x07	; 7
    3bda:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <rcfg_parseUInt>

	if(parity<=3)
    3bde:	64 30       	cpi	r22, 0x04	; 4
    3be0:	60 f0       	brcs	.+24     	; 0x3bfa <rcfg_setParity+0x6c>
    3be2:	81 e0       	ldi	r24, 0x01	; 1
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
		return RCFG_SUCCESS;
	}
	else
		return RCFG_FAIL;
}
    3be4:	28 96       	adiw	r28, 0x08	; 8
    3be6:	0f b6       	in	r0, 0x3f	; 63
    3be8:	f8 94       	cli
    3bea:	de bf       	out	0x3e, r29	; 62
    3bec:	0f be       	out	0x3f, r0	; 63
    3bee:	cd bf       	out	0x3d, r28	; 61
    3bf0:	cf 91       	pop	r28
    3bf2:	df 91       	pop	r29
    3bf4:	1f 91       	pop	r17
    3bf6:	0f 91       	pop	r16
    3bf8:	08 95       	ret
	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
	parity = rcfg_parseUInt(&buf);

	if(parity<=3)
	{
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
    3bfa:	8d 81       	ldd	r24, Y+5	; 0x05
    3bfc:	9e 81       	ldd	r25, Y+6	; 0x06
    3bfe:	4a 81       	ldd	r20, Y+2	; 0x02
    3c00:	2b 81       	ldd	r18, Y+3	; 0x03
    3c02:	0c 81       	ldd	r16, Y+4	; 0x04
	uint8_t stop_bits=0;
	uint8_t data_bits=0;
	uint8_t BufferSizeLimit=0;

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
	parity = rcfg_parseUInt(&buf);
    3c04:	69 83       	std	Y+1, r22	; 0x01

	if(parity<=3)
	{
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
    3c06:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <serialEepromSetConfig>
    3c0a:	80 e0       	ldi	r24, 0x00	; 0
    3c0c:	eb cf       	rjmp	.-42     	; 0x3be4 <rcfg_setParity+0x56>

00003c0e <rcfg_setBaud>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setBaud(char * buf)
{
    3c0e:	0f 93       	push	r16
    3c10:	1f 93       	push	r17
    3c12:	df 93       	push	r29
    3c14:	cf 93       	push	r28
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	28 97       	sbiw	r28, 0x08	; 8
    3c1c:	0f b6       	in	r0, 0x3f	; 63
    3c1e:	f8 94       	cli
    3c20:	de bf       	out	0x3e, r29	; 62
    3c22:	0f be       	out	0x3f, r0	; 63
    3c24:	cd bf       	out	0x3d, r28	; 61
    3c26:	98 87       	std	Y+8, r25	; 0x08
    3c28:	8f 83       	std	Y+7, r24	; 0x07
	uint16_t prescaler=0;
    3c2a:	1e 82       	std	Y+6, r1	; 0x06
    3c2c:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t parity=0;
    3c2e:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    3c30:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    3c32:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t BufferSizeLimit=0;
    3c34:	1c 82       	std	Y+4, r1	; 0x04

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
    3c36:	ce 01       	movw	r24, r28
    3c38:	05 96       	adiw	r24, 0x05	; 5
    3c3a:	be 01       	movw	r22, r28
    3c3c:	6f 5f       	subi	r22, 0xFF	; 255
    3c3e:	7f 4f       	sbci	r23, 0xFF	; 255
    3c40:	ae 01       	movw	r20, r28
    3c42:	4e 5f       	subi	r20, 0xFE	; 254
    3c44:	5f 4f       	sbci	r21, 0xFF	; 255
    3c46:	9e 01       	movw	r18, r28
    3c48:	2d 5f       	subi	r18, 0xFD	; 253
    3c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    3c4c:	8e 01       	movw	r16, r28
    3c4e:	0c 5f       	subi	r16, 0xFC	; 252
    3c50:	1f 4f       	sbci	r17, 0xFF	; 255
    3c52:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	uint32_t baud = rcfg_parseUInt(&buf);
    3c56:	ce 01       	movw	r24, r28
    3c58:	07 96       	adiw	r24, 0x07	; 7
    3c5a:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <rcfg_parseUInt>
    3c5e:	9b 01       	movw	r18, r22
    3c60:	ac 01       	movw	r20, r24

	prescaler=F_CPU / (16 * baud) -1;
    3c62:	22 0f       	add	r18, r18
    3c64:	33 1f       	adc	r19, r19
    3c66:	44 1f       	adc	r20, r20
    3c68:	55 1f       	adc	r21, r21
    3c6a:	22 0f       	add	r18, r18
    3c6c:	33 1f       	adc	r19, r19
    3c6e:	44 1f       	adc	r20, r20
    3c70:	55 1f       	adc	r21, r21
    3c72:	22 0f       	add	r18, r18
    3c74:	33 1f       	adc	r19, r19
    3c76:	44 1f       	adc	r20, r20
    3c78:	55 1f       	adc	r21, r21
    3c7a:	22 0f       	add	r18, r18
    3c7c:	33 1f       	adc	r19, r19
    3c7e:	44 1f       	adc	r20, r20
    3c80:	55 1f       	adc	r21, r21
    3c82:	60 e0       	ldi	r22, 0x00	; 0
    3c84:	70 e0       	ldi	r23, 0x00	; 0
    3c86:	81 ee       	ldi	r24, 0xE1	; 225
    3c88:	90 e0       	ldi	r25, 0x00	; 0
    3c8a:	0e 94 23 30 	call	0x6046	; 0x6046 <__udivmodsi4>
    3c8e:	da 01       	movw	r26, r20
    3c90:	c9 01       	movw	r24, r18
    3c92:	01 97       	sbiw	r24, 0x01	; 1
    3c94:	9e 83       	std	Y+6, r25	; 0x06
    3c96:	8d 83       	std	Y+5, r24	; 0x05
	serialEepromSetConfig( prescaler,parity,stop_bits,data_bits,BufferSizeLimit );
    3c98:	69 81       	ldd	r22, Y+1	; 0x01
    3c9a:	4a 81       	ldd	r20, Y+2	; 0x02
    3c9c:	2b 81       	ldd	r18, Y+3	; 0x03
    3c9e:	0c 81       	ldd	r16, Y+4	; 0x04
    3ca0:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <serialEepromSetConfig>
	return RCFG_SUCCESS;
}
    3ca4:	80 e0       	ldi	r24, 0x00	; 0
    3ca6:	28 96       	adiw	r28, 0x08	; 8
    3ca8:	0f b6       	in	r0, 0x3f	; 63
    3caa:	f8 94       	cli
    3cac:	de bf       	out	0x3e, r29	; 62
    3cae:	0f be       	out	0x3f, r0	; 63
    3cb0:	cd bf       	out	0x3d, r28	; 61
    3cb2:	cf 91       	pop	r28
    3cb4:	df 91       	pop	r29
    3cb6:	1f 91       	pop	r17
    3cb8:	0f 91       	pop	r16
    3cba:	08 95       	ret

00003cbc <rcfg_setDPORT_Config>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDPORT_Config(char *buf) {
    3cbc:	cf 92       	push	r12
    3cbe:	df 92       	push	r13
    3cc0:	ef 92       	push	r14
    3cc2:	ff 92       	push	r15
    3cc4:	0f 93       	push	r16
    3cc6:	1f 93       	push	r17
    3cc8:	df 93       	push	r29
    3cca:	cf 93       	push	r28
    3ccc:	00 d0       	rcall	.+0      	; 0x3cce <rcfg_setDPORT_Config+0x12>
    3cce:	cd b7       	in	r28, 0x3d	; 61
    3cd0:	de b7       	in	r29, 0x3e	; 62
    3cd2:	9a 83       	std	Y+2, r25	; 0x02
    3cd4:	89 83       	std	Y+1, r24	; 0x01
  portAddress_t dport = (portAddress_t)rcfg_parseUInt(&buf);
    3cd6:	ce 01       	movw	r24, r28
    3cd8:	01 96       	adiw	r24, 0x01	; 1
    3cda:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <rcfg_parseUInt>
    3cde:	6b 01       	movw	r12, r22
    3ce0:	7c 01       	movw	r14, r24

  configEepromSetConfig(0, 0, 0, dport, 0);
    3ce2:	60 e0       	ldi	r22, 0x00	; 0
    3ce4:	70 e0       	ldi	r23, 0x00	; 0
    3ce6:	80 e0       	ldi	r24, 0x00	; 0
    3ce8:	90 e0       	ldi	r25, 0x00	; 0
    3cea:	40 e0       	ldi	r20, 0x00	; 0
    3cec:	50 e0       	ldi	r21, 0x00	; 0
    3cee:	00 e0       	ldi	r16, 0x00	; 0
    3cf0:	10 e0       	ldi	r17, 0x00	; 0
    3cf2:	20 e0       	ldi	r18, 0x00	; 0
    3cf4:	30 e0       	ldi	r19, 0x00	; 0
    3cf6:	76 01       	movw	r14, r12
    3cf8:	cc 24       	eor	r12, r12
    3cfa:	dd 24       	eor	r13, r13
    3cfc:	0e 94 b2 2b 	call	0x5764	; 0x5764 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3d00:	80 e0       	ldi	r24, 0x00	; 0
    3d02:	0f 90       	pop	r0
    3d04:	0f 90       	pop	r0
    3d06:	cf 91       	pop	r28
    3d08:	df 91       	pop	r29
    3d0a:	1f 91       	pop	r17
    3d0c:	0f 91       	pop	r16
    3d0e:	ff 90       	pop	r15
    3d10:	ef 90       	pop	r14
    3d12:	df 90       	pop	r13
    3d14:	cf 90       	pop	r12
    3d16:	08 95       	ret

00003d18 <rcfg_setDPORT_Data>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDPORT_Data(char *buf) {
    3d18:	cf 92       	push	r12
    3d1a:	df 92       	push	r13
    3d1c:	ef 92       	push	r14
    3d1e:	ff 92       	push	r15
    3d20:	0f 93       	push	r16
    3d22:	1f 93       	push	r17
    3d24:	df 93       	push	r29
    3d26:	cf 93       	push	r28
    3d28:	00 d0       	rcall	.+0      	; 0x3d2a <rcfg_setDPORT_Data+0x12>
    3d2a:	cd b7       	in	r28, 0x3d	; 61
    3d2c:	de b7       	in	r29, 0x3e	; 62
    3d2e:	9a 83       	std	Y+2, r25	; 0x02
    3d30:	89 83       	std	Y+1, r24	; 0x01
  portAddress_t dport = (portAddress_t)rcfg_parseUInt(&buf);
    3d32:	ce 01       	movw	r24, r28
    3d34:	01 96       	adiw	r24, 0x01	; 1
    3d36:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <rcfg_parseUInt>
    3d3a:	9b 01       	movw	r18, r22
    3d3c:	ac 01       	movw	r20, r24

  configEepromSetConfig(0, dport, 0, 0, 0);
    3d3e:	60 e0       	ldi	r22, 0x00	; 0
    3d40:	70 e0       	ldi	r23, 0x00	; 0
    3d42:	80 e0       	ldi	r24, 0x00	; 0
    3d44:	90 e0       	ldi	r25, 0x00	; 0
    3d46:	a9 01       	movw	r20, r18
    3d48:	00 e0       	ldi	r16, 0x00	; 0
    3d4a:	10 e0       	ldi	r17, 0x00	; 0
    3d4c:	20 e0       	ldi	r18, 0x00	; 0
    3d4e:	30 e0       	ldi	r19, 0x00	; 0
    3d50:	ee 24       	eor	r14, r14
    3d52:	ff 24       	eor	r15, r15
    3d54:	cc 24       	eor	r12, r12
    3d56:	dd 24       	eor	r13, r13
    3d58:	0e 94 b2 2b 	call	0x5764	; 0x5764 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3d5c:	80 e0       	ldi	r24, 0x00	; 0
    3d5e:	0f 90       	pop	r0
    3d60:	0f 90       	pop	r0
    3d62:	cf 91       	pop	r28
    3d64:	df 91       	pop	r29
    3d66:	1f 91       	pop	r17
    3d68:	0f 91       	pop	r16
    3d6a:	ff 90       	pop	r15
    3d6c:	ef 90       	pop	r14
    3d6e:	df 90       	pop	r13
    3d70:	cf 90       	pop	r12
    3d72:	08 95       	ret

00003d74 <rcfg_getDPORT_Config>:
  configEepromSetConfig(0, 0, dip, 0, 0);

  return RCFG_SUCCESS;
}

uint8_t rcfg_getDPORT_Config(char *buf) {
    3d74:	0f 93       	push	r16
    3d76:	1f 93       	push	r17
    3d78:	df 93       	push	r29
    3d7a:	cf 93       	push	r28
    3d7c:	cd b7       	in	r28, 0x3d	; 61
    3d7e:	de b7       	in	r29, 0x3e	; 62
    3d80:	27 97       	sbiw	r28, 0x07	; 7
    3d82:	0f b6       	in	r0, 0x3f	; 63
    3d84:	f8 94       	cli
    3d86:	de bf       	out	0x3e, r29	; 62
    3d88:	0f be       	out	0x3f, r0	; 63
    3d8a:	cd bf       	out	0x3d, r28	; 61
  portAddress_t dport;
  configEepromGetConfig(NULL, NULL, NULL, &dport, NULL);
    3d8c:	80 e0       	ldi	r24, 0x00	; 0
    3d8e:	90 e0       	ldi	r25, 0x00	; 0
    3d90:	60 e0       	ldi	r22, 0x00	; 0
    3d92:	70 e0       	ldi	r23, 0x00	; 0
    3d94:	40 e0       	ldi	r20, 0x00	; 0
    3d96:	50 e0       	ldi	r21, 0x00	; 0
    3d98:	9e 01       	movw	r18, r28
    3d9a:	2f 5f       	subi	r18, 0xFF	; 255
    3d9c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d9e:	00 e0       	ldi	r16, 0x00	; 0
    3da0:	10 e0       	ldi	r17, 0x00	; 0
    3da2:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <configEepromGetConfig>

  char sendbuf[5] = {0}; // clear buffer;
    3da6:	8e 01       	movw	r16, r28
    3da8:	0d 5f       	subi	r16, 0xFD	; 253
    3daa:	1f 4f       	sbci	r17, 0xFF	; 255
    3dac:	85 e0       	ldi	r24, 0x05	; 5
    3dae:	f8 01       	movw	r30, r16
    3db0:	11 92       	st	Z+, r1
    3db2:	8a 95       	dec	r24
    3db4:	e9 f7       	brne	.-6      	; 0x3db0 <rcfg_getDPORT_Config+0x3c>
  ultoa(dport, sendbuf, 10);
    3db6:	69 81       	ldd	r22, Y+1	; 0x01
    3db8:	7a 81       	ldd	r23, Y+2	; 0x02
    3dba:	80 e0       	ldi	r24, 0x00	; 0
    3dbc:	90 e0       	ldi	r25, 0x00	; 0
    3dbe:	a8 01       	movw	r20, r16
    3dc0:	2a e0       	ldi	r18, 0x0A	; 10
    3dc2:	30 e0       	ldi	r19, 0x00	; 0
    3dc4:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    3dca:	88 23       	and	r24, r24
    3dcc:	11 f1       	breq	.+68     	; 0x3e12 <rcfg_getDPORT_Config+0x9e>
    3dce:	60 e0       	ldi	r22, 0x00	; 0
    3dd0:	fe 01       	movw	r30, r28
    3dd2:	34 96       	adiw	r30, 0x04	; 4
    len++;
    3dd4:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3dd6:	81 91       	ld	r24, Z+
    3dd8:	88 23       	and	r24, r24
    3dda:	e1 f7       	brne	.-8      	; 0x3dd4 <rcfg_getDPORT_Config+0x60>
    3ddc:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(NULL, NULL, NULL, &dport, NULL);

  char sendbuf[5] = {0}; // clear buffer;
  ultoa(dport, sendbuf, 10);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3dde:	c8 01       	movw	r24, r16
    3de0:	45 e8       	ldi	r20, 0x85	; 133
    3de2:	59 e0       	ldi	r21, 0x09	; 9
    3de4:	2b e8       	ldi	r18, 0x8B	; 139
    3de6:	39 e0       	ldi	r19, 0x09	; 9
    3de8:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
  
  putString_com1("\r\nDestination Port for Config-Channel: ");
    3dec:	8a e9       	ldi	r24, 0x9A	; 154
    3dee:	92 e0       	ldi	r25, 0x02	; 2
    3df0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    3df4:	c8 01       	movw	r24, r16
    3df6:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    3dfa:	80 e0       	ldi	r24, 0x00	; 0
    3dfc:	27 96       	adiw	r28, 0x07	; 7
    3dfe:	0f b6       	in	r0, 0x3f	; 63
    3e00:	f8 94       	cli
    3e02:	de bf       	out	0x3e, r29	; 62
    3e04:	0f be       	out	0x3f, r0	; 63
    3e06:	cd bf       	out	0x3d, r28	; 61
    3e08:	cf 91       	pop	r28
    3e0a:	df 91       	pop	r29
    3e0c:	1f 91       	pop	r17
    3e0e:	0f 91       	pop	r16
    3e10:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3e12:	60 e0       	ldi	r22, 0x00	; 0
    3e14:	70 e0       	ldi	r23, 0x00	; 0
    3e16:	e3 cf       	rjmp	.-58     	; 0x3dde <rcfg_getDPORT_Config+0x6a>

00003e18 <rcfg_getDPORT_Data>:
  configEepromSetConfig(dip,0,0,0,0);

  return RCFG_SUCCESS;
}

uint8_t rcfg_getDPORT_Data(char *buf) {
    3e18:	0f 93       	push	r16
    3e1a:	1f 93       	push	r17
    3e1c:	df 93       	push	r29
    3e1e:	cf 93       	push	r28
    3e20:	cd b7       	in	r28, 0x3d	; 61
    3e22:	de b7       	in	r29, 0x3e	; 62
    3e24:	27 97       	sbiw	r28, 0x07	; 7
    3e26:	0f b6       	in	r0, 0x3f	; 63
    3e28:	f8 94       	cli
    3e2a:	de bf       	out	0x3e, r29	; 62
    3e2c:	0f be       	out	0x3f, r0	; 63
    3e2e:	cd bf       	out	0x3d, r28	; 61
  portAddress_t dport;
  configEepromGetConfig(NULL, &dport, NULL, NULL, NULL);
    3e30:	80 e0       	ldi	r24, 0x00	; 0
    3e32:	90 e0       	ldi	r25, 0x00	; 0
    3e34:	be 01       	movw	r22, r28
    3e36:	6f 5f       	subi	r22, 0xFF	; 255
    3e38:	7f 4f       	sbci	r23, 0xFF	; 255
    3e3a:	40 e0       	ldi	r20, 0x00	; 0
    3e3c:	50 e0       	ldi	r21, 0x00	; 0
    3e3e:	20 e0       	ldi	r18, 0x00	; 0
    3e40:	30 e0       	ldi	r19, 0x00	; 0
    3e42:	00 e0       	ldi	r16, 0x00	; 0
    3e44:	10 e0       	ldi	r17, 0x00	; 0
    3e46:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <configEepromGetConfig>

  char sendbuf[5] = {0}; // clear buffer;
    3e4a:	8e 01       	movw	r16, r28
    3e4c:	0d 5f       	subi	r16, 0xFD	; 253
    3e4e:	1f 4f       	sbci	r17, 0xFF	; 255
    3e50:	85 e0       	ldi	r24, 0x05	; 5
    3e52:	f8 01       	movw	r30, r16
    3e54:	11 92       	st	Z+, r1
    3e56:	8a 95       	dec	r24
    3e58:	e9 f7       	brne	.-6      	; 0x3e54 <rcfg_getDPORT_Data+0x3c>
  ultoa(dport, sendbuf, 10);
    3e5a:	69 81       	ldd	r22, Y+1	; 0x01
    3e5c:	7a 81       	ldd	r23, Y+2	; 0x02
    3e5e:	80 e0       	ldi	r24, 0x00	; 0
    3e60:	90 e0       	ldi	r25, 0x00	; 0
    3e62:	a8 01       	movw	r20, r16
    3e64:	2a e0       	ldi	r18, 0x0A	; 10
    3e66:	30 e0       	ldi	r19, 0x00	; 0
    3e68:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e6e:	88 23       	and	r24, r24
    3e70:	11 f1       	breq	.+68     	; 0x3eb6 <rcfg_getDPORT_Data+0x9e>
    3e72:	60 e0       	ldi	r22, 0x00	; 0
    3e74:	fe 01       	movw	r30, r28
    3e76:	34 96       	adiw	r30, 0x04	; 4
    len++;
    3e78:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3e7a:	81 91       	ld	r24, Z+
    3e7c:	88 23       	and	r24, r24
    3e7e:	e1 f7       	brne	.-8      	; 0x3e78 <rcfg_getDPORT_Data+0x60>
    3e80:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(NULL, &dport, NULL, NULL, NULL);

  char sendbuf[5] = {0}; // clear buffer;
  ultoa(dport, sendbuf, 10);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3e82:	c8 01       	movw	r24, r16
    3e84:	45 e8       	ldi	r20, 0x85	; 133
    3e86:	59 e0       	ldi	r21, 0x09	; 9
    3e88:	2b e8       	ldi	r18, 0x8B	; 139
    3e8a:	39 e0       	ldi	r19, 0x09	; 9
    3e8c:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nDestination Port for Data-Channel: ");
    3e90:	82 ec       	ldi	r24, 0xC2	; 194
    3e92:	92 e0       	ldi	r25, 0x02	; 2
    3e94:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    3e98:	c8 01       	movw	r24, r16
    3e9a:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    3e9e:	80 e0       	ldi	r24, 0x00	; 0
    3ea0:	27 96       	adiw	r28, 0x07	; 7
    3ea2:	0f b6       	in	r0, 0x3f	; 63
    3ea4:	f8 94       	cli
    3ea6:	de bf       	out	0x3e, r29	; 62
    3ea8:	0f be       	out	0x3f, r0	; 63
    3eaa:	cd bf       	out	0x3d, r28	; 61
    3eac:	cf 91       	pop	r28
    3eae:	df 91       	pop	r29
    3eb0:	1f 91       	pop	r17
    3eb2:	0f 91       	pop	r16
    3eb4:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3eb6:	60 e0       	ldi	r22, 0x00	; 0
    3eb8:	70 e0       	ldi	r23, 0x00	; 0
    3eba:	e3 cf       	rjmp	.-58     	; 0x3e82 <rcfg_getDPORT_Data+0x6a>

00003ebc <rcfg_setDIP_Config>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDIP_Config(char *buf) {
    3ebc:	cf 92       	push	r12
    3ebe:	df 92       	push	r13
    3ec0:	ef 92       	push	r14
    3ec2:	ff 92       	push	r15
    3ec4:	0f 93       	push	r16
    3ec6:	1f 93       	push	r17
    3ec8:	df 93       	push	r29
    3eca:	cf 93       	push	r28
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <rcfg_setDIP_Config+0x12>
    3ece:	cd b7       	in	r28, 0x3d	; 61
    3ed0:	de b7       	in	r29, 0x3e	; 62
    3ed2:	9a 83       	std	Y+2, r25	; 0x02
    3ed4:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t dip = rcfg_parseIP(&buf);
    3ed6:	ce 01       	movw	r24, r28
    3ed8:	01 96       	adiw	r24, 0x01	; 1
    3eda:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>
    3ede:	8b 01       	movw	r16, r22
    3ee0:	9c 01       	movw	r18, r24

  configEepromSetConfig(0, 0, dip, 0, 0);
    3ee2:	60 e0       	ldi	r22, 0x00	; 0
    3ee4:	70 e0       	ldi	r23, 0x00	; 0
    3ee6:	80 e0       	ldi	r24, 0x00	; 0
    3ee8:	90 e0       	ldi	r25, 0x00	; 0
    3eea:	40 e0       	ldi	r20, 0x00	; 0
    3eec:	50 e0       	ldi	r21, 0x00	; 0
    3eee:	ee 24       	eor	r14, r14
    3ef0:	ff 24       	eor	r15, r15
    3ef2:	cc 24       	eor	r12, r12
    3ef4:	dd 24       	eor	r13, r13
    3ef6:	0e 94 b2 2b 	call	0x5764	; 0x5764 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3efa:	80 e0       	ldi	r24, 0x00	; 0
    3efc:	0f 90       	pop	r0
    3efe:	0f 90       	pop	r0
    3f00:	cf 91       	pop	r28
    3f02:	df 91       	pop	r29
    3f04:	1f 91       	pop	r17
    3f06:	0f 91       	pop	r16
    3f08:	ff 90       	pop	r15
    3f0a:	ef 90       	pop	r14
    3f0c:	df 90       	pop	r13
    3f0e:	cf 90       	pop	r12
    3f10:	08 95       	ret

00003f12 <rcfg_setDIP_Data>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDIP_Data(char *buf) {
    3f12:	cf 92       	push	r12
    3f14:	df 92       	push	r13
    3f16:	ef 92       	push	r14
    3f18:	ff 92       	push	r15
    3f1a:	0f 93       	push	r16
    3f1c:	1f 93       	push	r17
    3f1e:	df 93       	push	r29
    3f20:	cf 93       	push	r28
    3f22:	00 d0       	rcall	.+0      	; 0x3f24 <rcfg_setDIP_Data+0x12>
    3f24:	cd b7       	in	r28, 0x3d	; 61
    3f26:	de b7       	in	r29, 0x3e	; 62
    3f28:	9a 83       	std	Y+2, r25	; 0x02
    3f2a:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t dip = rcfg_parseIP(&buf);
    3f2c:	ce 01       	movw	r24, r28
    3f2e:	01 96       	adiw	r24, 0x01	; 1
    3f30:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>

  configEepromSetConfig(dip,0,0,0,0);
    3f34:	40 e0       	ldi	r20, 0x00	; 0
    3f36:	50 e0       	ldi	r21, 0x00	; 0
    3f38:	00 e0       	ldi	r16, 0x00	; 0
    3f3a:	10 e0       	ldi	r17, 0x00	; 0
    3f3c:	20 e0       	ldi	r18, 0x00	; 0
    3f3e:	30 e0       	ldi	r19, 0x00	; 0
    3f40:	ee 24       	eor	r14, r14
    3f42:	ff 24       	eor	r15, r15
    3f44:	cc 24       	eor	r12, r12
    3f46:	dd 24       	eor	r13, r13
    3f48:	0e 94 b2 2b 	call	0x5764	; 0x5764 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3f4c:	80 e0       	ldi	r24, 0x00	; 0
    3f4e:	0f 90       	pop	r0
    3f50:	0f 90       	pop	r0
    3f52:	cf 91       	pop	r28
    3f54:	df 91       	pop	r29
    3f56:	1f 91       	pop	r17
    3f58:	0f 91       	pop	r16
    3f5a:	ff 90       	pop	r15
    3f5c:	ef 90       	pop	r14
    3f5e:	df 90       	pop	r13
    3f60:	cf 90       	pop	r12
    3f62:	08 95       	ret

00003f64 <rcfg_setNet>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setNet(char * buf)
{
    3f64:	6f 92       	push	r6
    3f66:	7f 92       	push	r7
    3f68:	8f 92       	push	r8
    3f6a:	9f 92       	push	r9
    3f6c:	af 92       	push	r10
    3f6e:	bf 92       	push	r11
    3f70:	cf 92       	push	r12
    3f72:	df 92       	push	r13
    3f74:	ef 92       	push	r14
    3f76:	ff 92       	push	r15
    3f78:	0f 93       	push	r16
    3f7a:	1f 93       	push	r17
    3f7c:	df 93       	push	r29
    3f7e:	cf 93       	push	r28
    3f80:	00 d0       	rcall	.+0      	; 0x3f82 <rcfg_setNet+0x1e>
    3f82:	cd b7       	in	r28, 0x3d	; 61
    3f84:	de b7       	in	r29, 0x3e	; 62
    3f86:	9a 83       	std	Y+2, r25	; 0x02
    3f88:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t ip = rcfg_parseIP(&buf);
    3f8a:	8e 01       	movw	r16, r28
    3f8c:	0f 5f       	subi	r16, 0xFF	; 255
    3f8e:	1f 4f       	sbci	r17, 0xFF	; 255
    3f90:	c8 01       	movw	r24, r16
    3f92:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>
    3f96:	3b 01       	movw	r6, r22
    3f98:	4c 01       	movw	r8, r24
  while(*buf == ' ') // skip whitespace(s)
    3f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9e:	80 81       	ld	r24, Z
    3fa0:	80 32       	cpi	r24, 0x20	; 32
    3fa2:	31 f4       	brne	.+12     	; 0x3fb0 <rcfg_setNet+0x4c>
    buf++;
    3fa4:	31 96       	adiw	r30, 0x01	; 1
    3fa6:	fa 83       	std	Y+2, r31	; 0x02
    3fa8:	e9 83       	std	Y+1, r30	; 0x01
}

uint8_t rcfg_setNet(char * buf)
{
  ipAddress_t ip = rcfg_parseIP(&buf);
  while(*buf == ' ') // skip whitespace(s)
    3faa:	80 81       	ld	r24, Z
    3fac:	80 32       	cpi	r24, 0x20	; 32
    3fae:	d1 f3       	breq	.-12     	; 0x3fa4 <rcfg_setNet+0x40>
    buf++;
  ipAddress_t nm = rcfg_parseIP(&buf);
    3fb0:	c8 01       	movw	r24, r16
    3fb2:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>
    3fb6:	5b 01       	movw	r10, r22
    3fb8:	6c 01       	movw	r12, r24
  while(*buf == ' ')
    3fba:	e9 81       	ldd	r30, Y+1	; 0x01
    3fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    3fbe:	80 81       	ld	r24, Z
    3fc0:	80 32       	cpi	r24, 0x20	; 32
    3fc2:	31 f4       	brne	.+12     	; 0x3fd0 <rcfg_setNet+0x6c>
    buf++;
    3fc4:	31 96       	adiw	r30, 0x01	; 1
    3fc6:	fa 83       	std	Y+2, r31	; 0x02
    3fc8:	e9 83       	std	Y+1, r30	; 0x01
{
  ipAddress_t ip = rcfg_parseIP(&buf);
  while(*buf == ' ') // skip whitespace(s)
    buf++;
  ipAddress_t nm = rcfg_parseIP(&buf);
  while(*buf == ' ')
    3fca:	80 81       	ld	r24, Z
    3fcc:	80 32       	cpi	r24, 0x20	; 32
    3fce:	d1 f3       	breq	.-12     	; 0x3fc4 <rcfg_setNet+0x60>
    buf++;
  ipAddress_t gw = rcfg_parseIP(&buf);
    3fd0:	c8 01       	movw	r24, r16
    3fd2:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>
    3fd6:	7b 01       	movw	r14, r22
    3fd8:	8c 01       	movw	r16, r24

  ipEepromSetConfig(ip,nm,gw);
    3fda:	c4 01       	movw	r24, r8
    3fdc:	b3 01       	movw	r22, r6
    3fde:	a6 01       	movw	r20, r12
    3fe0:	95 01       	movw	r18, r10
    3fe2:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    3fe6:	80 e0       	ldi	r24, 0x00	; 0
    3fe8:	0f 90       	pop	r0
    3fea:	0f 90       	pop	r0
    3fec:	cf 91       	pop	r28
    3fee:	df 91       	pop	r29
    3ff0:	1f 91       	pop	r17
    3ff2:	0f 91       	pop	r16
    3ff4:	ff 90       	pop	r15
    3ff6:	ef 90       	pop	r14
    3ff8:	df 90       	pop	r13
    3ffa:	cf 90       	pop	r12
    3ffc:	bf 90       	pop	r11
    3ffe:	af 90       	pop	r10
    4000:	9f 90       	pop	r9
    4002:	8f 90       	pop	r8
    4004:	7f 90       	pop	r7
    4006:	6f 90       	pop	r6
    4008:	08 95       	ret

0000400a <rcfg_setGW>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setGW(char * buf)
{
    400a:	ef 92       	push	r14
    400c:	ff 92       	push	r15
    400e:	0f 93       	push	r16
    4010:	1f 93       	push	r17
    4012:	df 93       	push	r29
    4014:	cf 93       	push	r28
    4016:	00 d0       	rcall	.+0      	; 0x4018 <rcfg_setGW+0xe>
    4018:	cd b7       	in	r28, 0x3d	; 61
    401a:	de b7       	in	r29, 0x3e	; 62
    401c:	9a 83       	std	Y+2, r25	; 0x02
    401e:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t gw = rcfg_parseIP(&buf);
    4020:	ce 01       	movw	r24, r28
    4022:	01 96       	adiw	r24, 0x01	; 1
    4024:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>
    4028:	7b 01       	movw	r14, r22
    402a:	8c 01       	movw	r16, r24

  ipEepromSetConfig(0,0,gw);
    402c:	60 e0       	ldi	r22, 0x00	; 0
    402e:	70 e0       	ldi	r23, 0x00	; 0
    4030:	80 e0       	ldi	r24, 0x00	; 0
    4032:	90 e0       	ldi	r25, 0x00	; 0
    4034:	20 e0       	ldi	r18, 0x00	; 0
    4036:	30 e0       	ldi	r19, 0x00	; 0
    4038:	40 e0       	ldi	r20, 0x00	; 0
    403a:	50 e0       	ldi	r21, 0x00	; 0
    403c:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    4040:	80 e0       	ldi	r24, 0x00	; 0
    4042:	0f 90       	pop	r0
    4044:	0f 90       	pop	r0
    4046:	cf 91       	pop	r28
    4048:	df 91       	pop	r29
    404a:	1f 91       	pop	r17
    404c:	0f 91       	pop	r16
    404e:	ff 90       	pop	r15
    4050:	ef 90       	pop	r14
    4052:	08 95       	ret

00004054 <rcfg_setNM>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setNM(char * buf)
{
    4054:	ef 92       	push	r14
    4056:	ff 92       	push	r15
    4058:	0f 93       	push	r16
    405a:	1f 93       	push	r17
    405c:	df 93       	push	r29
    405e:	cf 93       	push	r28
    4060:	00 d0       	rcall	.+0      	; 0x4062 <rcfg_setNM+0xe>
    4062:	cd b7       	in	r28, 0x3d	; 61
    4064:	de b7       	in	r29, 0x3e	; 62
    4066:	9a 83       	std	Y+2, r25	; 0x02
    4068:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t nm = rcfg_parseIP(&buf);
    406a:	ce 01       	movw	r24, r28
    406c:	01 96       	adiw	r24, 0x01	; 1
    406e:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>
    4072:	9b 01       	movw	r18, r22
    4074:	ac 01       	movw	r20, r24

  ipEepromSetConfig(0,nm,0);
    4076:	60 e0       	ldi	r22, 0x00	; 0
    4078:	70 e0       	ldi	r23, 0x00	; 0
    407a:	80 e0       	ldi	r24, 0x00	; 0
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	ee 24       	eor	r14, r14
    4080:	ff 24       	eor	r15, r15
    4082:	87 01       	movw	r16, r14
    4084:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    4088:	80 e0       	ldi	r24, 0x00	; 0
    408a:	0f 90       	pop	r0
    408c:	0f 90       	pop	r0
    408e:	cf 91       	pop	r28
    4090:	df 91       	pop	r29
    4092:	1f 91       	pop	r17
    4094:	0f 91       	pop	r16
    4096:	ff 90       	pop	r15
    4098:	ef 90       	pop	r14
    409a:	08 95       	ret

0000409c <rcfg_setIP>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setIP(char * buf)
{
    409c:	ef 92       	push	r14
    409e:	ff 92       	push	r15
    40a0:	0f 93       	push	r16
    40a2:	1f 93       	push	r17
    40a4:	df 93       	push	r29
    40a6:	cf 93       	push	r28
    40a8:	00 d0       	rcall	.+0      	; 0x40aa <rcfg_setIP+0xe>
    40aa:	cd b7       	in	r28, 0x3d	; 61
    40ac:	de b7       	in	r29, 0x3e	; 62
    40ae:	9a 83       	std	Y+2, r25	; 0x02
    40b0:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t ip = rcfg_parseIP(&buf);
    40b2:	ce 01       	movw	r24, r28
    40b4:	01 96       	adiw	r24, 0x01	; 1
    40b6:	0e 94 1d 28 	call	0x503a	; 0x503a <rcfg_parseIP>

  ipEepromSetConfig(ip,0,0);
    40ba:	20 e0       	ldi	r18, 0x00	; 0
    40bc:	30 e0       	ldi	r19, 0x00	; 0
    40be:	40 e0       	ldi	r20, 0x00	; 0
    40c0:	50 e0       	ldi	r21, 0x00	; 0
    40c2:	ee 24       	eor	r14, r14
    40c4:	ff 24       	eor	r15, r15
    40c6:	87 01       	movw	r16, r14
    40c8:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    40cc:	80 e0       	ldi	r24, 0x00	; 0
    40ce:	0f 90       	pop	r0
    40d0:	0f 90       	pop	r0
    40d2:	cf 91       	pop	r28
    40d4:	df 91       	pop	r29
    40d6:	1f 91       	pop	r17
    40d8:	0f 91       	pop	r16
    40da:	ff 90       	pop	r15
    40dc:	ef 90       	pop	r14
    40de:	08 95       	ret

000040e0 <rcfg_getMAC>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getMAC(char * buf)
{
    40e0:	bf 92       	push	r11
    40e2:	cf 92       	push	r12
    40e4:	df 92       	push	r13
    40e6:	ef 92       	push	r14
    40e8:	ff 92       	push	r15
    40ea:	0f 93       	push	r16
    40ec:	1f 93       	push	r17
    40ee:	df 93       	push	r29
    40f0:	cf 93       	push	r28
    40f2:	cd b7       	in	r28, 0x3d	; 61
    40f4:	de b7       	in	r29, 0x3e	; 62
    40f6:	67 97       	sbiw	r28, 0x17	; 23
    40f8:	0f b6       	in	r0, 0x3f	; 63
    40fa:	f8 94       	cli
    40fc:	de bf       	out	0x3e, r29	; 62
    40fe:	0f be       	out	0x3f, r0	; 63
    4100:	cd bf       	out	0x3d, r28	; 61
  uint8_t mac[6];


  char sendbuf[17] = {0}; // clear buffer
    4102:	f7 e0       	ldi	r31, 0x07	; 7
    4104:	cf 2e       	mov	r12, r31
    4106:	d1 2c       	mov	r13, r1
    4108:	cc 0e       	add	r12, r28
    410a:	dd 1e       	adc	r13, r29
    410c:	81 e1       	ldi	r24, 0x11	; 17
    410e:	f6 01       	movw	r30, r12
    4110:	11 92       	st	Z+, r1
    4112:	8a 95       	dec	r24
    4114:	e9 f7       	brne	.-6      	; 0x4110 <rcfg_getMAC+0x30>
    4116:	7e 01       	movw	r14, r28
    4118:	08 94       	sec
    411a:	e1 1c       	adc	r14, r1
    411c:	f1 1c       	adc	r15, r1
    411e:	86 01       	movw	r16, r12
    utoa(mac[i], bufpos, 16);
    while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    *bufpos++ = ':';
    4120:	ea e3       	ldi	r30, 0x3A	; 58
    4122:	be 2e       	mov	r11, r30

  char sendbuf[17] = {0}; // clear buffer
  char * bufpos = sendbuf;
  uint8_t i;
  for (i=0; i<=5; i++) {
    utoa(mac[i], bufpos, 16);
    4124:	f7 01       	movw	r30, r14
    4126:	80 81       	ld	r24, Z
    4128:	90 e0       	ldi	r25, 0x00	; 0
    412a:	b8 01       	movw	r22, r16
    412c:	40 e1       	ldi	r20, 0x10	; 16
    412e:	50 e0       	ldi	r21, 0x00	; 0
    4130:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4134:	02 c0       	rjmp	.+4      	; 0x413a <rcfg_getMAC+0x5a>
    while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    4136:	0f 5f       	subi	r16, 0xFF	; 255
    4138:	1f 4f       	sbci	r17, 0xFF	; 255
  char sendbuf[17] = {0}; // clear buffer
  char * bufpos = sendbuf;
  uint8_t i;
  for (i=0; i<=5; i++) {
    utoa(mac[i], bufpos, 16);
    while ( (*bufpos >= '0' && *bufpos <= '9') ||
    413a:	f8 01       	movw	r30, r16
    413c:	90 81       	ld	r25, Z
    413e:	89 2f       	mov	r24, r25
    4140:	80 53       	subi	r24, 0x30	; 48
    4142:	8a 30       	cpi	r24, 0x0A	; 10
    4144:	c0 f3       	brcs	.-16     	; 0x4136 <rcfg_getMAC+0x56>
    4146:	81 53       	subi	r24, 0x31	; 49
    4148:	86 30       	cpi	r24, 0x06	; 6
    414a:	a8 f3       	brcs	.-22     	; 0x4136 <rcfg_getMAC+0x56>
    414c:	91 54       	subi	r25, 0x41	; 65
    414e:	96 30       	cpi	r25, 0x06	; 6
    4150:	90 f3       	brcs	.-28     	; 0x4136 <rcfg_getMAC+0x56>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    *bufpos++ = ':';
    4152:	b1 92       	st	Z+, r11
    4154:	08 94       	sec
    4156:	e1 1c       	adc	r14, r1
    4158:	f1 1c       	adc	r15, r1


  char sendbuf[17] = {0}; // clear buffer
  char * bufpos = sendbuf;
  uint8_t i;
  for (i=0; i<=5; i++) {
    415a:	ec 14       	cp	r14, r12
    415c:	fd 04       	cpc	r15, r13
    415e:	11 f0       	breq	.+4      	; 0x4164 <rcfg_getMAC+0x84>
    4160:	8f 01       	movw	r16, r30
    4162:	e0 cf       	rjmp	.-64     	; 0x4124 <rcfg_getMAC+0x44>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    *bufpos++ = ':';
  }
  *(--bufpos) = '\0';
    4164:	f8 01       	movw	r30, r16
    4166:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4168:	8f 81       	ldd	r24, Y+7	; 0x07
    416a:	88 23       	and	r24, r24
    416c:	39 f1       	breq	.+78     	; 0x41bc <rcfg_getMAC+0xdc>
    416e:	60 e0       	ldi	r22, 0x00	; 0
    4170:	fe 01       	movw	r30, r28
    4172:	38 96       	adiw	r30, 0x08	; 8
    len++;
    4174:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4176:	81 91       	ld	r24, Z+
    4178:	88 23       	and	r24, r24
    417a:	e1 f7       	brne	.-8      	; 0x4174 <rcfg_getMAC+0x94>
    417c:	70 e0       	ldi	r23, 0x00	; 0
	  bufpos++;
    *bufpos++ = ':';
  }
  *(--bufpos) = '\0';

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    417e:	c6 01       	movw	r24, r12
    4180:	45 e8       	ldi	r20, 0x85	; 133
    4182:	59 e0       	ldi	r21, 0x09	; 9
    4184:	2b e8       	ldi	r18, 0x8B	; 139
    4186:	39 e0       	ldi	r19, 0x09	; 9
    4188:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nMAC-Address: ");
    418c:	88 ee       	ldi	r24, 0xE8	; 232
    418e:	92 e0       	ldi	r25, 0x02	; 2
    4190:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    4194:	c6 01       	movw	r24, r12
    4196:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    419a:	80 e0       	ldi	r24, 0x00	; 0
    419c:	67 96       	adiw	r28, 0x17	; 23
    419e:	0f b6       	in	r0, 0x3f	; 63
    41a0:	f8 94       	cli
    41a2:	de bf       	out	0x3e, r29	; 62
    41a4:	0f be       	out	0x3f, r0	; 63
    41a6:	cd bf       	out	0x3d, r28	; 61
    41a8:	cf 91       	pop	r28
    41aa:	df 91       	pop	r29
    41ac:	1f 91       	pop	r17
    41ae:	0f 91       	pop	r16
    41b0:	ff 90       	pop	r15
    41b2:	ef 90       	pop	r14
    41b4:	df 90       	pop	r13
    41b6:	cf 90       	pop	r12
    41b8:	bf 90       	pop	r11
    41ba:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    41bc:	60 e0       	ldi	r22, 0x00	; 0
    41be:	70 e0       	ldi	r23, 0x00	; 0
    41c0:	de cf       	rjmp	.-68     	; 0x417e <rcfg_getMAC+0x9e>

000041c2 <ip2str>:
    len++;
  return len;
}

char * ip2str(char * buf, ipAddress_t ip)
{
    41c2:	df 92       	push	r13
    41c4:	ef 92       	push	r14
    41c6:	ff 92       	push	r15
    41c8:	0f 93       	push	r16
    41ca:	1f 93       	push	r17
    41cc:	df 93       	push	r29
    41ce:	cf 93       	push	r28
    41d0:	00 d0       	rcall	.+0      	; 0x41d2 <ip2str+0x10>
    41d2:	00 d0       	rcall	.+0      	; 0x41d4 <ip2str+0x12>
    41d4:	cd b7       	in	r28, 0x3d	; 61
    41d6:	de b7       	in	r29, 0x3e	; 62
    41d8:	8c 01       	movw	r16, r24
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    41da:	49 83       	std	Y+1, r20	; 0x01
    41dc:	5a 83       	std	Y+2, r21	; 0x02
    41de:	6b 83       	std	Y+3, r22	; 0x03
    41e0:	7c 83       	std	Y+4, r23	; 0x04
    41e2:	b4 e0       	ldi	r27, 0x04	; 4
    41e4:	eb 2e       	mov	r14, r27
    41e6:	f1 2c       	mov	r15, r1
    41e8:	ec 0e       	add	r14, r28
    41ea:	fd 1e       	adc	r15, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    41ec:	ae e2       	ldi	r26, 0x2E	; 46
    41ee:	da 2e       	mov	r13, r26
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    41f0:	f7 01       	movw	r30, r14
    41f2:	80 81       	ld	r24, Z
    41f4:	90 e0       	ldi	r25, 0x00	; 0
    41f6:	b8 01       	movw	r22, r16
    41f8:	4a e0       	ldi	r20, 0x0A	; 10
    41fa:	50 e0       	ldi	r21, 0x00	; 0
    41fc:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4200:	02 c0       	rjmp	.+4      	; 0x4206 <ip2str+0x44>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4202:	0f 5f       	subi	r16, 0xFF	; 255
    4204:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4206:	f8 01       	movw	r30, r16
    4208:	80 81       	ld	r24, Z
    420a:	80 53       	subi	r24, 0x30	; 48
    420c:	8a 30       	cpi	r24, 0x0A	; 10
    420e:	c8 f3       	brcs	.-14     	; 0x4202 <ip2str+0x40>
      buf++;
    *buf++ = '.';
    4210:	f8 01       	movw	r30, r16
    4212:	d1 92       	st	Z+, r13
    4214:	08 94       	sec
    4216:	e1 08       	sbc	r14, r1
    4218:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    421a:	ec 16       	cp	r14, r28
    421c:	fd 06       	cpc	r15, r29
    421e:	11 f0       	breq	.+4      	; 0x4224 <ip2str+0x62>
    4220:	8f 01       	movw	r16, r30
    4222:	e6 cf       	rjmp	.-52     	; 0x41f0 <ip2str+0x2e>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    4224:	f8 01       	movw	r30, r16
    4226:	10 82       	st	Z, r1

  // return current position in buf
  return buf;
}
    4228:	c8 01       	movw	r24, r16
    422a:	0f 90       	pop	r0
    422c:	0f 90       	pop	r0
    422e:	0f 90       	pop	r0
    4230:	0f 90       	pop	r0
    4232:	cf 91       	pop	r28
    4234:	df 91       	pop	r29
    4236:	1f 91       	pop	r17
    4238:	0f 91       	pop	r16
    423a:	ff 90       	pop	r15
    423c:	ef 90       	pop	r14
    423e:	df 90       	pop	r13
    4240:	08 95       	ret

00004242 <rcfg_setMAC>:
}



uint8_t rcfg_setMAC(char * buf)
{
    4242:	0f 93       	push	r16
    4244:	1f 93       	push	r17
    4246:	df 93       	push	r29
    4248:	cf 93       	push	r28
    424a:	cd b7       	in	r28, 0x3d	; 61
    424c:	de b7       	in	r29, 0x3e	; 62
    424e:	28 97       	sbiw	r28, 0x08	; 8
    4250:	0f b6       	in	r0, 0x3f	; 63
    4252:	f8 94       	cli
    4254:	de bf       	out	0x3e, r29	; 62
    4256:	0f be       	out	0x3f, r0	; 63
    4258:	cd bf       	out	0x3d, r28	; 61
    425a:	98 87       	std	Y+8, r25	; 0x08
    425c:	8f 83       	std	Y+7, r24	; 0x07
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    425e:	8e 01       	movw	r16, r28
    4260:	09 5f       	subi	r16, 0xF9	; 249
    4262:	1f 4f       	sbci	r17, 0xFF	; 255
    4264:	c8 01       	movw	r24, r16
    4266:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <rcfg_parseUHex>
    426a:	69 83       	std	Y+1, r22	; 0x01
    buf++; // skip byte delimiter (usually ':')
    426c:	8f 81       	ldd	r24, Y+7	; 0x07
    426e:	98 85       	ldd	r25, Y+8	; 0x08
    4270:	01 96       	adiw	r24, 0x01	; 1
    4272:	98 87       	std	Y+8, r25	; 0x08
    4274:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    4276:	c8 01       	movw	r24, r16
    4278:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <rcfg_parseUHex>
    427c:	6a 83       	std	Y+2, r22	; 0x02
    buf++; // skip byte delimiter (usually ':')
    427e:	8f 81       	ldd	r24, Y+7	; 0x07
    4280:	98 85       	ldd	r25, Y+8	; 0x08
    4282:	01 96       	adiw	r24, 0x01	; 1
    4284:	98 87       	std	Y+8, r25	; 0x08
    4286:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    4288:	c8 01       	movw	r24, r16
    428a:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <rcfg_parseUHex>
    428e:	6b 83       	std	Y+3, r22	; 0x03
    buf++; // skip byte delimiter (usually ':')
    4290:	8f 81       	ldd	r24, Y+7	; 0x07
    4292:	98 85       	ldd	r25, Y+8	; 0x08
    4294:	01 96       	adiw	r24, 0x01	; 1
    4296:	98 87       	std	Y+8, r25	; 0x08
    4298:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    429a:	c8 01       	movw	r24, r16
    429c:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <rcfg_parseUHex>
    42a0:	6c 83       	std	Y+4, r22	; 0x04
    buf++; // skip byte delimiter (usually ':')
    42a2:	8f 81       	ldd	r24, Y+7	; 0x07
    42a4:	98 85       	ldd	r25, Y+8	; 0x08
    42a6:	01 96       	adiw	r24, 0x01	; 1
    42a8:	98 87       	std	Y+8, r25	; 0x08
    42aa:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    42ac:	c8 01       	movw	r24, r16
    42ae:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <rcfg_parseUHex>
    42b2:	6d 83       	std	Y+5, r22	; 0x05
    buf++; // skip byte delimiter (usually ':')
    42b4:	8f 81       	ldd	r24, Y+7	; 0x07
    42b6:	98 85       	ldd	r25, Y+8	; 0x08
    42b8:	01 96       	adiw	r24, 0x01	; 1
    42ba:	98 87       	std	Y+8, r25	; 0x08
    42bc:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    42be:	c8 01       	movw	r24, r16
    42c0:	0e 94 ec 27 	call	0x4fd8	; 0x4fd8 <rcfg_parseUHex>
    42c4:	6e 83       	std	Y+6, r22	; 0x06
    buf++; // skip byte delimiter (usually ':')
    42c6:	8f 81       	ldd	r24, Y+7	; 0x07
    42c8:	98 85       	ldd	r25, Y+8	; 0x08
    42ca:	01 96       	adiw	r24, 0x01	; 1
    42cc:	98 87       	std	Y+8, r25	; 0x08
    42ce:	8f 83       	std	Y+7, r24	; 0x07
  }
  ethernetEepromSetConfig(mac);
    42d0:	ce 01       	movw	r24, r28
    42d2:	01 96       	adiw	r24, 0x01	; 1
    42d4:	0e 94 31 07 	call	0xe62	; 0xe62 <ethernetEepromSetConfig>

  return RCFG_SUCCESS;
}
    42d8:	80 e0       	ldi	r24, 0x00	; 0
    42da:	28 96       	adiw	r28, 0x08	; 8
    42dc:	0f b6       	in	r0, 0x3f	; 63
    42de:	f8 94       	cli
    42e0:	de bf       	out	0x3e, r29	; 62
    42e2:	0f be       	out	0x3f, r0	; 63
    42e4:	cd bf       	out	0x3d, r28	; 61
    42e6:	cf 91       	pop	r28
    42e8:	df 91       	pop	r29
    42ea:	1f 91       	pop	r17
    42ec:	0f 91       	pop	r16
    42ee:	08 95       	ret

000042f0 <rcfg_getDIP_Config>:
  configEepromSetConfig(0, dport, 0, 0, 0);

  return RCFG_SUCCESS;
}

uint8_t rcfg_getDIP_Config(char *buf) {
    42f0:	9f 92       	push	r9
    42f2:	af 92       	push	r10
    42f4:	bf 92       	push	r11
    42f6:	cf 92       	push	r12
    42f8:	df 92       	push	r13
    42fa:	ef 92       	push	r14
    42fc:	ff 92       	push	r15
    42fe:	0f 93       	push	r16
    4300:	1f 93       	push	r17
    4302:	df 93       	push	r29
    4304:	cf 93       	push	r28
    4306:	cd b7       	in	r28, 0x3d	; 61
    4308:	de b7       	in	r29, 0x3e	; 62
    430a:	67 97       	sbiw	r28, 0x17	; 23
    430c:	0f b6       	in	r0, 0x3f	; 63
    430e:	f8 94       	cli
    4310:	de bf       	out	0x3e, r29	; 62
    4312:	0f be       	out	0x3f, r0	; 63
    4314:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t dip;
  configEepromGetConfig(NULL, NULL, &dip, NULL, NULL);
    4316:	80 e0       	ldi	r24, 0x00	; 0
    4318:	90 e0       	ldi	r25, 0x00	; 0
    431a:	60 e0       	ldi	r22, 0x00	; 0
    431c:	70 e0       	ldi	r23, 0x00	; 0
    431e:	ae 01       	movw	r20, r28
    4320:	4f 5f       	subi	r20, 0xFF	; 255
    4322:	5f 4f       	sbci	r21, 0xFF	; 255
    4324:	20 e0       	ldi	r18, 0x00	; 0
    4326:	30 e0       	ldi	r19, 0x00	; 0
    4328:	00 e0       	ldi	r16, 0x00	; 0
    432a:	10 e0       	ldi	r17, 0x00	; 0
    432c:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <configEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer;
    4330:	39 e0       	ldi	r19, 0x09	; 9
    4332:	a3 2e       	mov	r10, r19
    4334:	b1 2c       	mov	r11, r1
    4336:	ac 0e       	add	r10, r28
    4338:	bd 1e       	adc	r11, r29
    433a:	8f e0       	ldi	r24, 0x0F	; 15
    433c:	f5 01       	movw	r30, r10
    433e:	11 92       	st	Z+, r1
    4340:	8a 95       	dec	r24
    4342:	e9 f7       	brne	.-6      	; 0x433e <rcfg_getDIP_Config+0x4e>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4344:	89 81       	ldd	r24, Y+1	; 0x01
    4346:	9a 81       	ldd	r25, Y+2	; 0x02
    4348:	ab 81       	ldd	r26, Y+3	; 0x03
    434a:	bc 81       	ldd	r27, Y+4	; 0x04
    434c:	8d 83       	std	Y+5, r24	; 0x05
    434e:	9e 83       	std	Y+6, r25	; 0x06
    4350:	af 83       	std	Y+7, r26	; 0x07
    4352:	b8 87       	std	Y+8, r27	; 0x08
    4354:	28 e0       	ldi	r18, 0x08	; 8
    4356:	e2 2e       	mov	r14, r18
    4358:	f1 2c       	mov	r15, r1
    435a:	ec 0e       	add	r14, r28
    435c:	fd 1e       	adc	r15, r29
    435e:	85 01       	movw	r16, r10
    4360:	94 e0       	ldi	r25, 0x04	; 4
    4362:	c9 2e       	mov	r12, r25
    4364:	d1 2c       	mov	r13, r1
    4366:	cc 0e       	add	r12, r28
    4368:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    436a:	8e e2       	ldi	r24, 0x2E	; 46
    436c:	98 2e       	mov	r9, r24
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    436e:	f7 01       	movw	r30, r14
    4370:	80 81       	ld	r24, Z
    4372:	90 e0       	ldi	r25, 0x00	; 0
    4374:	b8 01       	movw	r22, r16
    4376:	4a e0       	ldi	r20, 0x0A	; 10
    4378:	50 e0       	ldi	r21, 0x00	; 0
    437a:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    437e:	02 c0       	rjmp	.+4      	; 0x4384 <rcfg_getDIP_Config+0x94>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4380:	0f 5f       	subi	r16, 0xFF	; 255
    4382:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4384:	f8 01       	movw	r30, r16
    4386:	80 81       	ld	r24, Z
    4388:	80 53       	subi	r24, 0x30	; 48
    438a:	8a 30       	cpi	r24, 0x0A	; 10
    438c:	c8 f3       	brcs	.-14     	; 0x4380 <rcfg_getDIP_Config+0x90>
      buf++;
    *buf++ = '.';
    438e:	f8 01       	movw	r30, r16
    4390:	91 92       	st	Z+, r9
    4392:	08 94       	sec
    4394:	e1 08       	sbc	r14, r1
    4396:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4398:	ec 14       	cp	r14, r12
    439a:	fd 04       	cpc	r15, r13
    439c:	11 f0       	breq	.+4      	; 0x43a2 <rcfg_getDIP_Config+0xb2>
    439e:	8f 01       	movw	r16, r30
    43a0:	e6 cf       	rjmp	.-52     	; 0x436e <rcfg_getDIP_Config+0x7e>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    43a2:	f8 01       	movw	r30, r16
    43a4:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    43a6:	89 85       	ldd	r24, Y+9	; 0x09
    43a8:	88 23       	and	r24, r24
    43aa:	49 f1       	breq	.+82     	; 0x43fe <rcfg_getDIP_Config+0x10e>
    43ac:	60 e0       	ldi	r22, 0x00	; 0
    43ae:	fe 01       	movw	r30, r28
    43b0:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    43b2:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    43b4:	81 91       	ld	r24, Z+
    43b6:	88 23       	and	r24, r24
    43b8:	e1 f7       	brne	.-8      	; 0x43b2 <rcfg_getDIP_Config+0xc2>
    43ba:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(NULL, NULL, &dip, NULL, NULL);

  char sendbuf[15] = {0}; // clear buffer;
  ip2str(sendbuf, dip);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    43bc:	c5 01       	movw	r24, r10
    43be:	45 e8       	ldi	r20, 0x85	; 133
    43c0:	59 e0       	ldi	r21, 0x09	; 9
    43c2:	2b e8       	ldi	r18, 0x8B	; 139
    43c4:	39 e0       	ldi	r19, 0x09	; 9
    43c6:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nDestination IP for Config-Channel: ");
    43ca:	88 ef       	ldi	r24, 0xF8	; 248
    43cc:	92 e0       	ldi	r25, 0x02	; 2
    43ce:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    43d2:	c5 01       	movw	r24, r10
    43d4:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    43d8:	80 e0       	ldi	r24, 0x00	; 0
    43da:	67 96       	adiw	r28, 0x17	; 23
    43dc:	0f b6       	in	r0, 0x3f	; 63
    43de:	f8 94       	cli
    43e0:	de bf       	out	0x3e, r29	; 62
    43e2:	0f be       	out	0x3f, r0	; 63
    43e4:	cd bf       	out	0x3d, r28	; 61
    43e6:	cf 91       	pop	r28
    43e8:	df 91       	pop	r29
    43ea:	1f 91       	pop	r17
    43ec:	0f 91       	pop	r16
    43ee:	ff 90       	pop	r15
    43f0:	ef 90       	pop	r14
    43f2:	df 90       	pop	r13
    43f4:	cf 90       	pop	r12
    43f6:	bf 90       	pop	r11
    43f8:	af 90       	pop	r10
    43fa:	9f 90       	pop	r9
    43fc:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    43fe:	60 e0       	ldi	r22, 0x00	; 0
    4400:	70 e0       	ldi	r23, 0x00	; 0
    4402:	dc cf       	rjmp	.-72     	; 0x43bc <rcfg_getDIP_Config+0xcc>

00004404 <rcfg_getDIP_Data>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_getDIP_Data(char *buf) {
    4404:	9f 92       	push	r9
    4406:	af 92       	push	r10
    4408:	bf 92       	push	r11
    440a:	cf 92       	push	r12
    440c:	df 92       	push	r13
    440e:	ef 92       	push	r14
    4410:	ff 92       	push	r15
    4412:	0f 93       	push	r16
    4414:	1f 93       	push	r17
    4416:	df 93       	push	r29
    4418:	cf 93       	push	r28
    441a:	cd b7       	in	r28, 0x3d	; 61
    441c:	de b7       	in	r29, 0x3e	; 62
    441e:	67 97       	sbiw	r28, 0x17	; 23
    4420:	0f b6       	in	r0, 0x3f	; 63
    4422:	f8 94       	cli
    4424:	de bf       	out	0x3e, r29	; 62
    4426:	0f be       	out	0x3f, r0	; 63
    4428:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t dip;
  configEepromGetConfig(&dip, NULL, NULL, NULL, NULL);
    442a:	ce 01       	movw	r24, r28
    442c:	01 96       	adiw	r24, 0x01	; 1
    442e:	60 e0       	ldi	r22, 0x00	; 0
    4430:	70 e0       	ldi	r23, 0x00	; 0
    4432:	40 e0       	ldi	r20, 0x00	; 0
    4434:	50 e0       	ldi	r21, 0x00	; 0
    4436:	20 e0       	ldi	r18, 0x00	; 0
    4438:	30 e0       	ldi	r19, 0x00	; 0
    443a:	00 e0       	ldi	r16, 0x00	; 0
    443c:	10 e0       	ldi	r17, 0x00	; 0
    443e:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <configEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer;
    4442:	79 e0       	ldi	r23, 0x09	; 9
    4444:	a7 2e       	mov	r10, r23
    4446:	b1 2c       	mov	r11, r1
    4448:	ac 0e       	add	r10, r28
    444a:	bd 1e       	adc	r11, r29
    444c:	8f e0       	ldi	r24, 0x0F	; 15
    444e:	f5 01       	movw	r30, r10
    4450:	11 92       	st	Z+, r1
    4452:	8a 95       	dec	r24
    4454:	e9 f7       	brne	.-6      	; 0x4450 <rcfg_getDIP_Data+0x4c>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4456:	89 81       	ldd	r24, Y+1	; 0x01
    4458:	9a 81       	ldd	r25, Y+2	; 0x02
    445a:	ab 81       	ldd	r26, Y+3	; 0x03
    445c:	bc 81       	ldd	r27, Y+4	; 0x04
    445e:	8d 83       	std	Y+5, r24	; 0x05
    4460:	9e 83       	std	Y+6, r25	; 0x06
    4462:	af 83       	std	Y+7, r26	; 0x07
    4464:	b8 87       	std	Y+8, r27	; 0x08
    4466:	68 e0       	ldi	r22, 0x08	; 8
    4468:	e6 2e       	mov	r14, r22
    446a:	f1 2c       	mov	r15, r1
    446c:	ec 0e       	add	r14, r28
    446e:	fd 1e       	adc	r15, r29
    4470:	85 01       	movw	r16, r10
    4472:	54 e0       	ldi	r21, 0x04	; 4
    4474:	c5 2e       	mov	r12, r21
    4476:	d1 2c       	mov	r13, r1
    4478:	cc 0e       	add	r12, r28
    447a:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    447c:	4e e2       	ldi	r20, 0x2E	; 46
    447e:	94 2e       	mov	r9, r20
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4480:	f7 01       	movw	r30, r14
    4482:	80 81       	ld	r24, Z
    4484:	90 e0       	ldi	r25, 0x00	; 0
    4486:	b8 01       	movw	r22, r16
    4488:	4a e0       	ldi	r20, 0x0A	; 10
    448a:	50 e0       	ldi	r21, 0x00	; 0
    448c:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4490:	02 c0       	rjmp	.+4      	; 0x4496 <rcfg_getDIP_Data+0x92>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4492:	0f 5f       	subi	r16, 0xFF	; 255
    4494:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4496:	f8 01       	movw	r30, r16
    4498:	80 81       	ld	r24, Z
    449a:	80 53       	subi	r24, 0x30	; 48
    449c:	8a 30       	cpi	r24, 0x0A	; 10
    449e:	c8 f3       	brcs	.-14     	; 0x4492 <rcfg_getDIP_Data+0x8e>
      buf++;
    *buf++ = '.';
    44a0:	f8 01       	movw	r30, r16
    44a2:	91 92       	st	Z+, r9
    44a4:	08 94       	sec
    44a6:	e1 08       	sbc	r14, r1
    44a8:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    44aa:	ec 14       	cp	r14, r12
    44ac:	fd 04       	cpc	r15, r13
    44ae:	11 f0       	breq	.+4      	; 0x44b4 <rcfg_getDIP_Data+0xb0>
    44b0:	8f 01       	movw	r16, r30
    44b2:	e6 cf       	rjmp	.-52     	; 0x4480 <rcfg_getDIP_Data+0x7c>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    44b4:	f8 01       	movw	r30, r16
    44b6:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    44b8:	89 85       	ldd	r24, Y+9	; 0x09
    44ba:	88 23       	and	r24, r24
    44bc:	49 f1       	breq	.+82     	; 0x4510 <rcfg_getDIP_Data+0x10c>
    44be:	60 e0       	ldi	r22, 0x00	; 0
    44c0:	fe 01       	movw	r30, r28
    44c2:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    44c4:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    44c6:	81 91       	ld	r24, Z+
    44c8:	88 23       	and	r24, r24
    44ca:	e1 f7       	brne	.-8      	; 0x44c4 <rcfg_getDIP_Data+0xc0>
    44cc:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(&dip, NULL, NULL, NULL, NULL);

  char sendbuf[15] = {0}; // clear buffer;
  ip2str(sendbuf, dip);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    44ce:	c5 01       	movw	r24, r10
    44d0:	45 e8       	ldi	r20, 0x85	; 133
    44d2:	59 e0       	ldi	r21, 0x09	; 9
    44d4:	2b e8       	ldi	r18, 0x8B	; 139
    44d6:	39 e0       	ldi	r19, 0x09	; 9
    44d8:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nDestination IP for Data-Channel: ");
    44dc:	8e e1       	ldi	r24, 0x1E	; 30
    44de:	93 e0       	ldi	r25, 0x03	; 3
    44e0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    44e4:	c5 01       	movw	r24, r10
    44e6:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    44ea:	80 e0       	ldi	r24, 0x00	; 0
    44ec:	67 96       	adiw	r28, 0x17	; 23
    44ee:	0f b6       	in	r0, 0x3f	; 63
    44f0:	f8 94       	cli
    44f2:	de bf       	out	0x3e, r29	; 62
    44f4:	0f be       	out	0x3f, r0	; 63
    44f6:	cd bf       	out	0x3d, r28	; 61
    44f8:	cf 91       	pop	r28
    44fa:	df 91       	pop	r29
    44fc:	1f 91       	pop	r17
    44fe:	0f 91       	pop	r16
    4500:	ff 90       	pop	r15
    4502:	ef 90       	pop	r14
    4504:	df 90       	pop	r13
    4506:	cf 90       	pop	r12
    4508:	bf 90       	pop	r11
    450a:	af 90       	pop	r10
    450c:	9f 90       	pop	r9
    450e:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4510:	60 e0       	ldi	r22, 0x00	; 0
    4512:	70 e0       	ldi	r23, 0x00	; 0
    4514:	dc cf       	rjmp	.-72     	; 0x44ce <rcfg_getDIP_Data+0xca>

00004516 <rcfg_getNet>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getNet(char * buf)
{
    4516:	4f 92       	push	r4
    4518:	5f 92       	push	r5
    451a:	6f 92       	push	r6
    451c:	7f 92       	push	r7
    451e:	9f 92       	push	r9
    4520:	af 92       	push	r10
    4522:	bf 92       	push	r11
    4524:	cf 92       	push	r12
    4526:	df 92       	push	r13
    4528:	ef 92       	push	r14
    452a:	ff 92       	push	r15
    452c:	0f 93       	push	r16
    452e:	1f 93       	push	r17
    4530:	df 93       	push	r29
    4532:	cf 93       	push	r28
    4534:	cd b7       	in	r28, 0x3d	; 61
    4536:	de b7       	in	r29, 0x3e	; 62
    4538:	c7 54       	subi	r28, 0x47	; 71
    453a:	d0 40       	sbci	r29, 0x00	; 0
    453c:	0f b6       	in	r0, 0x3f	; 63
    453e:	f8 94       	cli
    4540:	de bf       	out	0x3e, r29	; 62
    4542:	0f be       	out	0x3f, r0	; 63
    4544:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t ip, nm, gw;
  ipEepromGetConfig(&ip, &nm, &gw);
    4546:	ce 01       	movw	r24, r28
    4548:	01 96       	adiw	r24, 0x01	; 1
    454a:	be 01       	movw	r22, r28
    454c:	6b 5f       	subi	r22, 0xFB	; 251
    454e:	7f 4f       	sbci	r23, 0xFF	; 255
    4550:	ae 01       	movw	r20, r28
    4552:	47 5f       	subi	r20, 0xF7	; 247
    4554:	5f 4f       	sbci	r21, 0xFF	; 255
    4556:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[47] = {0}; // clear buffer;
    455a:	39 e1       	ldi	r19, 0x19	; 25
    455c:	43 2e       	mov	r4, r19
    455e:	51 2c       	mov	r5, r1
    4560:	4c 0e       	add	r4, r28
    4562:	5d 1e       	adc	r5, r29
    4564:	8f e2       	ldi	r24, 0x2F	; 47
    4566:	f2 01       	movw	r30, r4
    4568:	11 92       	st	Z+, r1
    456a:	8a 95       	dec	r24
    456c:	e9 f7       	brne	.-6      	; 0x4568 <rcfg_getNet+0x52>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    456e:	89 81       	ldd	r24, Y+1	; 0x01
    4570:	9a 81       	ldd	r25, Y+2	; 0x02
    4572:	ab 81       	ldd	r26, Y+3	; 0x03
    4574:	bc 81       	ldd	r27, Y+4	; 0x04
    4576:	8d 87       	std	Y+13, r24	; 0x0d
    4578:	9e 87       	std	Y+14, r25	; 0x0e
    457a:	af 87       	std	Y+15, r26	; 0x0f
    457c:	b8 8b       	std	Y+16, r27	; 0x10
    457e:	20 e1       	ldi	r18, 0x10	; 16
    4580:	62 2e       	mov	r6, r18
    4582:	71 2c       	mov	r7, r1
    4584:	6c 0e       	add	r6, r28
    4586:	7d 1e       	adc	r7, r29
    4588:	63 01       	movw	r12, r6
    458a:	82 01       	movw	r16, r4
    458c:	9c e0       	ldi	r25, 0x0C	; 12
    458e:	a9 2e       	mov	r10, r25
    4590:	b1 2c       	mov	r11, r1
    4592:	ac 0e       	add	r10, r28
    4594:	bd 1e       	adc	r11, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4596:	8e e2       	ldi	r24, 0x2E	; 46
    4598:	98 2e       	mov	r9, r24
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    459a:	f6 01       	movw	r30, r12
    459c:	80 81       	ld	r24, Z
    459e:	90 e0       	ldi	r25, 0x00	; 0
    45a0:	b8 01       	movw	r22, r16
    45a2:	4a e0       	ldi	r20, 0x0A	; 10
    45a4:	50 e0       	ldi	r21, 0x00	; 0
    45a6:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    45aa:	02 c0       	rjmp	.+4      	; 0x45b0 <rcfg_getNet+0x9a>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    45ac:	0f 5f       	subi	r16, 0xFF	; 255
    45ae:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    45b0:	f8 01       	movw	r30, r16
    45b2:	80 81       	ld	r24, Z
    45b4:	80 53       	subi	r24, 0x30	; 48
    45b6:	8a 30       	cpi	r24, 0x0A	; 10
    45b8:	c8 f3       	brcs	.-14     	; 0x45ac <rcfg_getNet+0x96>
      buf++;
    *buf++ = '.';
    45ba:	f8 01       	movw	r30, r16
    45bc:	91 92       	st	Z+, r9
    45be:	7f 01       	movw	r14, r30
    45c0:	08 94       	sec
    45c2:	c1 08       	sbc	r12, r1
    45c4:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    45c6:	ca 14       	cp	r12, r10
    45c8:	db 04       	cpc	r13, r11
    45ca:	11 f0       	breq	.+4      	; 0x45d0 <rcfg_getNet+0xba>
    45cc:	8f 01       	movw	r16, r30
    45ce:	e5 cf       	rjmp	.-54     	; 0x459a <rcfg_getNet+0x84>
  ipEepromGetConfig(&ip, &nm, &gw);

  char sendbuf[47] = {0}; // clear buffer;
  char * newpos;
  newpos = ip2str(sendbuf, ip);
  *newpos++ = ' ';
    45d0:	80 e2       	ldi	r24, 0x20	; 32
    45d2:	f8 01       	movw	r30, r16
    45d4:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    45d6:	8d 81       	ldd	r24, Y+5	; 0x05
    45d8:	9e 81       	ldd	r25, Y+6	; 0x06
    45da:	af 81       	ldd	r26, Y+7	; 0x07
    45dc:	b8 85       	ldd	r27, Y+8	; 0x08
    45de:	89 8b       	std	Y+17, r24	; 0x11
    45e0:	9a 8b       	std	Y+18, r25	; 0x12
    45e2:	ab 8b       	std	Y+19, r26	; 0x13
    45e4:	bc 8b       	std	Y+20, r27	; 0x14
    45e6:	b4 e1       	ldi	r27, 0x14	; 20
    45e8:	ab 2e       	mov	r10, r27
    45ea:	b1 2c       	mov	r11, r1
    45ec:	ac 0e       	add	r10, r28
    45ee:	bd 1e       	adc	r11, r29
    45f0:	65 01       	movw	r12, r10
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    45f2:	ae e2       	ldi	r26, 0x2E	; 46
    45f4:	9a 2e       	mov	r9, r26
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    45f6:	f6 01       	movw	r30, r12
    45f8:	80 81       	ld	r24, Z
    45fa:	90 e0       	ldi	r25, 0x00	; 0
    45fc:	b7 01       	movw	r22, r14
    45fe:	4a e0       	ldi	r20, 0x0A	; 10
    4600:	50 e0       	ldi	r21, 0x00	; 0
    4602:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4606:	03 c0       	rjmp	.+6      	; 0x460e <rcfg_getNet+0xf8>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4608:	08 94       	sec
    460a:	e1 1c       	adc	r14, r1
    460c:	f1 1c       	adc	r15, r1
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    460e:	f7 01       	movw	r30, r14
    4610:	80 81       	ld	r24, Z
    4612:	80 53       	subi	r24, 0x30	; 48
    4614:	8a 30       	cpi	r24, 0x0A	; 10
    4616:	c0 f3       	brcs	.-16     	; 0x4608 <rcfg_getNet+0xf2>
      buf++;
    *buf++ = '.';
    4618:	f7 01       	movw	r30, r14
    461a:	91 92       	st	Z+, r9
    461c:	8f 01       	movw	r16, r30
    461e:	08 94       	sec
    4620:	c1 08       	sbc	r12, r1
    4622:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4624:	c6 14       	cp	r12, r6
    4626:	d7 04       	cpc	r13, r7
    4628:	11 f0       	breq	.+4      	; 0x462e <rcfg_getNet+0x118>
    462a:	7f 01       	movw	r14, r30
    462c:	e4 cf       	rjmp	.-56     	; 0x45f6 <rcfg_getNet+0xe0>
  char sendbuf[47] = {0}; // clear buffer;
  char * newpos;
  newpos = ip2str(sendbuf, ip);
  *newpos++ = ' ';
  newpos = ip2str(newpos, nm);
  *newpos++ = ' ';
    462e:	80 e2       	ldi	r24, 0x20	; 32
    4630:	f7 01       	movw	r30, r14
    4632:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4634:	89 85       	ldd	r24, Y+9	; 0x09
    4636:	9a 85       	ldd	r25, Y+10	; 0x0a
    4638:	ab 85       	ldd	r26, Y+11	; 0x0b
    463a:	bc 85       	ldd	r27, Y+12	; 0x0c
    463c:	8d 8b       	std	Y+21, r24	; 0x15
    463e:	9e 8b       	std	Y+22, r25	; 0x16
    4640:	af 8b       	std	Y+23, r26	; 0x17
    4642:	b8 8f       	std	Y+24, r27	; 0x18
    4644:	f8 e1       	ldi	r31, 0x18	; 24
    4646:	ef 2e       	mov	r14, r31
    4648:	f1 2c       	mov	r15, r1
    464a:	ec 0e       	add	r14, r28
    464c:	fd 1e       	adc	r15, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    464e:	ee e2       	ldi	r30, 0x2E	; 46
    4650:	de 2e       	mov	r13, r30
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4652:	f7 01       	movw	r30, r14
    4654:	80 81       	ld	r24, Z
    4656:	90 e0       	ldi	r25, 0x00	; 0
    4658:	b8 01       	movw	r22, r16
    465a:	4a e0       	ldi	r20, 0x0A	; 10
    465c:	50 e0       	ldi	r21, 0x00	; 0
    465e:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4662:	02 c0       	rjmp	.+4      	; 0x4668 <rcfg_getNet+0x152>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4664:	0f 5f       	subi	r16, 0xFF	; 255
    4666:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4668:	f8 01       	movw	r30, r16
    466a:	80 81       	ld	r24, Z
    466c:	80 53       	subi	r24, 0x30	; 48
    466e:	8a 30       	cpi	r24, 0x0A	; 10
    4670:	c8 f3       	brcs	.-14     	; 0x4664 <rcfg_getNet+0x14e>
      buf++;
    *buf++ = '.';
    4672:	f8 01       	movw	r30, r16
    4674:	d1 92       	st	Z+, r13
    4676:	08 94       	sec
    4678:	e1 08       	sbc	r14, r1
    467a:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    467c:	ea 14       	cp	r14, r10
    467e:	fb 04       	cpc	r15, r11
    4680:	11 f0       	breq	.+4      	; 0x4686 <rcfg_getNet+0x170>
    4682:	8f 01       	movw	r16, r30
    4684:	e6 cf       	rjmp	.-52     	; 0x4652 <rcfg_getNet+0x13c>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    4686:	f8 01       	movw	r30, r16
    4688:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    468a:	89 8d       	ldd	r24, Y+25	; 0x19
    468c:	88 23       	and	r24, r24
    468e:	71 f1       	breq	.+92     	; 0x46ec <rcfg_getNet+0x1d6>
    4690:	60 e0       	ldi	r22, 0x00	; 0
    4692:	fe 01       	movw	r30, r28
    4694:	7a 96       	adiw	r30, 0x1a	; 26
    len++;
    4696:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4698:	81 91       	ld	r24, Z+
    469a:	88 23       	and	r24, r24
    469c:	e1 f7       	brne	.-8      	; 0x4696 <rcfg_getNet+0x180>
    469e:	70 e0       	ldi	r23, 0x00	; 0
  *newpos++ = ' ';
  newpos = ip2str(newpos, nm);
  *newpos++ = ' ';
  ip2str(newpos,gw);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    46a0:	c2 01       	movw	r24, r4
    46a2:	45 e8       	ldi	r20, 0x85	; 133
    46a4:	59 e0       	ldi	r21, 0x09	; 9
    46a6:	2b e8       	ldi	r18, 0x8B	; 139
    46a8:	39 e0       	ldi	r19, 0x09	; 9
    46aa:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nNIC-Overview: ");
    46ae:	82 e4       	ldi	r24, 0x42	; 66
    46b0:	93 e0       	ldi	r25, 0x03	; 3
    46b2:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    46b6:	c2 01       	movw	r24, r4
    46b8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    46bc:	80 e0       	ldi	r24, 0x00	; 0
    46be:	c9 5b       	subi	r28, 0xB9	; 185
    46c0:	df 4f       	sbci	r29, 0xFF	; 255
    46c2:	0f b6       	in	r0, 0x3f	; 63
    46c4:	f8 94       	cli
    46c6:	de bf       	out	0x3e, r29	; 62
    46c8:	0f be       	out	0x3f, r0	; 63
    46ca:	cd bf       	out	0x3d, r28	; 61
    46cc:	cf 91       	pop	r28
    46ce:	df 91       	pop	r29
    46d0:	1f 91       	pop	r17
    46d2:	0f 91       	pop	r16
    46d4:	ff 90       	pop	r15
    46d6:	ef 90       	pop	r14
    46d8:	df 90       	pop	r13
    46da:	cf 90       	pop	r12
    46dc:	bf 90       	pop	r11
    46de:	af 90       	pop	r10
    46e0:	9f 90       	pop	r9
    46e2:	7f 90       	pop	r7
    46e4:	6f 90       	pop	r6
    46e6:	5f 90       	pop	r5
    46e8:	4f 90       	pop	r4
    46ea:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    46ec:	60 e0       	ldi	r22, 0x00	; 0
    46ee:	70 e0       	ldi	r23, 0x00	; 0
    46f0:	d7 cf       	rjmp	.-82     	; 0x46a0 <rcfg_getNet+0x18a>

000046f2 <rcfg_getGW>:




uint8_t rcfg_getGW(char * buf)
{
    46f2:	9f 92       	push	r9
    46f4:	af 92       	push	r10
    46f6:	bf 92       	push	r11
    46f8:	cf 92       	push	r12
    46fa:	df 92       	push	r13
    46fc:	ef 92       	push	r14
    46fe:	ff 92       	push	r15
    4700:	0f 93       	push	r16
    4702:	1f 93       	push	r17
    4704:	df 93       	push	r29
    4706:	cf 93       	push	r28
    4708:	cd b7       	in	r28, 0x3d	; 61
    470a:	de b7       	in	r29, 0x3e	; 62
    470c:	67 97       	sbiw	r28, 0x17	; 23
    470e:	0f b6       	in	r0, 0x3f	; 63
    4710:	f8 94       	cli
    4712:	de bf       	out	0x3e, r29	; 62
    4714:	0f be       	out	0x3f, r0	; 63
    4716:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t gw;
  ipEepromGetConfig(NULL, NULL, &gw);
    4718:	80 e0       	ldi	r24, 0x00	; 0
    471a:	90 e0       	ldi	r25, 0x00	; 0
    471c:	60 e0       	ldi	r22, 0x00	; 0
    471e:	70 e0       	ldi	r23, 0x00	; 0
    4720:	ae 01       	movw	r20, r28
    4722:	4f 5f       	subi	r20, 0xFF	; 255
    4724:	5f 4f       	sbci	r21, 0xFF	; 255
    4726:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer;
    472a:	79 e0       	ldi	r23, 0x09	; 9
    472c:	a7 2e       	mov	r10, r23
    472e:	b1 2c       	mov	r11, r1
    4730:	ac 0e       	add	r10, r28
    4732:	bd 1e       	adc	r11, r29
    4734:	8f e0       	ldi	r24, 0x0F	; 15
    4736:	f5 01       	movw	r30, r10
    4738:	11 92       	st	Z+, r1
    473a:	8a 95       	dec	r24
    473c:	e9 f7       	brne	.-6      	; 0x4738 <rcfg_getGW+0x46>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    473e:	89 81       	ldd	r24, Y+1	; 0x01
    4740:	9a 81       	ldd	r25, Y+2	; 0x02
    4742:	ab 81       	ldd	r26, Y+3	; 0x03
    4744:	bc 81       	ldd	r27, Y+4	; 0x04
    4746:	8d 83       	std	Y+5, r24	; 0x05
    4748:	9e 83       	std	Y+6, r25	; 0x06
    474a:	af 83       	std	Y+7, r26	; 0x07
    474c:	b8 87       	std	Y+8, r27	; 0x08
    474e:	68 e0       	ldi	r22, 0x08	; 8
    4750:	e6 2e       	mov	r14, r22
    4752:	f1 2c       	mov	r15, r1
    4754:	ec 0e       	add	r14, r28
    4756:	fd 1e       	adc	r15, r29
    4758:	85 01       	movw	r16, r10
    475a:	54 e0       	ldi	r21, 0x04	; 4
    475c:	c5 2e       	mov	r12, r21
    475e:	d1 2c       	mov	r13, r1
    4760:	cc 0e       	add	r12, r28
    4762:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4764:	4e e2       	ldi	r20, 0x2E	; 46
    4766:	94 2e       	mov	r9, r20
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4768:	f7 01       	movw	r30, r14
    476a:	80 81       	ld	r24, Z
    476c:	90 e0       	ldi	r25, 0x00	; 0
    476e:	b8 01       	movw	r22, r16
    4770:	4a e0       	ldi	r20, 0x0A	; 10
    4772:	50 e0       	ldi	r21, 0x00	; 0
    4774:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4778:	02 c0       	rjmp	.+4      	; 0x477e <rcfg_getGW+0x8c>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    477a:	0f 5f       	subi	r16, 0xFF	; 255
    477c:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    477e:	f8 01       	movw	r30, r16
    4780:	80 81       	ld	r24, Z
    4782:	80 53       	subi	r24, 0x30	; 48
    4784:	8a 30       	cpi	r24, 0x0A	; 10
    4786:	c8 f3       	brcs	.-14     	; 0x477a <rcfg_getGW+0x88>
      buf++;
    *buf++ = '.';
    4788:	f8 01       	movw	r30, r16
    478a:	91 92       	st	Z+, r9
    478c:	08 94       	sec
    478e:	e1 08       	sbc	r14, r1
    4790:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4792:	ec 14       	cp	r14, r12
    4794:	fd 04       	cpc	r15, r13
    4796:	11 f0       	breq	.+4      	; 0x479c <rcfg_getGW+0xaa>
    4798:	8f 01       	movw	r16, r30
    479a:	e6 cf       	rjmp	.-52     	; 0x4768 <rcfg_getGW+0x76>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    479c:	f8 01       	movw	r30, r16
    479e:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    47a0:	89 85       	ldd	r24, Y+9	; 0x09
    47a2:	88 23       	and	r24, r24
    47a4:	49 f1       	breq	.+82     	; 0x47f8 <rcfg_getGW+0x106>
    47a6:	60 e0       	ldi	r22, 0x00	; 0
    47a8:	fe 01       	movw	r30, r28
    47aa:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    47ac:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    47ae:	81 91       	ld	r24, Z+
    47b0:	88 23       	and	r24, r24
    47b2:	e1 f7       	brne	.-8      	; 0x47ac <rcfg_getGW+0xba>
    47b4:	70 e0       	ldi	r23, 0x00	; 0
  ipEepromGetConfig(NULL, NULL, &gw);

  char sendbuf[15] = {0}; // clear buffer;
  ip2str(sendbuf, gw);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    47b6:	c5 01       	movw	r24, r10
    47b8:	45 e8       	ldi	r20, 0x85	; 133
    47ba:	59 e0       	ldi	r21, 0x09	; 9
    47bc:	2b e8       	ldi	r18, 0x8B	; 139
    47be:	39 e0       	ldi	r19, 0x09	; 9
    47c0:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nGateway: ");
    47c4:	83 e5       	ldi	r24, 0x53	; 83
    47c6:	93 e0       	ldi	r25, 0x03	; 3
    47c8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    47cc:	c5 01       	movw	r24, r10
    47ce:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    47d2:	80 e0       	ldi	r24, 0x00	; 0
    47d4:	67 96       	adiw	r28, 0x17	; 23
    47d6:	0f b6       	in	r0, 0x3f	; 63
    47d8:	f8 94       	cli
    47da:	de bf       	out	0x3e, r29	; 62
    47dc:	0f be       	out	0x3f, r0	; 63
    47de:	cd bf       	out	0x3d, r28	; 61
    47e0:	cf 91       	pop	r28
    47e2:	df 91       	pop	r29
    47e4:	1f 91       	pop	r17
    47e6:	0f 91       	pop	r16
    47e8:	ff 90       	pop	r15
    47ea:	ef 90       	pop	r14
    47ec:	df 90       	pop	r13
    47ee:	cf 90       	pop	r12
    47f0:	bf 90       	pop	r11
    47f2:	af 90       	pop	r10
    47f4:	9f 90       	pop	r9
    47f6:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    47f8:	60 e0       	ldi	r22, 0x00	; 0
    47fa:	70 e0       	ldi	r23, 0x00	; 0
    47fc:	dc cf       	rjmp	.-72     	; 0x47b6 <rcfg_getGW+0xc4>

000047fe <rcfg_getNM>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getNM(char * buf)
{
    47fe:	9f 92       	push	r9
    4800:	af 92       	push	r10
    4802:	bf 92       	push	r11
    4804:	cf 92       	push	r12
    4806:	df 92       	push	r13
    4808:	ef 92       	push	r14
    480a:	ff 92       	push	r15
    480c:	0f 93       	push	r16
    480e:	1f 93       	push	r17
    4810:	df 93       	push	r29
    4812:	cf 93       	push	r28
    4814:	cd b7       	in	r28, 0x3d	; 61
    4816:	de b7       	in	r29, 0x3e	; 62
    4818:	67 97       	sbiw	r28, 0x17	; 23
    481a:	0f b6       	in	r0, 0x3f	; 63
    481c:	f8 94       	cli
    481e:	de bf       	out	0x3e, r29	; 62
    4820:	0f be       	out	0x3f, r0	; 63
    4822:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t nm;
  ipEepromGetConfig(NULL, &nm, NULL);
    4824:	80 e0       	ldi	r24, 0x00	; 0
    4826:	90 e0       	ldi	r25, 0x00	; 0
    4828:	be 01       	movw	r22, r28
    482a:	6f 5f       	subi	r22, 0xFF	; 255
    482c:	7f 4f       	sbci	r23, 0xFF	; 255
    482e:	40 e0       	ldi	r20, 0x00	; 0
    4830:	50 e0       	ldi	r21, 0x00	; 0
    4832:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer
    4836:	b9 e0       	ldi	r27, 0x09	; 9
    4838:	ab 2e       	mov	r10, r27
    483a:	b1 2c       	mov	r11, r1
    483c:	ac 0e       	add	r10, r28
    483e:	bd 1e       	adc	r11, r29
    4840:	8f e0       	ldi	r24, 0x0F	; 15
    4842:	f5 01       	movw	r30, r10
    4844:	11 92       	st	Z+, r1
    4846:	8a 95       	dec	r24
    4848:	e9 f7       	brne	.-6      	; 0x4844 <rcfg_getNM+0x46>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    484a:	89 81       	ldd	r24, Y+1	; 0x01
    484c:	9a 81       	ldd	r25, Y+2	; 0x02
    484e:	ab 81       	ldd	r26, Y+3	; 0x03
    4850:	bc 81       	ldd	r27, Y+4	; 0x04
    4852:	8d 83       	std	Y+5, r24	; 0x05
    4854:	9e 83       	std	Y+6, r25	; 0x06
    4856:	af 83       	std	Y+7, r26	; 0x07
    4858:	b8 87       	std	Y+8, r27	; 0x08
    485a:	a8 e0       	ldi	r26, 0x08	; 8
    485c:	ea 2e       	mov	r14, r26
    485e:	f1 2c       	mov	r15, r1
    4860:	ec 0e       	add	r14, r28
    4862:	fd 1e       	adc	r15, r29
    4864:	85 01       	movw	r16, r10
    4866:	f4 e0       	ldi	r31, 0x04	; 4
    4868:	cf 2e       	mov	r12, r31
    486a:	d1 2c       	mov	r13, r1
    486c:	cc 0e       	add	r12, r28
    486e:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4870:	ee e2       	ldi	r30, 0x2E	; 46
    4872:	9e 2e       	mov	r9, r30
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4874:	f7 01       	movw	r30, r14
    4876:	80 81       	ld	r24, Z
    4878:	90 e0       	ldi	r25, 0x00	; 0
    487a:	b8 01       	movw	r22, r16
    487c:	4a e0       	ldi	r20, 0x0A	; 10
    487e:	50 e0       	ldi	r21, 0x00	; 0
    4880:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4884:	02 c0       	rjmp	.+4      	; 0x488a <rcfg_getNM+0x8c>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4886:	0f 5f       	subi	r16, 0xFF	; 255
    4888:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    488a:	f8 01       	movw	r30, r16
    488c:	80 81       	ld	r24, Z
    488e:	80 53       	subi	r24, 0x30	; 48
    4890:	8a 30       	cpi	r24, 0x0A	; 10
    4892:	c8 f3       	brcs	.-14     	; 0x4886 <rcfg_getNM+0x88>
      buf++;
    *buf++ = '.';
    4894:	f8 01       	movw	r30, r16
    4896:	91 92       	st	Z+, r9
    4898:	08 94       	sec
    489a:	e1 08       	sbc	r14, r1
    489c:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    489e:	ec 14       	cp	r14, r12
    48a0:	fd 04       	cpc	r15, r13
    48a2:	11 f0       	breq	.+4      	; 0x48a8 <rcfg_getNM+0xaa>
    48a4:	8f 01       	movw	r16, r30
    48a6:	e6 cf       	rjmp	.-52     	; 0x4874 <rcfg_getNM+0x76>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    48a8:	f8 01       	movw	r30, r16
    48aa:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    48ac:	89 85       	ldd	r24, Y+9	; 0x09
    48ae:	88 23       	and	r24, r24
    48b0:	49 f1       	breq	.+82     	; 0x4904 <rcfg_getNM+0x106>
    48b2:	60 e0       	ldi	r22, 0x00	; 0
    48b4:	fe 01       	movw	r30, r28
    48b6:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    48b8:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    48ba:	81 91       	ld	r24, Z+
    48bc:	88 23       	and	r24, r24
    48be:	e1 f7       	brne	.-8      	; 0x48b8 <rcfg_getNM+0xba>
    48c0:	70 e0       	ldi	r23, 0x00	; 0
  ipEepromGetConfig(NULL, &nm, NULL);

  char sendbuf[15] = {0}; // clear buffer
  ip2str(sendbuf, nm);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    48c2:	c5 01       	movw	r24, r10
    48c4:	45 e8       	ldi	r20, 0x85	; 133
    48c6:	59 e0       	ldi	r21, 0x09	; 9
    48c8:	2b e8       	ldi	r18, 0x8B	; 139
    48ca:	39 e0       	ldi	r19, 0x09	; 9
    48cc:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>


  putString_com1("\r\nNetwork-Mask: ");
    48d0:	8f e5       	ldi	r24, 0x5F	; 95
    48d2:	93 e0       	ldi	r25, 0x03	; 3
    48d4:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    48d8:	c5 01       	movw	r24, r10
    48da:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;


}
    48de:	80 e0       	ldi	r24, 0x00	; 0
    48e0:	67 96       	adiw	r28, 0x17	; 23
    48e2:	0f b6       	in	r0, 0x3f	; 63
    48e4:	f8 94       	cli
    48e6:	de bf       	out	0x3e, r29	; 62
    48e8:	0f be       	out	0x3f, r0	; 63
    48ea:	cd bf       	out	0x3d, r28	; 61
    48ec:	cf 91       	pop	r28
    48ee:	df 91       	pop	r29
    48f0:	1f 91       	pop	r17
    48f2:	0f 91       	pop	r16
    48f4:	ff 90       	pop	r15
    48f6:	ef 90       	pop	r14
    48f8:	df 90       	pop	r13
    48fa:	cf 90       	pop	r12
    48fc:	bf 90       	pop	r11
    48fe:	af 90       	pop	r10
    4900:	9f 90       	pop	r9
    4902:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4904:	60 e0       	ldi	r22, 0x00	; 0
    4906:	70 e0       	ldi	r23, 0x00	; 0
    4908:	dc cf       	rjmp	.-72     	; 0x48c2 <rcfg_getNM+0xc4>

0000490a <rcfg_getIP>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getIP(char * buf)
{
    490a:	9f 92       	push	r9
    490c:	af 92       	push	r10
    490e:	bf 92       	push	r11
    4910:	cf 92       	push	r12
    4912:	df 92       	push	r13
    4914:	ef 92       	push	r14
    4916:	ff 92       	push	r15
    4918:	0f 93       	push	r16
    491a:	1f 93       	push	r17
    491c:	df 93       	push	r29
    491e:	cf 93       	push	r28
    4920:	cd b7       	in	r28, 0x3d	; 61
    4922:	de b7       	in	r29, 0x3e	; 62
    4924:	67 97       	sbiw	r28, 0x17	; 23
    4926:	0f b6       	in	r0, 0x3f	; 63
    4928:	f8 94       	cli
    492a:	de bf       	out	0x3e, r29	; 62
    492c:	0f be       	out	0x3f, r0	; 63
    492e:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t ip;
  ipEepromGetConfig(&ip, NULL, NULL);
    4930:	ce 01       	movw	r24, r28
    4932:	01 96       	adiw	r24, 0x01	; 1
    4934:	60 e0       	ldi	r22, 0x00	; 0
    4936:	70 e0       	ldi	r23, 0x00	; 0
    4938:	40 e0       	ldi	r20, 0x00	; 0
    493a:	50 e0       	ldi	r21, 0x00	; 0
    493c:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer
    4940:	39 e0       	ldi	r19, 0x09	; 9
    4942:	a3 2e       	mov	r10, r19
    4944:	b1 2c       	mov	r11, r1
    4946:	ac 0e       	add	r10, r28
    4948:	bd 1e       	adc	r11, r29
    494a:	8f e0       	ldi	r24, 0x0F	; 15
    494c:	f5 01       	movw	r30, r10
    494e:	11 92       	st	Z+, r1
    4950:	8a 95       	dec	r24
    4952:	e9 f7       	brne	.-6      	; 0x494e <rcfg_getIP+0x44>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4954:	89 81       	ldd	r24, Y+1	; 0x01
    4956:	9a 81       	ldd	r25, Y+2	; 0x02
    4958:	ab 81       	ldd	r26, Y+3	; 0x03
    495a:	bc 81       	ldd	r27, Y+4	; 0x04
    495c:	8d 83       	std	Y+5, r24	; 0x05
    495e:	9e 83       	std	Y+6, r25	; 0x06
    4960:	af 83       	std	Y+7, r26	; 0x07
    4962:	b8 87       	std	Y+8, r27	; 0x08
    4964:	28 e0       	ldi	r18, 0x08	; 8
    4966:	e2 2e       	mov	r14, r18
    4968:	f1 2c       	mov	r15, r1
    496a:	ec 0e       	add	r14, r28
    496c:	fd 1e       	adc	r15, r29
    496e:	85 01       	movw	r16, r10
    4970:	94 e0       	ldi	r25, 0x04	; 4
    4972:	c9 2e       	mov	r12, r25
    4974:	d1 2c       	mov	r13, r1
    4976:	cc 0e       	add	r12, r28
    4978:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    497a:	8e e2       	ldi	r24, 0x2E	; 46
    497c:	98 2e       	mov	r9, r24
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    497e:	f7 01       	movw	r30, r14
    4980:	80 81       	ld	r24, Z
    4982:	90 e0       	ldi	r25, 0x00	; 0
    4984:	b8 01       	movw	r22, r16
    4986:	4a e0       	ldi	r20, 0x0A	; 10
    4988:	50 e0       	ldi	r21, 0x00	; 0
    498a:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    498e:	02 c0       	rjmp	.+4      	; 0x4994 <rcfg_getIP+0x8a>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4990:	0f 5f       	subi	r16, 0xFF	; 255
    4992:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4994:	f8 01       	movw	r30, r16
    4996:	80 81       	ld	r24, Z
    4998:	80 53       	subi	r24, 0x30	; 48
    499a:	8a 30       	cpi	r24, 0x0A	; 10
    499c:	c8 f3       	brcs	.-14     	; 0x4990 <rcfg_getIP+0x86>
      buf++;
    *buf++ = '.';
    499e:	f8 01       	movw	r30, r16
    49a0:	91 92       	st	Z+, r9
    49a2:	08 94       	sec
    49a4:	e1 08       	sbc	r14, r1
    49a6:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    49a8:	ec 14       	cp	r14, r12
    49aa:	fd 04       	cpc	r15, r13
    49ac:	11 f0       	breq	.+4      	; 0x49b2 <rcfg_getIP+0xa8>
    49ae:	8f 01       	movw	r16, r30
    49b0:	e6 cf       	rjmp	.-52     	; 0x497e <rcfg_getIP+0x74>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    49b2:	f8 01       	movw	r30, r16
    49b4:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    49b6:	89 85       	ldd	r24, Y+9	; 0x09
    49b8:	88 23       	and	r24, r24
    49ba:	49 f1       	breq	.+82     	; 0x4a0e <rcfg_getIP+0x104>
    49bc:	60 e0       	ldi	r22, 0x00	; 0
    49be:	fe 01       	movw	r30, r28
    49c0:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    49c2:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    49c4:	81 91       	ld	r24, Z+
    49c6:	88 23       	and	r24, r24
    49c8:	e1 f7       	brne	.-8      	; 0x49c2 <rcfg_getIP+0xb8>
    49ca:	70 e0       	ldi	r23, 0x00	; 0
  ipEepromGetConfig(&ip, NULL, NULL);

  char sendbuf[15] = {0}; // clear buffer
  ip2str(sendbuf, ip);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    49cc:	c5 01       	movw	r24, r10
    49ce:	45 e8       	ldi	r20, 0x85	; 133
    49d0:	59 e0       	ldi	r21, 0x09	; 9
    49d2:	2b e8       	ldi	r18, 0x8B	; 139
    49d4:	39 e0       	ldi	r19, 0x09	; 9
    49d6:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString_com1("\r\nIP-Address: ");
    49da:	80 e7       	ldi	r24, 0x70	; 112
    49dc:	93 e0       	ldi	r25, 0x03	; 3
    49de:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  putString_com1(sendbuf);
    49e2:	c5 01       	movw	r24, r10
    49e4:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


  return RCFG_SUCCESS;
}
    49e8:	80 e0       	ldi	r24, 0x00	; 0
    49ea:	67 96       	adiw	r28, 0x17	; 23
    49ec:	0f b6       	in	r0, 0x3f	; 63
    49ee:	f8 94       	cli
    49f0:	de bf       	out	0x3e, r29	; 62
    49f2:	0f be       	out	0x3f, r0	; 63
    49f4:	cd bf       	out	0x3d, r28	; 61
    49f6:	cf 91       	pop	r28
    49f8:	df 91       	pop	r29
    49fa:	1f 91       	pop	r17
    49fc:	0f 91       	pop	r16
    49fe:	ff 90       	pop	r15
    4a00:	ef 90       	pop	r14
    4a02:	df 90       	pop	r13
    4a04:	cf 90       	pop	r12
    4a06:	bf 90       	pop	r11
    4a08:	af 90       	pop	r10
    4a0a:	9f 90       	pop	r9
    4a0c:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4a0e:	60 e0       	ldi	r22, 0x00	; 0
    4a10:	70 e0       	ldi	r23, 0x00	; 0
    4a12:	dc cf       	rjmp	.-72     	; 0x49cc <rcfg_getIP+0xc2>

00004a14 <rcfg_getConfig>:
}



uint8_t rcfg_getConfig(char * buf)
{
    4a14:	4f 92       	push	r4
    4a16:	5f 92       	push	r5
    4a18:	7f 92       	push	r7
    4a1a:	8f 92       	push	r8
    4a1c:	9f 92       	push	r9
    4a1e:	af 92       	push	r10
    4a20:	bf 92       	push	r11
    4a22:	cf 92       	push	r12
    4a24:	df 92       	push	r13
    4a26:	ef 92       	push	r14
    4a28:	ff 92       	push	r15
    4a2a:	0f 93       	push	r16
    4a2c:	1f 93       	push	r17
    4a2e:	df 93       	push	r29
    4a30:	cf 93       	push	r28
    4a32:	cd b7       	in	r28, 0x3d	; 61
    4a34:	de b7       	in	r29, 0x3e	; 62
    4a36:	c6 57       	subi	r28, 0x76	; 118
    4a38:	d0 40       	sbci	r29, 0x00	; 0
    4a3a:	0f b6       	in	r0, 0x3f	; 63
    4a3c:	f8 94       	cli
    4a3e:	de bf       	out	0x3e, r29	; 62
    4a40:	0f be       	out	0x3f, r0	; 63
    4a42:	cd bf       	out	0x3d, r28	; 61


//Address 100 IP4_EEPROM

	ipAddress_t ip, nm, gw;
	ipEepromGetConfig(&ip, &nm, &gw);
    4a44:	ce 01       	movw	r24, r28
    4a46:	0d 96       	adiw	r24, 0x0d	; 13
    4a48:	be 01       	movw	r22, r28
    4a4a:	6f 5e       	subi	r22, 0xEF	; 239
    4a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a4e:	ae 01       	movw	r20, r28
    4a50:	4b 5e       	subi	r20, 0xEB	; 235
    4a52:	5f 4f       	sbci	r21, 0xFF	; 255
    4a54:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

	char sendbuf[50] = {0}; // clear buffer;
    4a58:	65 e4       	ldi	r22, 0x45	; 69
    4a5a:	86 2e       	mov	r8, r22
    4a5c:	91 2c       	mov	r9, r1
    4a5e:	8c 0e       	add	r8, r28
    4a60:	9d 1e       	adc	r9, r29
    4a62:	82 e3       	ldi	r24, 0x32	; 50
    4a64:	f4 01       	movw	r30, r8
    4a66:	11 92       	st	Z+, r1
    4a68:	8a 95       	dec	r24
    4a6a:	e9 f7       	brne	.-6      	; 0x4a66 <rcfg_getConfig+0x52>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4a6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a6e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a70:	af 85       	ldd	r26, Y+15	; 0x0f
    4a72:	b8 89       	ldd	r27, Y+16	; 0x10
    4a74:	89 a3       	std	Y+33, r24	; 0x21
    4a76:	9a a3       	std	Y+34, r25	; 0x22
    4a78:	ab a3       	std	Y+35, r26	; 0x23
    4a7a:	bc a3       	std	Y+36, r27	; 0x24
    4a7c:	54 e2       	ldi	r21, 0x24	; 36
    4a7e:	45 2e       	mov	r4, r21
    4a80:	51 2c       	mov	r5, r1
    4a82:	4c 0e       	add	r4, r28
    4a84:	5d 1e       	adc	r5, r29
    4a86:	62 01       	movw	r12, r4
    4a88:	84 01       	movw	r16, r8
    4a8a:	40 e2       	ldi	r20, 0x20	; 32
    4a8c:	a4 2e       	mov	r10, r20
    4a8e:	b1 2c       	mov	r11, r1
    4a90:	ac 0e       	add	r10, r28
    4a92:	bd 1e       	adc	r11, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4a94:	3e e2       	ldi	r19, 0x2E	; 46
    4a96:	73 2e       	mov	r7, r19
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4a98:	f6 01       	movw	r30, r12
    4a9a:	80 81       	ld	r24, Z
    4a9c:	90 e0       	ldi	r25, 0x00	; 0
    4a9e:	b8 01       	movw	r22, r16
    4aa0:	4a e0       	ldi	r20, 0x0A	; 10
    4aa2:	50 e0       	ldi	r21, 0x00	; 0
    4aa4:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4aa8:	02 c0       	rjmp	.+4      	; 0x4aae <rcfg_getConfig+0x9a>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4aaa:	0f 5f       	subi	r16, 0xFF	; 255
    4aac:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4aae:	f8 01       	movw	r30, r16
    4ab0:	80 81       	ld	r24, Z
    4ab2:	80 53       	subi	r24, 0x30	; 48
    4ab4:	8a 30       	cpi	r24, 0x0A	; 10
    4ab6:	c8 f3       	brcs	.-14     	; 0x4aaa <rcfg_getConfig+0x96>
      buf++;
    *buf++ = '.';
    4ab8:	f8 01       	movw	r30, r16
    4aba:	71 92       	st	Z+, r7
    4abc:	7f 01       	movw	r14, r30
    4abe:	08 94       	sec
    4ac0:	c1 08       	sbc	r12, r1
    4ac2:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4ac4:	ca 14       	cp	r12, r10
    4ac6:	db 04       	cpc	r13, r11
    4ac8:	11 f0       	breq	.+4      	; 0x4ace <rcfg_getConfig+0xba>
    4aca:	8f 01       	movw	r16, r30
    4acc:	e5 cf       	rjmp	.-54     	; 0x4a98 <rcfg_getConfig+0x84>
	ipEepromGetConfig(&ip, &nm, &gw);

	char sendbuf[50] = {0}; // clear buffer;
	char * newpos;
	newpos = ip2str(sendbuf, ip);
	*newpos++ = ' ';
    4ace:	80 e2       	ldi	r24, 0x20	; 32
    4ad0:	f8 01       	movw	r30, r16
    4ad2:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4ad4:	89 89       	ldd	r24, Y+17	; 0x11
    4ad6:	9a 89       	ldd	r25, Y+18	; 0x12
    4ad8:	ab 89       	ldd	r26, Y+19	; 0x13
    4ada:	bc 89       	ldd	r27, Y+20	; 0x14
    4adc:	8d a3       	std	Y+37, r24	; 0x25
    4ade:	9e a3       	std	Y+38, r25	; 0x26
    4ae0:	af a3       	std	Y+39, r26	; 0x27
    4ae2:	b8 a7       	std	Y+40, r27	; 0x28
    4ae4:	28 e2       	ldi	r18, 0x28	; 40
    4ae6:	a2 2e       	mov	r10, r18
    4ae8:	b1 2c       	mov	r11, r1
    4aea:	ac 0e       	add	r10, r28
    4aec:	bd 1e       	adc	r11, r29
    4aee:	65 01       	movw	r12, r10
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4af0:	9e e2       	ldi	r25, 0x2E	; 46
    4af2:	79 2e       	mov	r7, r25
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4af4:	f6 01       	movw	r30, r12
    4af6:	80 81       	ld	r24, Z
    4af8:	90 e0       	ldi	r25, 0x00	; 0
    4afa:	b7 01       	movw	r22, r14
    4afc:	4a e0       	ldi	r20, 0x0A	; 10
    4afe:	50 e0       	ldi	r21, 0x00	; 0
    4b00:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4b04:	03 c0       	rjmp	.+6      	; 0x4b0c <rcfg_getConfig+0xf8>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4b06:	08 94       	sec
    4b08:	e1 1c       	adc	r14, r1
    4b0a:	f1 1c       	adc	r15, r1
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4b0c:	f7 01       	movw	r30, r14
    4b0e:	80 81       	ld	r24, Z
    4b10:	80 53       	subi	r24, 0x30	; 48
    4b12:	8a 30       	cpi	r24, 0x0A	; 10
    4b14:	c0 f3       	brcs	.-16     	; 0x4b06 <rcfg_getConfig+0xf2>
      buf++;
    *buf++ = '.';
    4b16:	f7 01       	movw	r30, r14
    4b18:	71 92       	st	Z+, r7
    4b1a:	8f 01       	movw	r16, r30
    4b1c:	08 94       	sec
    4b1e:	c1 08       	sbc	r12, r1
    4b20:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4b22:	c4 14       	cp	r12, r4
    4b24:	d5 04       	cpc	r13, r5
    4b26:	11 f0       	breq	.+4      	; 0x4b2c <rcfg_getConfig+0x118>
    4b28:	7f 01       	movw	r14, r30
    4b2a:	e4 cf       	rjmp	.-56     	; 0x4af4 <rcfg_getConfig+0xe0>
	char sendbuf[50] = {0}; // clear buffer;
	char * newpos;
	newpos = ip2str(sendbuf, ip);
	*newpos++ = ' ';
	newpos = ip2str(newpos, nm);
	*newpos++ = ' ';
    4b2c:	80 e2       	ldi	r24, 0x20	; 32
    4b2e:	f7 01       	movw	r30, r14
    4b30:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4b32:	8d 89       	ldd	r24, Y+21	; 0x15
    4b34:	9e 89       	ldd	r25, Y+22	; 0x16
    4b36:	af 89       	ldd	r26, Y+23	; 0x17
    4b38:	b8 8d       	ldd	r27, Y+24	; 0x18
    4b3a:	89 a7       	std	Y+41, r24	; 0x29
    4b3c:	9a a7       	std	Y+42, r25	; 0x2a
    4b3e:	ab a7       	std	Y+43, r26	; 0x2b
    4b40:	bc a7       	std	Y+44, r27	; 0x2c
    4b42:	8c e2       	ldi	r24, 0x2C	; 44
    4b44:	48 2e       	mov	r4, r24
    4b46:	51 2c       	mov	r5, r1
    4b48:	4c 0e       	add	r4, r28
    4b4a:	5d 1e       	adc	r5, r29
    4b4c:	72 01       	movw	r14, r4
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4b4e:	be e2       	ldi	r27, 0x2E	; 46
    4b50:	db 2e       	mov	r13, r27
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4b52:	f7 01       	movw	r30, r14
    4b54:	80 81       	ld	r24, Z
    4b56:	90 e0       	ldi	r25, 0x00	; 0
    4b58:	b8 01       	movw	r22, r16
    4b5a:	4a e0       	ldi	r20, 0x0A	; 10
    4b5c:	50 e0       	ldi	r21, 0x00	; 0
    4b5e:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4b62:	02 c0       	rjmp	.+4      	; 0x4b68 <rcfg_getConfig+0x154>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4b64:	0f 5f       	subi	r16, 0xFF	; 255
    4b66:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4b68:	f8 01       	movw	r30, r16
    4b6a:	80 81       	ld	r24, Z
    4b6c:	80 53       	subi	r24, 0x30	; 48
    4b6e:	8a 30       	cpi	r24, 0x0A	; 10
    4b70:	c8 f3       	brcs	.-14     	; 0x4b64 <rcfg_getConfig+0x150>
      buf++;
    *buf++ = '.';
    4b72:	f8 01       	movw	r30, r16
    4b74:	d1 92       	st	Z+, r13
    4b76:	08 94       	sec
    4b78:	e1 08       	sbc	r14, r1
    4b7a:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4b7c:	ea 14       	cp	r14, r10
    4b7e:	fb 04       	cpc	r15, r11
    4b80:	11 f0       	breq	.+4      	; 0x4b86 <rcfg_getConfig+0x172>
    4b82:	8f 01       	movw	r16, r30
    4b84:	e6 cf       	rjmp	.-52     	; 0x4b52 <rcfg_getConfig+0x13e>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    4b86:	f8 01       	movw	r30, r16
    4b88:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4b8a:	f4 01       	movw	r30, r8
    4b8c:	80 81       	ld	r24, Z
    4b8e:	88 23       	and	r24, r24
    4b90:	09 f4       	brne	.+2      	; 0x4b94 <rcfg_getConfig+0x180>
    4b92:	da c1       	rjmp	.+948    	; 0x4f48 <rcfg_getConfig+0x534>
    4b94:	60 e0       	ldi	r22, 0x00	; 0
    4b96:	f4 01       	movw	r30, r8
    4b98:	31 96       	adiw	r30, 0x01	; 1
    len++;
    4b9a:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4b9c:	81 91       	ld	r24, Z+
    4b9e:	88 23       	and	r24, r24
    4ba0:	e1 f7       	brne	.-8      	; 0x4b9a <rcfg_getConfig+0x186>
    4ba2:	70 e0       	ldi	r23, 0x00	; 0
	*newpos++ = ' ';
	newpos = ip2str(newpos, nm);
	*newpos++ = ' ';
	ip2str(newpos,gw);

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    4ba4:	c4 01       	movw	r24, r8
    4ba6:	45 e8       	ldi	r20, 0x85	; 133
    4ba8:	59 e0       	ldi	r21, 0x09	; 9
    4baa:	2b e8       	ldi	r18, 0x8B	; 139
    4bac:	39 e0       	ldi	r19, 0x09	; 9
    4bae:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString_com1("\r\nConfig-Overview: ");
    4bb2:	8f e7       	ldi	r24, 0x7F	; 127
    4bb4:	93 e0       	ldi	r25, 0x03	; 3
    4bb6:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1("\r\nAb Adresse 0x100: ");
    4bba:	83 e9       	ldi	r24, 0x93	; 147
    4bbc:	93 e0       	ldi	r25, 0x03	; 3
    4bbe:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>



	putString_com1("(IP,Netmask,GW) ");
    4bc2:	88 ea       	ldi	r24, 0xA8	; 168
    4bc4:	93 e0       	ldi	r25, 0x03	; 3
    4bc6:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(sendbuf);
    4bca:	c4 01       	movw	r24, r8
    4bcc:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	//Address 200 MAC_EEPROM
	

	uint8_t mac[6];
	ethernetEepromGetConfig(mac);
    4bd0:	8e 01       	movw	r16, r28
    4bd2:	0b 5c       	subi	r16, 0xCB	; 203
    4bd4:	1f 4f       	sbci	r17, 0xFF	; 255
    4bd6:	c8 01       	movw	r24, r16
    4bd8:	0e 94 f7 06 	call	0xdee	; 0xdee <ethernetEepromGetConfig>

	sendbuf[0] = '\0'; // clear buffer
    4bdc:	f4 01       	movw	r30, r8
    4bde:	10 82       	st	Z, r1
    4be0:	78 01       	movw	r14, r16
    4be2:	84 01       	movw	r16, r8
    4be4:	ab e3       	ldi	r26, 0x3B	; 59
    4be6:	ca 2e       	mov	r12, r26
    4be8:	d1 2c       	mov	r13, r1
    4bea:	cc 0e       	add	r12, r28
    4bec:	dd 1e       	adc	r13, r29
	utoa(mac[i], bufpos, 16);
	while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
	*bufpos++ = ':';
    4bee:	fa e3       	ldi	r31, 0x3A	; 58
    4bf0:	bf 2e       	mov	r11, r31

	sendbuf[0] = '\0'; // clear buffer
	char * bufpos = sendbuf;
	uint8_t i;
	for (i=0; i<=5; i++) {
	utoa(mac[i], bufpos, 16);
    4bf2:	f7 01       	movw	r30, r14
    4bf4:	80 81       	ld	r24, Z
    4bf6:	90 e0       	ldi	r25, 0x00	; 0
    4bf8:	b8 01       	movw	r22, r16
    4bfa:	40 e1       	ldi	r20, 0x10	; 16
    4bfc:	50 e0       	ldi	r21, 0x00	; 0
    4bfe:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4c02:	02 c0       	rjmp	.+4      	; 0x4c08 <rcfg_getConfig+0x1f4>
	while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    4c04:	0f 5f       	subi	r16, 0xFF	; 255
    4c06:	1f 4f       	sbci	r17, 0xFF	; 255
	sendbuf[0] = '\0'; // clear buffer
	char * bufpos = sendbuf;
	uint8_t i;
	for (i=0; i<=5; i++) {
	utoa(mac[i], bufpos, 16);
	while ( (*bufpos >= '0' && *bufpos <= '9') ||
    4c08:	f8 01       	movw	r30, r16
    4c0a:	90 81       	ld	r25, Z
    4c0c:	89 2f       	mov	r24, r25
    4c0e:	80 53       	subi	r24, 0x30	; 48
    4c10:	8a 30       	cpi	r24, 0x0A	; 10
    4c12:	c0 f3       	brcs	.-16     	; 0x4c04 <rcfg_getConfig+0x1f0>
    4c14:	81 53       	subi	r24, 0x31	; 49
    4c16:	86 30       	cpi	r24, 0x06	; 6
    4c18:	a8 f3       	brcs	.-22     	; 0x4c04 <rcfg_getConfig+0x1f0>
    4c1a:	91 54       	subi	r25, 0x41	; 65
    4c1c:	96 30       	cpi	r25, 0x06	; 6
    4c1e:	90 f3       	brcs	.-28     	; 0x4c04 <rcfg_getConfig+0x1f0>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
	*bufpos++ = ':';
    4c20:	b1 92       	st	Z+, r11
    4c22:	08 94       	sec
    4c24:	e1 1c       	adc	r14, r1
    4c26:	f1 1c       	adc	r15, r1
	ethernetEepromGetConfig(mac);

	sendbuf[0] = '\0'; // clear buffer
	char * bufpos = sendbuf;
	uint8_t i;
	for (i=0; i<=5; i++) {
    4c28:	ec 14       	cp	r14, r12
    4c2a:	fd 04       	cpc	r15, r13
    4c2c:	11 f0       	breq	.+4      	; 0x4c32 <rcfg_getConfig+0x21e>
    4c2e:	8f 01       	movw	r16, r30
    4c30:	e0 cf       	rjmp	.-64     	; 0x4bf2 <rcfg_getConfig+0x1de>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
	*bufpos++ = ':';
	}
	*(--bufpos) = '\0';
    4c32:	f8 01       	movw	r30, r16
    4c34:	10 82       	st	Z, r1

	putString_com1("\r\nAb Adresse 0x200: ");
    4c36:	89 eb       	ldi	r24, 0xB9	; 185
    4c38:	93 e0       	ldi	r25, 0x03	; 3
    4c3a:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1("(MAC-Address) ");
    4c3e:	8e ec       	ldi	r24, 0xCE	; 206
    4c40:	93 e0       	ldi	r25, 0x03	; 3
    4c42:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(sendbuf);
    4c46:	c4 01       	movw	r24, r8
    4c48:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>



	//Address 300 SERIAL_EEPROM

	uint16_t prescaler=0;
    4c4c:	1e 82       	std	Y+6, r1	; 0x06
    4c4e:	1d 82       	std	Y+5, r1	; 0x05
	uint8_t parity=0;
    4c50:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    4c52:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    4c54:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t BufferSizeLimit=0;
    4c56:	1c 82       	std	Y+4, r1	; 0x04

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits,&BufferSizeLimit);
    4c58:	ce 01       	movw	r24, r28
    4c5a:	05 96       	adiw	r24, 0x05	; 5
    4c5c:	be 01       	movw	r22, r28
    4c5e:	6f 5f       	subi	r22, 0xFF	; 255
    4c60:	7f 4f       	sbci	r23, 0xFF	; 255
    4c62:	ae 01       	movw	r20, r28
    4c64:	4e 5f       	subi	r20, 0xFE	; 254
    4c66:	5f 4f       	sbci	r21, 0xFF	; 255
    4c68:	9e 01       	movw	r18, r28
    4c6a:	2d 5f       	subi	r18, 0xFD	; 253
    4c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    4c6e:	8e 01       	movw	r16, r28
    4c70:	0c 5f       	subi	r16, 0xFC	; 252
    4c72:	1f 4f       	sbci	r17, 0xFF	; 255
    4c74:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	stop_bits+=1;
    4c78:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7a:	8f 5f       	subi	r24, 0xFF	; 255
    4c7c:	8a 83       	std	Y+2, r24	; 0x02
	data_bits+=5;
    4c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c80:	8b 5f       	subi	r24, 0xFB	; 251
    4c82:	8b 83       	std	Y+3, r24	; 0x03

	putString_com1("\r\nAb Adresse 0x300: ");
    4c84:	8d ed       	ldi	r24, 0xDD	; 221
    4c86:	93 e0       	ldi	r25, 0x03	; 3
    4c88:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


	putString_com1("(Prescaler,Parity,StopBits,DataBits,BufferSizeLimit)\r\n");
    4c8c:	82 ef       	ldi	r24, 0xF2	; 242
    4c8e:	93 e0       	ldi	r25, 0x03	; 3
    4c90:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	char buffer[10];

	ultoa(prescaler,buffer,10);
    4c94:	6d 81       	ldd	r22, Y+5	; 0x05
    4c96:	7e 81       	ldd	r23, Y+6	; 0x06
    4c98:	80 e0       	ldi	r24, 0x00	; 0
    4c9a:	90 e0       	ldi	r25, 0x00	; 0
    4c9c:	a7 01       	movw	r20, r14
    4c9e:	2a e0       	ldi	r18, 0x0A	; 10
    4ca0:	30 e0       	ldi	r19, 0x00	; 0
    4ca2:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(buffer);
    4ca6:	c7 01       	movw	r24, r14
    4ca8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	putString_com1("  ");
    4cac:	89 e2       	ldi	r24, 0x29	; 41
    4cae:	94 e0       	ldi	r25, 0x04	; 4
    4cb0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	ultoa(parity,buffer,10);
    4cb4:	69 81       	ldd	r22, Y+1	; 0x01
    4cb6:	70 e0       	ldi	r23, 0x00	; 0
    4cb8:	80 e0       	ldi	r24, 0x00	; 0
    4cba:	90 e0       	ldi	r25, 0x00	; 0
    4cbc:	a7 01       	movw	r20, r14
    4cbe:	2a e0       	ldi	r18, 0x0A	; 10
    4cc0:	30 e0       	ldi	r19, 0x00	; 0
    4cc2:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(buffer);
    4cc6:	c7 01       	movw	r24, r14
    4cc8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	putString_com1("  ");
    4ccc:	89 e2       	ldi	r24, 0x29	; 41
    4cce:	94 e0       	ldi	r25, 0x04	; 4
    4cd0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	ultoa(stop_bits,buffer,10);
    4cd4:	6a 81       	ldd	r22, Y+2	; 0x02
    4cd6:	70 e0       	ldi	r23, 0x00	; 0
    4cd8:	80 e0       	ldi	r24, 0x00	; 0
    4cda:	90 e0       	ldi	r25, 0x00	; 0
    4cdc:	a7 01       	movw	r20, r14
    4cde:	2a e0       	ldi	r18, 0x0A	; 10
    4ce0:	30 e0       	ldi	r19, 0x00	; 0
    4ce2:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(buffer);
    4ce6:	c7 01       	movw	r24, r14
    4ce8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	putString_com1("  ");
    4cec:	89 e2       	ldi	r24, 0x29	; 41
    4cee:	94 e0       	ldi	r25, 0x04	; 4
    4cf0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	ultoa(data_bits,buffer,10);
    4cf4:	6b 81       	ldd	r22, Y+3	; 0x03
    4cf6:	70 e0       	ldi	r23, 0x00	; 0
    4cf8:	80 e0       	ldi	r24, 0x00	; 0
    4cfa:	90 e0       	ldi	r25, 0x00	; 0
    4cfc:	a7 01       	movw	r20, r14
    4cfe:	2a e0       	ldi	r18, 0x0A	; 10
    4d00:	30 e0       	ldi	r19, 0x00	; 0
    4d02:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(buffer);
    4d06:	c7 01       	movw	r24, r14
    4d08:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	putString_com1("  ");
    4d0c:	89 e2       	ldi	r24, 0x29	; 41
    4d0e:	94 e0       	ldi	r25, 0x04	; 4
    4d10:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	ultoa(BufferSizeLimit,buffer,10);
    4d14:	6c 81       	ldd	r22, Y+4	; 0x04
    4d16:	70 e0       	ldi	r23, 0x00	; 0
    4d18:	80 e0       	ldi	r24, 0x00	; 0
    4d1a:	90 e0       	ldi	r25, 0x00	; 0
    4d1c:	a7 01       	movw	r20, r14
    4d1e:	2a e0       	ldi	r18, 0x0A	; 10
    4d20:	30 e0       	ldi	r19, 0x00	; 0
    4d22:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(buffer);
    4d26:	c7 01       	movw	r24, r14
    4d28:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	putString_com1("\r\nPrescaler belongs to this baudrate: ");
    4d2c:	8c e2       	ldi	r24, 0x2C	; 44
    4d2e:	94 e0       	ldi	r25, 0x04	; 4
    4d30:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>


	uint32_t baud=F_CPU  / (16 * (prescaler + 1));
	ultoa(baud, buffer, 10);
    4d34:	2d 81       	ldd	r18, Y+5	; 0x05
    4d36:	3e 81       	ldd	r19, Y+6	; 0x06
    4d38:	2f 5f       	subi	r18, 0xFF	; 255
    4d3a:	3f 4f       	sbci	r19, 0xFF	; 255
    4d3c:	22 95       	swap	r18
    4d3e:	32 95       	swap	r19
    4d40:	30 7f       	andi	r19, 0xF0	; 240
    4d42:	32 27       	eor	r19, r18
    4d44:	20 7f       	andi	r18, 0xF0	; 240
    4d46:	32 27       	eor	r19, r18
    4d48:	40 e0       	ldi	r20, 0x00	; 0
    4d4a:	50 e0       	ldi	r21, 0x00	; 0
    4d4c:	60 e0       	ldi	r22, 0x00	; 0
    4d4e:	70 e0       	ldi	r23, 0x00	; 0
    4d50:	81 ee       	ldi	r24, 0xE1	; 225
    4d52:	90 e0       	ldi	r25, 0x00	; 0
    4d54:	0e 94 23 30 	call	0x6046	; 0x6046 <__udivmodsi4>
    4d58:	ca 01       	movw	r24, r20
    4d5a:	b9 01       	movw	r22, r18
    4d5c:	a7 01       	movw	r20, r14
    4d5e:	2a e0       	ldi	r18, 0x0A	; 10
    4d60:	30 e0       	ldi	r19, 0x00	; 0
    4d62:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(buffer);
    4d66:	c7 01       	movw	r24, r14
    4d68:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	putString_com1("\r\nParity Value means: ");
    4d6c:	83 e5       	ldi	r24, 0x53	; 83
    4d6e:	94 e0       	ldi	r25, 0x04	; 4
    4d70:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	switch (parity)
    4d74:	89 81       	ldd	r24, Y+1	; 0x01
    4d76:	81 30       	cpi	r24, 0x01	; 1
    4d78:	09 f4       	brne	.+2      	; 0x4d7c <rcfg_getConfig+0x368>
    4d7a:	e1 c0       	rjmp	.+450    	; 0x4f3e <rcfg_getConfig+0x52a>
    4d7c:	81 30       	cpi	r24, 0x01	; 1
    4d7e:	08 f4       	brcc	.+2      	; 0x4d82 <rcfg_getConfig+0x36e>
    4d80:	50 c0       	rjmp	.+160    	; 0x4e22 <rcfg_getConfig+0x40e>
    4d82:	82 30       	cpi	r24, 0x02	; 2
    4d84:	09 f4       	brne	.+2      	; 0x4d88 <rcfg_getConfig+0x374>
    4d86:	d6 c0       	rjmp	.+428    	; 0x4f34 <rcfg_getConfig+0x520>
    4d88:	83 30       	cpi	r24, 0x03	; 3
    4d8a:	21 f4       	brne	.+8      	; 0x4d94 <rcfg_getConfig+0x380>
		break;
		case 2:
			putString_com1("Parity Enabled, Even Parity: ");
		break;
		case 3:
			putString_com1("Parity Enabled, Odd Parity: ");
    4d8c:	8c ea       	ldi	r24, 0xAC	; 172
    4d8e:	94 e0       	ldi	r25, 0x04	; 4
    4d90:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	portAddress_t dport_data;
	portAddress_t dport_config;
	portAddress_t  sPort;


	configEepromGetConfig(&dip_data, &dport_data, &dip_config, &dport_config, &sPort);
    4d94:	ce 01       	movw	r24, r28
    4d96:	49 96       	adiw	r24, 0x19	; 25
    4d98:	be 01       	movw	r22, r28
    4d9a:	69 5f       	subi	r22, 0xF9	; 249
    4d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    4d9e:	ae 01       	movw	r20, r28
    4da0:	43 5e       	subi	r20, 0xE3	; 227
    4da2:	5f 4f       	sbci	r21, 0xFF	; 255
    4da4:	9e 01       	movw	r18, r28
    4da6:	27 5f       	subi	r18, 0xF7	; 247
    4da8:	3f 4f       	sbci	r19, 0xFF	; 255
    4daa:	8e 01       	movw	r16, r28
    4dac:	05 5f       	subi	r16, 0xF5	; 245
    4dae:	1f 4f       	sbci	r17, 0xFF	; 255
    4db0:	0e 94 d0 2a 	call	0x55a0	; 0x55a0 <configEepromGetConfig>

	



	putString_com1("\r\nAb Adresse 0x400: ");
    4db4:	89 ec       	ldi	r24, 0xC9	; 201
    4db6:	94 e0       	ldi	r25, 0x04	; 4
    4db8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1("(IP_d,port_d,IP_c,port_c,sPort) ");
    4dbc:	8e ed       	ldi	r24, 0xDE	; 222
    4dbe:	94 e0       	ldi	r25, 0x04	; 4
    4dc0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	putString_com1("\r\n");
    4dc4:	8a e1       	ldi	r24, 0x1A	; 26
    4dc6:	92 e0       	ldi	r25, 0x02	; 2
    4dc8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4dcc:	89 8d       	ldd	r24, Y+25	; 0x19
    4dce:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4dd0:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4dd2:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4dd4:	8d a7       	std	Y+45, r24	; 0x2d
    4dd6:	9e a7       	std	Y+46, r25	; 0x2e
    4dd8:	af a7       	std	Y+47, r26	; 0x2f
    4dda:	b8 ab       	std	Y+48, r27	; 0x30
    4ddc:	70 e3       	ldi	r23, 0x30	; 48
    4dde:	a7 2e       	mov	r10, r23
    4de0:	b1 2c       	mov	r11, r1
    4de2:	ac 0e       	add	r10, r28
    4de4:	bd 1e       	adc	r11, r29
    4de6:	75 01       	movw	r14, r10
    4de8:	84 01       	movw	r16, r8
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4dea:	6e e2       	ldi	r22, 0x2E	; 46
    4dec:	d6 2e       	mov	r13, r22
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4dee:	f7 01       	movw	r30, r14
    4df0:	80 81       	ld	r24, Z
    4df2:	90 e0       	ldi	r25, 0x00	; 0
    4df4:	b8 01       	movw	r22, r16
    4df6:	4a e0       	ldi	r20, 0x0A	; 10
    4df8:	50 e0       	ldi	r21, 0x00	; 0
    4dfa:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4dfe:	02 c0       	rjmp	.+4      	; 0x4e04 <rcfg_getConfig+0x3f0>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4e00:	0f 5f       	subi	r16, 0xFF	; 255
    4e02:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4e04:	f8 01       	movw	r30, r16
    4e06:	80 81       	ld	r24, Z
    4e08:	80 53       	subi	r24, 0x30	; 48
    4e0a:	8a 30       	cpi	r24, 0x0A	; 10
    4e0c:	c8 f3       	brcs	.-14     	; 0x4e00 <rcfg_getConfig+0x3ec>
      buf++;
    *buf++ = '.';
    4e0e:	f8 01       	movw	r30, r16
    4e10:	d1 92       	st	Z+, r13
    4e12:	08 94       	sec
    4e14:	e1 08       	sbc	r14, r1
    4e16:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4e18:	e4 14       	cp	r14, r4
    4e1a:	f5 04       	cpc	r15, r5
    4e1c:	39 f0       	breq	.+14     	; 0x4e2c <rcfg_getConfig+0x418>
    4e1e:	8f 01       	movw	r16, r30
    4e20:	e6 cf       	rjmp	.-52     	; 0x4dee <rcfg_getConfig+0x3da>

	putString_com1("\r\nParity Value means: ");
	switch (parity)
	{
		case 0:
			putString_com1("Parity Disabled: ");
    4e22:	8a e6       	ldi	r24, 0x6A	; 106
    4e24:	94 e0       	ldi	r25, 0x04	; 4
    4e26:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    4e2a:	b4 cf       	rjmp	.-152    	; 0x4d94 <rcfg_getConfig+0x380>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    4e2c:	f8 01       	movw	r30, r16
    4e2e:	10 82       	st	Z, r1
	putString_com1("\r\nAb Adresse 0x400: ");
	putString_com1("(IP_d,port_d,IP_c,port_c,sPort) ");

	putString_com1("\r\n");
	ip2str(sendbuf, dip_data);
	putString_com1(sendbuf);
    4e30:	c4 01       	movw	r24, r8
    4e32:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(" ");
    4e36:	8f ef       	ldi	r24, 0xFF	; 255
    4e38:	94 e0       	ldi	r25, 0x04	; 4
    4e3a:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	ultoa(dport_data,sendbuf, 10);
    4e3e:	6f 81       	ldd	r22, Y+7	; 0x07
    4e40:	78 85       	ldd	r23, Y+8	; 0x08
    4e42:	80 e0       	ldi	r24, 0x00	; 0
    4e44:	90 e0       	ldi	r25, 0x00	; 0
    4e46:	a4 01       	movw	r20, r8
    4e48:	2a e0       	ldi	r18, 0x0A	; 10
    4e4a:	30 e0       	ldi	r19, 0x00	; 0
    4e4c:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(sendbuf);
    4e50:	c4 01       	movw	r24, r8
    4e52:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(" ");
    4e56:	8f ef       	ldi	r24, 0xFF	; 255
    4e58:	94 e0       	ldi	r25, 0x04	; 4
    4e5a:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4e5e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4e60:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4e62:	af 8d       	ldd	r26, Y+31	; 0x1f
    4e64:	b8 a1       	ldd	r27, Y+32	; 0x20
    4e66:	89 ab       	std	Y+49, r24	; 0x31
    4e68:	9a ab       	std	Y+50, r25	; 0x32
    4e6a:	ab ab       	std	Y+51, r26	; 0x33
    4e6c:	bc ab       	std	Y+52, r27	; 0x34
    4e6e:	54 e3       	ldi	r21, 0x34	; 52
    4e70:	e5 2e       	mov	r14, r21
    4e72:	f1 2c       	mov	r15, r1
    4e74:	ec 0e       	add	r14, r28
    4e76:	fd 1e       	adc	r15, r29
    4e78:	84 01       	movw	r16, r8
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4e7a:	4e e2       	ldi	r20, 0x2E	; 46
    4e7c:	d4 2e       	mov	r13, r20
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4e7e:	f7 01       	movw	r30, r14
    4e80:	80 81       	ld	r24, Z
    4e82:	90 e0       	ldi	r25, 0x00	; 0
    4e84:	b8 01       	movw	r22, r16
    4e86:	4a e0       	ldi	r20, 0x0A	; 10
    4e88:	50 e0       	ldi	r21, 0x00	; 0
    4e8a:	0e 94 de 2f 	call	0x5fbc	; 0x5fbc <utoa>
    4e8e:	02 c0       	rjmp	.+4      	; 0x4e94 <rcfg_getConfig+0x480>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4e90:	0f 5f       	subi	r16, 0xFF	; 255
    4e92:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4e94:	f8 01       	movw	r30, r16
    4e96:	80 81       	ld	r24, Z
    4e98:	80 53       	subi	r24, 0x30	; 48
    4e9a:	8a 30       	cpi	r24, 0x0A	; 10
    4e9c:	c8 f3       	brcs	.-14     	; 0x4e90 <rcfg_getConfig+0x47c>
      buf++;
    *buf++ = '.';
    4e9e:	f8 01       	movw	r30, r16
    4ea0:	d1 92       	st	Z+, r13
    4ea2:	08 94       	sec
    4ea4:	e1 08       	sbc	r14, r1
    4ea6:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4ea8:	ea 14       	cp	r14, r10
    4eaa:	fb 04       	cpc	r15, r11
    4eac:	11 f0       	breq	.+4      	; 0x4eb2 <rcfg_getConfig+0x49e>
    4eae:	8f 01       	movw	r16, r30
    4eb0:	e6 cf       	rjmp	.-52     	; 0x4e7e <rcfg_getConfig+0x46a>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    4eb2:	f8 01       	movw	r30, r16
    4eb4:	10 82       	st	Z, r1
	ultoa(dport_data,sendbuf, 10);
	putString_com1(sendbuf);
	putString_com1(" ");

	ip2str(sendbuf, dip_config);
	putString_com1(sendbuf);
    4eb6:	c4 01       	movw	r24, r8
    4eb8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(" ");
    4ebc:	8f ef       	ldi	r24, 0xFF	; 255
    4ebe:	94 e0       	ldi	r25, 0x04	; 4
    4ec0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	ultoa(dport_config,sendbuf,10);
    4ec4:	69 85       	ldd	r22, Y+9	; 0x09
    4ec6:	7a 85       	ldd	r23, Y+10	; 0x0a
    4ec8:	80 e0       	ldi	r24, 0x00	; 0
    4eca:	90 e0       	ldi	r25, 0x00	; 0
    4ecc:	a4 01       	movw	r20, r8
    4ece:	2a e0       	ldi	r18, 0x0A	; 10
    4ed0:	30 e0       	ldi	r19, 0x00	; 0
    4ed2:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(sendbuf);
    4ed6:	c4 01       	movw	r24, r8
    4ed8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(" ");
    4edc:	8f ef       	ldi	r24, 0xFF	; 255
    4ede:	94 e0       	ldi	r25, 0x04	; 4
    4ee0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>

	ultoa(sPort,sendbuf, 10);
    4ee4:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ee6:	7c 85       	ldd	r23, Y+12	; 0x0c
    4ee8:	80 e0       	ldi	r24, 0x00	; 0
    4eea:	90 e0       	ldi	r25, 0x00	; 0
    4eec:	a4 01       	movw	r20, r8
    4eee:	2a e0       	ldi	r18, 0x0A	; 10
    4ef0:	30 e0       	ldi	r19, 0x00	; 0
    4ef2:	0e 94 b9 2f 	call	0x5f72	; 0x5f72 <ultoa>
	putString_com1(sendbuf);
    4ef6:	c4 01       	movw	r24, r8
    4ef8:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1("\r\n");
    4efc:	8a e1       	ldi	r24, 0x1A	; 26
    4efe:	92 e0       	ldi	r25, 0x02	; 2
    4f00:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>




	return RCFG_SUCCESS;
}
    4f04:	80 e0       	ldi	r24, 0x00	; 0
    4f06:	ca 58       	subi	r28, 0x8A	; 138
    4f08:	df 4f       	sbci	r29, 0xFF	; 255
    4f0a:	0f b6       	in	r0, 0x3f	; 63
    4f0c:	f8 94       	cli
    4f0e:	de bf       	out	0x3e, r29	; 62
    4f10:	0f be       	out	0x3f, r0	; 63
    4f12:	cd bf       	out	0x3d, r28	; 61
    4f14:	cf 91       	pop	r28
    4f16:	df 91       	pop	r29
    4f18:	1f 91       	pop	r17
    4f1a:	0f 91       	pop	r16
    4f1c:	ff 90       	pop	r15
    4f1e:	ef 90       	pop	r14
    4f20:	df 90       	pop	r13
    4f22:	cf 90       	pop	r12
    4f24:	bf 90       	pop	r11
    4f26:	af 90       	pop	r10
    4f28:	9f 90       	pop	r9
    4f2a:	8f 90       	pop	r8
    4f2c:	7f 90       	pop	r7
    4f2e:	5f 90       	pop	r5
    4f30:	4f 90       	pop	r4
    4f32:	08 95       	ret
		break;
		case 1:
			putString_com1("Parity Reserved: ");
		break;
		case 2:
			putString_com1("Parity Enabled, Even Parity: ");
    4f34:	8e e8       	ldi	r24, 0x8E	; 142
    4f36:	94 e0       	ldi	r25, 0x04	; 4
    4f38:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    4f3c:	2b cf       	rjmp	.-426    	; 0x4d94 <rcfg_getConfig+0x380>
	{
		case 0:
			putString_com1("Parity Disabled: ");
		break;
		case 1:
			putString_com1("Parity Reserved: ");
    4f3e:	8c e7       	ldi	r24, 0x7C	; 124
    4f40:	94 e0       	ldi	r25, 0x04	; 4
    4f42:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    4f46:	26 cf       	rjmp	.-436    	; 0x4d94 <rcfg_getConfig+0x380>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4f48:	60 e0       	ldi	r22, 0x00	; 0
    4f4a:	70 e0       	ldi	r23, 0x00	; 0
    4f4c:	2b ce       	rjmp	.-938    	; 0x4ba4 <rcfg_getConfig+0x190>

00004f4e <rcfg_parseUInt>:
    4f4e:	af 92       	push	r10
    4f50:	bf 92       	push	r11
    4f52:	df 92       	push	r13
    4f54:	ef 92       	push	r14
    4f56:	ff 92       	push	r15
    4f58:	0f 93       	push	r16
    4f5a:	1f 93       	push	r17
    4f5c:	cf 93       	push	r28
    4f5e:	df 93       	push	r29
    4f60:	5c 01       	movw	r10, r24
    4f62:	fc 01       	movw	r30, r24
    4f64:	c0 81       	ld	r28, Z
    4f66:	d1 81       	ldd	r29, Z+1	; 0x01
    4f68:	d8 80       	ld	r13, Y
    4f6a:	8d 2d       	mov	r24, r13
    4f6c:	80 53       	subi	r24, 0x30	; 48
    4f6e:	8a 30       	cpi	r24, 0x0A	; 10
    4f70:	78 f5       	brcc	.+94     	; 0x4fd0 <rcfg_parseUInt+0x82>
    4f72:	ee 24       	eor	r14, r14
    4f74:	ff 24       	eor	r15, r15
    4f76:	87 01       	movw	r16, r14
    4f78:	c8 01       	movw	r24, r16
    4f7a:	b7 01       	movw	r22, r14
    4f7c:	2a e0       	ldi	r18, 0x0A	; 10
    4f7e:	30 e0       	ldi	r19, 0x00	; 0
    4f80:	40 e0       	ldi	r20, 0x00	; 0
    4f82:	50 e0       	ldi	r21, 0x00	; 0
    4f84:	0e 94 04 30 	call	0x6008	; 0x6008 <__mulsi3>
    4f88:	2d 2d       	mov	r18, r13
    4f8a:	33 27       	eor	r19, r19
    4f8c:	27 fd       	sbrc	r18, 7
    4f8e:	30 95       	com	r19
    4f90:	20 53       	subi	r18, 0x30	; 48
    4f92:	30 40       	sbci	r19, 0x00	; 0
    4f94:	79 01       	movw	r14, r18
    4f96:	00 27       	eor	r16, r16
    4f98:	f7 fc       	sbrc	r15, 7
    4f9a:	00 95       	com	r16
    4f9c:	10 2f       	mov	r17, r16
    4f9e:	e6 0e       	add	r14, r22
    4fa0:	f7 1e       	adc	r15, r23
    4fa2:	08 1f       	adc	r16, r24
    4fa4:	19 1f       	adc	r17, r25
    4fa6:	21 96       	adiw	r28, 0x01	; 1
    4fa8:	d8 80       	ld	r13, Y
    4faa:	8d 2d       	mov	r24, r13
    4fac:	80 53       	subi	r24, 0x30	; 48
    4fae:	8a 30       	cpi	r24, 0x0A	; 10
    4fb0:	18 f3       	brcs	.-58     	; 0x4f78 <rcfg_parseUInt+0x2a>
    4fb2:	f5 01       	movw	r30, r10
    4fb4:	d1 83       	std	Z+1, r29	; 0x01
    4fb6:	c0 83       	st	Z, r28
    4fb8:	b7 01       	movw	r22, r14
    4fba:	c8 01       	movw	r24, r16
    4fbc:	df 91       	pop	r29
    4fbe:	cf 91       	pop	r28
    4fc0:	1f 91       	pop	r17
    4fc2:	0f 91       	pop	r16
    4fc4:	ff 90       	pop	r15
    4fc6:	ef 90       	pop	r14
    4fc8:	df 90       	pop	r13
    4fca:	bf 90       	pop	r11
    4fcc:	af 90       	pop	r10
    4fce:	08 95       	ret
    4fd0:	ee 24       	eor	r14, r14
    4fd2:	ff 24       	eor	r15, r15
    4fd4:	87 01       	movw	r16, r14
    4fd6:	ed cf       	rjmp	.-38     	; 0x4fb2 <rcfg_parseUInt+0x64>

00004fd8 <rcfg_parseUHex>:
    4fd8:	dc 01       	movw	r26, r24
    4fda:	ed 91       	ld	r30, X+
    4fdc:	fc 91       	ld	r31, X
    4fde:	11 97       	sbiw	r26, 0x01	; 1
    4fe0:	80 e0       	ldi	r24, 0x00	; 0
    4fe2:	20 e0       	ldi	r18, 0x00	; 0
    4fe4:	30 e0       	ldi	r19, 0x00	; 0
    4fe6:	40 e0       	ldi	r20, 0x00	; 0
    4fe8:	50 e0       	ldi	r21, 0x00	; 0
    4fea:	22 0f       	add	r18, r18
    4fec:	33 1f       	adc	r19, r19
    4fee:	44 1f       	adc	r20, r20
    4ff0:	55 1f       	adc	r21, r21
    4ff2:	22 0f       	add	r18, r18
    4ff4:	33 1f       	adc	r19, r19
    4ff6:	44 1f       	adc	r20, r20
    4ff8:	55 1f       	adc	r21, r21
    4ffa:	22 0f       	add	r18, r18
    4ffc:	33 1f       	adc	r19, r19
    4ffe:	44 1f       	adc	r20, r20
    5000:	55 1f       	adc	r21, r21
    5002:	22 0f       	add	r18, r18
    5004:	33 1f       	adc	r19, r19
    5006:	44 1f       	adc	r20, r20
    5008:	55 1f       	adc	r21, r21
    500a:	28 0f       	add	r18, r24
    500c:	31 1d       	adc	r19, r1
    500e:	41 1d       	adc	r20, r1
    5010:	51 1d       	adc	r21, r1
    5012:	90 81       	ld	r25, Z
    5014:	89 2f       	mov	r24, r25
    5016:	80 53       	subi	r24, 0x30	; 48
    5018:	8a 30       	cpi	r24, 0x0A	; 10
    501a:	40 f0       	brcs	.+16     	; 0x502c <rcfg_parseUHex+0x54>
    501c:	81 53       	subi	r24, 0x31	; 49
    501e:	86 30       	cpi	r24, 0x06	; 6
    5020:	20 f0       	brcs	.+8      	; 0x502a <rcfg_parseUHex+0x52>
    5022:	89 2f       	mov	r24, r25
    5024:	81 54       	subi	r24, 0x41	; 65
    5026:	86 30       	cpi	r24, 0x06	; 6
    5028:	18 f4       	brcc	.+6      	; 0x5030 <rcfg_parseUHex+0x58>
    502a:	86 5f       	subi	r24, 0xF6	; 246
    502c:	31 96       	adiw	r30, 0x01	; 1
    502e:	dd cf       	rjmp	.-70     	; 0x4fea <rcfg_parseUHex+0x12>
    5030:	ed 93       	st	X+, r30
    5032:	fc 93       	st	X, r31
    5034:	b9 01       	movw	r22, r18
    5036:	ca 01       	movw	r24, r20
    5038:	08 95       	ret

0000503a <rcfg_parseIP>:
    503a:	4f 92       	push	r4
    503c:	5f 92       	push	r5
    503e:	6f 92       	push	r6
    5040:	7f 92       	push	r7
    5042:	8f 92       	push	r8
    5044:	9f 92       	push	r9
    5046:	af 92       	push	r10
    5048:	bf 92       	push	r11
    504a:	cf 92       	push	r12
    504c:	df 92       	push	r13
    504e:	ef 92       	push	r14
    5050:	ff 92       	push	r15
    5052:	0f 93       	push	r16
    5054:	1f 93       	push	r17
    5056:	df 93       	push	r29
    5058:	cf 93       	push	r28
    505a:	cd b7       	in	r28, 0x3d	; 61
    505c:	de b7       	in	r29, 0x3e	; 62
    505e:	28 97       	sbiw	r28, 0x08	; 8
    5060:	0f b6       	in	r0, 0x3f	; 63
    5062:	f8 94       	cli
    5064:	de bf       	out	0x3e, r29	; 62
    5066:	0f be       	out	0x3f, r0	; 63
    5068:	cd bf       	out	0x3d, r28	; 61
    506a:	2c 01       	movw	r4, r24
    506c:	dc 01       	movw	r26, r24
    506e:	ad 90       	ld	r10, X+
    5070:	bc 90       	ld	r11, X
    5072:	f5 01       	movw	r30, r10
    5074:	d0 80       	ld	r13, Z
    5076:	8d 2d       	mov	r24, r13
    5078:	80 53       	subi	r24, 0x30	; 48
    507a:	8a 30       	cpi	r24, 0x0A	; 10
    507c:	08 f0       	brcs	.+2      	; 0x5080 <rcfg_parseIP+0x46>
    507e:	02 c1       	rjmp	.+516    	; 0x5284 <rcfg_parseIP+0x24a>
    5080:	ee 24       	eor	r14, r14
    5082:	ff 24       	eor	r15, r15
    5084:	87 01       	movw	r16, r14
    5086:	c8 01       	movw	r24, r16
    5088:	b7 01       	movw	r22, r14
    508a:	2a e0       	ldi	r18, 0x0A	; 10
    508c:	30 e0       	ldi	r19, 0x00	; 0
    508e:	40 e0       	ldi	r20, 0x00	; 0
    5090:	50 e0       	ldi	r21, 0x00	; 0
    5092:	0e 94 04 30 	call	0x6008	; 0x6008 <__mulsi3>
    5096:	2d 2d       	mov	r18, r13
    5098:	33 27       	eor	r19, r19
    509a:	27 fd       	sbrc	r18, 7
    509c:	30 95       	com	r19
    509e:	20 53       	subi	r18, 0x30	; 48
    50a0:	30 40       	sbci	r19, 0x00	; 0
    50a2:	79 01       	movw	r14, r18
    50a4:	00 27       	eor	r16, r16
    50a6:	f7 fc       	sbrc	r15, 7
    50a8:	00 95       	com	r16
    50aa:	10 2f       	mov	r17, r16
    50ac:	e6 0e       	add	r14, r22
    50ae:	f7 1e       	adc	r15, r23
    50b0:	08 1f       	adc	r16, r24
    50b2:	19 1f       	adc	r17, r25
    50b4:	08 94       	sec
    50b6:	a1 1c       	adc	r10, r1
    50b8:	b1 1c       	adc	r11, r1
    50ba:	d5 01       	movw	r26, r10
    50bc:	dc 90       	ld	r13, X
    50be:	8d 2d       	mov	r24, r13
    50c0:	80 53       	subi	r24, 0x30	; 48
    50c2:	8a 30       	cpi	r24, 0x0A	; 10
    50c4:	00 f3       	brcs	.-64     	; 0x5086 <rcfg_parseIP+0x4c>
    50c6:	9e 2c       	mov	r9, r14
    50c8:	88 24       	eor	r8, r8
    50ca:	77 24       	eor	r7, r7
    50cc:	66 24       	eor	r6, r6
    50ce:	be e2       	ldi	r27, 0x2E	; 46
    50d0:	db 16       	cp	r13, r27
    50d2:	e9 f0       	breq	.+58     	; 0x510e <rcfg_parseIP+0xd4>
    50d4:	20 e0       	ldi	r18, 0x00	; 0
    50d6:	30 e0       	ldi	r19, 0x00	; 0
    50d8:	40 e0       	ldi	r20, 0x00	; 0
    50da:	50 e0       	ldi	r21, 0x00	; 0
    50dc:	b9 01       	movw	r22, r18
    50de:	ca 01       	movw	r24, r20
    50e0:	28 96       	adiw	r28, 0x08	; 8
    50e2:	0f b6       	in	r0, 0x3f	; 63
    50e4:	f8 94       	cli
    50e6:	de bf       	out	0x3e, r29	; 62
    50e8:	0f be       	out	0x3f, r0	; 63
    50ea:	cd bf       	out	0x3d, r28	; 61
    50ec:	cf 91       	pop	r28
    50ee:	df 91       	pop	r29
    50f0:	1f 91       	pop	r17
    50f2:	0f 91       	pop	r16
    50f4:	ff 90       	pop	r15
    50f6:	ef 90       	pop	r14
    50f8:	df 90       	pop	r13
    50fa:	cf 90       	pop	r12
    50fc:	bf 90       	pop	r11
    50fe:	af 90       	pop	r10
    5100:	9f 90       	pop	r9
    5102:	8f 90       	pop	r8
    5104:	7f 90       	pop	r7
    5106:	6f 90       	pop	r6
    5108:	5f 90       	pop	r5
    510a:	4f 90       	pop	r4
    510c:	08 95       	ret
    510e:	65 01       	movw	r12, r10
    5110:	08 94       	sec
    5112:	c1 1c       	adc	r12, r1
    5114:	d1 1c       	adc	r13, r1
    5116:	f5 01       	movw	r30, r10
    5118:	b1 80       	ldd	r11, Z+1	; 0x01
    511a:	8b 2d       	mov	r24, r11
    511c:	80 53       	subi	r24, 0x30	; 48
    511e:	8a 30       	cpi	r24, 0x0A	; 10
    5120:	08 f0       	brcs	.+2      	; 0x5124 <rcfg_parseIP+0xea>
    5122:	b4 c0       	rjmp	.+360    	; 0x528c <rcfg_parseIP+0x252>
    5124:	ee 24       	eor	r14, r14
    5126:	ff 24       	eor	r15, r15
    5128:	87 01       	movw	r16, r14
    512a:	c8 01       	movw	r24, r16
    512c:	b7 01       	movw	r22, r14
    512e:	2a e0       	ldi	r18, 0x0A	; 10
    5130:	30 e0       	ldi	r19, 0x00	; 0
    5132:	40 e0       	ldi	r20, 0x00	; 0
    5134:	50 e0       	ldi	r21, 0x00	; 0
    5136:	0e 94 04 30 	call	0x6008	; 0x6008 <__mulsi3>
    513a:	2b 2d       	mov	r18, r11
    513c:	33 27       	eor	r19, r19
    513e:	27 fd       	sbrc	r18, 7
    5140:	30 95       	com	r19
    5142:	20 53       	subi	r18, 0x30	; 48
    5144:	30 40       	sbci	r19, 0x00	; 0
    5146:	79 01       	movw	r14, r18
    5148:	00 27       	eor	r16, r16
    514a:	f7 fc       	sbrc	r15, 7
    514c:	00 95       	com	r16
    514e:	10 2f       	mov	r17, r16
    5150:	e6 0e       	add	r14, r22
    5152:	f7 1e       	adc	r15, r23
    5154:	08 1f       	adc	r16, r24
    5156:	19 1f       	adc	r17, r25
    5158:	08 94       	sec
    515a:	c1 1c       	adc	r12, r1
    515c:	d1 1c       	adc	r13, r1
    515e:	d6 01       	movw	r26, r12
    5160:	bc 90       	ld	r11, X
    5162:	8b 2d       	mov	r24, r11
    5164:	80 53       	subi	r24, 0x30	; 48
    5166:	8a 30       	cpi	r24, 0x0A	; 10
    5168:	00 f3       	brcs	.-64     	; 0x512a <rcfg_parseIP+0xf0>
    516a:	d7 01       	movw	r26, r14
    516c:	99 27       	eor	r25, r25
    516e:	88 27       	eor	r24, r24
    5170:	89 83       	std	Y+1, r24	; 0x01
    5172:	9a 83       	std	Y+2, r25	; 0x02
    5174:	ab 83       	std	Y+3, r26	; 0x03
    5176:	bc 83       	std	Y+4, r27	; 0x04
    5178:	9e e2       	ldi	r25, 0x2E	; 46
    517a:	b9 16       	cp	r11, r25
    517c:	09 f0       	breq	.+2      	; 0x5180 <rcfg_parseIP+0x146>
    517e:	aa cf       	rjmp	.-172    	; 0x50d4 <rcfg_parseIP+0x9a>
    5180:	56 01       	movw	r10, r12
    5182:	08 94       	sec
    5184:	a1 1c       	adc	r10, r1
    5186:	b1 1c       	adc	r11, r1
    5188:	d6 01       	movw	r26, r12
    518a:	11 96       	adiw	r26, 0x01	; 1
    518c:	dc 90       	ld	r13, X
    518e:	8d 2d       	mov	r24, r13
    5190:	80 53       	subi	r24, 0x30	; 48
    5192:	8a 30       	cpi	r24, 0x0A	; 10
    5194:	08 f0       	brcs	.+2      	; 0x5198 <rcfg_parseIP+0x15e>
    5196:	7f c0       	rjmp	.+254    	; 0x5296 <rcfg_parseIP+0x25c>
    5198:	ee 24       	eor	r14, r14
    519a:	ff 24       	eor	r15, r15
    519c:	87 01       	movw	r16, r14
    519e:	c8 01       	movw	r24, r16
    51a0:	b7 01       	movw	r22, r14
    51a2:	2a e0       	ldi	r18, 0x0A	; 10
    51a4:	30 e0       	ldi	r19, 0x00	; 0
    51a6:	40 e0       	ldi	r20, 0x00	; 0
    51a8:	50 e0       	ldi	r21, 0x00	; 0
    51aa:	0e 94 04 30 	call	0x6008	; 0x6008 <__mulsi3>
    51ae:	2d 2d       	mov	r18, r13
    51b0:	33 27       	eor	r19, r19
    51b2:	27 fd       	sbrc	r18, 7
    51b4:	30 95       	com	r19
    51b6:	20 53       	subi	r18, 0x30	; 48
    51b8:	30 40       	sbci	r19, 0x00	; 0
    51ba:	79 01       	movw	r14, r18
    51bc:	00 27       	eor	r16, r16
    51be:	f7 fc       	sbrc	r15, 7
    51c0:	00 95       	com	r16
    51c2:	10 2f       	mov	r17, r16
    51c4:	e6 0e       	add	r14, r22
    51c6:	f7 1e       	adc	r15, r23
    51c8:	08 1f       	adc	r16, r24
    51ca:	19 1f       	adc	r17, r25
    51cc:	08 94       	sec
    51ce:	a1 1c       	adc	r10, r1
    51d0:	b1 1c       	adc	r11, r1
    51d2:	f5 01       	movw	r30, r10
    51d4:	d0 80       	ld	r13, Z
    51d6:	8d 2d       	mov	r24, r13
    51d8:	80 53       	subi	r24, 0x30	; 48
    51da:	8a 30       	cpi	r24, 0x0A	; 10
    51dc:	00 f3       	brcs	.-64     	; 0x519e <rcfg_parseIP+0x164>
    51de:	b0 2f       	mov	r27, r16
    51e0:	af 2d       	mov	r26, r15
    51e2:	9e 2d       	mov	r25, r14
    51e4:	88 27       	eor	r24, r24
    51e6:	8d 83       	std	Y+5, r24	; 0x05
    51e8:	9e 83       	std	Y+6, r25	; 0x06
    51ea:	af 83       	std	Y+7, r26	; 0x07
    51ec:	b8 87       	std	Y+8, r27	; 0x08
    51ee:	9e e2       	ldi	r25, 0x2E	; 46
    51f0:	d9 16       	cp	r13, r25
    51f2:	09 f0       	breq	.+2      	; 0x51f6 <rcfg_parseIP+0x1bc>
    51f4:	6f cf       	rjmp	.-290    	; 0x50d4 <rcfg_parseIP+0x9a>
    51f6:	65 01       	movw	r12, r10
    51f8:	08 94       	sec
    51fa:	c1 1c       	adc	r12, r1
    51fc:	d1 1c       	adc	r13, r1
    51fe:	d5 01       	movw	r26, r10
    5200:	11 96       	adiw	r26, 0x01	; 1
    5202:	bc 90       	ld	r11, X
    5204:	8b 2d       	mov	r24, r11
    5206:	80 53       	subi	r24, 0x30	; 48
    5208:	8a 30       	cpi	r24, 0x0A	; 10
    520a:	08 f0       	brcs	.+2      	; 0x520e <rcfg_parseIP+0x1d4>
    520c:	49 c0       	rjmp	.+146    	; 0x52a0 <rcfg_parseIP+0x266>
    520e:	ee 24       	eor	r14, r14
    5210:	ff 24       	eor	r15, r15
    5212:	87 01       	movw	r16, r14
    5214:	c8 01       	movw	r24, r16
    5216:	b7 01       	movw	r22, r14
    5218:	2a e0       	ldi	r18, 0x0A	; 10
    521a:	30 e0       	ldi	r19, 0x00	; 0
    521c:	40 e0       	ldi	r20, 0x00	; 0
    521e:	50 e0       	ldi	r21, 0x00	; 0
    5220:	0e 94 04 30 	call	0x6008	; 0x6008 <__mulsi3>
    5224:	2b 2d       	mov	r18, r11
    5226:	33 27       	eor	r19, r19
    5228:	27 fd       	sbrc	r18, 7
    522a:	30 95       	com	r19
    522c:	20 53       	subi	r18, 0x30	; 48
    522e:	30 40       	sbci	r19, 0x00	; 0
    5230:	79 01       	movw	r14, r18
    5232:	00 27       	eor	r16, r16
    5234:	f7 fc       	sbrc	r15, 7
    5236:	00 95       	com	r16
    5238:	10 2f       	mov	r17, r16
    523a:	e6 0e       	add	r14, r22
    523c:	f7 1e       	adc	r15, r23
    523e:	08 1f       	adc	r16, r24
    5240:	19 1f       	adc	r17, r25
    5242:	08 94       	sec
    5244:	c1 1c       	adc	r12, r1
    5246:	d1 1c       	adc	r13, r1
    5248:	f6 01       	movw	r30, r12
    524a:	b0 80       	ld	r11, Z
    524c:	8b 2d       	mov	r24, r11
    524e:	80 53       	subi	r24, 0x30	; 48
    5250:	8a 30       	cpi	r24, 0x0A	; 10
    5252:	00 f3       	brcs	.-64     	; 0x5214 <rcfg_parseIP+0x1da>
    5254:	29 81       	ldd	r18, Y+1	; 0x01
    5256:	3a 81       	ldd	r19, Y+2	; 0x02
    5258:	4b 81       	ldd	r20, Y+3	; 0x03
    525a:	5c 81       	ldd	r21, Y+4	; 0x04
    525c:	26 29       	or	r18, r6
    525e:	37 29       	or	r19, r7
    5260:	48 29       	or	r20, r8
    5262:	59 29       	or	r21, r9
    5264:	8d 81       	ldd	r24, Y+5	; 0x05
    5266:	9e 81       	ldd	r25, Y+6	; 0x06
    5268:	af 81       	ldd	r26, Y+7	; 0x07
    526a:	b8 85       	ldd	r27, Y+8	; 0x08
    526c:	28 2b       	or	r18, r24
    526e:	39 2b       	or	r19, r25
    5270:	4a 2b       	or	r20, r26
    5272:	5b 2b       	or	r21, r27
    5274:	2e 29       	or	r18, r14
    5276:	3f 29       	or	r19, r15
    5278:	40 2b       	or	r20, r16
    527a:	51 2b       	or	r21, r17
    527c:	d2 01       	movw	r26, r4
    527e:	cd 92       	st	X+, r12
    5280:	dc 92       	st	X, r13
    5282:	2c cf       	rjmp	.-424    	; 0x50dc <rcfg_parseIP+0xa2>
    5284:	66 24       	eor	r6, r6
    5286:	77 24       	eor	r7, r7
    5288:	43 01       	movw	r8, r6
    528a:	21 cf       	rjmp	.-446    	; 0x50ce <rcfg_parseIP+0x94>
    528c:	19 82       	std	Y+1, r1	; 0x01
    528e:	1a 82       	std	Y+2, r1	; 0x02
    5290:	1b 82       	std	Y+3, r1	; 0x03
    5292:	1c 82       	std	Y+4, r1	; 0x04
    5294:	71 cf       	rjmp	.-286    	; 0x5178 <rcfg_parseIP+0x13e>
    5296:	1d 82       	std	Y+5, r1	; 0x05
    5298:	1e 82       	std	Y+6, r1	; 0x06
    529a:	1f 82       	std	Y+7, r1	; 0x07
    529c:	18 86       	std	Y+8, r1	; 0x08
    529e:	a7 cf       	rjmp	.-178    	; 0x51ee <rcfg_parseIP+0x1b4>
    52a0:	ee 24       	eor	r14, r14
    52a2:	ff 24       	eor	r15, r15
    52a4:	87 01       	movw	r16, r14
    52a6:	d6 cf       	rjmp	.-84     	; 0x5254 <rcfg_parseIP+0x21a>

000052a8 <onRtpControl>:
  {":DISABLE", rcfg_Disable},
  {"", NULL} // end-of-table -- do not delete this line!
};

void onRtpControl(char* buf, uint8_t len)
{
    52a8:	1f 93       	push	r17
    52aa:	cf 93       	push	r28
    52ac:	df 93       	push	r29
    52ae:	ec 01       	movw	r28, r24
    52b0:	16 2f       	mov	r17, r22



  // check if rcfg has been disabled using ":DISABLE?"
  if (Config_is_Disabled()) {
    52b2:	0e 94 15 1b 	call	0x362a	; 0x362a <Config_is_Disabled>
    52b6:	88 23       	and	r24, r24
    52b8:	09 f0       	breq	.+2      	; 0x52bc <onRtpControl+0x14>
    52ba:	84 c0       	rjmp	.+264    	; 0x53c4 <onRtpControl+0x11c>
  }


  // some syntax checks
  uint8_t pos = 1;
  while (pos < len)
    52bc:	12 30       	cpi	r17, 0x02	; 2
    52be:	08 f4       	brcc	.+2      	; 0x52c2 <onRtpControl+0x1a>
    52c0:	d2 c0       	rjmp	.+420    	; 0x5466 <onRtpControl+0x1be>
  {
    if (buf[pos] == '?')
    52c2:	89 81       	ldd	r24, Y+1	; 0x01
    52c4:	8f 33       	cpi	r24, 0x3F	; 63
    52c6:	61 f0       	breq	.+24     	; 0x52e0 <onRtpControl+0x38>
    52c8:	fe 01       	movw	r30, r28
    52ca:	91 e0       	ldi	r25, 0x01	; 1
    52cc:	04 c0       	rjmp	.+8      	; 0x52d6 <onRtpControl+0x2e>
    52ce:	82 81       	ldd	r24, Z+2	; 0x02
    52d0:	31 96       	adiw	r30, 0x01	; 1
    52d2:	8f 33       	cpi	r24, 0x3F	; 63
    52d4:	19 f0       	breq	.+6      	; 0x52dc <onRtpControl+0x34>
    {
      break;
    }
    pos++;
    52d6:	9f 5f       	subi	r25, 0xFF	; 255
  }


  // some syntax checks
  uint8_t pos = 1;
  while (pos < len)
    52d8:	91 17       	cp	r25, r17
    52da:	c8 f3       	brcs	.-14     	; 0x52ce <onRtpControl+0x26>
  }
  
 


  if (pos == len || buf[0] != ':')
    52dc:	91 17       	cp	r25, r17
    52de:	19 f0       	breq	.+6      	; 0x52e6 <onRtpControl+0x3e>
    52e0:	88 81       	ld	r24, Y
    52e2:	8a 33       	cpi	r24, 0x3A	; 58
    52e4:	a9 f0       	breq	.+42     	; 0x5310 <onRtpControl+0x68>
  {
    putString_com1("\r\nonRtpControl() Syntax Error,sent:");
    52e6:	86 e4       	ldi	r24, 0x46	; 70
    52e8:	95 e0       	ldi	r25, 0x05	; 5
    52ea:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
	putString_com1(buf);
    52ee:	ce 01       	movw	r24, r28
    52f0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    // '?' not found or ':' missing
    rtpSendCommand("Syntax Error\n", 13, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    52f4:	8a e6       	ldi	r24, 0x6A	; 106
    52f6:	95 e0       	ldi	r25, 0x05	; 5
    52f8:	6d e0       	ldi	r22, 0x0D	; 13
    52fa:	70 e0       	ldi	r23, 0x00	; 0
    52fc:	45 e8       	ldi	r20, 0x85	; 133
    52fe:	59 e0       	ldi	r21, 0x09	; 9
    5300:	2b e8       	ldi	r18, 0x8B	; 139
    5302:	39 e0       	ldi	r19, 0x09	; 9
    5304:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
  // command not found
  rtpSendCommand("Error located between ears of user.\n", 36, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);    
  return;

  
}
    5308:	df 91       	pop	r29
    530a:	cf 91       	pop	r28
    530c:	1f 91       	pop	r17
    530e:	08 95       	ret
    return;
  }
  
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    5310:	60 91 68 07 	lds	r22, 0x0768
    5314:	70 91 69 07 	lds	r23, 0x0769
    5318:	61 15       	cp	r22, r1
    531a:	71 05       	cpc	r23, r1
    531c:	09 f4       	brne	.+2      	; 0x5320 <onRtpControl+0x78>
    531e:	3d c0       	rjmp	.+122    	; 0x539a <onRtpControl+0xf2>
    5320:	50 e0       	ldi	r21, 0x00	; 0
    5322:	a0 e0       	ldi	r26, 0x00	; 0
    5324:	b0 e0       	ldi	r27, 0x00	; 0
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    5326:	1a e3       	ldi	r17, 0x3A	; 58
    5328:	aa 0f       	add	r26, r26
    532a:	bb 1f       	adc	r27, r27
    532c:	aa 0f       	add	r26, r26
    532e:	bb 1f       	adc	r27, r27
    5330:	aa 59       	subi	r26, 0x9A	; 154
    5332:	b8 4f       	sbci	r27, 0xF8	; 248
    5334:	0d 90       	ld	r0, X+
    5336:	bc 91       	ld	r27, X
    5338:	a0 2d       	mov	r26, r0
    533a:	4c 91       	ld	r20, X
    533c:	84 2f       	mov	r24, r20
    533e:	81 27       	eor	r24, r17
    5340:	8f 75       	andi	r24, 0x5F	; 95
    5342:	09 f0       	breq	.+2      	; 0x5346 <onRtpControl+0x9e>
    5344:	5b c0       	rjmp	.+182    	; 0x53fc <onRtpControl+0x154>
	putString_com1(buf);
    // '?' not found or ':' missing
    rtpSendCommand("Syntax Error\n", 13, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);

	
    return;
    5346:	90 e0       	ldi	r25, 0x00	; 0
    5348:	02 c0       	rjmp	.+4      	; 0x534e <onRtpControl+0xa6>
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    534a:	e0 32       	cpi	r30, 0x20	; 32
    534c:	79 f0       	breq	.+30     	; 0x536c <onRtpControl+0xc4>
	  pos++;
    534e:	9f 5f       	subi	r25, 0xFF	; 255
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    5350:	29 2f       	mov	r18, r25
    5352:	30 e0       	ldi	r19, 0x00	; 0
    5354:	fd 01       	movw	r30, r26
    5356:	e2 0f       	add	r30, r18
    5358:	f3 1f       	adc	r31, r19
    535a:	40 81       	ld	r20, Z
    535c:	fe 01       	movw	r30, r28
    535e:	e2 0f       	add	r30, r18
    5360:	f3 1f       	adc	r31, r19
    5362:	e0 81       	ld	r30, Z
    5364:	8e 2f       	mov	r24, r30
    5366:	84 27       	eor	r24, r20
    5368:	8f 75       	andi	r24, 0x5F	; 95
    536a:	79 f3       	breq	.-34     	; 0x534a <onRtpControl+0xa2>
	  pos++;
	}
	if (rcfg_commands[cmd].name[pos] == 0 && (buf[pos]==' ' || buf[pos]=='?') ) {
    536c:	44 23       	and	r20, r20
    536e:	31 f4       	brne	.+12     	; 0x537c <onRtpControl+0xd4>
    5370:	e0 32       	cpi	r30, 0x20	; 32
    5372:	09 f4       	brne	.+2      	; 0x5376 <onRtpControl+0xce>
    5374:	47 c0       	rjmp	.+142    	; 0x5404 <onRtpControl+0x15c>
    5376:	ef 33       	cpi	r30, 0x3F	; 63
    5378:	09 f4       	brne	.+2      	; 0x537c <onRtpControl+0xd4>
    537a:	44 c0       	rjmp	.+136    	; 0x5404 <onRtpControl+0x15c>

	  return;
	}
	
	// compare to next command
	cmd++;
    537c:	5f 5f       	subi	r21, 0xFF	; 255
    return;
  }
  
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    537e:	a5 2f       	mov	r26, r21
    5380:	b0 e0       	ldi	r27, 0x00	; 0
    5382:	fd 01       	movw	r30, r26
    5384:	ee 0f       	add	r30, r30
    5386:	ff 1f       	adc	r31, r31
    5388:	ee 0f       	add	r30, r30
    538a:	ff 1f       	adc	r31, r31
    538c:	e8 59       	subi	r30, 0x98	; 152
    538e:	f8 4f       	sbci	r31, 0xF8	; 248
    5390:	60 81       	ld	r22, Z
    5392:	71 81       	ldd	r23, Z+1	; 0x01
    5394:	61 15       	cp	r22, r1
    5396:	71 05       	cpc	r23, r1
    5398:	39 f6       	brne	.-114    	; 0x5328 <onRtpControl+0x80>
	// compare to next command
	cmd++;
  }


  putString_com1("onRtpControl() Command not found, sent:");
    539a:	86 eb       	ldi	r24, 0xB6	; 182
    539c:	95 e0       	ldi	r25, 0x05	; 5
    539e:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
 putString_com1(buf);
    53a2:	ce 01       	movw	r24, r28
    53a4:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  // command not found
  rtpSendCommand("Error located between ears of user.\n", 36, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);    
    53a8:	8e ed       	ldi	r24, 0xDE	; 222
    53aa:	95 e0       	ldi	r25, 0x05	; 5
    53ac:	64 e2       	ldi	r22, 0x24	; 36
    53ae:	70 e0       	ldi	r23, 0x00	; 0
    53b0:	45 e8       	ldi	r20, 0x85	; 133
    53b2:	59 e0       	ldi	r21, 0x09	; 9
    53b4:	2b e8       	ldi	r18, 0x8B	; 139
    53b6:	39 e0       	ldi	r19, 0x09	; 9
    53b8:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
  return;

  
}
    53bc:	df 91       	pop	r29
    53be:	cf 91       	pop	r28
    53c0:	1f 91       	pop	r17
    53c2:	08 95       	ret



  // check if rcfg has been disabled using ":DISABLE?"
  if (Config_is_Disabled()) {
    rtpSendCommand("Config has been disabled.", 25, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    53c4:	81 e0       	ldi	r24, 0x01	; 1
    53c6:	95 e0       	ldi	r25, 0x05	; 5
    53c8:	69 e1       	ldi	r22, 0x19	; 25
    53ca:	70 e0       	ldi	r23, 0x00	; 0
    53cc:	45 e8       	ldi	r20, 0x85	; 133
    53ce:	59 e0       	ldi	r21, 0x09	; 9
    53d0:	2b e8       	ldi	r18, 0x8B	; 139
    53d2:	39 e0       	ldi	r19, 0x09	; 9
    53d4:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
    rtpSendCommand("FAIL\n", 5, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    53d8:	8b e1       	ldi	r24, 0x1B	; 27
    53da:	95 e0       	ldi	r25, 0x05	; 5
    53dc:	65 e0       	ldi	r22, 0x05	; 5
    53de:	70 e0       	ldi	r23, 0x00	; 0
    53e0:	45 e8       	ldi	r20, 0x85	; 133
    53e2:	59 e0       	ldi	r21, 0x09	; 9
    53e4:	2b e8       	ldi	r18, 0x8B	; 139
    53e6:	39 e0       	ldi	r19, 0x09	; 9
    53e8:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
	putString_com1("\r\nonRtpControl() Config_is_Disabled:");
    53ec:	81 e2       	ldi	r24, 0x21	; 33
    53ee:	95 e0       	ldi	r25, 0x05	; 5
    53f0:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
  // command not found
  rtpSendCommand("Error located between ears of user.\n", 36, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);    
  return;

  
}
    53f4:	df 91       	pop	r29
    53f6:	cf 91       	pop	r28
    53f8:	1f 91       	pop	r17
    53fa:	08 95       	ret
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    53fc:	ea e3       	ldi	r30, 0x3A	; 58
    53fe:	20 e0       	ldi	r18, 0x00	; 0
    5400:	30 e0       	ldi	r19, 0x00	; 0
    5402:	b4 cf       	rjmp	.-152    	; 0x536c <onRtpControl+0xc4>
	  pos++;
	}
	if (rcfg_commands[cmd].name[pos] == 0 && (buf[pos]==' ' || buf[pos]=='?') ) {
	  // command found
      while(buf[pos] == ' ')
    5404:	de 01       	movw	r26, r28
    5406:	a2 0f       	add	r26, r18
    5408:	b3 1f       	adc	r27, r19
    540a:	8c 91       	ld	r24, X
    540c:	80 32       	cpi	r24, 0x20	; 32
    540e:	41 f4       	brne	.+16     	; 0x5420 <onRtpControl+0x178>
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
	  pos++;
	}
	if (rcfg_commands[cmd].name[pos] == 0 && (buf[pos]==' ' || buf[pos]=='?') ) {
    5410:	f9 01       	movw	r30, r18
    5412:	31 96       	adiw	r30, 0x01	; 1
    5414:	ec 0f       	add	r30, r28
    5416:	fd 1f       	adc	r31, r29
    5418:	df 01       	movw	r26, r30
	  // command found
      while(buf[pos] == ' ')
    541a:	81 91       	ld	r24, Z+
    541c:	80 32       	cpi	r24, 0x20	; 32
    541e:	e1 f3       	breq	.-8      	; 0x5418 <onRtpControl+0x170>
	    buf++;
      //rtpSendCommand(&rcfg_commands[cmd].name[0], 8, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort); // debug
      // execute command

      uint8_t rv;
      rv = rcfg_commands[cmd].func(&buf[pos]);
    5420:	cd 01       	movw	r24, r26
    5422:	fb 01       	movw	r30, r22
    5424:	09 95       	icall
  


      // send ack
      if (rv == RCFG_SUCCESS ) 
    5426:	88 23       	and	r24, r24
    5428:	79 f4       	brne	.+30     	; 0x5448 <onRtpControl+0x1a0>
	  {
        rtpSendCommand("OK\n", 3, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    542a:	88 e7       	ldi	r24, 0x78	; 120
    542c:	95 e0       	ldi	r25, 0x05	; 5
    542e:	63 e0       	ldi	r22, 0x03	; 3
    5430:	70 e0       	ldi	r23, 0x00	; 0
    5432:	45 e8       	ldi	r20, 0x85	; 133
    5434:	59 e0       	ldi	r21, 0x09	; 9
    5436:	2b e8       	ldi	r18, 0x8B	; 139
    5438:	39 e0       	ldi	r19, 0x09	; 9
    543a:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
		putString_com1("\r\nonRtpControl() meldet OK:");
    543e:	8c e7       	ldi	r24, 0x7C	; 124
    5440:	95 e0       	ldi	r25, 0x05	; 5
    5442:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    5446:	60 cf       	rjmp	.-320    	; 0x5308 <onRtpControl+0x60>
      } 
	  else 
	  {
        rtpSendCommand("FAIL\n", 5, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    5448:	8b e1       	ldi	r24, 0x1B	; 27
    544a:	95 e0       	ldi	r25, 0x05	; 5
    544c:	65 e0       	ldi	r22, 0x05	; 5
    544e:	70 e0       	ldi	r23, 0x00	; 0
    5450:	45 e8       	ldi	r20, 0x85	; 133
    5452:	59 e0       	ldi	r21, 0x09	; 9
    5454:	2b e8       	ldi	r18, 0x8B	; 139
    5456:	39 e0       	ldi	r19, 0x09	; 9
    5458:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
		putString_com1("\r\nonRtpControl() meldet FAIL:");
    545c:	88 e9       	ldi	r24, 0x98	; 152
    545e:	95 e0       	ldi	r25, 0x05	; 5
    5460:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <putString_com1>
    5464:	51 cf       	rjmp	.-350    	; 0x5308 <onRtpControl+0x60>
  }


  // some syntax checks
  uint8_t pos = 1;
  while (pos < len)
    5466:	91 e0       	ldi	r25, 0x01	; 1
    5468:	39 cf       	rjmp	.-398    	; 0x52dc <onRtpControl+0x34>

0000546a <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    546a:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    546c:	e1 99       	sbic	0x1c, 1	; 28
    546e:	fe cf       	rjmp	.-4      	; 0x546c <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    5470:	3f bb       	out	0x1f, r19	; 31
    5472:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5474:	e0 9a       	sbi	0x1c, 0	; 28
    5476:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    5478:	08 95       	ret

0000547a <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    547a:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    547c:	e1 99       	sbic	0x1c, 1	; 28
    547e:	fe cf       	rjmp	.-4      	; 0x547c <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    5480:	3f bb       	out	0x1f, r19	; 31
    5482:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    5484:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    5486:	0f b6       	in	r0, 0x3f	; 63
    5488:	f8 94       	cli
    548a:	e2 9a       	sbi	0x1c, 2	; 28
    548c:	e1 9a       	sbi	0x1c, 1	; 28
    548e:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    5490:	08 95       	ret

00005492 <EepromWriteConfig>:
    5492:	af 92       	push	r10
    5494:	bf 92       	push	r11
    5496:	cf 92       	push	r12
    5498:	df 92       	push	r13
    549a:	ef 92       	push	r14
    549c:	ff 92       	push	r15
    549e:	0f 93       	push	r16
    54a0:	1f 93       	push	r17
    54a2:	df 93       	push	r29
    54a4:	cf 93       	push	r28
    54a6:	00 d0       	rcall	.+0      	; 0x54a8 <EepromWriteConfig+0x16>
    54a8:	00 d0       	rcall	.+0      	; 0x54aa <EepromWriteConfig+0x18>
    54aa:	cd b7       	in	r28, 0x3d	; 61
    54ac:	de b7       	in	r29, 0x3e	; 62
    54ae:	5c 01       	movw	r10, r24
    54b0:	7b 01       	movw	r14, r22
    54b2:	04 2f       	mov	r16, r20
    54b4:	10 e0       	ldi	r17, 0x00	; 0
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    54b6:	8d e3       	ldi	r24, 0x3D	; 61
    54b8:	c8 2e       	mov	r12, r24
    54ba:	8a e2       	ldi	r24, 0x2A	; 42
    54bc:	d8 2e       	mov	r13, r24
    54be:	c5 01       	movw	r24, r10
    54c0:	a8 01       	movw	r20, r16
    54c2:	96 01       	movw	r18, r12
    54c4:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <__eewr_block>
    54c8:	c7 01       	movw	r24, r14
    54ca:	b8 01       	movw	r22, r16
    54cc:	0e 94 bd 1a 	call	0x357a	; 0x357a <calculateCheckSum>
    54d0:	9a 83       	std	Y+2, r25	; 0x02
    54d2:	89 83       	std	Y+1, r24	; 0x01
    54d4:	80 95       	com	r24
    54d6:	90 95       	com	r25
    54d8:	9c 83       	std	Y+4, r25	; 0x04
    54da:	8b 83       	std	Y+3, r24	; 0x03
    54dc:	c5 01       	movw	r24, r10
    54de:	80 0f       	add	r24, r16
    54e0:	91 1f       	adc	r25, r17
    54e2:	be 01       	movw	r22, r28
    54e4:	6f 5f       	subi	r22, 0xFF	; 255
    54e6:	7f 4f       	sbci	r23, 0xFF	; 255
    54e8:	44 e0       	ldi	r20, 0x04	; 4
    54ea:	50 e0       	ldi	r21, 0x00	; 0
    54ec:	96 01       	movw	r18, r12
    54ee:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <__eewr_block>
    54f2:	0f 90       	pop	r0
    54f4:	0f 90       	pop	r0
    54f6:	0f 90       	pop	r0
    54f8:	0f 90       	pop	r0
    54fa:	cf 91       	pop	r28
    54fc:	df 91       	pop	r29
    54fe:	1f 91       	pop	r17
    5500:	0f 91       	pop	r16
    5502:	ff 90       	pop	r15
    5504:	ef 90       	pop	r14
    5506:	df 90       	pop	r13
    5508:	cf 90       	pop	r12
    550a:	bf 90       	pop	r11
    550c:	af 90       	pop	r10
    550e:	08 95       	ret

00005510 <EepromReadConfig>:
    5510:	cf 92       	push	r12
    5512:	df 92       	push	r13
    5514:	ef 92       	push	r14
    5516:	ff 92       	push	r15
    5518:	0f 93       	push	r16
    551a:	1f 93       	push	r17
    551c:	df 93       	push	r29
    551e:	cf 93       	push	r28
    5520:	00 d0       	rcall	.+0      	; 0x5522 <EepromReadConfig+0x12>
    5522:	00 d0       	rcall	.+0      	; 0x5524 <EepromReadConfig+0x14>
    5524:	cd b7       	in	r28, 0x3d	; 61
    5526:	de b7       	in	r29, 0x3e	; 62
    5528:	8c 01       	movw	r16, r24
    552a:	6b 01       	movw	r12, r22
    552c:	e1 99       	sbic	0x1c, 1	; 28
    552e:	fe cf       	rjmp	.-4      	; 0x552c <EepromReadConfig+0x1c>
    5530:	e4 2e       	mov	r14, r20
    5532:	ff 24       	eor	r15, r15
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    5534:	c6 01       	movw	r24, r12
    5536:	b8 01       	movw	r22, r16
    5538:	a7 01       	movw	r20, r14
    553a:	25 e3       	ldi	r18, 0x35	; 53
    553c:	3a e2       	ldi	r19, 0x2A	; 42
    553e:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    5542:	0e 0d       	add	r16, r14
    5544:	1f 1d       	adc	r17, r15
    5546:	ce 01       	movw	r24, r28
    5548:	01 96       	adiw	r24, 0x01	; 1
    554a:	b8 01       	movw	r22, r16
    554c:	44 e0       	ldi	r20, 0x04	; 4
    554e:	50 e0       	ldi	r21, 0x00	; 0
    5550:	25 e3       	ldi	r18, 0x35	; 53
    5552:	3a e2       	ldi	r19, 0x2A	; 42
    5554:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    5558:	8b 81       	ldd	r24, Y+3	; 0x03
    555a:	9c 81       	ldd	r25, Y+4	; 0x04
    555c:	80 95       	com	r24
    555e:	90 95       	com	r25
    5560:	29 81       	ldd	r18, Y+1	; 0x01
    5562:	3a 81       	ldd	r19, Y+2	; 0x02
    5564:	28 17       	cp	r18, r24
    5566:	39 07       	cpc	r19, r25
    5568:	79 f0       	breq	.+30     	; 0x5588 <EepromReadConfig+0x78>
    556a:	40 e0       	ldi	r20, 0x00	; 0
    556c:	84 2f       	mov	r24, r20
    556e:	0f 90       	pop	r0
    5570:	0f 90       	pop	r0
    5572:	0f 90       	pop	r0
    5574:	0f 90       	pop	r0
    5576:	cf 91       	pop	r28
    5578:	df 91       	pop	r29
    557a:	1f 91       	pop	r17
    557c:	0f 91       	pop	r16
    557e:	ff 90       	pop	r15
    5580:	ef 90       	pop	r14
    5582:	df 90       	pop	r13
    5584:	cf 90       	pop	r12
    5586:	08 95       	ret
    5588:	c6 01       	movw	r24, r12
    558a:	b7 01       	movw	r22, r14
    558c:	0e 94 bd 1a 	call	0x357a	; 0x357a <calculateCheckSum>
    5590:	40 e0       	ldi	r20, 0x00	; 0
    5592:	29 81       	ldd	r18, Y+1	; 0x01
    5594:	3a 81       	ldd	r19, Y+2	; 0x02
    5596:	82 17       	cp	r24, r18
    5598:	93 07       	cpc	r25, r19
    559a:	41 f7       	brne	.-48     	; 0x556c <EepromReadConfig+0x5c>
    559c:	41 e0       	ldi	r20, 0x01	; 1
    559e:	e6 cf       	rjmp	.-52     	; 0x556c <EepromReadConfig+0x5c>

000055a0 <configEepromGetConfig>:
    55a0:	4f 92       	push	r4
    55a2:	5f 92       	push	r5
    55a4:	6f 92       	push	r6
    55a6:	7f 92       	push	r7
    55a8:	8f 92       	push	r8
    55aa:	9f 92       	push	r9
    55ac:	af 92       	push	r10
    55ae:	bf 92       	push	r11
    55b0:	cf 92       	push	r12
    55b2:	df 92       	push	r13
    55b4:	ef 92       	push	r14
    55b6:	ff 92       	push	r15
    55b8:	0f 93       	push	r16
    55ba:	1f 93       	push	r17
    55bc:	df 93       	push	r29
    55be:	cf 93       	push	r28
    55c0:	cd b7       	in	r28, 0x3d	; 61
    55c2:	de b7       	in	r29, 0x3e	; 62
    55c4:	62 97       	sbiw	r28, 0x12	; 18
    55c6:	0f b6       	in	r0, 0x3f	; 63
    55c8:	f8 94       	cli
    55ca:	de bf       	out	0x3e, r29	; 62
    55cc:	0f be       	out	0x3f, r0	; 63
    55ce:	cd bf       	out	0x3d, r28	; 61
    55d0:	6c 01       	movw	r12, r24
    55d2:	5b 01       	movw	r10, r22
    55d4:	4a 01       	movw	r8, r20
    55d6:	39 01       	movw	r6, r18
    55d8:	28 01       	movw	r4, r16
    55da:	e1 99       	sbic	0x1c, 1	; 28
    55dc:	fe cf       	rjmp	.-4      	; 0x55da <configEepromGetConfig+0x3a>
    55de:	8e 01       	movw	r16, r28
    55e0:	0b 5f       	subi	r16, 0xFB	; 251
    55e2:	1f 4f       	sbci	r17, 0xFF	; 255
    55e4:	c8 01       	movw	r24, r16
    55e6:	60 e0       	ldi	r22, 0x00	; 0
    55e8:	74 e0       	ldi	r23, 0x04	; 4
    55ea:	4e e0       	ldi	r20, 0x0E	; 14
    55ec:	50 e0       	ldi	r21, 0x00	; 0
    55ee:	25 e3       	ldi	r18, 0x35	; 53
    55f0:	3a e2       	ldi	r19, 0x2A	; 42
    55f2:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    55f6:	ce 01       	movw	r24, r28
    55f8:	01 96       	adiw	r24, 0x01	; 1
    55fa:	6e e0       	ldi	r22, 0x0E	; 14
    55fc:	74 e0       	ldi	r23, 0x04	; 4
    55fe:	44 e0       	ldi	r20, 0x04	; 4
    5600:	50 e0       	ldi	r21, 0x00	; 0
    5602:	25 e3       	ldi	r18, 0x35	; 53
    5604:	3a e2       	ldi	r19, 0x2A	; 42
    5606:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    560a:	8b 81       	ldd	r24, Y+3	; 0x03
    560c:	9c 81       	ldd	r25, Y+4	; 0x04
    560e:	80 95       	com	r24
    5610:	90 95       	com	r25
    5612:	29 81       	ldd	r18, Y+1	; 0x01
    5614:	3a 81       	ldd	r19, Y+2	; 0x02
    5616:	28 17       	cp	r18, r24
    5618:	39 07       	cpc	r19, r25
    561a:	09 f4       	brne	.+2      	; 0x561e <configEepromGetConfig+0x7e>
    561c:	97 c0       	rjmp	.+302    	; 0x574c <configEepromGetConfig+0x1ac>
    561e:	d8 01       	movw	r26, r16
    5620:	ef e7       	ldi	r30, 0x7F	; 127
    5622:	f9 e0       	ldi	r31, 0x09	; 9
    5624:	8e e0       	ldi	r24, 0x0E	; 14
    5626:	01 90       	ld	r0, Z+
    5628:	0d 92       	st	X+, r0
    562a:	81 50       	subi	r24, 0x01	; 1
    562c:	e1 f7       	brne	.-8      	; 0x5626 <configEepromGetConfig+0x86>
    562e:	c1 14       	cp	r12, r1
    5630:	d1 04       	cpc	r13, r1
    5632:	69 f1       	breq	.+90     	; 0x568e <configEepromGetConfig+0xee>
    5634:	2d 81       	ldd	r18, Y+5	; 0x05
    5636:	3e 81       	ldd	r19, Y+6	; 0x06
    5638:	4f 81       	ldd	r20, Y+7	; 0x07
    563a:	58 85       	ldd	r21, Y+8	; 0x08
    563c:	12 2f       	mov	r17, r18
    563e:	00 27       	eor	r16, r16
    5640:	ff 24       	eor	r15, r15
    5642:	ee 24       	eor	r14, r14
    5644:	85 2f       	mov	r24, r21
    5646:	99 27       	eor	r25, r25
    5648:	aa 27       	eor	r26, r26
    564a:	bb 27       	eor	r27, r27
    564c:	e8 2a       	or	r14, r24
    564e:	f9 2a       	or	r15, r25
    5650:	0a 2b       	or	r16, r26
    5652:	1b 2b       	or	r17, r27
    5654:	da 01       	movw	r26, r20
    5656:	c9 01       	movw	r24, r18
    5658:	80 70       	andi	r24, 0x00	; 0
    565a:	90 70       	andi	r25, 0x00	; 0
    565c:	b0 70       	andi	r27, 0x00	; 0
    565e:	89 2f       	mov	r24, r25
    5660:	9a 2f       	mov	r25, r26
    5662:	ab 2f       	mov	r26, r27
    5664:	bb 27       	eor	r27, r27
    5666:	e8 2a       	or	r14, r24
    5668:	f9 2a       	or	r15, r25
    566a:	0a 2b       	or	r16, r26
    566c:	1b 2b       	or	r17, r27
    566e:	20 70       	andi	r18, 0x00	; 0
    5670:	40 70       	andi	r20, 0x00	; 0
    5672:	50 70       	andi	r21, 0x00	; 0
    5674:	54 2f       	mov	r21, r20
    5676:	43 2f       	mov	r20, r19
    5678:	32 2f       	mov	r19, r18
    567a:	22 27       	eor	r18, r18
    567c:	e2 2a       	or	r14, r18
    567e:	f3 2a       	or	r15, r19
    5680:	04 2b       	or	r16, r20
    5682:	15 2b       	or	r17, r21
    5684:	f6 01       	movw	r30, r12
    5686:	e0 82       	st	Z, r14
    5688:	f1 82       	std	Z+1, r15	; 0x01
    568a:	02 83       	std	Z+2, r16	; 0x02
    568c:	13 83       	std	Z+3, r17	; 0x03
    568e:	a1 14       	cp	r10, r1
    5690:	b1 04       	cpc	r11, r1
    5692:	29 f0       	breq	.+10     	; 0x569e <configEepromGetConfig+0xfe>
    5694:	89 85       	ldd	r24, Y+9	; 0x09
    5696:	9a 85       	ldd	r25, Y+10	; 0x0a
    5698:	f5 01       	movw	r30, r10
    569a:	91 83       	std	Z+1, r25	; 0x01
    569c:	80 83       	st	Z, r24
    569e:	81 14       	cp	r8, r1
    56a0:	91 04       	cpc	r9, r1
    56a2:	69 f1       	breq	.+90     	; 0x56fe <configEepromGetConfig+0x15e>
    56a4:	2b 85       	ldd	r18, Y+11	; 0x0b
    56a6:	3c 85       	ldd	r19, Y+12	; 0x0c
    56a8:	4d 85       	ldd	r20, Y+13	; 0x0d
    56aa:	5e 85       	ldd	r21, Y+14	; 0x0e
    56ac:	12 2f       	mov	r17, r18
    56ae:	00 27       	eor	r16, r16
    56b0:	ff 24       	eor	r15, r15
    56b2:	ee 24       	eor	r14, r14
    56b4:	85 2f       	mov	r24, r21
    56b6:	99 27       	eor	r25, r25
    56b8:	aa 27       	eor	r26, r26
    56ba:	bb 27       	eor	r27, r27
    56bc:	e8 2a       	or	r14, r24
    56be:	f9 2a       	or	r15, r25
    56c0:	0a 2b       	or	r16, r26
    56c2:	1b 2b       	or	r17, r27
    56c4:	da 01       	movw	r26, r20
    56c6:	c9 01       	movw	r24, r18
    56c8:	80 70       	andi	r24, 0x00	; 0
    56ca:	90 70       	andi	r25, 0x00	; 0
    56cc:	b0 70       	andi	r27, 0x00	; 0
    56ce:	89 2f       	mov	r24, r25
    56d0:	9a 2f       	mov	r25, r26
    56d2:	ab 2f       	mov	r26, r27
    56d4:	bb 27       	eor	r27, r27
    56d6:	e8 2a       	or	r14, r24
    56d8:	f9 2a       	or	r15, r25
    56da:	0a 2b       	or	r16, r26
    56dc:	1b 2b       	or	r17, r27
    56de:	20 70       	andi	r18, 0x00	; 0
    56e0:	40 70       	andi	r20, 0x00	; 0
    56e2:	50 70       	andi	r21, 0x00	; 0
    56e4:	54 2f       	mov	r21, r20
    56e6:	43 2f       	mov	r20, r19
    56e8:	32 2f       	mov	r19, r18
    56ea:	22 27       	eor	r18, r18
    56ec:	e2 2a       	or	r14, r18
    56ee:	f3 2a       	or	r15, r19
    56f0:	04 2b       	or	r16, r20
    56f2:	15 2b       	or	r17, r21
    56f4:	f4 01       	movw	r30, r8
    56f6:	e0 82       	st	Z, r14
    56f8:	f1 82       	std	Z+1, r15	; 0x01
    56fa:	02 83       	std	Z+2, r16	; 0x02
    56fc:	13 83       	std	Z+3, r17	; 0x03
    56fe:	61 14       	cp	r6, r1
    5700:	71 04       	cpc	r7, r1
    5702:	29 f0       	breq	.+10     	; 0x570e <configEepromGetConfig+0x16e>
    5704:	8f 85       	ldd	r24, Y+15	; 0x0f
    5706:	98 89       	ldd	r25, Y+16	; 0x10
    5708:	f3 01       	movw	r30, r6
    570a:	91 83       	std	Z+1, r25	; 0x01
    570c:	80 83       	st	Z, r24
    570e:	41 14       	cp	r4, r1
    5710:	51 04       	cpc	r5, r1
    5712:	29 f0       	breq	.+10     	; 0x571e <configEepromGetConfig+0x17e>
    5714:	89 89       	ldd	r24, Y+17	; 0x11
    5716:	9a 89       	ldd	r25, Y+18	; 0x12
    5718:	f2 01       	movw	r30, r4
    571a:	91 83       	std	Z+1, r25	; 0x01
    571c:	80 83       	st	Z, r24
    571e:	62 96       	adiw	r28, 0x12	; 18
    5720:	0f b6       	in	r0, 0x3f	; 63
    5722:	f8 94       	cli
    5724:	de bf       	out	0x3e, r29	; 62
    5726:	0f be       	out	0x3f, r0	; 63
    5728:	cd bf       	out	0x3d, r28	; 61
    572a:	cf 91       	pop	r28
    572c:	df 91       	pop	r29
    572e:	1f 91       	pop	r17
    5730:	0f 91       	pop	r16
    5732:	ff 90       	pop	r15
    5734:	ef 90       	pop	r14
    5736:	df 90       	pop	r13
    5738:	cf 90       	pop	r12
    573a:	bf 90       	pop	r11
    573c:	af 90       	pop	r10
    573e:	9f 90       	pop	r9
    5740:	8f 90       	pop	r8
    5742:	7f 90       	pop	r7
    5744:	6f 90       	pop	r6
    5746:	5f 90       	pop	r5
    5748:	4f 90       	pop	r4
    574a:	08 95       	ret
    574c:	c8 01       	movw	r24, r16
    574e:	6e e0       	ldi	r22, 0x0E	; 14
    5750:	70 e0       	ldi	r23, 0x00	; 0
    5752:	0e 94 bd 1a 	call	0x357a	; 0x357a <calculateCheckSum>
    5756:	29 81       	ldd	r18, Y+1	; 0x01
    5758:	3a 81       	ldd	r19, Y+2	; 0x02
    575a:	82 17       	cp	r24, r18
    575c:	93 07       	cpc	r25, r19
    575e:	09 f0       	breq	.+2      	; 0x5762 <configEepromGetConfig+0x1c2>
    5760:	5e cf       	rjmp	.-324    	; 0x561e <configEepromGetConfig+0x7e>
    5762:	65 cf       	rjmp	.-310    	; 0x562e <configEepromGetConfig+0x8e>

00005764 <configEepromSetConfig>:
    5764:	2f 92       	push	r2
    5766:	3f 92       	push	r3
    5768:	4f 92       	push	r4
    576a:	5f 92       	push	r5
    576c:	6f 92       	push	r6
    576e:	7f 92       	push	r7
    5770:	8f 92       	push	r8
    5772:	9f 92       	push	r9
    5774:	af 92       	push	r10
    5776:	bf 92       	push	r11
    5778:	cf 92       	push	r12
    577a:	df 92       	push	r13
    577c:	ef 92       	push	r14
    577e:	ff 92       	push	r15
    5780:	0f 93       	push	r16
    5782:	1f 93       	push	r17
    5784:	df 93       	push	r29
    5786:	cf 93       	push	r28
    5788:	cd b7       	in	r28, 0x3d	; 61
    578a:	de b7       	in	r29, 0x3e	; 62
    578c:	62 97       	sbiw	r28, 0x12	; 18
    578e:	0f b6       	in	r0, 0x3f	; 63
    5790:	f8 94       	cli
    5792:	de bf       	out	0x3e, r29	; 62
    5794:	0f be       	out	0x3f, r0	; 63
    5796:	cd bf       	out	0x3d, r28	; 61
    5798:	4b 01       	movw	r8, r22
    579a:	5c 01       	movw	r10, r24
    579c:	1a 01       	movw	r2, r20
    579e:	28 01       	movw	r4, r16
    57a0:	39 01       	movw	r6, r18
    57a2:	e1 99       	sbic	0x1c, 1	; 28
    57a4:	fe cf       	rjmp	.-4      	; 0x57a2 <configEepromSetConfig+0x3e>
    57a6:	8e 01       	movw	r16, r28
    57a8:	0b 5f       	subi	r16, 0xFB	; 251
    57aa:	1f 4f       	sbci	r17, 0xFF	; 255
    57ac:	c8 01       	movw	r24, r16
    57ae:	60 e0       	ldi	r22, 0x00	; 0
    57b0:	74 e0       	ldi	r23, 0x04	; 4
    57b2:	4e e0       	ldi	r20, 0x0E	; 14
    57b4:	50 e0       	ldi	r21, 0x00	; 0
    57b6:	25 e3       	ldi	r18, 0x35	; 53
    57b8:	3a e2       	ldi	r19, 0x2A	; 42
    57ba:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    57be:	ce 01       	movw	r24, r28
    57c0:	01 96       	adiw	r24, 0x01	; 1
    57c2:	6e e0       	ldi	r22, 0x0E	; 14
    57c4:	74 e0       	ldi	r23, 0x04	; 4
    57c6:	44 e0       	ldi	r20, 0x04	; 4
    57c8:	50 e0       	ldi	r21, 0x00	; 0
    57ca:	25 e3       	ldi	r18, 0x35	; 53
    57cc:	3a e2       	ldi	r19, 0x2A	; 42
    57ce:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    57d2:	8b 81       	ldd	r24, Y+3	; 0x03
    57d4:	9c 81       	ldd	r25, Y+4	; 0x04
    57d6:	80 95       	com	r24
    57d8:	90 95       	com	r25
    57da:	29 81       	ldd	r18, Y+1	; 0x01
    57dc:	3a 81       	ldd	r19, Y+2	; 0x02
    57de:	28 17       	cp	r18, r24
    57e0:	39 07       	cpc	r19, r25
    57e2:	09 f4       	brne	.+2      	; 0x57e6 <configEepromSetConfig+0x82>
    57e4:	b3 c0       	rjmp	.+358    	; 0x594c <configEepromSetConfig+0x1e8>
    57e6:	d8 01       	movw	r26, r16
    57e8:	ef e7       	ldi	r30, 0x7F	; 127
    57ea:	f9 e0       	ldi	r31, 0x09	; 9
    57ec:	8e e0       	ldi	r24, 0x0E	; 14
    57ee:	01 90       	ld	r0, Z+
    57f0:	0d 92       	st	X+, r0
    57f2:	81 50       	subi	r24, 0x01	; 1
    57f4:	e1 f7       	brne	.-8      	; 0x57ee <configEepromSetConfig+0x8a>
    57f6:	81 14       	cp	r8, r1
    57f8:	91 04       	cpc	r9, r1
    57fa:	a1 04       	cpc	r10, r1
    57fc:	b1 04       	cpc	r11, r1
    57fe:	69 f1       	breq	.+90     	; 0x585a <configEepromSetConfig+0xf6>
    5800:	58 2d       	mov	r21, r8
    5802:	44 27       	eor	r20, r20
    5804:	33 27       	eor	r19, r19
    5806:	22 27       	eor	r18, r18
    5808:	8b 2d       	mov	r24, r11
    580a:	99 27       	eor	r25, r25
    580c:	aa 27       	eor	r26, r26
    580e:	bb 27       	eor	r27, r27
    5810:	28 2b       	or	r18, r24
    5812:	39 2b       	or	r19, r25
    5814:	4a 2b       	or	r20, r26
    5816:	5b 2b       	or	r21, r27
    5818:	d5 01       	movw	r26, r10
    581a:	c4 01       	movw	r24, r8
    581c:	80 70       	andi	r24, 0x00	; 0
    581e:	90 70       	andi	r25, 0x00	; 0
    5820:	b0 70       	andi	r27, 0x00	; 0
    5822:	89 2f       	mov	r24, r25
    5824:	9a 2f       	mov	r25, r26
    5826:	ab 2f       	mov	r26, r27
    5828:	bb 27       	eor	r27, r27
    582a:	28 2b       	or	r18, r24
    582c:	39 2b       	or	r19, r25
    582e:	4a 2b       	or	r20, r26
    5830:	5b 2b       	or	r21, r27
    5832:	80 e0       	ldi	r24, 0x00	; 0
    5834:	9f ef       	ldi	r25, 0xFF	; 255
    5836:	a0 e0       	ldi	r26, 0x00	; 0
    5838:	b0 e0       	ldi	r27, 0x00	; 0
    583a:	88 22       	and	r8, r24
    583c:	99 22       	and	r9, r25
    583e:	aa 22       	and	r10, r26
    5840:	bb 22       	and	r11, r27
    5842:	ba 2d       	mov	r27, r10
    5844:	a9 2d       	mov	r26, r9
    5846:	98 2d       	mov	r25, r8
    5848:	88 27       	eor	r24, r24
    584a:	28 2b       	or	r18, r24
    584c:	39 2b       	or	r19, r25
    584e:	4a 2b       	or	r20, r26
    5850:	5b 2b       	or	r21, r27
    5852:	2d 83       	std	Y+5, r18	; 0x05
    5854:	3e 83       	std	Y+6, r19	; 0x06
    5856:	4f 83       	std	Y+7, r20	; 0x07
    5858:	58 87       	std	Y+8, r21	; 0x08
    585a:	21 14       	cp	r2, r1
    585c:	31 04       	cpc	r3, r1
    585e:	11 f0       	breq	.+4      	; 0x5864 <configEepromSetConfig+0x100>
    5860:	3a 86       	std	Y+10, r3	; 0x0a
    5862:	29 86       	std	Y+9, r2	; 0x09
    5864:	41 14       	cp	r4, r1
    5866:	51 04       	cpc	r5, r1
    5868:	61 04       	cpc	r6, r1
    586a:	71 04       	cpc	r7, r1
    586c:	69 f1       	breq	.+90     	; 0x58c8 <configEepromSetConfig+0x164>
    586e:	54 2d       	mov	r21, r4
    5870:	44 27       	eor	r20, r20
    5872:	33 27       	eor	r19, r19
    5874:	22 27       	eor	r18, r18
    5876:	87 2d       	mov	r24, r7
    5878:	99 27       	eor	r25, r25
    587a:	aa 27       	eor	r26, r26
    587c:	bb 27       	eor	r27, r27
    587e:	28 2b       	or	r18, r24
    5880:	39 2b       	or	r19, r25
    5882:	4a 2b       	or	r20, r26
    5884:	5b 2b       	or	r21, r27
    5886:	d3 01       	movw	r26, r6
    5888:	c2 01       	movw	r24, r4
    588a:	80 70       	andi	r24, 0x00	; 0
    588c:	90 70       	andi	r25, 0x00	; 0
    588e:	b0 70       	andi	r27, 0x00	; 0
    5890:	89 2f       	mov	r24, r25
    5892:	9a 2f       	mov	r25, r26
    5894:	ab 2f       	mov	r26, r27
    5896:	bb 27       	eor	r27, r27
    5898:	28 2b       	or	r18, r24
    589a:	39 2b       	or	r19, r25
    589c:	4a 2b       	or	r20, r26
    589e:	5b 2b       	or	r21, r27
    58a0:	80 e0       	ldi	r24, 0x00	; 0
    58a2:	9f ef       	ldi	r25, 0xFF	; 255
    58a4:	a0 e0       	ldi	r26, 0x00	; 0
    58a6:	b0 e0       	ldi	r27, 0x00	; 0
    58a8:	48 22       	and	r4, r24
    58aa:	59 22       	and	r5, r25
    58ac:	6a 22       	and	r6, r26
    58ae:	7b 22       	and	r7, r27
    58b0:	b6 2d       	mov	r27, r6
    58b2:	a5 2d       	mov	r26, r5
    58b4:	94 2d       	mov	r25, r4
    58b6:	88 27       	eor	r24, r24
    58b8:	28 2b       	or	r18, r24
    58ba:	39 2b       	or	r19, r25
    58bc:	4a 2b       	or	r20, r26
    58be:	5b 2b       	or	r21, r27
    58c0:	2b 87       	std	Y+11, r18	; 0x0b
    58c2:	3c 87       	std	Y+12, r19	; 0x0c
    58c4:	4d 87       	std	Y+13, r20	; 0x0d
    58c6:	5e 87       	std	Y+14, r21	; 0x0e
    58c8:	e1 14       	cp	r14, r1
    58ca:	f1 04       	cpc	r15, r1
    58cc:	11 f0       	breq	.+4      	; 0x58d2 <configEepromSetConfig+0x16e>
    58ce:	f8 8a       	std	Y+16, r15	; 0x10
    58d0:	ef 86       	std	Y+15, r14	; 0x0f
    58d2:	c1 14       	cp	r12, r1
    58d4:	d1 04       	cpc	r13, r1
    58d6:	11 f0       	breq	.+4      	; 0x58dc <configEepromSetConfig+0x178>
    58d8:	da 8a       	std	Y+18, r13	; 0x12
    58da:	c9 8a       	std	Y+17, r12	; 0x11
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    58dc:	80 e0       	ldi	r24, 0x00	; 0
    58de:	94 e0       	ldi	r25, 0x04	; 4
    58e0:	b8 01       	movw	r22, r16
    58e2:	4e e0       	ldi	r20, 0x0E	; 14
    58e4:	50 e0       	ldi	r21, 0x00	; 0
    58e6:	2d e3       	ldi	r18, 0x3D	; 61
    58e8:	3a e2       	ldi	r19, 0x2A	; 42
    58ea:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <__eewr_block>
    58ee:	c8 01       	movw	r24, r16
    58f0:	6e e0       	ldi	r22, 0x0E	; 14
    58f2:	70 e0       	ldi	r23, 0x00	; 0
    58f4:	0e 94 bd 1a 	call	0x357a	; 0x357a <calculateCheckSum>
    58f8:	9a 83       	std	Y+2, r25	; 0x02
    58fa:	89 83       	std	Y+1, r24	; 0x01
    58fc:	80 95       	com	r24
    58fe:	90 95       	com	r25
    5900:	9c 83       	std	Y+4, r25	; 0x04
    5902:	8b 83       	std	Y+3, r24	; 0x03
    5904:	8e e0       	ldi	r24, 0x0E	; 14
    5906:	94 e0       	ldi	r25, 0x04	; 4
    5908:	be 01       	movw	r22, r28
    590a:	6f 5f       	subi	r22, 0xFF	; 255
    590c:	7f 4f       	sbci	r23, 0xFF	; 255
    590e:	44 e0       	ldi	r20, 0x04	; 4
    5910:	50 e0       	ldi	r21, 0x00	; 0
    5912:	2d e3       	ldi	r18, 0x3D	; 61
    5914:	3a e2       	ldi	r19, 0x2A	; 42
    5916:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <__eewr_block>
    591a:	62 96       	adiw	r28, 0x12	; 18
    591c:	0f b6       	in	r0, 0x3f	; 63
    591e:	f8 94       	cli
    5920:	de bf       	out	0x3e, r29	; 62
    5922:	0f be       	out	0x3f, r0	; 63
    5924:	cd bf       	out	0x3d, r28	; 61
    5926:	cf 91       	pop	r28
    5928:	df 91       	pop	r29
    592a:	1f 91       	pop	r17
    592c:	0f 91       	pop	r16
    592e:	ff 90       	pop	r15
    5930:	ef 90       	pop	r14
    5932:	df 90       	pop	r13
    5934:	cf 90       	pop	r12
    5936:	bf 90       	pop	r11
    5938:	af 90       	pop	r10
    593a:	9f 90       	pop	r9
    593c:	8f 90       	pop	r8
    593e:	7f 90       	pop	r7
    5940:	6f 90       	pop	r6
    5942:	5f 90       	pop	r5
    5944:	4f 90       	pop	r4
    5946:	3f 90       	pop	r3
    5948:	2f 90       	pop	r2
    594a:	08 95       	ret
    594c:	c8 01       	movw	r24, r16
    594e:	6e e0       	ldi	r22, 0x0E	; 14
    5950:	70 e0       	ldi	r23, 0x00	; 0
    5952:	0e 94 bd 1a 	call	0x357a	; 0x357a <calculateCheckSum>
    5956:	29 81       	ldd	r18, Y+1	; 0x01
    5958:	3a 81       	ldd	r19, Y+2	; 0x02
    595a:	82 17       	cp	r24, r18
    595c:	93 07       	cpc	r25, r19
    595e:	09 f0       	breq	.+2      	; 0x5962 <configEepromSetConfig+0x1fe>
    5960:	42 cf       	rjmp	.-380    	; 0x57e6 <configEepromSetConfig+0x82>
    5962:	49 cf       	rjmp	.-366    	; 0x57f6 <configEepromSetConfig+0x92>

00005964 <onInitConfig>:
    5964:	df 93       	push	r29
    5966:	cf 93       	push	r28
    5968:	00 d0       	rcall	.+0      	; 0x596a <onInitConfig+0x6>
    596a:	00 d0       	rcall	.+0      	; 0x596c <onInitConfig+0x8>
    596c:	cd b7       	in	r28, 0x3d	; 61
    596e:	de b7       	in	r29, 0x3e	; 62
    5970:	e1 99       	sbic	0x1c, 1	; 28
    5972:	fe cf       	rjmp	.-4      	; 0x5970 <onInitConfig+0xc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    5974:	8f e7       	ldi	r24, 0x7F	; 127
    5976:	99 e0       	ldi	r25, 0x09	; 9
    5978:	60 e0       	ldi	r22, 0x00	; 0
    597a:	74 e0       	ldi	r23, 0x04	; 4
    597c:	4e e0       	ldi	r20, 0x0E	; 14
    597e:	50 e0       	ldi	r21, 0x00	; 0
    5980:	25 e3       	ldi	r18, 0x35	; 53
    5982:	3a e2       	ldi	r19, 0x2A	; 42
    5984:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    5988:	ce 01       	movw	r24, r28
    598a:	01 96       	adiw	r24, 0x01	; 1
    598c:	6e e0       	ldi	r22, 0x0E	; 14
    598e:	74 e0       	ldi	r23, 0x04	; 4
    5990:	44 e0       	ldi	r20, 0x04	; 4
    5992:	50 e0       	ldi	r21, 0x00	; 0
    5994:	25 e3       	ldi	r18, 0x35	; 53
    5996:	3a e2       	ldi	r19, 0x2A	; 42
    5998:	0e 94 60 2f 	call	0x5ec0	; 0x5ec0 <__eerd_block>
    599c:	8b 81       	ldd	r24, Y+3	; 0x03
    599e:	9c 81       	ldd	r25, Y+4	; 0x04
    59a0:	80 95       	com	r24
    59a2:	90 95       	com	r25
    59a4:	29 81       	ldd	r18, Y+1	; 0x01
    59a6:	3a 81       	ldd	r19, Y+2	; 0x02
    59a8:	28 17       	cp	r18, r24
    59aa:	39 07       	cpc	r19, r25
    59ac:	69 f1       	breq	.+90     	; 0x5a08 <onInitConfig+0xa4>
    59ae:	21 e8       	ldi	r18, 0x81	; 129
    59b0:	35 e4       	ldi	r19, 0x45	; 69
    59b2:	40 eb       	ldi	r20, 0xB0	; 176
    59b4:	5d e7       	ldi	r21, 0x7D	; 125
    59b6:	20 93 7f 09 	sts	0x097F, r18
    59ba:	30 93 80 09 	sts	0x0980, r19
    59be:	40 93 81 09 	sts	0x0981, r20
    59c2:	50 93 82 09 	sts	0x0982, r21
    59c6:	81 e6       	ldi	r24, 0x61	; 97
    59c8:	9e e1       	ldi	r25, 0x1E	; 30
    59ca:	90 93 84 09 	sts	0x0984, r25
    59ce:	80 93 83 09 	sts	0x0983, r24
    59d2:	20 93 85 09 	sts	0x0985, r18
    59d6:	30 93 86 09 	sts	0x0986, r19
    59da:	40 93 87 09 	sts	0x0987, r20
    59de:	50 93 88 09 	sts	0x0988, r21
    59e2:	82 e6       	ldi	r24, 0x62	; 98
    59e4:	9e e1       	ldi	r25, 0x1E	; 30
    59e6:	90 93 8a 09 	sts	0x098A, r25
    59ea:	80 93 89 09 	sts	0x0989, r24
    59ee:	82 e0       	ldi	r24, 0x02	; 2
    59f0:	97 ed       	ldi	r25, 0xD7	; 215
    59f2:	90 93 8c 09 	sts	0x098C, r25
    59f6:	80 93 8b 09 	sts	0x098B, r24
    59fa:	0f 90       	pop	r0
    59fc:	0f 90       	pop	r0
    59fe:	0f 90       	pop	r0
    5a00:	0f 90       	pop	r0
    5a02:	cf 91       	pop	r28
    5a04:	df 91       	pop	r29
    5a06:	08 95       	ret
    5a08:	8f e7       	ldi	r24, 0x7F	; 127
    5a0a:	99 e0       	ldi	r25, 0x09	; 9
    5a0c:	6e e0       	ldi	r22, 0x0E	; 14
    5a0e:	70 e0       	ldi	r23, 0x00	; 0
    5a10:	0e 94 bd 1a 	call	0x357a	; 0x357a <calculateCheckSum>
    5a14:	29 81       	ldd	r18, Y+1	; 0x01
    5a16:	3a 81       	ldd	r19, Y+2	; 0x02
    5a18:	82 17       	cp	r24, r18
    5a1a:	93 07       	cpc	r25, r19
    5a1c:	41 f6       	brne	.-112    	; 0x59ae <onInitConfig+0x4a>
    5a1e:	ed cf       	rjmp	.-38     	; 0x59fa <onInitConfig+0x96>

00005a20 <com1Initialize>:
// Initialisierungen
//------------------------------------------------------------------------
void com1Initialize(uint16_t baud, uint8_t settings)
{

	DDRD |= (1<<PD2);	//PD2 =0 eingang (RXD)		0100
    5a20:	8a 9a       	sbi	0x11, 2	; 17
	DDRD &= ~(1<<PD3);		//PD3 =1 ausgang (TXD)
    5a22:	8b 98       	cbi	0x11, 3	; 17



	PORTD |= (1<<PD2);	//PD0 ist eingang --> pullup hoch
    5a24:	92 9a       	sbi	0x12, 2	; 18
	

	// UART initialisieren

 // disable double speed, as we don't need it 
    UCSR1A &= ~(1 << U2X0);
    5a26:	eb e9       	ldi	r30, 0x9B	; 155
    5a28:	f0 e0       	ldi	r31, 0x00	; 0
    5a2a:	80 81       	ld	r24, Z
    5a2c:	8d 7f       	andi	r24, 0xFD	; 253
    5a2e:	80 83       	st	Z, r24

	UBRR1L=(uint8_t)(F_CPU/(BAUD*16L))-1; 	// Baudrate festlegen
    5a30:	87 e0       	ldi	r24, 0x07	; 7
    5a32:	80 93 99 00 	sts	0x0099, r24
	UBRR1H=(uint8_t)((F_CPU/(BAUD*16L))-1)>>8; 	// Baudrate festlegen
    5a36:	10 92 98 00 	sts	0x0098, r1

//	UBRR1L=7; 	// Baudrate festlegen
//	UBRR1H=7>>8; 	// Baudrate festlegen


	UCSR1B =(1<<RXCIE)|(1<<TXCIE)|(1<<UDRIE)|(1<<RXEN)|(1<<TXEN);
    5a3a:	88 ef       	ldi	r24, 0xF8	; 248
    5a3c:	80 93 9a 00 	sts	0x009A, r24
	UCSR1C =(1<<UCSZ1)|(1<<UCSZ0);
    5a40:	86 e0       	ldi	r24, 0x06	; 6
    5a42:	80 93 9d 00 	sts	0x009D, r24


	TCCR0=0x05; 	// Teiler 1/1024
    5a46:	85 e0       	ldi	r24, 0x05	; 5
    5a48:	83 bf       	out	0x33, r24	; 51
	TIMSK|=1; 	// Interrupt bei berlauf
    5a4a:	87 b7       	in	r24, 0x37	; 55
    5a4c:	81 60       	ori	r24, 0x01	; 1
    5a4e:	87 bf       	out	0x37, r24	; 55

com1_recv.recvCount = com1_recv.recvBuffer;
    5a50:	87 eb       	ldi	r24, 0xB7	; 183
    5a52:	99 e0       	ldi	r25, 0x09	; 9
    5a54:	90 93 e0 09 	sts	0x09E0, r25
    5a58:	80 93 df 09 	sts	0x09DF, r24

}
    5a5c:	08 95       	ret

00005a5e <putChar>:
// Funktion 	: ...
// IN  	 	: char data
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
    5a5e:	98 2f       	mov	r25, r24
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5a60:	80 91 9b 00 	lds	r24, 0x009B
    5a64:	85 ff       	sbrs	r24, 5
    5a66:	fc cf       	rjmp	.-8      	; 0x5a60 <putChar+0x2>
	//sende
	UDR1=data;
    5a68:	90 93 9c 00 	sts	0x009C, r25
}
    5a6c:	08 95       	ret

00005a6e <getChar>:
// OUT 	 	: data
//----------------------------------------------------------------------
char getChar()
{
	//warte bis RX-complete RXC UCSRA / USR bei z.B.: AT090S2313
	while (!(UCSR1A&128));
    5a6e:	80 91 9b 00 	lds	r24, 0x009B
    5a72:	87 ff       	sbrs	r24, 7
    5a74:	fc cf       	rjmp	.-8      	; 0x5a6e <getChar>
	//empfangen
	;

	return UDR1;
    5a76:	80 91 9c 00 	lds	r24, 0x009C
}
    5a7a:	08 95       	ret

00005a7c <__vector_31>:

//--------------------------------------------------------------------
// USART_UDRE_vect - UART Interrupt bei Senderegister leer
//--------------------------------------------------------------------
ISR(USART1_UDRE_vect)
{
    5a7c:	1f 92       	push	r1
    5a7e:	0f 92       	push	r0
    5a80:	0f b6       	in	r0, 0x3f	; 63
    5a82:	0f 92       	push	r0
    5a84:	0b b6       	in	r0, 0x3b	; 59
    5a86:	0f 92       	push	r0
    5a88:	11 24       	eor	r1, r1
    5a8a:	8f 93       	push	r24
    5a8c:	ef 93       	push	r30
    5a8e:	ff 93       	push	r31
	UCSR1B &= ~ (1 << UDRIE1);
    5a90:	ea e9       	ldi	r30, 0x9A	; 154
    5a92:	f0 e0       	ldi	r31, 0x00	; 0
    5a94:	80 81       	ld	r24, Z
    5a96:	8f 7d       	andi	r24, 0xDF	; 223
    5a98:	80 83       	st	Z, r24
}
    5a9a:	ff 91       	pop	r31
    5a9c:	ef 91       	pop	r30
    5a9e:	8f 91       	pop	r24
    5aa0:	0f 90       	pop	r0
    5aa2:	0b be       	out	0x3b, r0	; 59
    5aa4:	0f 90       	pop	r0
    5aa6:	0f be       	out	0x3f, r0	; 63
    5aa8:	0f 90       	pop	r0
    5aaa:	1f 90       	pop	r1
    5aac:	18 95       	reti

00005aae <__vector_32>:

//--------------------------------------------------------------------
// USART_TXC_vect - UART Interrupt bei Sendevorgang beendet
//--------------------------------------------------------------------
ISR(USART1_TX_vect)
{
    5aae:	1f 92       	push	r1
    5ab0:	0f 92       	push	r0
    5ab2:	0f b6       	in	r0, 0x3f	; 63
    5ab4:	0f 92       	push	r0
    5ab6:	11 24       	eor	r1, r1
	
}
    5ab8:	0f 90       	pop	r0
    5aba:	0f be       	out	0x3f, r0	; 63
    5abc:	0f 90       	pop	r0
    5abe:	1f 90       	pop	r1
    5ac0:	18 95       	reti

00005ac2 <putString_com1>:
// Funktion 	: ...
// IN  	 	: char *buffer, Zeichenkette mit NUll abgeschlossen
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString_com1(char *buffer)
{
    5ac2:	fc 01       	movw	r30, r24
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5ac4:	90 81       	ld	r25, Z
    5ac6:	99 23       	and	r25, r25
    5ac8:	51 f0       	breq	.+20     	; 0x5ade <putString_com1+0x1c>
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5aca:	80 91 9b 00 	lds	r24, 0x009B
    5ace:	85 ff       	sbrs	r24, 5
    5ad0:	fc cf       	rjmp	.-8      	; 0x5aca <putString_com1+0x8>
	//sende
	UDR1=data;
    5ad2:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString_com1(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5ad6:	91 81       	ldd	r25, Z+1	; 0x01
    5ad8:	31 96       	adiw	r30, 0x01	; 1
    5ada:	99 23       	and	r25, r25
    5adc:	b1 f7       	brne	.-20     	; 0x5aca <putString_com1+0x8>
    5ade:	08 95       	ret

00005ae0 <ExecuteCommand>:

}


void ExecuteCommand(char* command,uint8_t len)
{
    5ae0:	1f 93       	push	r17
    5ae2:	cf 93       	push	r28
    5ae4:	df 93       	push	r29
    5ae6:	ec 01       	movw	r28, r24
    5ae8:	16 2f       	mov	r17, r22
	if(strcmp(command,"hallo")==0)
    5aea:	66 ee       	ldi	r22, 0xE6	; 230
    5aec:	77 e0       	ldi	r23, 0x07	; 7
    5aee:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <strcmp>
    5af2:	00 97       	sbiw	r24, 0x00	; 0
    5af4:	b1 f4       	brne	.+44     	; 0x5b22 <ExecuteCommand+0x42>
    5af6:	ed ee       	ldi	r30, 0xED	; 237
    5af8:	f7 e0       	ldi	r31, 0x07	; 7
    5afa:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5afc:	80 91 9b 00 	lds	r24, 0x009B
    5b00:	85 ff       	sbrs	r24, 5
    5b02:	fc cf       	rjmp	.-8      	; 0x5afc <ExecuteCommand+0x1c>
	//sende
	UDR1=data;
    5b04:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString_com1(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5b08:	91 91       	ld	r25, Z+
    5b0a:	99 23       	and	r25, r25
    5b0c:	b9 f7       	brne	.-18     	; 0x5afc <ExecuteCommand+0x1c>
void ExecuteCommand(char* command,uint8_t len)
{
	if(strcmp(command,"hallo")==0)
	{
		putString_com1("Befehl erfolgreich dekodiert");
		debug=0;
    5b0e:	10 92 38 08 	sts	0x0838, r1
    5b12:	10 92 37 08 	sts	0x0837, r1
		DebugTimerList();
    5b16:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <DebugTimerList>
	 	 CommandBuffer.NewCommand=1;
		strcpy(CommandBuffer.recvCommand,command);
		CommandBuffer.len=len;
	}

}
    5b1a:	df 91       	pop	r29
    5b1c:	cf 91       	pop	r28
    5b1e:	1f 91       	pop	r17
    5b20:	08 95       	ret
	{
		putString_com1("Befehl erfolgreich dekodiert");
		debug=0;
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
    5b22:	ce 01       	movw	r24, r28
    5b24:	69 e0       	ldi	r22, 0x09	; 9
    5b26:	78 e0       	ldi	r23, 0x08	; 8
    5b28:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <strcmp>
    5b2c:	00 97       	sbiw	r24, 0x00	; 0
    5b2e:	b1 f4       	brne	.+44     	; 0x5b5c <ExecuteCommand+0x7c>
    5b30:	e0 e1       	ldi	r30, 0x10	; 16
    5b32:	f8 e0       	ldi	r31, 0x08	; 8
    5b34:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5b36:	80 91 9b 00 	lds	r24, 0x009B
    5b3a:	85 ff       	sbrs	r24, 5
    5b3c:	fc cf       	rjmp	.-8      	; 0x5b36 <ExecuteCommand+0x56>
	//sende
	UDR1=data;
    5b3e:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString_com1(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5b42:	91 91       	ld	r25, Z+
    5b44:	99 23       	and	r25, r25
    5b46:	b9 f7       	brne	.-18     	; 0x5b36 <ExecuteCommand+0x56>
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
	{
		putString_com1("Befehl2 erfolgreich dekodiert");
		debug=1;
    5b48:	81 e0       	ldi	r24, 0x01	; 1
    5b4a:	90 e0       	ldi	r25, 0x00	; 0
    5b4c:	90 93 38 08 	sts	0x0838, r25
    5b50:	80 93 37 08 	sts	0x0837, r24
	 	 CommandBuffer.NewCommand=1;
		strcpy(CommandBuffer.recvCommand,command);
		CommandBuffer.len=len;
	}

}
    5b54:	df 91       	pop	r29
    5b56:	cf 91       	pop	r28
    5b58:	1f 91       	pop	r17
    5b5a:	08 95       	ret
		debug=1;
	}

	else
	{
	 	 CommandBuffer.NewCommand=1;
    5b5c:	81 e0       	ldi	r24, 0x01	; 1
    5b5e:	80 93 b5 09 	sts	0x09B5, r24
		strcpy(CommandBuffer.recvCommand,command);
    5b62:	8d e8       	ldi	r24, 0x8D	; 141
    5b64:	99 e0       	ldi	r25, 0x09	; 9
    5b66:	be 01       	movw	r22, r28
    5b68:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <strcpy>
		CommandBuffer.len=len;
    5b6c:	10 93 b6 09 	sts	0x09B6, r17
    5b70:	d4 cf       	rjmp	.-88     	; 0x5b1a <ExecuteCommand+0x3a>

00005b72 <__vector_30>:

//--------------------------------------------------------------------
// USART_RXC_vect - UART Interrupt bei Datenempfang komplett
//--------------------------------------------------------------------
ISR(USART1_RX_vect)
{
    5b72:	1f 92       	push	r1
    5b74:	0f 92       	push	r0
    5b76:	0f b6       	in	r0, 0x3f	; 63
    5b78:	0f 92       	push	r0
    5b7a:	0b b6       	in	r0, 0x3b	; 59
    5b7c:	0f 92       	push	r0
    5b7e:	11 24       	eor	r1, r1
    5b80:	1f 93       	push	r17
    5b82:	2f 93       	push	r18
    5b84:	3f 93       	push	r19
    5b86:	4f 93       	push	r20
    5b88:	5f 93       	push	r21
    5b8a:	6f 93       	push	r22
    5b8c:	7f 93       	push	r23
    5b8e:	8f 93       	push	r24
    5b90:	9f 93       	push	r25
    5b92:	af 93       	push	r26
    5b94:	bf 93       	push	r27
    5b96:	cf 93       	push	r28
    5b98:	df 93       	push	r29
    5b9a:	ef 93       	push	r30
    5b9c:	ff 93       	push	r31
// OUT 	 	: data
//----------------------------------------------------------------------
char getChar()
{
	//warte bis RX-complete RXC UCSRA / USR bei z.B.: AT090S2313
	while (!(UCSR1A&128));
    5b9e:	80 91 9b 00 	lds	r24, 0x009B
    5ba2:	87 ff       	sbrs	r24, 7
    5ba4:	fc cf       	rjmp	.-8      	; 0x5b9e <__vector_30+0x2c>
	//empfangen
	;

	return UDR1;
    5ba6:	90 91 9c 00 	lds	r25, 0x009C
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5baa:	80 91 9b 00 	lds	r24, 0x009B
    5bae:	85 ff       	sbrs	r24, 5
    5bb0:	fc cf       	rjmp	.-8      	; 0x5baa <__vector_30+0x38>
	//sende
	UDR1=data;
    5bb2:	90 93 9c 00 	sts	0x009C, r25

	char x=getChar();
	putChar(x);


	if(x != 0xD)	//einfaches newline testen
    5bb6:	9d 30       	cpi	r25, 0x0D	; 13
    5bb8:	21 f1       	breq	.+72     	; 0x5c02 <__vector_30+0x90>
	{
		
		// Save the received byte...
	    com1_recv.recvCount[0] = x;
    5bba:	e0 91 df 09 	lds	r30, 0x09DF
    5bbe:	f0 91 e0 09 	lds	r31, 0x09E0
    5bc2:	90 83       	st	Z, r25
  
	    // increase our helper...
	    com1_recv.recvCount++;
    5bc4:	80 91 df 09 	lds	r24, 0x09DF
    5bc8:	90 91 e0 09 	lds	r25, 0x09E0
    5bcc:	01 96       	adiw	r24, 0x01	; 1
    5bce:	90 93 e0 09 	sts	0x09E0, r25
    5bd2:	80 93 df 09 	sts	0x09DF, r24
		com1_recv.recvCount = com1_recv.recvBuffer;

	
	}

}
    5bd6:	ff 91       	pop	r31
    5bd8:	ef 91       	pop	r30
    5bda:	df 91       	pop	r29
    5bdc:	cf 91       	pop	r28
    5bde:	bf 91       	pop	r27
    5be0:	af 91       	pop	r26
    5be2:	9f 91       	pop	r25
    5be4:	8f 91       	pop	r24
    5be6:	7f 91       	pop	r23
    5be8:	6f 91       	pop	r22
    5bea:	5f 91       	pop	r21
    5bec:	4f 91       	pop	r20
    5bee:	3f 91       	pop	r19
    5bf0:	2f 91       	pop	r18
    5bf2:	1f 91       	pop	r17
    5bf4:	0f 90       	pop	r0
    5bf6:	0b be       	out	0x3b, r0	; 59
    5bf8:	0f 90       	pop	r0
    5bfa:	0f be       	out	0x3f, r0	; 63
    5bfc:	0f 90       	pop	r0
    5bfe:	1f 90       	pop	r1
    5c00:	18 95       	reti
		
	}
	else 
	{

		com1_recv.recvCount[0] = '\0';
    5c02:	e0 91 df 09 	lds	r30, 0x09DF
    5c06:	f0 91 e0 09 	lds	r31, 0x09E0
    5c0a:	10 82       	st	Z, r1

		ExecuteCommand(com1_recv.recvBuffer,com1_recv.recvCount-com1_recv.recvBuffer);
    5c0c:	10 91 df 09 	lds	r17, 0x09DF
}


void ExecuteCommand(char* command,uint8_t len)
{
	if(strcmp(command,"hallo")==0)
    5c10:	c7 eb       	ldi	r28, 0xB7	; 183
    5c12:	d9 e0       	ldi	r29, 0x09	; 9
    5c14:	ce 01       	movw	r24, r28
    5c16:	66 ee       	ldi	r22, 0xE6	; 230
    5c18:	77 e0       	ldi	r23, 0x07	; 7
    5c1a:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <strcmp>
    5c1e:	00 97       	sbiw	r24, 0x00	; 0
    5c20:	b9 f4       	brne	.+46     	; 0x5c50 <__vector_30+0xde>
    5c22:	ed ee       	ldi	r30, 0xED	; 237
    5c24:	f7 e0       	ldi	r31, 0x07	; 7
    5c26:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5c28:	80 91 9b 00 	lds	r24, 0x009B
    5c2c:	85 ff       	sbrs	r24, 5
    5c2e:	fc cf       	rjmp	.-8      	; 0x5c28 <__vector_30+0xb6>
	//sende
	UDR1=data;
    5c30:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString_com1(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5c34:	91 91       	ld	r25, Z+
    5c36:	99 23       	and	r25, r25
    5c38:	b9 f7       	brne	.-18     	; 0x5c28 <__vector_30+0xb6>
void ExecuteCommand(char* command,uint8_t len)
{
	if(strcmp(command,"hallo")==0)
	{
		putString_com1("Befehl erfolgreich dekodiert");
		debug=0;
    5c3a:	10 92 38 08 	sts	0x0838, r1
    5c3e:	10 92 37 08 	sts	0x0837, r1
		DebugTimerList();
    5c42:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <DebugTimerList>
		com1_recv.recvCount[0] = '\0';

		ExecuteCommand(com1_recv.recvBuffer,com1_recv.recvCount-com1_recv.recvBuffer);


		com1_recv.recvCount = com1_recv.recvBuffer;
    5c46:	d0 93 e0 09 	sts	0x09E0, r29
    5c4a:	c0 93 df 09 	sts	0x09DF, r28
    5c4e:	c3 cf       	rjmp	.-122    	; 0x5bd6 <__vector_30+0x64>
	{
		putString_com1("Befehl erfolgreich dekodiert");
		debug=0;
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
    5c50:	ce 01       	movw	r24, r28
    5c52:	69 e0       	ldi	r22, 0x09	; 9
    5c54:	78 e0       	ldi	r23, 0x08	; 8
    5c56:	0e 94 50 2f 	call	0x5ea0	; 0x5ea0 <strcmp>
    5c5a:	00 97       	sbiw	r24, 0x00	; 0
    5c5c:	99 f4       	brne	.+38     	; 0x5c84 <__vector_30+0x112>
    5c5e:	e0 e1       	ldi	r30, 0x10	; 16
    5c60:	f8 e0       	ldi	r31, 0x08	; 8
    5c62:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5c64:	80 91 9b 00 	lds	r24, 0x009B
    5c68:	85 ff       	sbrs	r24, 5
    5c6a:	fc cf       	rjmp	.-8      	; 0x5c64 <__vector_30+0xf2>
	//sende
	UDR1=data;
    5c6c:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString_com1(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5c70:	91 91       	ld	r25, Z+
    5c72:	99 23       	and	r25, r25
    5c74:	b9 f7       	brne	.-18     	; 0x5c64 <__vector_30+0xf2>
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
	{
		putString_com1("Befehl2 erfolgreich dekodiert");
		debug=1;
    5c76:	81 e0       	ldi	r24, 0x01	; 1
    5c78:	90 e0       	ldi	r25, 0x00	; 0
    5c7a:	90 93 38 08 	sts	0x0838, r25
    5c7e:	80 93 37 08 	sts	0x0837, r24
    5c82:	e1 cf       	rjmp	.-62     	; 0x5c46 <__vector_30+0xd4>
	}

	else
	{
	 	 CommandBuffer.NewCommand=1;
    5c84:	81 e0       	ldi	r24, 0x01	; 1
    5c86:	80 93 b5 09 	sts	0x09B5, r24
		strcpy(CommandBuffer.recvCommand,command);
    5c8a:	8d e8       	ldi	r24, 0x8D	; 141
    5c8c:	99 e0       	ldi	r25, 0x09	; 9
    5c8e:	be 01       	movw	r22, r28
    5c90:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <strcpy>
		CommandBuffer.len=len;
    5c94:	1c 1b       	sub	r17, r28
    5c96:	10 93 b6 09 	sts	0x09B6, r17
    5c9a:	d5 cf       	rjmp	.-86     	; 0x5c46 <__vector_30+0xd4>

00005c9c <malloc>:
    5c9c:	cf 93       	push	r28
    5c9e:	df 93       	push	r29
    5ca0:	bc 01       	movw	r22, r24
    5ca2:	82 30       	cpi	r24, 0x02	; 2
    5ca4:	91 05       	cpc	r25, r1
    5ca6:	10 f4       	brcc	.+4      	; 0x5cac <malloc+0x10>
    5ca8:	62 e0       	ldi	r22, 0x02	; 2
    5caa:	70 e0       	ldi	r23, 0x00	; 0
    5cac:	a0 91 e3 09 	lds	r26, 0x09E3
    5cb0:	b0 91 e4 09 	lds	r27, 0x09E4
    5cb4:	ed 01       	movw	r28, r26
    5cb6:	e0 e0       	ldi	r30, 0x00	; 0
    5cb8:	f0 e0       	ldi	r31, 0x00	; 0
    5cba:	40 e0       	ldi	r20, 0x00	; 0
    5cbc:	50 e0       	ldi	r21, 0x00	; 0
    5cbe:	21 c0       	rjmp	.+66     	; 0x5d02 <malloc+0x66>
    5cc0:	88 81       	ld	r24, Y
    5cc2:	99 81       	ldd	r25, Y+1	; 0x01
    5cc4:	86 17       	cp	r24, r22
    5cc6:	97 07       	cpc	r25, r23
    5cc8:	69 f4       	brne	.+26     	; 0x5ce4 <malloc+0x48>
    5cca:	8a 81       	ldd	r24, Y+2	; 0x02
    5ccc:	9b 81       	ldd	r25, Y+3	; 0x03
    5cce:	30 97       	sbiw	r30, 0x00	; 0
    5cd0:	19 f0       	breq	.+6      	; 0x5cd8 <malloc+0x3c>
    5cd2:	93 83       	std	Z+3, r25	; 0x03
    5cd4:	82 83       	std	Z+2, r24	; 0x02
    5cd6:	04 c0       	rjmp	.+8      	; 0x5ce0 <malloc+0x44>
    5cd8:	90 93 e4 09 	sts	0x09E4, r25
    5cdc:	80 93 e3 09 	sts	0x09E3, r24
    5ce0:	fe 01       	movw	r30, r28
    5ce2:	34 c0       	rjmp	.+104    	; 0x5d4c <malloc+0xb0>
    5ce4:	68 17       	cp	r22, r24
    5ce6:	79 07       	cpc	r23, r25
    5ce8:	38 f4       	brcc	.+14     	; 0x5cf8 <malloc+0x5c>
    5cea:	41 15       	cp	r20, r1
    5cec:	51 05       	cpc	r21, r1
    5cee:	19 f0       	breq	.+6      	; 0x5cf6 <malloc+0x5a>
    5cf0:	84 17       	cp	r24, r20
    5cf2:	95 07       	cpc	r25, r21
    5cf4:	08 f4       	brcc	.+2      	; 0x5cf8 <malloc+0x5c>
    5cf6:	ac 01       	movw	r20, r24
    5cf8:	fe 01       	movw	r30, r28
    5cfa:	8a 81       	ldd	r24, Y+2	; 0x02
    5cfc:	9b 81       	ldd	r25, Y+3	; 0x03
    5cfe:	9c 01       	movw	r18, r24
    5d00:	e9 01       	movw	r28, r18
    5d02:	20 97       	sbiw	r28, 0x00	; 0
    5d04:	e9 f6       	brne	.-70     	; 0x5cc0 <malloc+0x24>
    5d06:	41 15       	cp	r20, r1
    5d08:	51 05       	cpc	r21, r1
    5d0a:	a9 f1       	breq	.+106    	; 0x5d76 <malloc+0xda>
    5d0c:	ca 01       	movw	r24, r20
    5d0e:	86 1b       	sub	r24, r22
    5d10:	97 0b       	sbc	r25, r23
    5d12:	04 97       	sbiw	r24, 0x04	; 4
    5d14:	08 f4       	brcc	.+2      	; 0x5d18 <malloc+0x7c>
    5d16:	ba 01       	movw	r22, r20
    5d18:	e0 e0       	ldi	r30, 0x00	; 0
    5d1a:	f0 e0       	ldi	r31, 0x00	; 0
    5d1c:	2a c0       	rjmp	.+84     	; 0x5d72 <malloc+0xd6>
    5d1e:	8d 91       	ld	r24, X+
    5d20:	9c 91       	ld	r25, X
    5d22:	11 97       	sbiw	r26, 0x01	; 1
    5d24:	84 17       	cp	r24, r20
    5d26:	95 07       	cpc	r25, r21
    5d28:	f9 f4       	brne	.+62     	; 0x5d68 <malloc+0xcc>
    5d2a:	64 17       	cp	r22, r20
    5d2c:	75 07       	cpc	r23, r21
    5d2e:	81 f4       	brne	.+32     	; 0x5d50 <malloc+0xb4>
    5d30:	12 96       	adiw	r26, 0x02	; 2
    5d32:	8d 91       	ld	r24, X+
    5d34:	9c 91       	ld	r25, X
    5d36:	13 97       	sbiw	r26, 0x03	; 3
    5d38:	30 97       	sbiw	r30, 0x00	; 0
    5d3a:	19 f0       	breq	.+6      	; 0x5d42 <malloc+0xa6>
    5d3c:	93 83       	std	Z+3, r25	; 0x03
    5d3e:	82 83       	std	Z+2, r24	; 0x02
    5d40:	04 c0       	rjmp	.+8      	; 0x5d4a <malloc+0xae>
    5d42:	90 93 e4 09 	sts	0x09E4, r25
    5d46:	80 93 e3 09 	sts	0x09E3, r24
    5d4a:	fd 01       	movw	r30, r26
    5d4c:	32 96       	adiw	r30, 0x02	; 2
    5d4e:	4c c0       	rjmp	.+152    	; 0x5de8 <malloc+0x14c>
    5d50:	ca 01       	movw	r24, r20
    5d52:	86 1b       	sub	r24, r22
    5d54:	97 0b       	sbc	r25, r23
    5d56:	fd 01       	movw	r30, r26
    5d58:	e8 0f       	add	r30, r24
    5d5a:	f9 1f       	adc	r31, r25
    5d5c:	61 93       	st	Z+, r22
    5d5e:	71 93       	st	Z+, r23
    5d60:	02 97       	sbiw	r24, 0x02	; 2
    5d62:	8d 93       	st	X+, r24
    5d64:	9c 93       	st	X, r25
    5d66:	40 c0       	rjmp	.+128    	; 0x5de8 <malloc+0x14c>
    5d68:	fd 01       	movw	r30, r26
    5d6a:	82 81       	ldd	r24, Z+2	; 0x02
    5d6c:	93 81       	ldd	r25, Z+3	; 0x03
    5d6e:	9c 01       	movw	r18, r24
    5d70:	d9 01       	movw	r26, r18
    5d72:	10 97       	sbiw	r26, 0x00	; 0
    5d74:	a1 f6       	brne	.-88     	; 0x5d1e <malloc+0x82>
    5d76:	80 91 e1 09 	lds	r24, 0x09E1
    5d7a:	90 91 e2 09 	lds	r25, 0x09E2
    5d7e:	89 2b       	or	r24, r25
    5d80:	41 f4       	brne	.+16     	; 0x5d92 <malloc+0xf6>
    5d82:	80 91 2f 08 	lds	r24, 0x082F
    5d86:	90 91 30 08 	lds	r25, 0x0830
    5d8a:	90 93 e2 09 	sts	0x09E2, r25
    5d8e:	80 93 e1 09 	sts	0x09E1, r24
    5d92:	40 91 31 08 	lds	r20, 0x0831
    5d96:	50 91 32 08 	lds	r21, 0x0832
    5d9a:	41 15       	cp	r20, r1
    5d9c:	51 05       	cpc	r21, r1
    5d9e:	41 f4       	brne	.+16     	; 0x5db0 <malloc+0x114>
    5da0:	4d b7       	in	r20, 0x3d	; 61
    5da2:	5e b7       	in	r21, 0x3e	; 62
    5da4:	80 91 2d 08 	lds	r24, 0x082D
    5da8:	90 91 2e 08 	lds	r25, 0x082E
    5dac:	48 1b       	sub	r20, r24
    5dae:	59 0b       	sbc	r21, r25
    5db0:	20 91 e1 09 	lds	r18, 0x09E1
    5db4:	30 91 e2 09 	lds	r19, 0x09E2
    5db8:	ca 01       	movw	r24, r20
    5dba:	82 1b       	sub	r24, r18
    5dbc:	93 0b       	sbc	r25, r19
    5dbe:	86 17       	cp	r24, r22
    5dc0:	97 07       	cpc	r25, r23
    5dc2:	80 f0       	brcs	.+32     	; 0x5de4 <malloc+0x148>
    5dc4:	ab 01       	movw	r20, r22
    5dc6:	4e 5f       	subi	r20, 0xFE	; 254
    5dc8:	5f 4f       	sbci	r21, 0xFF	; 255
    5dca:	84 17       	cp	r24, r20
    5dcc:	95 07       	cpc	r25, r21
    5dce:	50 f0       	brcs	.+20     	; 0x5de4 <malloc+0x148>
    5dd0:	42 0f       	add	r20, r18
    5dd2:	53 1f       	adc	r21, r19
    5dd4:	50 93 e2 09 	sts	0x09E2, r21
    5dd8:	40 93 e1 09 	sts	0x09E1, r20
    5ddc:	f9 01       	movw	r30, r18
    5dde:	61 93       	st	Z+, r22
    5de0:	71 93       	st	Z+, r23
    5de2:	02 c0       	rjmp	.+4      	; 0x5de8 <malloc+0x14c>
    5de4:	e0 e0       	ldi	r30, 0x00	; 0
    5de6:	f0 e0       	ldi	r31, 0x00	; 0
    5de8:	cf 01       	movw	r24, r30
    5dea:	df 91       	pop	r29
    5dec:	cf 91       	pop	r28
    5dee:	08 95       	ret

00005df0 <free>:
    5df0:	cf 93       	push	r28
    5df2:	df 93       	push	r29
    5df4:	00 97       	sbiw	r24, 0x00	; 0
    5df6:	09 f4       	brne	.+2      	; 0x5dfa <free+0xa>
    5df8:	50 c0       	rjmp	.+160    	; 0x5e9a <free+0xaa>
    5dfa:	ec 01       	movw	r28, r24
    5dfc:	22 97       	sbiw	r28, 0x02	; 2
    5dfe:	1b 82       	std	Y+3, r1	; 0x03
    5e00:	1a 82       	std	Y+2, r1	; 0x02
    5e02:	a0 91 e3 09 	lds	r26, 0x09E3
    5e06:	b0 91 e4 09 	lds	r27, 0x09E4
    5e0a:	10 97       	sbiw	r26, 0x00	; 0
    5e0c:	09 f1       	breq	.+66     	; 0x5e50 <free+0x60>
    5e0e:	40 e0       	ldi	r20, 0x00	; 0
    5e10:	50 e0       	ldi	r21, 0x00	; 0
    5e12:	ac 17       	cp	r26, r28
    5e14:	bd 07       	cpc	r27, r29
    5e16:	08 f1       	brcs	.+66     	; 0x5e5a <free+0x6a>
    5e18:	bb 83       	std	Y+3, r27	; 0x03
    5e1a:	aa 83       	std	Y+2, r26	; 0x02
    5e1c:	fe 01       	movw	r30, r28
    5e1e:	21 91       	ld	r18, Z+
    5e20:	31 91       	ld	r19, Z+
    5e22:	e2 0f       	add	r30, r18
    5e24:	f3 1f       	adc	r31, r19
    5e26:	ae 17       	cp	r26, r30
    5e28:	bf 07       	cpc	r27, r31
    5e2a:	79 f4       	brne	.+30     	; 0x5e4a <free+0x5a>
    5e2c:	8d 91       	ld	r24, X+
    5e2e:	9c 91       	ld	r25, X
    5e30:	11 97       	sbiw	r26, 0x01	; 1
    5e32:	28 0f       	add	r18, r24
    5e34:	39 1f       	adc	r19, r25
    5e36:	2e 5f       	subi	r18, 0xFE	; 254
    5e38:	3f 4f       	sbci	r19, 0xFF	; 255
    5e3a:	39 83       	std	Y+1, r19	; 0x01
    5e3c:	28 83       	st	Y, r18
    5e3e:	12 96       	adiw	r26, 0x02	; 2
    5e40:	8d 91       	ld	r24, X+
    5e42:	9c 91       	ld	r25, X
    5e44:	13 97       	sbiw	r26, 0x03	; 3
    5e46:	9b 83       	std	Y+3, r25	; 0x03
    5e48:	8a 83       	std	Y+2, r24	; 0x02
    5e4a:	41 15       	cp	r20, r1
    5e4c:	51 05       	cpc	r21, r1
    5e4e:	71 f4       	brne	.+28     	; 0x5e6c <free+0x7c>
    5e50:	d0 93 e4 09 	sts	0x09E4, r29
    5e54:	c0 93 e3 09 	sts	0x09E3, r28
    5e58:	20 c0       	rjmp	.+64     	; 0x5e9a <free+0xaa>
    5e5a:	12 96       	adiw	r26, 0x02	; 2
    5e5c:	8d 91       	ld	r24, X+
    5e5e:	9c 91       	ld	r25, X
    5e60:	13 97       	sbiw	r26, 0x03	; 3
    5e62:	ad 01       	movw	r20, r26
    5e64:	00 97       	sbiw	r24, 0x00	; 0
    5e66:	11 f0       	breq	.+4      	; 0x5e6c <free+0x7c>
    5e68:	dc 01       	movw	r26, r24
    5e6a:	d3 cf       	rjmp	.-90     	; 0x5e12 <free+0x22>
    5e6c:	fa 01       	movw	r30, r20
    5e6e:	d3 83       	std	Z+3, r29	; 0x03
    5e70:	c2 83       	std	Z+2, r28	; 0x02
    5e72:	21 91       	ld	r18, Z+
    5e74:	31 91       	ld	r19, Z+
    5e76:	e2 0f       	add	r30, r18
    5e78:	f3 1f       	adc	r31, r19
    5e7a:	ce 17       	cp	r28, r30
    5e7c:	df 07       	cpc	r29, r31
    5e7e:	69 f4       	brne	.+26     	; 0x5e9a <free+0xaa>
    5e80:	88 81       	ld	r24, Y
    5e82:	99 81       	ldd	r25, Y+1	; 0x01
    5e84:	28 0f       	add	r18, r24
    5e86:	39 1f       	adc	r19, r25
    5e88:	2e 5f       	subi	r18, 0xFE	; 254
    5e8a:	3f 4f       	sbci	r19, 0xFF	; 255
    5e8c:	fa 01       	movw	r30, r20
    5e8e:	31 83       	std	Z+1, r19	; 0x01
    5e90:	20 83       	st	Z, r18
    5e92:	8a 81       	ldd	r24, Y+2	; 0x02
    5e94:	9b 81       	ldd	r25, Y+3	; 0x03
    5e96:	93 83       	std	Z+3, r25	; 0x03
    5e98:	82 83       	std	Z+2, r24	; 0x02
    5e9a:	df 91       	pop	r29
    5e9c:	cf 91       	pop	r28
    5e9e:	08 95       	ret

00005ea0 <strcmp>:
    5ea0:	fb 01       	movw	r30, r22
    5ea2:	dc 01       	movw	r26, r24
    5ea4:	8d 91       	ld	r24, X+
    5ea6:	01 90       	ld	r0, Z+
    5ea8:	80 19       	sub	r24, r0
    5eaa:	01 10       	cpse	r0, r1
    5eac:	d9 f3       	breq	.-10     	; 0x5ea4 <strcmp+0x4>
    5eae:	99 0b       	sbc	r25, r25
    5eb0:	08 95       	ret

00005eb2 <strcpy>:
    5eb2:	fb 01       	movw	r30, r22
    5eb4:	dc 01       	movw	r26, r24
    5eb6:	01 90       	ld	r0, Z+
    5eb8:	0d 92       	st	X+, r0
    5eba:	00 20       	and	r0, r0
    5ebc:	e1 f7       	brne	.-8      	; 0x5eb6 <strcpy+0x4>
    5ebe:	08 95       	ret

00005ec0 <__eerd_block>:
    5ec0:	a0 e0       	ldi	r26, 0x00	; 0
    5ec2:	b0 e0       	ldi	r27, 0x00	; 0
    5ec4:	e6 e6       	ldi	r30, 0x66	; 102
    5ec6:	ff e2       	ldi	r31, 0x2F	; 47
    5ec8:	0c 94 63 30 	jmp	0x60c6	; 0x60c6 <__prologue_saves__+0x14>
    5ecc:	7c 01       	movw	r14, r24
    5ece:	eb 01       	movw	r28, r22
    5ed0:	8a 01       	movw	r16, r20
    5ed2:	69 01       	movw	r12, r18
    5ed4:	09 c0       	rjmp	.+18     	; 0x5ee8 <__eerd_block+0x28>
    5ed6:	ce 01       	movw	r24, r28
    5ed8:	21 96       	adiw	r28, 0x01	; 1
    5eda:	f6 01       	movw	r30, r12
    5edc:	09 95       	icall
    5ede:	f7 01       	movw	r30, r14
    5ee0:	81 93       	st	Z+, r24
    5ee2:	7f 01       	movw	r14, r30
    5ee4:	01 50       	subi	r16, 0x01	; 1
    5ee6:	10 40       	sbci	r17, 0x00	; 0
    5ee8:	01 15       	cp	r16, r1
    5eea:	11 05       	cpc	r17, r1
    5eec:	a1 f7       	brne	.-24     	; 0x5ed6 <__eerd_block+0x16>
    5eee:	cd b7       	in	r28, 0x3d	; 61
    5ef0:	de b7       	in	r29, 0x3e	; 62
    5ef2:	e8 e0       	ldi	r30, 0x08	; 8
    5ef4:	0c 94 7f 30 	jmp	0x60fe	; 0x60fe <__epilogue_restores__+0x14>

00005ef8 <__eewr_block>:
    5ef8:	a0 e0       	ldi	r26, 0x00	; 0
    5efa:	b0 e0       	ldi	r27, 0x00	; 0
    5efc:	e2 e8       	ldi	r30, 0x82	; 130
    5efe:	ff e2       	ldi	r31, 0x2F	; 47
    5f00:	0c 94 63 30 	jmp	0x60c6	; 0x60c6 <__prologue_saves__+0x14>
    5f04:	ec 01       	movw	r28, r24
    5f06:	7b 01       	movw	r14, r22
    5f08:	8a 01       	movw	r16, r20
    5f0a:	69 01       	movw	r12, r18
    5f0c:	09 c0       	rjmp	.+18     	; 0x5f20 <__eewr_block+0x28>
    5f0e:	ce 01       	movw	r24, r28
    5f10:	21 96       	adiw	r28, 0x01	; 1
    5f12:	f7 01       	movw	r30, r14
    5f14:	61 91       	ld	r22, Z+
    5f16:	7f 01       	movw	r14, r30
    5f18:	f6 01       	movw	r30, r12
    5f1a:	09 95       	icall
    5f1c:	01 50       	subi	r16, 0x01	; 1
    5f1e:	10 40       	sbci	r17, 0x00	; 0
    5f20:	01 15       	cp	r16, r1
    5f22:	11 05       	cpc	r17, r1
    5f24:	a1 f7       	brne	.-24     	; 0x5f0e <__eewr_block+0x16>
    5f26:	cd b7       	in	r28, 0x3d	; 61
    5f28:	de b7       	in	r29, 0x3e	; 62
    5f2a:	e8 e0       	ldi	r30, 0x08	; 8
    5f2c:	0c 94 7f 30 	jmp	0x60fe	; 0x60fe <__epilogue_restores__+0x14>

00005f30 <itoa>:
    5f30:	fb 01       	movw	r30, r22
    5f32:	9f 01       	movw	r18, r30
    5f34:	e8 94       	clt
    5f36:	42 30       	cpi	r20, 0x02	; 2
    5f38:	c4 f0       	brlt	.+48     	; 0x5f6a <itoa+0x3a>
    5f3a:	45 32       	cpi	r20, 0x25	; 37
    5f3c:	b4 f4       	brge	.+44     	; 0x5f6a <itoa+0x3a>
    5f3e:	4a 30       	cpi	r20, 0x0A	; 10
    5f40:	29 f4       	brne	.+10     	; 0x5f4c <itoa+0x1c>
    5f42:	97 fb       	bst	r25, 7
    5f44:	1e f4       	brtc	.+6      	; 0x5f4c <itoa+0x1c>
    5f46:	90 95       	com	r25
    5f48:	81 95       	neg	r24
    5f4a:	9f 4f       	sbci	r25, 0xFF	; 255
    5f4c:	64 2f       	mov	r22, r20
    5f4e:	77 27       	eor	r23, r23
    5f50:	0e 94 45 30 	call	0x608a	; 0x608a <__udivmodhi4>
    5f54:	80 5d       	subi	r24, 0xD0	; 208
    5f56:	8a 33       	cpi	r24, 0x3A	; 58
    5f58:	0c f0       	brlt	.+2      	; 0x5f5c <itoa+0x2c>
    5f5a:	89 5d       	subi	r24, 0xD9	; 217
    5f5c:	81 93       	st	Z+, r24
    5f5e:	cb 01       	movw	r24, r22
    5f60:	00 97       	sbiw	r24, 0x00	; 0
    5f62:	a1 f7       	brne	.-24     	; 0x5f4c <itoa+0x1c>
    5f64:	16 f4       	brtc	.+4      	; 0x5f6a <itoa+0x3a>
    5f66:	5d e2       	ldi	r21, 0x2D	; 45
    5f68:	51 93       	st	Z+, r21
    5f6a:	10 82       	st	Z, r1
    5f6c:	c9 01       	movw	r24, r18
    5f6e:	0c 94 f4 2f 	jmp	0x5fe8	; 0x5fe8 <strrev>

00005f72 <ultoa>:
    5f72:	fa 01       	movw	r30, r20
    5f74:	cf 93       	push	r28
    5f76:	ff 93       	push	r31
    5f78:	ef 93       	push	r30
    5f7a:	22 30       	cpi	r18, 0x02	; 2
    5f7c:	cc f0       	brlt	.+50     	; 0x5fb0 <ultoa+0x3e>
    5f7e:	25 32       	cpi	r18, 0x25	; 37
    5f80:	bc f4       	brge	.+46     	; 0x5fb0 <ultoa+0x3e>
    5f82:	c2 2f       	mov	r28, r18
    5f84:	2c 2f       	mov	r18, r28
    5f86:	33 27       	eor	r19, r19
    5f88:	44 27       	eor	r20, r20
    5f8a:	55 27       	eor	r21, r21
    5f8c:	ff 93       	push	r31
    5f8e:	ef 93       	push	r30
    5f90:	0e 94 23 30 	call	0x6046	; 0x6046 <__udivmodsi4>
    5f94:	ef 91       	pop	r30
    5f96:	ff 91       	pop	r31
    5f98:	60 5d       	subi	r22, 0xD0	; 208
    5f9a:	6a 33       	cpi	r22, 0x3A	; 58
    5f9c:	0c f0       	brlt	.+2      	; 0x5fa0 <ultoa+0x2e>
    5f9e:	69 5d       	subi	r22, 0xD9	; 217
    5fa0:	61 93       	st	Z+, r22
    5fa2:	b9 01       	movw	r22, r18
    5fa4:	ca 01       	movw	r24, r20
    5fa6:	60 50       	subi	r22, 0x00	; 0
    5fa8:	70 40       	sbci	r23, 0x00	; 0
    5faa:	80 40       	sbci	r24, 0x00	; 0
    5fac:	90 40       	sbci	r25, 0x00	; 0
    5fae:	51 f7       	brne	.-44     	; 0x5f84 <ultoa+0x12>
    5fb0:	10 82       	st	Z, r1
    5fb2:	8f 91       	pop	r24
    5fb4:	9f 91       	pop	r25
    5fb6:	cf 91       	pop	r28
    5fb8:	0c 94 f4 2f 	jmp	0x5fe8	; 0x5fe8 <strrev>

00005fbc <utoa>:
    5fbc:	fb 01       	movw	r30, r22
    5fbe:	9f 01       	movw	r18, r30
    5fc0:	42 30       	cpi	r20, 0x02	; 2
    5fc2:	74 f0       	brlt	.+28     	; 0x5fe0 <utoa+0x24>
    5fc4:	45 32       	cpi	r20, 0x25	; 37
    5fc6:	64 f4       	brge	.+24     	; 0x5fe0 <utoa+0x24>
    5fc8:	64 2f       	mov	r22, r20
    5fca:	77 27       	eor	r23, r23
    5fcc:	0e 94 45 30 	call	0x608a	; 0x608a <__udivmodhi4>
    5fd0:	80 5d       	subi	r24, 0xD0	; 208
    5fd2:	8a 33       	cpi	r24, 0x3A	; 58
    5fd4:	0c f0       	brlt	.+2      	; 0x5fd8 <utoa+0x1c>
    5fd6:	89 5d       	subi	r24, 0xD9	; 217
    5fd8:	81 93       	st	Z+, r24
    5fda:	cb 01       	movw	r24, r22
    5fdc:	00 97       	sbiw	r24, 0x00	; 0
    5fde:	a1 f7       	brne	.-24     	; 0x5fc8 <utoa+0xc>
    5fe0:	10 82       	st	Z, r1
    5fe2:	c9 01       	movw	r24, r18
    5fe4:	0c 94 f4 2f 	jmp	0x5fe8	; 0x5fe8 <strrev>

00005fe8 <strrev>:
    5fe8:	dc 01       	movw	r26, r24
    5fea:	fc 01       	movw	r30, r24
    5fec:	67 2f       	mov	r22, r23
    5fee:	71 91       	ld	r23, Z+
    5ff0:	77 23       	and	r23, r23
    5ff2:	e1 f7       	brne	.-8      	; 0x5fec <strrev+0x4>
    5ff4:	32 97       	sbiw	r30, 0x02	; 2
    5ff6:	04 c0       	rjmp	.+8      	; 0x6000 <strrev+0x18>
    5ff8:	7c 91       	ld	r23, X
    5ffa:	6d 93       	st	X+, r22
    5ffc:	70 83       	st	Z, r23
    5ffe:	62 91       	ld	r22, -Z
    6000:	ae 17       	cp	r26, r30
    6002:	bf 07       	cpc	r27, r31
    6004:	c8 f3       	brcs	.-14     	; 0x5ff8 <strrev+0x10>
    6006:	08 95       	ret

00006008 <__mulsi3>:
    6008:	62 9f       	mul	r22, r18
    600a:	d0 01       	movw	r26, r0
    600c:	73 9f       	mul	r23, r19
    600e:	f0 01       	movw	r30, r0
    6010:	82 9f       	mul	r24, r18
    6012:	e0 0d       	add	r30, r0
    6014:	f1 1d       	adc	r31, r1
    6016:	64 9f       	mul	r22, r20
    6018:	e0 0d       	add	r30, r0
    601a:	f1 1d       	adc	r31, r1
    601c:	92 9f       	mul	r25, r18
    601e:	f0 0d       	add	r31, r0
    6020:	83 9f       	mul	r24, r19
    6022:	f0 0d       	add	r31, r0
    6024:	74 9f       	mul	r23, r20
    6026:	f0 0d       	add	r31, r0
    6028:	65 9f       	mul	r22, r21
    602a:	f0 0d       	add	r31, r0
    602c:	99 27       	eor	r25, r25
    602e:	72 9f       	mul	r23, r18
    6030:	b0 0d       	add	r27, r0
    6032:	e1 1d       	adc	r30, r1
    6034:	f9 1f       	adc	r31, r25
    6036:	63 9f       	mul	r22, r19
    6038:	b0 0d       	add	r27, r0
    603a:	e1 1d       	adc	r30, r1
    603c:	f9 1f       	adc	r31, r25
    603e:	bd 01       	movw	r22, r26
    6040:	cf 01       	movw	r24, r30
    6042:	11 24       	eor	r1, r1
    6044:	08 95       	ret

00006046 <__udivmodsi4>:
    6046:	a1 e2       	ldi	r26, 0x21	; 33
    6048:	1a 2e       	mov	r1, r26
    604a:	aa 1b       	sub	r26, r26
    604c:	bb 1b       	sub	r27, r27
    604e:	fd 01       	movw	r30, r26
    6050:	0d c0       	rjmp	.+26     	; 0x606c <__udivmodsi4_ep>

00006052 <__udivmodsi4_loop>:
    6052:	aa 1f       	adc	r26, r26
    6054:	bb 1f       	adc	r27, r27
    6056:	ee 1f       	adc	r30, r30
    6058:	ff 1f       	adc	r31, r31
    605a:	a2 17       	cp	r26, r18
    605c:	b3 07       	cpc	r27, r19
    605e:	e4 07       	cpc	r30, r20
    6060:	f5 07       	cpc	r31, r21
    6062:	20 f0       	brcs	.+8      	; 0x606c <__udivmodsi4_ep>
    6064:	a2 1b       	sub	r26, r18
    6066:	b3 0b       	sbc	r27, r19
    6068:	e4 0b       	sbc	r30, r20
    606a:	f5 0b       	sbc	r31, r21

0000606c <__udivmodsi4_ep>:
    606c:	66 1f       	adc	r22, r22
    606e:	77 1f       	adc	r23, r23
    6070:	88 1f       	adc	r24, r24
    6072:	99 1f       	adc	r25, r25
    6074:	1a 94       	dec	r1
    6076:	69 f7       	brne	.-38     	; 0x6052 <__udivmodsi4_loop>
    6078:	60 95       	com	r22
    607a:	70 95       	com	r23
    607c:	80 95       	com	r24
    607e:	90 95       	com	r25
    6080:	9b 01       	movw	r18, r22
    6082:	ac 01       	movw	r20, r24
    6084:	bd 01       	movw	r22, r26
    6086:	cf 01       	movw	r24, r30
    6088:	08 95       	ret

0000608a <__udivmodhi4>:
    608a:	aa 1b       	sub	r26, r26
    608c:	bb 1b       	sub	r27, r27
    608e:	51 e1       	ldi	r21, 0x11	; 17
    6090:	07 c0       	rjmp	.+14     	; 0x60a0 <__udivmodhi4_ep>

00006092 <__udivmodhi4_loop>:
    6092:	aa 1f       	adc	r26, r26
    6094:	bb 1f       	adc	r27, r27
    6096:	a6 17       	cp	r26, r22
    6098:	b7 07       	cpc	r27, r23
    609a:	10 f0       	brcs	.+4      	; 0x60a0 <__udivmodhi4_ep>
    609c:	a6 1b       	sub	r26, r22
    609e:	b7 0b       	sbc	r27, r23

000060a0 <__udivmodhi4_ep>:
    60a0:	88 1f       	adc	r24, r24
    60a2:	99 1f       	adc	r25, r25
    60a4:	5a 95       	dec	r21
    60a6:	a9 f7       	brne	.-22     	; 0x6092 <__udivmodhi4_loop>
    60a8:	80 95       	com	r24
    60aa:	90 95       	com	r25
    60ac:	bc 01       	movw	r22, r24
    60ae:	cd 01       	movw	r24, r26
    60b0:	08 95       	ret

000060b2 <__prologue_saves__>:
    60b2:	2f 92       	push	r2
    60b4:	3f 92       	push	r3
    60b6:	4f 92       	push	r4
    60b8:	5f 92       	push	r5
    60ba:	6f 92       	push	r6
    60bc:	7f 92       	push	r7
    60be:	8f 92       	push	r8
    60c0:	9f 92       	push	r9
    60c2:	af 92       	push	r10
    60c4:	bf 92       	push	r11
    60c6:	cf 92       	push	r12
    60c8:	df 92       	push	r13
    60ca:	ef 92       	push	r14
    60cc:	ff 92       	push	r15
    60ce:	0f 93       	push	r16
    60d0:	1f 93       	push	r17
    60d2:	cf 93       	push	r28
    60d4:	df 93       	push	r29
    60d6:	cd b7       	in	r28, 0x3d	; 61
    60d8:	de b7       	in	r29, 0x3e	; 62
    60da:	ca 1b       	sub	r28, r26
    60dc:	db 0b       	sbc	r29, r27
    60de:	0f b6       	in	r0, 0x3f	; 63
    60e0:	f8 94       	cli
    60e2:	de bf       	out	0x3e, r29	; 62
    60e4:	0f be       	out	0x3f, r0	; 63
    60e6:	cd bf       	out	0x3d, r28	; 61
    60e8:	09 94       	ijmp

000060ea <__epilogue_restores__>:
    60ea:	2a 88       	ldd	r2, Y+18	; 0x12
    60ec:	39 88       	ldd	r3, Y+17	; 0x11
    60ee:	48 88       	ldd	r4, Y+16	; 0x10
    60f0:	5f 84       	ldd	r5, Y+15	; 0x0f
    60f2:	6e 84       	ldd	r6, Y+14	; 0x0e
    60f4:	7d 84       	ldd	r7, Y+13	; 0x0d
    60f6:	8c 84       	ldd	r8, Y+12	; 0x0c
    60f8:	9b 84       	ldd	r9, Y+11	; 0x0b
    60fa:	aa 84       	ldd	r10, Y+10	; 0x0a
    60fc:	b9 84       	ldd	r11, Y+9	; 0x09
    60fe:	c8 84       	ldd	r12, Y+8	; 0x08
    6100:	df 80       	ldd	r13, Y+7	; 0x07
    6102:	ee 80       	ldd	r14, Y+6	; 0x06
    6104:	fd 80       	ldd	r15, Y+5	; 0x05
    6106:	0c 81       	ldd	r16, Y+4	; 0x04
    6108:	1b 81       	ldd	r17, Y+3	; 0x03
    610a:	aa 81       	ldd	r26, Y+2	; 0x02
    610c:	b9 81       	ldd	r27, Y+1	; 0x01
    610e:	ce 0f       	add	r28, r30
    6110:	d1 1d       	adc	r29, r1
    6112:	0f b6       	in	r0, 0x3f	; 63
    6114:	f8 94       	cli
    6116:	de bf       	out	0x3e, r29	; 62
    6118:	0f be       	out	0x3f, r0	; 63
    611a:	cd bf       	out	0x3d, r28	; 61
    611c:	ed 01       	movw	r28, r26
    611e:	08 95       	ret

00006120 <_exit>:
    6120:	f8 94       	cli

00006122 <__stop_program>:
    6122:	ff cf       	rjmp	.-2      	; 0x6122 <__stop_program>
