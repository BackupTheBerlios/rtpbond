
aeb.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000006e0  00800100  00005f1a  00005fae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005f1a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b0  008007e0  008007e0  0000668e  2**0
                  ALLOC
  3 .debug_aranges 000002c0  00000000  00000000  0000668e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000dcc  00000000  00000000  0000694e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000063a8  00000000  00000000  0000771a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001e0f  00000000  00000000  0000dac2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005c90  00000000  00000000  0000f8d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000b10  00000000  00000000  00015564  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001277  00000000  00000000  00016074  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004259  00000000  00000000  000172eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000890  00000000  00000000  0001b544  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      30:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      40:	0c 94 2a 10 	jmp	0x2054	; 0x2054 <__vector_16>
      44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      48:	0c 94 ee 11 	jmp	0x23dc	; 0x23dc <__vector_18>
      4c:	0c 94 2a 12 	jmp	0x2454	; 0x2454 <__vector_19>
      50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      68:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      6c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      70:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      74:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      78:	0c 94 a8 2c 	jmp	0x5950	; 0x5950 <__vector_30>
      7c:	0c 94 2d 2c 	jmp	0x585a	; 0x585a <__vector_31>
      80:	0c 94 46 2c 	jmp	0x588c	; 0x588c <__vector_32>
      84:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      88:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	17 e0       	ldi	r17, 0x07	; 7
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ea e1       	ldi	r30, 0x1A	; 26
      a0:	ff e5       	ldi	r31, 0x5F	; 95
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a0 3e       	cpi	r26, 0xE0	; 224
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>
      b2:	1b be       	out	0x3b, r1	; 59

000000b4 <__do_clear_bss>:
      b4:	19 e0       	ldi	r17, 0x09	; 9
      b6:	a0 ee       	ldi	r26, 0xE0	; 224
      b8:	b7 e0       	ldi	r27, 0x07	; 7
      ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
      bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
      be:	a0 39       	cpi	r26, 0x90	; 144
      c0:	b1 07       	cpc	r27, r17
      c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>
      c4:	0e 94 68 00 	call	0xd0	; 0xd0 <main>
      c8:	0c 94 8b 2f 	jmp	0x5f16	; 0x5f16 <_exit>

000000cc <__bad_interrupt>:
      cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <main>:
// Main-Funktion
/////////////////////////////////////////////////////////////////////////////
int main()
{
	
  cli();
      d0:	f8 94       	cli

  debug=0;
      d2:	10 92 e4 07 	sts	0x07E4, r1
      d6:	10 92 e3 07 	sts	0x07E3, r1
    // Move interrupts to boot flash section
    MCUCR = (1<<IVSEL);
    //+***************** BOOTLOADER ONLY ***********************
  #else
    // Enable change of interrupt vectors 
    MCUCR = (1<<IVCE);
      da:	81 e0       	ldi	r24, 0x01	; 1
      dc:	85 bf       	out	0x35, r24	; 53
    // Restore interrupts vectors 
    MCUCR = (0<<IVSEL);
      de:	15 be       	out	0x35, r1	; 53
  #endif
  


  // Load configuration from EEPROM if valid, else load fallback config
  onInitConfig();
      e0:	0e 94 a1 2b 	call	0x5742	; 0x5742 <onInitConfig>


  // At first, we initialize the real time clock ...
   onInitClock();
      e4:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <onInitClock>
  // ... then the timer, it depends on the clock module ...
 onInitTimer();
      e8:	0e 94 fe 0c 	call	0x19fc	; 0x19fc <onInitTimer>



  // ... Ethernet depends itself on the timer module ...
  onInitEthernet();
      ec:	0e 94 56 07 	call	0xeac	; 0xeac <onInitEthernet>
  #ifdef REQUIRES_SERIAL
    // ... the same applies to the serial module
    onInitSerial();
      f0:	0e 94 bb 0c 	call	0x1976	; 0x1976 <onInitSerial>

com1Initialize(0,0);
      f4:	80 e0       	ldi	r24, 0x00	; 0
      f6:	90 e0       	ldi	r25, 0x00	; 0
      f8:	60 e0       	ldi	r22, 0x00	; 0
      fa:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <com1Initialize>
    onInitWatchdog();  
  #endif
  // ... initialization finished, it is save to enable interrupts...
  
  
  onInitApplication();
      fe:	0e 94 8a 1a 	call	0x3514	; 0x3514 <onInitApplication>




sei();
     102:	78 94       	sei

	while (1)  	// Mainloop-Begin
	{

	 // Check for timer events
    onTimer();
     104:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <onTimer>
   
    // COM Event Handler...
   // #ifdef REQUIRES_SERIAL alx
      onSerial();
     108:	0e 94 88 0c 	call	0x1910	; 0x1910 <onSerial>
  //  #endif
           
    onEthernet();
     10c:	0e 94 f6 07 	call	0xfec	; 0xfec <onEthernet>

	if(debug>=1)
     110:	80 91 e3 07 	lds	r24, 0x07E3
     114:	90 91 e4 07 	lds	r25, 0x07E4
     118:	89 2b       	or	r24, r25
     11a:	a1 f3       	breq	.-24     	; 0x104 <main+0x34>
	 putString("running");
     11c:	80 e0       	ldi	r24, 0x00	; 0
     11e:	91 e0       	ldi	r25, 0x01	; 1
     120:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
     124:	ef cf       	rjmp	.-34     	; 0x104 <main+0x34>

00000126 <arpAddMacByIPv4>:
  
  return;
}

uint8_t arpAddMacByIPv4(ipAddress_t* ip, struct macAddress_t* mac)
{
     126:	0f 93       	push	r16
     128:	1f 93       	push	r17
     12a:	cf 93       	push	r28
     12c:	df 93       	push	r29
     12e:	fc 01       	movw	r30, r24
     130:	16 2f       	mov	r17, r22
     132:	07 2f       	mov	r16, r23
     134:	20 81       	ld	r18, Z
     136:	31 81       	ldd	r19, Z+1	; 0x01
     138:	42 81       	ldd	r20, Z+2	; 0x02
     13a:	53 81       	ldd	r21, Z+3	; 0x03
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     13c:	80 91 19 08 	lds	r24, 0x0819
     140:	90 91 1a 08 	lds	r25, 0x081A
     144:	a0 91 1b 08 	lds	r26, 0x081B
     148:	b0 91 1c 08 	lds	r27, 0x081C
     14c:	82 17       	cp	r24, r18
     14e:	93 07       	cpc	r25, r19
     150:	a4 07       	cpc	r26, r20
     152:	b5 07       	cpc	r27, r21
     154:	09 f4       	brne	.+2      	; 0x158 <arpAddMacByIPv4+0x32>
     156:	72 c0       	rjmp	.+228    	; 0x23c <arpAddMacByIPv4+0x116>
     158:	80 91 0e 08 	lds	r24, 0x080E
     15c:	90 91 0f 08 	lds	r25, 0x080F
     160:	a0 91 10 08 	lds	r26, 0x0810
     164:	b0 91 11 08 	lds	r27, 0x0811
     168:	82 17       	cp	r24, r18
     16a:	93 07       	cpc	r25, r19
     16c:	a4 07       	cpc	r26, r20
     16e:	b5 07       	cpc	r27, r21
     170:	09 f4       	brne	.+2      	; 0x174 <arpAddMacByIPv4+0x4e>
     172:	92 c0       	rjmp	.+292    	; 0x298 <arpAddMacByIPv4+0x172>
      hArp.arpCache[i].age = 255;
      return 0;
    }
    
    // we mark is entry as usable if it's overaged or was never used    
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
     174:	90 91 1d 08 	lds	r25, 0x081D
     178:	80 91 12 08 	lds	r24, 0x0812
     17c:	98 17       	cp	r25, r24
     17e:	08 f0       	brcs	.+2      	; 0x182 <arpAddMacByIPv4+0x5c>
     180:	54 c0       	rjmp	.+168    	; 0x22a <arpAddMacByIPv4+0x104>
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     182:	e8 e0       	ldi	r30, 0x08	; 8
     184:	f8 e0       	ldi	r31, 0x08	; 8
     186:	80 91 03 08 	lds	r24, 0x0803
     18a:	90 91 04 08 	lds	r25, 0x0804
     18e:	a0 91 05 08 	lds	r26, 0x0805
     192:	b0 91 06 08 	lds	r27, 0x0806
     196:	82 17       	cp	r24, r18
     198:	93 07       	cpc	r25, r19
     19a:	a4 07       	cpc	r26, r20
     19c:	b5 07       	cpc	r27, r21
     19e:	09 f4       	brne	.+2      	; 0x1a2 <arpAddMacByIPv4+0x7c>
     1a0:	72 c0       	rjmp	.+228    	; 0x286 <arpAddMacByIPv4+0x160>
      hArp.arpCache[i].age = 255;
      return 0;
    }
    
    // we mark is entry as usable if it's overaged or was never used    
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
     1a2:	92 85       	ldd	r25, Z+10	; 0x0a
     1a4:	80 91 07 08 	lds	r24, 0x0807
     1a8:	98 17       	cp	r25, r24
     1aa:	e0 f1       	brcs	.+120    	; 0x224 <arpAddMacByIPv4+0xfe>
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     1ac:	80 91 f8 07 	lds	r24, 0x07F8
     1b0:	90 91 f9 07 	lds	r25, 0x07F9
     1b4:	a0 91 fa 07 	lds	r26, 0x07FA
     1b8:	b0 91 fb 07 	lds	r27, 0x07FB
     1bc:	82 17       	cp	r24, r18
     1be:	93 07       	cpc	r25, r19
     1c0:	a4 07       	cpc	r26, r20
     1c2:	b5 07       	cpc	r27, r21
     1c4:	09 f4       	brne	.+2      	; 0x1c8 <arpAddMacByIPv4+0xa2>
     1c6:	62 c0       	rjmp	.+196    	; 0x28c <arpAddMacByIPv4+0x166>
      hArp.arpCache[i].age = 255;
      return 0;
    }
    
    // we mark is entry as usable if it's overaged or was never used    
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
     1c8:	92 85       	ldd	r25, Z+10	; 0x0a
     1ca:	80 91 fc 07 	lds	r24, 0x07FC
     1ce:	98 17       	cp	r25, r24
     1d0:	78 f1       	brcs	.+94     	; 0x230 <arpAddMacByIPv4+0x10a>
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     1d2:	80 91 ed 07 	lds	r24, 0x07ED
     1d6:	90 91 ee 07 	lds	r25, 0x07EE
     1da:	a0 91 ef 07 	lds	r26, 0x07EF
     1de:	b0 91 f0 07 	lds	r27, 0x07F0
     1e2:	82 17       	cp	r24, r18
     1e4:	93 07       	cpc	r25, r19
     1e6:	a4 07       	cpc	r26, r20
     1e8:	b5 07       	cpc	r27, r21
     1ea:	09 f4       	brne	.+2      	; 0x1ee <arpAddMacByIPv4+0xc8>
     1ec:	52 c0       	rjmp	.+164    	; 0x292 <arpAddMacByIPv4+0x16c>
      hArp.arpCache[i].age = 255;
      return 0;
    }
    
    // we mark is entry as usable if it's overaged or was never used    
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
     1ee:	92 85       	ldd	r25, Z+10	; 0x0a
     1f0:	80 91 f1 07 	lds	r24, 0x07F1
     1f4:	98 17       	cp	r25, r24
     1f6:	f8 f0       	brcs	.+62     	; 0x236 <arpAddMacByIPv4+0x110>
      oldest = &hArp.arpCache[i]; 
  }
  
  // overwrite the oldest entry
  oldest->ip = *ip;
     1f8:	26 83       	std	Z+6, r18	; 0x06
     1fa:	37 83       	std	Z+7, r19	; 0x07
     1fc:	40 87       	std	Z+8, r20	; 0x08
     1fe:	51 87       	std	Z+9, r21	; 0x09
  oldest->mac = *mac;
     200:	ef 01       	movw	r28, r30
     202:	81 2f       	mov	r24, r17
     204:	90 2f       	mov	r25, r16
     206:	9c 01       	movw	r18, r24
     208:	d9 01       	movw	r26, r18
     20a:	86 e0       	ldi	r24, 0x06	; 6
     20c:	0d 90       	ld	r0, X+
     20e:	09 92       	st	Y+, r0
     210:	81 50       	subi	r24, 0x01	; 1
     212:	e1 f7       	brne	.-8      	; 0x20c <arpAddMacByIPv4+0xe6>
  oldest->age = 255;
     214:	8f ef       	ldi	r24, 0xFF	; 255
     216:	82 87       	std	Z+10, r24	; 0x0a
  
  return 0;
}
     218:	80 e0       	ldi	r24, 0x00	; 0
     21a:	df 91       	pop	r29
     21c:	cf 91       	pop	r28
     21e:	1f 91       	pop	r17
     220:	0f 91       	pop	r16
     222:	08 95       	ret
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     224:	ed ef       	ldi	r30, 0xFD	; 253
     226:	f7 e0       	ldi	r31, 0x07	; 7
     228:	c1 cf       	rjmp	.-126    	; 0x1ac <arpAddMacByIPv4+0x86>
      hArp.arpCache[i].age = 255;
      return 0;
    }
    
    // we mark is entry as usable if it's overaged or was never used    
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
     22a:	e3 e1       	ldi	r30, 0x13	; 19
     22c:	f8 e0       	ldi	r31, 0x08	; 8
     22e:	ab cf       	rjmp	.-170    	; 0x186 <arpAddMacByIPv4+0x60>
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     230:	e2 ef       	ldi	r30, 0xF2	; 242
     232:	f7 e0       	ldi	r31, 0x07	; 7
     234:	ce cf       	rjmp	.-100    	; 0x1d2 <arpAddMacByIPv4+0xac>
      hArp.arpCache[i].age = 255;
      return 0;
    }
    
    // we mark is entry as usable if it's overaged or was never used    
    if ((oldest == NULL) || (oldest->age < hArp.arpCache[i].age))
     236:	e7 ee       	ldi	r30, 0xE7	; 231
     238:	f7 e0       	ldi	r31, 0x07	; 7
     23a:	de cf       	rjmp	.-68     	; 0x1f8 <arpAddMacByIPv4+0xd2>
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     23c:	44 e0       	ldi	r20, 0x04	; 4
     23e:	50 e0       	ldi	r21, 0x00	; 0
    {
      hArp.arpCache[i].mac = *mac;
     240:	ba 01       	movw	r22, r20
     242:	66 0f       	add	r22, r22
     244:	77 1f       	adc	r23, r23
     246:	ea 01       	movw	r28, r20
     248:	cc 0f       	add	r28, r28
     24a:	dd 1f       	adc	r29, r29
     24c:	cc 0f       	add	r28, r28
     24e:	dd 1f       	adc	r29, r29
     250:	cc 0f       	add	r28, r28
     252:	dd 1f       	adc	r29, r29
     254:	fb 01       	movw	r30, r22
     256:	ec 0f       	add	r30, r28
     258:	fd 1f       	adc	r31, r29
     25a:	e4 0f       	add	r30, r20
     25c:	f5 1f       	adc	r31, r21
     25e:	e9 51       	subi	r30, 0x19	; 25
     260:	f8 4f       	sbci	r31, 0xF8	; 248
     262:	81 2f       	mov	r24, r17
     264:	90 2f       	mov	r25, r16
     266:	9c 01       	movw	r18, r24
     268:	d9 01       	movw	r26, r18
     26a:	86 e0       	ldi	r24, 0x06	; 6
     26c:	0d 90       	ld	r0, X+
     26e:	01 92       	st	Z+, r0
     270:	81 50       	subi	r24, 0x01	; 1
     272:	e1 f7       	brne	.-8      	; 0x26c <arpAddMacByIPv4+0x146>
      hArp.arpCache[i].age = 255;
     274:	c6 0f       	add	r28, r22
     276:	d7 1f       	adc	r29, r23
     278:	c4 0f       	add	r28, r20
     27a:	d5 1f       	adc	r29, r21
     27c:	c9 51       	subi	r28, 0x19	; 25
     27e:	d8 4f       	sbci	r29, 0xF8	; 248
     280:	8f ef       	ldi	r24, 0xFF	; 255
     282:	8a 87       	std	Y+10, r24	; 0x0a
     284:	c9 cf       	rjmp	.-110    	; 0x218 <arpAddMacByIPv4+0xf2>
  struct arpCacheEntry_t* oldest = NULL;
  
  while (i--)
  {
    // is it a direct hit?
    if (hArp.arpCache[i].ip == *ip)
     286:	42 e0       	ldi	r20, 0x02	; 2
     288:	50 e0       	ldi	r21, 0x00	; 0
     28a:	da cf       	rjmp	.-76     	; 0x240 <arpAddMacByIPv4+0x11a>
     28c:	41 e0       	ldi	r20, 0x01	; 1
     28e:	50 e0       	ldi	r21, 0x00	; 0
     290:	d7 cf       	rjmp	.-82     	; 0x240 <arpAddMacByIPv4+0x11a>
     292:	40 e0       	ldi	r20, 0x00	; 0
     294:	50 e0       	ldi	r21, 0x00	; 0
     296:	d4 cf       	rjmp	.-88     	; 0x240 <arpAddMacByIPv4+0x11a>
     298:	43 e0       	ldi	r20, 0x03	; 3
     29a:	50 e0       	ldi	r21, 0x00	; 0
     29c:	d1 cf       	rjmp	.-94     	; 0x240 <arpAddMacByIPv4+0x11a>

0000029e <onInitArp>:
  int i = ARP_CACHE_SIZE;
  
  while (i--)
  {
    // a time to Live of 0 means empty
    hArp.arpCache[i].age = 0;
     29e:	10 92 1d 08 	sts	0x081D, r1
     2a2:	10 92 12 08 	sts	0x0812, r1
     2a6:	10 92 07 08 	sts	0x0807, r1
     2aa:	10 92 fc 07 	sts	0x07FC, r1
     2ae:	10 92 f1 07 	sts	0x07F1, r1
  }
  
  timerAddTimeout(ARP_AGE_INTERVAL,onArpTimeout);
     2b2:	80 e7       	ldi	r24, 0x70	; 112
     2b4:	97 e1       	ldi	r25, 0x17	; 23
     2b6:	60 e6       	ldi	r22, 0x60	; 96
     2b8:	71 e0       	ldi	r23, 0x01	; 1
     2ba:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <timerAddTimeout>
  
  return;
}
     2be:	08 95       	ret

000002c0 <onArpTimeout>:
void onArpTimeout()
{
  int i = ARP_CACHE_SIZE;
  while (i--)
  {
    if (hArp.arpCache[i].age == 0)
     2c0:	80 91 1d 08 	lds	r24, 0x081D
     2c4:	88 23       	and	r24, r24
     2c6:	19 f0       	breq	.+6      	; 0x2ce <onArpTimeout+0xe>
      continue;
    
    hArp.arpCache[i].age--;
     2c8:	81 50       	subi	r24, 0x01	; 1
     2ca:	80 93 1d 08 	sts	0x081D, r24
void onArpTimeout()
{
  int i = ARP_CACHE_SIZE;
  while (i--)
  {
    if (hArp.arpCache[i].age == 0)
     2ce:	80 91 12 08 	lds	r24, 0x0812
     2d2:	88 23       	and	r24, r24
     2d4:	19 f0       	breq	.+6      	; 0x2dc <onArpTimeout+0x1c>
      continue;
    
    hArp.arpCache[i].age--;
     2d6:	81 50       	subi	r24, 0x01	; 1
     2d8:	80 93 12 08 	sts	0x0812, r24
void onArpTimeout()
{
  int i = ARP_CACHE_SIZE;
  while (i--)
  {
    if (hArp.arpCache[i].age == 0)
     2dc:	80 91 07 08 	lds	r24, 0x0807
     2e0:	88 23       	and	r24, r24
     2e2:	19 f0       	breq	.+6      	; 0x2ea <onArpTimeout+0x2a>
      continue;
    
    hArp.arpCache[i].age--;
     2e4:	81 50       	subi	r24, 0x01	; 1
     2e6:	80 93 07 08 	sts	0x0807, r24
void onArpTimeout()
{
  int i = ARP_CACHE_SIZE;
  while (i--)
  {
    if (hArp.arpCache[i].age == 0)
     2ea:	80 91 fc 07 	lds	r24, 0x07FC
     2ee:	88 23       	and	r24, r24
     2f0:	19 f0       	breq	.+6      	; 0x2f8 <onArpTimeout+0x38>
      continue;
    
    hArp.arpCache[i].age--;
     2f2:	81 50       	subi	r24, 0x01	; 1
     2f4:	80 93 fc 07 	sts	0x07FC, r24
void onArpTimeout()
{
  int i = ARP_CACHE_SIZE;
  while (i--)
  {
    if (hArp.arpCache[i].age == 0)
     2f8:	80 91 f1 07 	lds	r24, 0x07F1
     2fc:	88 23       	and	r24, r24
     2fe:	19 f0       	breq	.+6      	; 0x306 <onArpTimeout+0x46>
      continue;
    
    hArp.arpCache[i].age--;
     300:	81 50       	subi	r24, 0x01	; 1
     302:	80 93 f1 07 	sts	0x07F1, r24
  
  // Every entry can age exactly 255 times, ...
  // ... as we age the arpcache very 6 seconds,...
  // ... this results in an total timeout of approx ...
  // ... 25 Minutes.
  timerAddTimeout(ARP_AGE_INTERVAL,onArpTimeout);
     306:	80 e7       	ldi	r24, 0x70	; 112
     308:	97 e1       	ldi	r25, 0x17	; 23
     30a:	60 e6       	ldi	r22, 0x60	; 96
     30c:	71 e0       	ldi	r23, 0x01	; 1
     30e:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <timerAddTimeout>
  
  return;
}
     312:	08 95       	ret

00000314 <onArpRequest>:
  
  return onArpRequest(handle,tpa,tha);
}

uint8_t onArpRequest(struct nicRequestHandle_t* handle,ipAddress_t* tpa, struct macAddress_t* tha)
{
     314:	af 92       	push	r10
     316:	bf 92       	push	r11
     318:	cf 92       	push	r12
     31a:	df 92       	push	r13
     31c:	ef 92       	push	r14
     31e:	ff 92       	push	r15
     320:	0f 93       	push	r16
     322:	1f 93       	push	r17
     324:	df 93       	push	r29
     326:	cf 93       	push	r28
     328:	00 d0       	rcall	.+0      	; 0x32a <onArpRequest+0x16>
     32a:	00 d0       	rcall	.+0      	; 0x32c <onArpRequest+0x18>
     32c:	00 d0       	rcall	.+0      	; 0x32e <onArpRequest+0x1a>
     32e:	cd b7       	in	r28, 0x3d	; 61
     330:	de b7       	in	r29, 0x3e	; 62
     332:	5c 01       	movw	r10, r24
     334:	8b 01       	movw	r16, r22
     336:	6a 01       	movw	r12, r20
  struct soArpHeader_t* header 
    = (struct soArpHeader_t*) nicAddPacketHeader(handle, sizeof(struct soArpHeader_t));
     338:	6c e1       	ldi	r22, 0x1C	; 28
     33a:	70 e0       	ldi	r23, 0x00	; 0
     33c:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     340:	7c 01       	movw	r14, r24

  // Set Hardwaretype to Ethernet...
  header->htype = 0x0100;
     342:	80 e0       	ldi	r24, 0x00	; 0
     344:	91 e0       	ldi	r25, 0x01	; 1
     346:	f7 01       	movw	r30, r14
     348:	91 83       	std	Z+1, r25	; 0x01
     34a:	80 83       	st	Z, r24
  // ... the protocol is IP
  header->ptype = 0x0008;
     34c:	88 e0       	ldi	r24, 0x08	; 8
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	93 83       	std	Z+3, r25	; 0x03
     352:	82 83       	std	Z+2, r24	; 0x02
  // Ethernet addresses are 6bytes long...
  header->hlen  = 0x06;
     354:	86 e0       	ldi	r24, 0x06	; 6
     356:	84 83       	std	Z+4, r24	; 0x04
  // ... ip adresses are 4bytes.
  header->plen  = 0x04;  
     358:	84 e0       	ldi	r24, 0x04	; 4
     35a:	85 83       	std	Z+5, r24	; 0x05
  
  header->tpa = *tpa;  
     35c:	f8 01       	movw	r30, r16
     35e:	80 81       	ld	r24, Z
     360:	91 81       	ldd	r25, Z+1	; 0x01
     362:	a2 81       	ldd	r26, Z+2	; 0x02
     364:	b3 81       	ldd	r27, Z+3	; 0x03
     366:	f7 01       	movw	r30, r14
     368:	80 8f       	std	Z+24, r24	; 0x18
     36a:	91 8f       	std	Z+25, r25	; 0x19
     36c:	a2 8f       	std	Z+26, r26	; 0x1a
     36e:	b3 8f       	std	Z+27, r27	; 0x1b
  // obtain a copy of the hardware address...
  header->sha = *getHardwareAddress();
     370:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     374:	d7 01       	movw	r26, r14
     376:	18 96       	adiw	r26, 0x08	; 8
     378:	fc 01       	movw	r30, r24
     37a:	86 e0       	ldi	r24, 0x06	; 6
     37c:	01 90       	ld	r0, Z+
     37e:	0d 92       	st	X+, r0
     380:	81 50       	subi	r24, 0x01	; 1
     382:	e1 f7       	brne	.-8      	; 0x37c <onArpRequest+0x68>
  // set the ip of the sender;
  header->spa = *ipGetAddress();
     384:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     388:	fc 01       	movw	r30, r24
     38a:	80 81       	ld	r24, Z
     38c:	91 81       	ldd	r25, Z+1	; 0x01
     38e:	a2 81       	ldd	r26, Z+2	; 0x02
     390:	b3 81       	ldd	r27, Z+3	; 0x03
     392:	f7 01       	movw	r30, r14
     394:	86 87       	std	Z+14, r24	; 0x0e
     396:	97 87       	std	Z+15, r25	; 0x0f
     398:	a0 8b       	std	Z+16, r26	; 0x10
     39a:	b1 8b       	std	Z+17, r27	; 0x11
  
  if (tha == NULL)
     39c:	c1 14       	cp	r12, r1
     39e:	d1 04       	cpc	r13, r1
     3a0:	21 f1       	breq	.+72     	; 0x3ea <onArpRequest+0xd6>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, &mac);
  }
  else
  {
    header->operation = ARP_OPCODE_RESPONSE;
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	92 e0       	ldi	r25, 0x02	; 2
     3a6:	f7 01       	movw	r30, r14
     3a8:	97 83       	std	Z+7, r25	; 0x07
     3aa:	86 83       	std	Z+6, r24	; 0x06
    header->tha = *tha;
     3ac:	d7 01       	movw	r26, r14
     3ae:	52 96       	adiw	r26, 0x12	; 18
     3b0:	f6 01       	movw	r30, r12
     3b2:	86 e0       	ldi	r24, 0x06	; 6
     3b4:	01 90       	ld	r0, Z+
     3b6:	0d 92       	st	X+, r0
     3b8:	81 50       	subi	r24, 0x01	; 1
     3ba:	e1 f7       	brne	.-8      	; 0x3b4 <onArpRequest+0xa0>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, tha);
     3bc:	c5 01       	movw	r24, r10
     3be:	68 e0       	ldi	r22, 0x08	; 8
     3c0:	76 e0       	ldi	r23, 0x06	; 6
     3c2:	a6 01       	movw	r20, r12
     3c4:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
  }  
  
}
     3c8:	26 96       	adiw	r28, 0x06	; 6
     3ca:	0f b6       	in	r0, 0x3f	; 63
     3cc:	f8 94       	cli
     3ce:	de bf       	out	0x3e, r29	; 62
     3d0:	0f be       	out	0x3f, r0	; 63
     3d2:	cd bf       	out	0x3d, r28	; 61
     3d4:	cf 91       	pop	r28
     3d6:	df 91       	pop	r29
     3d8:	1f 91       	pop	r17
     3da:	0f 91       	pop	r16
     3dc:	ff 90       	pop	r15
     3de:	ef 90       	pop	r14
     3e0:	df 90       	pop	r13
     3e2:	cf 90       	pop	r12
     3e4:	bf 90       	pop	r11
     3e6:	af 90       	pop	r10
     3e8:	08 95       	ret
  // set the ip of the sender;
  header->spa = *ipGetAddress();
  
  if (tha == NULL)
  {
    header->operation  = ARP_OPCODE_REQUEST; 
     3ea:	80 e0       	ldi	r24, 0x00	; 0
     3ec:	91 e0       	ldi	r25, 0x01	; 1
     3ee:	97 83       	std	Z+7, r25	; 0x07
     3f0:	86 83       	std	Z+6, r24	; 0x06
    header->tha.octet1 = 0x0000;
     3f2:	12 8a       	std	Z+18, r1	; 0x12
    header->tha.octet2 = 0x0000;
     3f4:	13 8a       	std	Z+19, r1	; 0x13
    header->tha.octet3 = 0x0000;
     3f6:	14 8a       	std	Z+20, r1	; 0x14
    header->tha.octet4 = 0x0000;
     3f8:	15 8a       	std	Z+21, r1	; 0x15
    header->tha.octet5 = 0x0000;
     3fa:	16 8a       	std	Z+22, r1	; 0x16
    header->tha.octet6 = 0x0000;
     3fc:	17 8a       	std	Z+23, r1	; 0x17
    
    // ARP packets are broadcast packets... 
    struct macAddress_t mac
        = { .octet1 = 0xFF,  .octet2 = 0xFF,  .octet3 = 0xFF,
            .octet4 = 0xFF,  .octet5 = 0xFF,  .octet6 = 0xFF  };
     3fe:	ae 01       	movw	r20, r28
     400:	4f 5f       	subi	r20, 0xFF	; 255
     402:	5f 4f       	sbci	r21, 0xFF	; 255
     404:	da 01       	movw	r26, r20
     406:	e8 e0       	ldi	r30, 0x08	; 8
     408:	f1 e0       	ldi	r31, 0x01	; 1
     40a:	86 e0       	ldi	r24, 0x06	; 6
     40c:	01 90       	ld	r0, Z+
     40e:	0d 92       	st	X+, r0
     410:	81 50       	subi	r24, 0x01	; 1
     412:	e1 f7       	brne	.-8      	; 0x40c <onArpRequest+0xf8>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, &mac);
     414:	c5 01       	movw	r24, r10
     416:	68 e0       	ldi	r22, 0x08	; 8
     418:	76 e0       	ldi	r23, 0x06	; 6
     41a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     41e:	d4 cf       	rjmp	.-88     	; 0x3c8 <onArpRequest+0xb4>

00000420 <arpSendResponse>:
    
  return onArpRequest(handle,tpa,NULL);
}

uint8_t arpSendResponse(ipAddress_t* tpa,  struct macAddress_t* tha)
{  
     420:	af 92       	push	r10
     422:	bf 92       	push	r11
     424:	cf 92       	push	r12
     426:	df 92       	push	r13
     428:	ef 92       	push	r14
     42a:	ff 92       	push	r15
     42c:	0f 93       	push	r16
     42e:	1f 93       	push	r17
     430:	df 93       	push	r29
     432:	cf 93       	push	r28
     434:	00 d0       	rcall	.+0      	; 0x436 <arpSendResponse+0x16>
     436:	00 d0       	rcall	.+0      	; 0x438 <arpSendResponse+0x18>
     438:	00 d0       	rcall	.+0      	; 0x43a <arpSendResponse+0x1a>
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
     43e:	8c 01       	movw	r16, r24
     440:	6b 01       	movw	r12, r22
  struct nicRequestHandle_t* handle = nicNewRequest();
     442:	0e 94 44 19 	call	0x3288	; 0x3288 <nicNewRequest>
     446:	5c 01       	movw	r10, r24
}

uint8_t onArpRequest(struct nicRequestHandle_t* handle,ipAddress_t* tpa, struct macAddress_t* tha)
{
  struct soArpHeader_t* header 
    = (struct soArpHeader_t*) nicAddPacketHeader(handle, sizeof(struct soArpHeader_t));
     448:	6c e1       	ldi	r22, 0x1C	; 28
     44a:	70 e0       	ldi	r23, 0x00	; 0
     44c:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     450:	7c 01       	movw	r14, r24

  // Set Hardwaretype to Ethernet...
  header->htype = 0x0100;
     452:	80 e0       	ldi	r24, 0x00	; 0
     454:	91 e0       	ldi	r25, 0x01	; 1
     456:	f7 01       	movw	r30, r14
     458:	91 83       	std	Z+1, r25	; 0x01
     45a:	80 83       	st	Z, r24
  // ... the protocol is IP
  header->ptype = 0x0008;
     45c:	88 e0       	ldi	r24, 0x08	; 8
     45e:	90 e0       	ldi	r25, 0x00	; 0
     460:	93 83       	std	Z+3, r25	; 0x03
     462:	82 83       	std	Z+2, r24	; 0x02
  // Ethernet addresses are 6bytes long...
  header->hlen  = 0x06;
     464:	86 e0       	ldi	r24, 0x06	; 6
     466:	84 83       	std	Z+4, r24	; 0x04
  // ... ip adresses are 4bytes.
  header->plen  = 0x04;  
     468:	84 e0       	ldi	r24, 0x04	; 4
     46a:	85 83       	std	Z+5, r24	; 0x05
  
  header->tpa = *tpa;  
     46c:	f8 01       	movw	r30, r16
     46e:	80 81       	ld	r24, Z
     470:	91 81       	ldd	r25, Z+1	; 0x01
     472:	a2 81       	ldd	r26, Z+2	; 0x02
     474:	b3 81       	ldd	r27, Z+3	; 0x03
     476:	f7 01       	movw	r30, r14
     478:	80 8f       	std	Z+24, r24	; 0x18
     47a:	91 8f       	std	Z+25, r25	; 0x19
     47c:	a2 8f       	std	Z+26, r26	; 0x1a
     47e:	b3 8f       	std	Z+27, r27	; 0x1b
  // obtain a copy of the hardware address...
  header->sha = *getHardwareAddress();
     480:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     484:	d7 01       	movw	r26, r14
     486:	18 96       	adiw	r26, 0x08	; 8
     488:	fc 01       	movw	r30, r24
     48a:	86 e0       	ldi	r24, 0x06	; 6
     48c:	01 90       	ld	r0, Z+
     48e:	0d 92       	st	X+, r0
     490:	81 50       	subi	r24, 0x01	; 1
     492:	e1 f7       	brne	.-8      	; 0x48c <arpSendResponse+0x6c>
  // set the ip of the sender;
  header->spa = *ipGetAddress();
     494:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     498:	fc 01       	movw	r30, r24
     49a:	80 81       	ld	r24, Z
     49c:	91 81       	ldd	r25, Z+1	; 0x01
     49e:	a2 81       	ldd	r26, Z+2	; 0x02
     4a0:	b3 81       	ldd	r27, Z+3	; 0x03
     4a2:	f7 01       	movw	r30, r14
     4a4:	86 87       	std	Z+14, r24	; 0x0e
     4a6:	97 87       	std	Z+15, r25	; 0x0f
     4a8:	a0 8b       	std	Z+16, r26	; 0x10
     4aa:	b1 8b       	std	Z+17, r27	; 0x11
  
  if (tha == NULL)
     4ac:	c1 14       	cp	r12, r1
     4ae:	d1 04       	cpc	r13, r1
     4b0:	21 f1       	breq	.+72     	; 0x4fa <arpSendResponse+0xda>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, &mac);
  }
  else
  {
    header->operation = ARP_OPCODE_RESPONSE;
     4b2:	80 e0       	ldi	r24, 0x00	; 0
     4b4:	92 e0       	ldi	r25, 0x02	; 2
     4b6:	f7 01       	movw	r30, r14
     4b8:	97 83       	std	Z+7, r25	; 0x07
     4ba:	86 83       	std	Z+6, r24	; 0x06
    header->tha = *tha;
     4bc:	d7 01       	movw	r26, r14
     4be:	52 96       	adiw	r26, 0x12	; 18
     4c0:	f6 01       	movw	r30, r12
     4c2:	86 e0       	ldi	r24, 0x06	; 6
     4c4:	01 90       	ld	r0, Z+
     4c6:	0d 92       	st	X+, r0
     4c8:	81 50       	subi	r24, 0x01	; 1
     4ca:	e1 f7       	brne	.-8      	; 0x4c4 <arpSendResponse+0xa4>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, tha);
     4cc:	c5 01       	movw	r24, r10
     4ce:	68 e0       	ldi	r22, 0x08	; 8
     4d0:	76 e0       	ldi	r23, 0x06	; 6
     4d2:	a6 01       	movw	r20, r12
     4d4:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
uint8_t arpSendResponse(ipAddress_t* tpa,  struct macAddress_t* tha)
{  
  struct nicRequestHandle_t* handle = nicNewRequest();
  
  return onArpRequest(handle,tpa,tha);
}
     4d8:	26 96       	adiw	r28, 0x06	; 6
     4da:	0f b6       	in	r0, 0x3f	; 63
     4dc:	f8 94       	cli
     4de:	de bf       	out	0x3e, r29	; 62
     4e0:	0f be       	out	0x3f, r0	; 63
     4e2:	cd bf       	out	0x3d, r28	; 61
     4e4:	cf 91       	pop	r28
     4e6:	df 91       	pop	r29
     4e8:	1f 91       	pop	r17
     4ea:	0f 91       	pop	r16
     4ec:	ff 90       	pop	r15
     4ee:	ef 90       	pop	r14
     4f0:	df 90       	pop	r13
     4f2:	cf 90       	pop	r12
     4f4:	bf 90       	pop	r11
     4f6:	af 90       	pop	r10
     4f8:	08 95       	ret
  // set the ip of the sender;
  header->spa = *ipGetAddress();
  
  if (tha == NULL)
  {
    header->operation  = ARP_OPCODE_REQUEST; 
     4fa:	80 e0       	ldi	r24, 0x00	; 0
     4fc:	91 e0       	ldi	r25, 0x01	; 1
     4fe:	97 83       	std	Z+7, r25	; 0x07
     500:	86 83       	std	Z+6, r24	; 0x06
    header->tha.octet1 = 0x0000;
     502:	12 8a       	std	Z+18, r1	; 0x12
    header->tha.octet2 = 0x0000;
     504:	13 8a       	std	Z+19, r1	; 0x13
    header->tha.octet3 = 0x0000;
     506:	14 8a       	std	Z+20, r1	; 0x14
    header->tha.octet4 = 0x0000;
     508:	15 8a       	std	Z+21, r1	; 0x15
    header->tha.octet5 = 0x0000;
     50a:	16 8a       	std	Z+22, r1	; 0x16
    header->tha.octet6 = 0x0000;
     50c:	17 8a       	std	Z+23, r1	; 0x17
    
    // ARP packets are broadcast packets... 
    struct macAddress_t mac
        = { .octet1 = 0xFF,  .octet2 = 0xFF,  .octet3 = 0xFF,
            .octet4 = 0xFF,  .octet5 = 0xFF,  .octet6 = 0xFF  };
     50e:	ae 01       	movw	r20, r28
     510:	4f 5f       	subi	r20, 0xFF	; 255
     512:	5f 4f       	sbci	r21, 0xFF	; 255
     514:	da 01       	movw	r26, r20
     516:	e8 e0       	ldi	r30, 0x08	; 8
     518:	f1 e0       	ldi	r31, 0x01	; 1
     51a:	86 e0       	ldi	r24, 0x06	; 6
     51c:	01 90       	ld	r0, Z+
     51e:	0d 92       	st	X+, r0
     520:	81 50       	subi	r24, 0x01	; 1
     522:	e1 f7       	brne	.-8      	; 0x51c <arpSendResponse+0xfc>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, &mac);
     524:	c5 01       	movw	r24, r10
     526:	68 e0       	ldi	r22, 0x08	; 8
     528:	76 e0       	ldi	r23, 0x06	; 6
     52a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     52e:	d4 cf       	rjmp	.-88     	; 0x4d8 <arpSendResponse+0xb8>

00000530 <onArpResponse>:
  }  
  
}

void onArpResponse(struct nicResponseHandle_t* response, struct macAddress_t* source)
{
     530:	ef 92       	push	r14
     532:	ff 92       	push	r15
     534:	0f 93       	push	r16
     536:	1f 93       	push	r17
     538:	df 93       	push	r29
     53a:	cf 93       	push	r28
     53c:	cd b7       	in	r28, 0x3d	; 61
     53e:	de b7       	in	r29, 0x3e	; 62
     540:	6c 97       	sbiw	r28, 0x1c	; 28
     542:	0f b6       	in	r0, 0x3f	; 63
     544:	f8 94       	cli
     546:	de bf       	out	0x3e, r29	; 62
     548:	0f be       	out	0x3f, r0	; 63
     54a:	cd bf       	out	0x3d, r28	; 61
     54c:	8c 01       	movw	r16, r24
  // drop if header invalid...
  if (nicResponseSize(response) < sizeof(struct soArpHeader_t))
     54e:	0e 94 95 18 	call	0x312a	; 0x312a <nicResponseSize>
     552:	4c 97       	sbiw	r24, 0x1c	; 28
     554:	68 f4       	brcc	.+26     	; 0x570 <onArpResponse+0x40>
    default:
      break;
  }
  
  return;
}
     556:	6c 96       	adiw	r28, 0x1c	; 28
     558:	0f b6       	in	r0, 0x3f	; 63
     55a:	f8 94       	cli
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	0f be       	out	0x3f, r0	; 63
     560:	cd bf       	out	0x3d, r28	; 61
     562:	cf 91       	pop	r28
     564:	df 91       	pop	r29
     566:	1f 91       	pop	r17
     568:	0f 91       	pop	r16
     56a:	ff 90       	pop	r15
     56c:	ef 90       	pop	r14
     56e:	08 95       	ret
  // drop if header invalid...
  if (nicResponseSize(response) < sizeof(struct soArpHeader_t))
    return;  
      
  struct soArpHeader_t header;
  nicResponseRead(response,(char*)(&header),sizeof(header));
     570:	c8 01       	movw	r24, r16
     572:	be 01       	movw	r22, r28
     574:	6f 5f       	subi	r22, 0xFF	; 255
     576:	7f 4f       	sbci	r23, 0xFF	; 255
     578:	4c e1       	ldi	r20, 0x1C	; 28
     57a:	50 e0       	ldi	r21, 0x00	; 0
     57c:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>

  // check if the arprequest is understandable
  if ((header.htype != ntohs(0x0001)) || (header.ptype != ntohs(0x0800))
     580:	89 81       	ldd	r24, Y+1	; 0x01
     582:	9a 81       	ldd	r25, Y+2	; 0x02
     584:	80 50       	subi	r24, 0x00	; 0
     586:	91 40       	sbci	r25, 0x01	; 1
     588:	31 f7       	brne	.-52     	; 0x556 <onArpResponse+0x26>
     58a:	8b 81       	ldd	r24, Y+3	; 0x03
     58c:	9c 81       	ldd	r25, Y+4	; 0x04
     58e:	08 97       	sbiw	r24, 0x08	; 8
     590:	11 f7       	brne	.-60     	; 0x556 <onArpResponse+0x26>
     592:	8d 81       	ldd	r24, Y+5	; 0x05
     594:	86 30       	cpi	r24, 0x06	; 6
     596:	f9 f6       	brne	.-66     	; 0x556 <onArpResponse+0x26>
     598:	8e 81       	ldd	r24, Y+6	; 0x06
     59a:	84 30       	cpi	r24, 0x04	; 4
     59c:	e1 f6       	brne	.-72     	; 0x556 <onArpResponse+0x26>
        || (header.hlen != 0x06) || (header.plen != 0x04))    
    return;
  
  // Someone talking to us?
  if (header.tpa != *ipGetAddress())
     59e:	e9 8c       	ldd	r14, Y+25	; 0x19
     5a0:	fa 8c       	ldd	r15, Y+26	; 0x1a
     5a2:	0b 8d       	ldd	r16, Y+27	; 0x1b
     5a4:	1c 8d       	ldd	r17, Y+28	; 0x1c
     5a6:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     5aa:	fc 01       	movw	r30, r24
     5ac:	80 81       	ld	r24, Z
     5ae:	91 81       	ldd	r25, Z+1	; 0x01
     5b0:	a2 81       	ldd	r26, Z+2	; 0x02
     5b2:	b3 81       	ldd	r27, Z+3	; 0x03
     5b4:	e8 16       	cp	r14, r24
     5b6:	f9 06       	cpc	r15, r25
     5b8:	0a 07       	cpc	r16, r26
     5ba:	1b 07       	cpc	r17, r27
     5bc:	61 f6       	brne	.-104    	; 0x556 <onArpResponse+0x26>
    return;
   
  switch (header.operation)
     5be:	8f 81       	ldd	r24, Y+7	; 0x07
     5c0:	98 85       	ldd	r25, Y+8	; 0x08
     5c2:	21 e0       	ldi	r18, 0x01	; 1
     5c4:	80 30       	cpi	r24, 0x00	; 0
     5c6:	92 07       	cpc	r25, r18
     5c8:	89 f0       	breq	.+34     	; 0x5ec <onArpResponse+0xbc>
     5ca:	80 50       	subi	r24, 0x00	; 0
     5cc:	92 40       	sbci	r25, 0x02	; 2
     5ce:	09 f0       	breq	.+2      	; 0x5d2 <onArpResponse+0xa2>
     5d0:	c2 cf       	rjmp	.-124    	; 0x556 <onArpResponse+0x26>
     5d2:	3f e0       	ldi	r19, 0x0F	; 15
     5d4:	e3 2e       	mov	r14, r19
     5d6:	f1 2c       	mov	r15, r1
     5d8:	ec 0e       	add	r14, r28
     5da:	fd 1e       	adc	r15, r29
     5dc:	8e 01       	movw	r16, r28
     5de:	07 5f       	subi	r16, 0xF7	; 247
     5e0:	1f 4f       	sbci	r17, 0xFF	; 255
      arpSendResponse(&header.spa,&header.sha);
      // ... and then add the mac address...
      // ... yes, here is no break missing, its a fall through statement
    case ARP_OPCODE_RESPONSE:
      // it's an arp reply, update the arp table
      arpAddMacByIPv4(&header.spa,&header.sha);      
     5e2:	c7 01       	movw	r24, r14
     5e4:	b8 01       	movw	r22, r16
     5e6:	0e 94 93 00 	call	0x126	; 0x126 <arpAddMacByIPv4>
     5ea:	b5 cf       	rjmp	.-150    	; 0x556 <onArpResponse+0x26>
   
  switch (header.operation)
  {
    case ARP_OPCODE_REQUEST:
      // it's an arp discover, tell him who we are...
      arpSendResponse(&header.spa,&header.sha);
     5ec:	2f e0       	ldi	r18, 0x0F	; 15
     5ee:	e2 2e       	mov	r14, r18
     5f0:	f1 2c       	mov	r15, r1
     5f2:	ec 0e       	add	r14, r28
     5f4:	fd 1e       	adc	r15, r29
     5f6:	8e 01       	movw	r16, r28
     5f8:	07 5f       	subi	r16, 0xF7	; 247
     5fa:	1f 4f       	sbci	r17, 0xFF	; 255
     5fc:	c7 01       	movw	r24, r14
     5fe:	b8 01       	movw	r22, r16
     600:	0e 94 10 02 	call	0x420	; 0x420 <arpSendResponse>
     604:	ee cf       	rjmp	.-36     	; 0x5e2 <onArpResponse+0xb2>

00000606 <arpSendRequest>:
  struct macAddress_t tha; // target hardware address, needs to be 0 on requests
  ipAddress_t tpa;             // target protocol address
};

uint8_t arpSendRequest(ipAddress_t* tpa)
{  
     606:	cf 92       	push	r12
     608:	df 92       	push	r13
     60a:	ef 92       	push	r14
     60c:	ff 92       	push	r15
     60e:	0f 93       	push	r16
     610:	1f 93       	push	r17
     612:	df 93       	push	r29
     614:	cf 93       	push	r28
     616:	00 d0       	rcall	.+0      	; 0x618 <arpSendRequest+0x12>
     618:	00 d0       	rcall	.+0      	; 0x61a <arpSendRequest+0x14>
     61a:	00 d0       	rcall	.+0      	; 0x61c <arpSendRequest+0x16>
     61c:	cd b7       	in	r28, 0x3d	; 61
     61e:	de b7       	in	r29, 0x3e	; 62
     620:	8c 01       	movw	r16, r24
  struct nicRequestHandle_t* handle = nicNewRequest();    
     622:	0e 94 44 19 	call	0x3288	; 0x3288 <nicNewRequest>
     626:	6c 01       	movw	r12, r24
}

uint8_t onArpRequest(struct nicRequestHandle_t* handle,ipAddress_t* tpa, struct macAddress_t* tha)
{
  struct soArpHeader_t* header 
    = (struct soArpHeader_t*) nicAddPacketHeader(handle, sizeof(struct soArpHeader_t));
     628:	6c e1       	ldi	r22, 0x1C	; 28
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     630:	7c 01       	movw	r14, r24

  // Set Hardwaretype to Ethernet...
  header->htype = 0x0100;
     632:	80 e0       	ldi	r24, 0x00	; 0
     634:	91 e0       	ldi	r25, 0x01	; 1
     636:	f7 01       	movw	r30, r14
     638:	91 83       	std	Z+1, r25	; 0x01
     63a:	80 83       	st	Z, r24
  // ... the protocol is IP
  header->ptype = 0x0008;
     63c:	88 e0       	ldi	r24, 0x08	; 8
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	93 83       	std	Z+3, r25	; 0x03
     642:	82 83       	std	Z+2, r24	; 0x02
  // Ethernet addresses are 6bytes long...
  header->hlen  = 0x06;
     644:	86 e0       	ldi	r24, 0x06	; 6
     646:	84 83       	std	Z+4, r24	; 0x04
  // ... ip adresses are 4bytes.
  header->plen  = 0x04;  
     648:	84 e0       	ldi	r24, 0x04	; 4
     64a:	85 83       	std	Z+5, r24	; 0x05
  
  header->tpa = *tpa;  
     64c:	f8 01       	movw	r30, r16
     64e:	80 81       	ld	r24, Z
     650:	91 81       	ldd	r25, Z+1	; 0x01
     652:	a2 81       	ldd	r26, Z+2	; 0x02
     654:	b3 81       	ldd	r27, Z+3	; 0x03
     656:	f7 01       	movw	r30, r14
     658:	80 8f       	std	Z+24, r24	; 0x18
     65a:	91 8f       	std	Z+25, r25	; 0x19
     65c:	a2 8f       	std	Z+26, r26	; 0x1a
     65e:	b3 8f       	std	Z+27, r27	; 0x1b
  // obtain a copy of the hardware address...
  header->sha = *getHardwareAddress();
     660:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     664:	d7 01       	movw	r26, r14
     666:	18 96       	adiw	r26, 0x08	; 8
     668:	fc 01       	movw	r30, r24
     66a:	86 e0       	ldi	r24, 0x06	; 6
     66c:	01 90       	ld	r0, Z+
     66e:	0d 92       	st	X+, r0
     670:	81 50       	subi	r24, 0x01	; 1
     672:	e1 f7       	brne	.-8      	; 0x66c <arpSendRequest+0x66>
  // set the ip of the sender;
  header->spa = *ipGetAddress();
     674:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     678:	fc 01       	movw	r30, r24
     67a:	80 81       	ld	r24, Z
     67c:	91 81       	ldd	r25, Z+1	; 0x01
     67e:	a2 81       	ldd	r26, Z+2	; 0x02
     680:	b3 81       	ldd	r27, Z+3	; 0x03
     682:	f7 01       	movw	r30, r14
     684:	86 87       	std	Z+14, r24	; 0x0e
     686:	97 87       	std	Z+15, r25	; 0x0f
     688:	a0 8b       	std	Z+16, r26	; 0x10
     68a:	b1 8b       	std	Z+17, r27	; 0x11
  
  if (tha == NULL)
  {
    header->operation  = ARP_OPCODE_REQUEST; 
     68c:	80 e0       	ldi	r24, 0x00	; 0
     68e:	91 e0       	ldi	r25, 0x01	; 1
     690:	97 83       	std	Z+7, r25	; 0x07
     692:	86 83       	std	Z+6, r24	; 0x06
    header->tha.octet1 = 0x0000;
     694:	12 8a       	std	Z+18, r1	; 0x12
    header->tha.octet2 = 0x0000;
     696:	13 8a       	std	Z+19, r1	; 0x13
    header->tha.octet3 = 0x0000;
     698:	14 8a       	std	Z+20, r1	; 0x14
    header->tha.octet4 = 0x0000;
     69a:	15 8a       	std	Z+21, r1	; 0x15
    header->tha.octet5 = 0x0000;
     69c:	16 8a       	std	Z+22, r1	; 0x16
    header->tha.octet6 = 0x0000;
     69e:	17 8a       	std	Z+23, r1	; 0x17
    
    // ARP packets are broadcast packets... 
    struct macAddress_t mac
        = { .octet1 = 0xFF,  .octet2 = 0xFF,  .octet3 = 0xFF,
            .octet4 = 0xFF,  .octet5 = 0xFF,  .octet6 = 0xFF  };
     6a0:	ae 01       	movw	r20, r28
     6a2:	4f 5f       	subi	r20, 0xFF	; 255
     6a4:	5f 4f       	sbci	r21, 0xFF	; 255
     6a6:	da 01       	movw	r26, r20
     6a8:	e8 e0       	ldi	r30, 0x08	; 8
     6aa:	f1 e0       	ldi	r31, 0x01	; 1
     6ac:	86 e0       	ldi	r24, 0x06	; 6
     6ae:	01 90       	ld	r0, Z+
     6b0:	0d 92       	st	X+, r0
     6b2:	81 50       	subi	r24, 0x01	; 1
     6b4:	e1 f7       	brne	.-8      	; 0x6ae <arpSendRequest+0xa8>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, &mac);
     6b6:	c6 01       	movw	r24, r12
     6b8:	68 e0       	ldi	r22, 0x08	; 8
     6ba:	76 e0       	ldi	r23, 0x06	; 6
     6bc:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
uint8_t arpSendRequest(ipAddress_t* tpa)
{  
  struct nicRequestHandle_t* handle = nicNewRequest();    
    
  return onArpRequest(handle,tpa,NULL);
}
     6c0:	26 96       	adiw	r28, 0x06	; 6
     6c2:	0f b6       	in	r0, 0x3f	; 63
     6c4:	f8 94       	cli
     6c6:	de bf       	out	0x3e, r29	; 62
     6c8:	0f be       	out	0x3f, r0	; 63
     6ca:	cd bf       	out	0x3d, r28	; 61
     6cc:	cf 91       	pop	r28
     6ce:	df 91       	pop	r29
     6d0:	1f 91       	pop	r17
     6d2:	0f 91       	pop	r16
     6d4:	ff 90       	pop	r15
     6d6:	ef 90       	pop	r14
     6d8:	df 90       	pop	r13
     6da:	cf 90       	pop	r12
     6dc:	08 95       	ret

000006de <arpLookupMacByIPv4>:
  
  return 0;
}

uint8_t arpLookupMacByIPv4(ipAddress_t* ip, struct macAddress_t* mac)
{  
     6de:	cf 92       	push	r12
     6e0:	df 92       	push	r13
     6e2:	ef 92       	push	r14
     6e4:	ff 92       	push	r15
     6e6:	0f 93       	push	r16
     6e8:	1f 93       	push	r17
     6ea:	df 93       	push	r29
     6ec:	cf 93       	push	r28
     6ee:	00 d0       	rcall	.+0      	; 0x6f0 <arpLookupMacByIPv4+0x12>
     6f0:	00 d0       	rcall	.+0      	; 0x6f2 <arpLookupMacByIPv4+0x14>
     6f2:	00 d0       	rcall	.+0      	; 0x6f4 <arpLookupMacByIPv4+0x16>
     6f4:	cd b7       	in	r28, 0x3d	; 61
     6f6:	de b7       	in	r29, 0x3e	; 62
     6f8:	7c 01       	movw	r14, r24
     6fa:	dc 01       	movw	r26, r24
     6fc:	2d 91       	ld	r18, X+
     6fe:	3d 91       	ld	r19, X+
     700:	4d 91       	ld	r20, X+
     702:	5c 91       	ld	r21, X
  int i = ARP_CACHE_SIZE;
  
  // check for a direct hit...
  while (i--)
  {
    if (hArp.arpCache[i].ip == *ip)
     704:	80 91 19 08 	lds	r24, 0x0819
     708:	90 91 1a 08 	lds	r25, 0x081A
     70c:	a0 91 1b 08 	lds	r26, 0x081B
     710:	b0 91 1c 08 	lds	r27, 0x081C
     714:	82 17       	cp	r24, r18
     716:	93 07       	cpc	r25, r19
     718:	a4 07       	cpc	r26, r20
     71a:	b5 07       	cpc	r27, r21
     71c:	09 f4       	brne	.+2      	; 0x720 <arpLookupMacByIPv4+0x42>
     71e:	c0 c0       	rjmp	.+384    	; 0x8a0 <arpLookupMacByIPv4+0x1c2>
     720:	80 91 0e 08 	lds	r24, 0x080E
     724:	90 91 0f 08 	lds	r25, 0x080F
     728:	a0 91 10 08 	lds	r26, 0x0810
     72c:	b0 91 11 08 	lds	r27, 0x0811
     730:	82 17       	cp	r24, r18
     732:	93 07       	cpc	r25, r19
     734:	a4 07       	cpc	r26, r20
     736:	b5 07       	cpc	r27, r21
     738:	09 f4       	brne	.+2      	; 0x73c <arpLookupMacByIPv4+0x5e>
     73a:	b5 c0       	rjmp	.+362    	; 0x8a6 <arpLookupMacByIPv4+0x1c8>
     73c:	80 91 03 08 	lds	r24, 0x0803
     740:	90 91 04 08 	lds	r25, 0x0804
     744:	a0 91 05 08 	lds	r26, 0x0805
     748:	b0 91 06 08 	lds	r27, 0x0806
     74c:	82 17       	cp	r24, r18
     74e:	93 07       	cpc	r25, r19
     750:	a4 07       	cpc	r26, r20
     752:	b5 07       	cpc	r27, r21
     754:	09 f4       	brne	.+2      	; 0x758 <arpLookupMacByIPv4+0x7a>
     756:	aa c0       	rjmp	.+340    	; 0x8ac <arpLookupMacByIPv4+0x1ce>
     758:	80 91 f8 07 	lds	r24, 0x07F8
     75c:	90 91 f9 07 	lds	r25, 0x07F9
     760:	a0 91 fa 07 	lds	r26, 0x07FA
     764:	b0 91 fb 07 	lds	r27, 0x07FB
     768:	82 17       	cp	r24, r18
     76a:	93 07       	cpc	r25, r19
     76c:	a4 07       	cpc	r26, r20
     76e:	b5 07       	cpc	r27, r21
     770:	09 f4       	brne	.+2      	; 0x774 <arpLookupMacByIPv4+0x96>
     772:	9f c0       	rjmp	.+318    	; 0x8b2 <arpLookupMacByIPv4+0x1d4>
     774:	80 91 ed 07 	lds	r24, 0x07ED
     778:	90 91 ee 07 	lds	r25, 0x07EE
     77c:	a0 91 ef 07 	lds	r26, 0x07EF
     780:	b0 91 f0 07 	lds	r27, 0x07F0
     784:	82 17       	cp	r24, r18
     786:	93 07       	cpc	r25, r19
     788:	a4 07       	cpc	r26, r20
     78a:	b5 07       	cpc	r27, r21
     78c:	09 f4       	brne	.+2      	; 0x790 <arpLookupMacByIPv4+0xb2>
     78e:	51 c0       	rjmp	.+162    	; 0x832 <arpLookupMacByIPv4+0x154>
  ipAddress_t tpa;             // target protocol address
};

uint8_t arpSendRequest(ipAddress_t* tpa)
{  
  struct nicRequestHandle_t* handle = nicNewRequest();    
     790:	0e 94 44 19 	call	0x3288	; 0x3288 <nicNewRequest>
     794:	6c 01       	movw	r12, r24
}

uint8_t onArpRequest(struct nicRequestHandle_t* handle,ipAddress_t* tpa, struct macAddress_t* tha)
{
  struct soArpHeader_t* header 
    = (struct soArpHeader_t*) nicAddPacketHeader(handle, sizeof(struct soArpHeader_t));
     796:	6c e1       	ldi	r22, 0x1C	; 28
     798:	70 e0       	ldi	r23, 0x00	; 0
     79a:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     79e:	8c 01       	movw	r16, r24

  // Set Hardwaretype to Ethernet...
  header->htype = 0x0100;
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	91 e0       	ldi	r25, 0x01	; 1
     7a4:	f8 01       	movw	r30, r16
     7a6:	91 83       	std	Z+1, r25	; 0x01
     7a8:	80 83       	st	Z, r24
  // ... the protocol is IP
  header->ptype = 0x0008;
     7aa:	88 e0       	ldi	r24, 0x08	; 8
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	93 83       	std	Z+3, r25	; 0x03
     7b0:	82 83       	std	Z+2, r24	; 0x02
  // Ethernet addresses are 6bytes long...
  header->hlen  = 0x06;
     7b2:	86 e0       	ldi	r24, 0x06	; 6
     7b4:	84 83       	std	Z+4, r24	; 0x04
  // ... ip adresses are 4bytes.
  header->plen  = 0x04;  
     7b6:	84 e0       	ldi	r24, 0x04	; 4
     7b8:	85 83       	std	Z+5, r24	; 0x05
  
  header->tpa = *tpa;  
     7ba:	f7 01       	movw	r30, r14
     7bc:	80 81       	ld	r24, Z
     7be:	91 81       	ldd	r25, Z+1	; 0x01
     7c0:	a2 81       	ldd	r26, Z+2	; 0x02
     7c2:	b3 81       	ldd	r27, Z+3	; 0x03
     7c4:	f8 01       	movw	r30, r16
     7c6:	80 8f       	std	Z+24, r24	; 0x18
     7c8:	91 8f       	std	Z+25, r25	; 0x19
     7ca:	a2 8f       	std	Z+26, r26	; 0x1a
     7cc:	b3 8f       	std	Z+27, r27	; 0x1b
  // obtain a copy of the hardware address...
  header->sha = *getHardwareAddress();
     7ce:	0e 94 f4 06 	call	0xde8	; 0xde8 <getHardwareAddress>
     7d2:	d8 01       	movw	r26, r16
     7d4:	18 96       	adiw	r26, 0x08	; 8
     7d6:	fc 01       	movw	r30, r24
     7d8:	86 e0       	ldi	r24, 0x06	; 6
     7da:	01 90       	ld	r0, Z+
     7dc:	0d 92       	st	X+, r0
     7de:	81 50       	subi	r24, 0x01	; 1
     7e0:	e1 f7       	brne	.-8      	; 0x7da <arpLookupMacByIPv4+0xfc>
  // set the ip of the sender;
  header->spa = *ipGetAddress();
     7e2:	0e 94 37 08 	call	0x106e	; 0x106e <ipGetAddress>
     7e6:	fc 01       	movw	r30, r24
     7e8:	80 81       	ld	r24, Z
     7ea:	91 81       	ldd	r25, Z+1	; 0x01
     7ec:	a2 81       	ldd	r26, Z+2	; 0x02
     7ee:	b3 81       	ldd	r27, Z+3	; 0x03
     7f0:	f8 01       	movw	r30, r16
     7f2:	86 87       	std	Z+14, r24	; 0x0e
     7f4:	97 87       	std	Z+15, r25	; 0x0f
     7f6:	a0 8b       	std	Z+16, r26	; 0x10
     7f8:	b1 8b       	std	Z+17, r27	; 0x11
  
  if (tha == NULL)
  {
    header->operation  = ARP_OPCODE_REQUEST; 
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	91 e0       	ldi	r25, 0x01	; 1
     7fe:	97 83       	std	Z+7, r25	; 0x07
     800:	86 83       	std	Z+6, r24	; 0x06
    header->tha.octet1 = 0x0000;
     802:	12 8a       	std	Z+18, r1	; 0x12
    header->tha.octet2 = 0x0000;
     804:	13 8a       	std	Z+19, r1	; 0x13
    header->tha.octet3 = 0x0000;
     806:	14 8a       	std	Z+20, r1	; 0x14
    header->tha.octet4 = 0x0000;
     808:	15 8a       	std	Z+21, r1	; 0x15
    header->tha.octet5 = 0x0000;
     80a:	16 8a       	std	Z+22, r1	; 0x16
    header->tha.octet6 = 0x0000;
     80c:	17 8a       	std	Z+23, r1	; 0x17
    
    // ARP packets are broadcast packets... 
    struct macAddress_t mac
        = { .octet1 = 0xFF,  .octet2 = 0xFF,  .octet3 = 0xFF,
            .octet4 = 0xFF,  .octet5 = 0xFF,  .octet6 = 0xFF  };
     80e:	ae 01       	movw	r20, r28
     810:	4f 5f       	subi	r20, 0xFF	; 255
     812:	5f 4f       	sbci	r21, 0xFF	; 255
     814:	da 01       	movw	r26, r20
     816:	e8 e0       	ldi	r30, 0x08	; 8
     818:	f1 e0       	ldi	r31, 0x01	; 1
     81a:	86 e0       	ldi	r24, 0x06	; 6
     81c:	01 90       	ld	r0, Z+
     81e:	0d 92       	st	X+, r0
     820:	81 50       	subi	r24, 0x01	; 1
     822:	e1 f7       	brne	.-8      	; 0x81c <arpLookupMacByIPv4+0x13e>
    
    return onEthernetRequest(handle,ETHERTYPE_ARP, &mac);
     824:	c6 01       	movw	r24, r12
     826:	68 e0       	ldi	r22, 0x08	; 8
     828:	76 e0       	ldi	r23, 0x06	; 6
     82a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	28 c0       	rjmp	.+80     	; 0x882 <arpLookupMacByIPv4+0x1a4>
  int i = ARP_CACHE_SIZE;
  
  // check for a direct hit...
  while (i--)
  {
    if (hArp.arpCache[i].ip == *ip)
     832:	40 e0       	ldi	r20, 0x00	; 0
     834:	50 e0       	ldi	r21, 0x00	; 0
    {
      // copy the mac addres into the buffer
      *mac = hArp.arpCache[i].mac;
     836:	8a 01       	movw	r16, r20
     838:	00 0f       	add	r16, r16
     83a:	11 1f       	adc	r17, r17
     83c:	7a 01       	movw	r14, r20
     83e:	ee 0c       	add	r14, r14
     840:	ff 1c       	adc	r15, r15
     842:	ee 0c       	add	r14, r14
     844:	ff 1c       	adc	r15, r15
     846:	ee 0c       	add	r14, r14
     848:	ff 1c       	adc	r15, r15
     84a:	f8 01       	movw	r30, r16
     84c:	ee 0d       	add	r30, r14
     84e:	ff 1d       	adc	r31, r15
     850:	e4 0f       	add	r30, r20
     852:	f5 1f       	adc	r31, r21
     854:	9b 01       	movw	r18, r22
     856:	e9 51       	subi	r30, 0x19	; 25
     858:	f8 4f       	sbci	r31, 0xF8	; 248
     85a:	86 e0       	ldi	r24, 0x06	; 6
     85c:	01 90       	ld	r0, Z+
     85e:	d9 01       	movw	r26, r18
     860:	0d 92       	st	X+, r0
     862:	9d 01       	movw	r18, r26
     864:	81 50       	subi	r24, 0x01	; 1
     866:	d1 f7       	brne	.-12     	; 0x85c <arpLookupMacByIPv4+0x17e>
      // and reset the age, as is was most recently used
      hArp.arpCache[i].age = 255;
     868:	e0 0e       	add	r14, r16
     86a:	f1 1e       	adc	r15, r17
     86c:	e4 0e       	add	r14, r20
     86e:	f5 1e       	adc	r15, r21
     870:	e7 ee       	ldi	r30, 0xE7	; 231
     872:	f7 e0       	ldi	r31, 0x07	; 7
     874:	ee 0e       	add	r14, r30
     876:	ff 1e       	adc	r15, r31
     878:	8f ef       	ldi	r24, 0xFF	; 255
     87a:	d7 01       	movw	r26, r14
     87c:	1a 96       	adiw	r26, 0x0a	; 10
     87e:	8c 93       	st	X, r24
     880:	80 e0       	ldi	r24, 0x00	; 0
  
  // ... no hit? Send a request
  arpSendRequest(ip);
  // ...and return an error
  return 1;
}
     882:	26 96       	adiw	r28, 0x06	; 6
     884:	0f b6       	in	r0, 0x3f	; 63
     886:	f8 94       	cli
     888:	de bf       	out	0x3e, r29	; 62
     88a:	0f be       	out	0x3f, r0	; 63
     88c:	cd bf       	out	0x3d, r28	; 61
     88e:	cf 91       	pop	r28
     890:	df 91       	pop	r29
     892:	1f 91       	pop	r17
     894:	0f 91       	pop	r16
     896:	ff 90       	pop	r15
     898:	ef 90       	pop	r14
     89a:	df 90       	pop	r13
     89c:	cf 90       	pop	r12
     89e:	08 95       	ret
  int i = ARP_CACHE_SIZE;
  
  // check for a direct hit...
  while (i--)
  {
    if (hArp.arpCache[i].ip == *ip)
     8a0:	44 e0       	ldi	r20, 0x04	; 4
     8a2:	50 e0       	ldi	r21, 0x00	; 0
     8a4:	c8 cf       	rjmp	.-112    	; 0x836 <arpLookupMacByIPv4+0x158>
     8a6:	43 e0       	ldi	r20, 0x03	; 3
     8a8:	50 e0       	ldi	r21, 0x00	; 0
     8aa:	c5 cf       	rjmp	.-118    	; 0x836 <arpLookupMacByIPv4+0x158>
     8ac:	42 e0       	ldi	r20, 0x02	; 2
     8ae:	50 e0       	ldi	r21, 0x00	; 0
     8b0:	c2 cf       	rjmp	.-124    	; 0x836 <arpLookupMacByIPv4+0x158>
     8b2:	41 e0       	ldi	r20, 0x01	; 1
     8b4:	50 e0       	ldi	r21, 0x00	; 0
     8b6:	bf cf       	rjmp	.-130    	; 0x836 <arpLookupMacByIPv4+0x158>

000008b8 <onInitRtp>:
  }
  
  void onInitRtp()
  {
    return;
  }
     8b8:	08 95       	ret

000008ba <onRtpResponse>:
    
    return;
  }
  
  void onRtpResponse(struct nicResponseHandle_t* response, struct netAddress_t* netAddr)
  {
     8ba:	ef 92       	push	r14
     8bc:	ff 92       	push	r15
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	df 93       	push	r29
     8c4:	cf 93       	push	r28
     8c6:	cd b7       	in	r28, 0x3d	; 61
     8c8:	de b7       	in	r29, 0x3e	; 62
     8ca:	66 97       	sbiw	r28, 0x16	; 22
     8cc:	0f b6       	in	r0, 0x3f	; 63
     8ce:	f8 94       	cli
     8d0:	de bf       	out	0x3e, r29	; 62
     8d2:	0f be       	out	0x3f, r0	; 63
     8d4:	cd bf       	out	0x3d, r28	; 61
     8d6:	7c 01       	movw	r14, r24



    if (nicResponseSize(response) < sizeof(struct soRtpHeader_t))
     8d8:	0e 94 95 18 	call	0x312a	; 0x312a <nicResponseSize>
     8dc:	0c 97       	sbiw	r24, 0x0c	; 12
     8de:	68 f4       	brcc	.+26     	; 0x8fa <onRtpResponse+0x40>

      free(buf);
    }  
#endif  
    return;
  }
     8e0:	66 96       	adiw	r28, 0x16	; 22
     8e2:	0f b6       	in	r0, 0x3f	; 63
     8e4:	f8 94       	cli
     8e6:	de bf       	out	0x3e, r29	; 62
     8e8:	0f be       	out	0x3f, r0	; 63
     8ea:	cd bf       	out	0x3d, r28	; 61
     8ec:	cf 91       	pop	r28
     8ee:	df 91       	pop	r29
     8f0:	1f 91       	pop	r17
     8f2:	0f 91       	pop	r16
     8f4:	ff 90       	pop	r15
     8f6:	ef 90       	pop	r14
     8f8:	08 95       	ret

    if (nicResponseSize(response) < sizeof(struct soRtpHeader_t))
      return;  
 
    struct soRtpHeader_t header;    
    nicResponseRead(response,(char*)(&header),sizeof(struct soRtpHeader_t));
     8fa:	c7 01       	movw	r24, r14
     8fc:	be 01       	movw	r22, r28
     8fe:	65 5f       	subi	r22, 0xF5	; 245
     900:	7f 4f       	sbci	r23, 0xFF	; 255
     902:	4c e0       	ldi	r20, 0x0C	; 12
     904:	50 e0       	ldi	r21, 0x00	; 0
     906:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>

    if (header.type == 0x4D)
     90a:	8c 85       	ldd	r24, Y+12	; 0x0c
     90c:	8d 34       	cpi	r24, 0x4D	; 77
     90e:	19 f1       	breq	.+70     	; 0x956 <onRtpResponse+0x9c>
      onRtpData(buf,len);
      
      free(buf);
    }
#ifdef REQUIRES_RCFG
    else if (header.type == 0x25)
     910:	85 32       	cpi	r24, 0x25	; 37
     912:	31 f7       	brne	.-52     	; 0x8e0 <onRtpResponse+0x26>
    {
      struct cdpHeader_t cdpHeader;
      nicResponseRead(response,(char*)(&cdpHeader), sizeof(struct cdpHeader_t));
     914:	c7 01       	movw	r24, r14
     916:	be 01       	movw	r22, r28
     918:	6f 5f       	subi	r22, 0xFF	; 255
     91a:	7f 4f       	sbci	r23, 0xFF	; 255
     91c:	4a e0       	ldi	r20, 0x0A	; 10
     91e:	50 e0       	ldi	r21, 0x00	; 0
     920:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
      
      if (cdpHeader.length == 0)
     924:	89 81       	ldd	r24, Y+1	; 0x01
     926:	88 23       	and	r24, r24
     928:	d9 f2       	breq	.-74     	; 0x8e0 <onRtpResponse+0x26>
        return;
      
      char* buf = malloc(cdpHeader.length);
     92a:	90 e0       	ldi	r25, 0x00	; 0
     92c:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
     930:	18 2f       	mov	r17, r24
     932:	09 2f       	mov	r16, r25
      uint8_t len = nicResponseRead(response,buf,cdpHeader.length);
     934:	49 81       	ldd	r20, Y+1	; 0x01
     936:	c7 01       	movw	r24, r14
     938:	61 2f       	mov	r22, r17
     93a:	70 2f       	mov	r23, r16
     93c:	50 e0       	ldi	r21, 0x00	; 0
     93e:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
     942:	68 2f       	mov	r22, r24

      onRtpControl(buf,len);
     944:	81 2f       	mov	r24, r17
     946:	90 2f       	mov	r25, r16
     948:	0e 94 43 28 	call	0x5086	; 0x5086 <onRtpControl>

      free(buf);
     94c:	81 2f       	mov	r24, r17
     94e:	90 2f       	mov	r25, r16
     950:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
     954:	c5 cf       	rjmp	.-118    	; 0x8e0 <onRtpResponse+0x26>
    nicResponseRead(response,(char*)(&header),sizeof(struct soRtpHeader_t));

    if (header.type == 0x4D)
    {
      struct cdpHeader_t cdpHeader;
      nicResponseRead(response,(char*)(&cdpHeader), sizeof(struct cdpHeader_t));
     956:	c7 01       	movw	r24, r14
     958:	be 01       	movw	r22, r28
     95a:	6f 5f       	subi	r22, 0xFF	; 255
     95c:	7f 4f       	sbci	r23, 0xFF	; 255
     95e:	4a e0       	ldi	r20, 0x0A	; 10
     960:	50 e0       	ldi	r21, 0x00	; 0
     962:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
      
      if (cdpHeader.length == 0)
     966:	89 81       	ldd	r24, Y+1	; 0x01
     968:	88 23       	and	r24, r24
     96a:	09 f4       	brne	.+2      	; 0x96e <onRtpResponse+0xb4>
     96c:	b9 cf       	rjmp	.-142    	; 0x8e0 <onRtpResponse+0x26>
        return;
      
      char* buf = malloc(cdpHeader.length);
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
     974:	18 2f       	mov	r17, r24
     976:	09 2f       	mov	r16, r25
      uint8_t len = nicResponseRead(response,buf,cdpHeader.length);
     978:	49 81       	ldd	r20, Y+1	; 0x01
     97a:	c7 01       	movw	r24, r14
     97c:	61 2f       	mov	r22, r17
     97e:	70 2f       	mov	r23, r16
     980:	50 e0       	ldi	r21, 0x00	; 0
     982:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
     986:	68 2f       	mov	r22, r24


	  
      
      onRtpData(buf,len);
     988:	81 2f       	mov	r24, r17
     98a:	90 2f       	mov	r25, r16
     98c:	0e 94 95 1a 	call	0x352a	; 0x352a <onRtpData>
      
      free(buf);
     990:	81 2f       	mov	r24, r17
     992:	90 2f       	mov	r25, r16
     994:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
     998:	a3 cf       	rjmp	.-186    	; 0x8e0 <onRtpResponse+0x26>

0000099a <onRtpRequest>:
    return;
  }
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
     99a:	6f 92       	push	r6
     99c:	7f 92       	push	r7
     99e:	8f 92       	push	r8
     9a0:	9f 92       	push	r9
     9a2:	af 92       	push	r10
     9a4:	bf 92       	push	r11
     9a6:	cf 92       	push	r12
     9a8:	df 92       	push	r13
     9aa:	ef 92       	push	r14
     9ac:	ff 92       	push	r15
     9ae:	0f 93       	push	r16
     9b0:	1f 93       	push	r17
     9b2:	5c 01       	movw	r10, r24
     9b4:	16 2f       	mov	r17, r22
     9b6:	4a 01       	movw	r8, r20
     9b8:	39 01       	movw	r6, r18
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     9ba:	6c e0       	ldi	r22, 0x0C	; 12
     9bc:	70 e0       	ldi	r23, 0x00	; 0
     9be:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     9c2:	6c 01       	movw	r12, r24
    
    header->version = 0x80;
     9c4:	80 e8       	ldi	r24, 0x80	; 128
     9c6:	f6 01       	movw	r30, r12
     9c8:	80 83       	st	Z, r24
    header->type = type;     
     9ca:	11 83       	std	Z+1, r17	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     9cc:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     9d0:	16 2f       	mov	r17, r22
     9d2:	00 27       	eor	r16, r16
     9d4:	ff 24       	eor	r15, r15
     9d6:	ee 24       	eor	r14, r14
     9d8:	29 2f       	mov	r18, r25
     9da:	33 27       	eor	r19, r19
     9dc:	44 27       	eor	r20, r20
     9de:	55 27       	eor	r21, r21
     9e0:	e2 2a       	or	r14, r18
     9e2:	f3 2a       	or	r15, r19
     9e4:	04 2b       	or	r16, r20
     9e6:	15 2b       	or	r17, r21
     9e8:	9b 01       	movw	r18, r22
     9ea:	ac 01       	movw	r20, r24
     9ec:	20 70       	andi	r18, 0x00	; 0
     9ee:	30 70       	andi	r19, 0x00	; 0
     9f0:	50 70       	andi	r21, 0x00	; 0
     9f2:	23 2f       	mov	r18, r19
     9f4:	34 2f       	mov	r19, r20
     9f6:	45 2f       	mov	r20, r21
     9f8:	55 27       	eor	r21, r21
     9fa:	e2 2a       	or	r14, r18
     9fc:	f3 2a       	or	r15, r19
     9fe:	04 2b       	or	r16, r20
     a00:	15 2b       	or	r17, r21
     a02:	60 70       	andi	r22, 0x00	; 0
     a04:	80 70       	andi	r24, 0x00	; 0
     a06:	90 70       	andi	r25, 0x00	; 0
     a08:	98 2f       	mov	r25, r24
     a0a:	87 2f       	mov	r24, r23
     a0c:	76 2f       	mov	r23, r22
     a0e:	66 27       	eor	r22, r22
     a10:	e6 2a       	or	r14, r22
     a12:	f7 2a       	or	r15, r23
     a14:	08 2b       	or	r16, r24
     a16:	19 2b       	or	r17, r25
     a18:	f6 01       	movw	r30, r12
     a1a:	e4 82       	std	Z+4, r14	; 0x04
     a1c:	f5 82       	std	Z+5, r15	; 0x05
     a1e:	06 83       	std	Z+6, r16	; 0x06
     a20:	17 83       	std	Z+7, r17	; 0x07
    header->ssrc = 0x00;
     a22:	10 86       	std	Z+8, r1	; 0x08
     a24:	11 86       	std	Z+9, r1	; 0x09
     a26:	12 86       	std	Z+10, r1	; 0x0a
     a28:	13 86       	std	Z+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     a2a:	80 91 1f 08 	lds	r24, 0x081F
     a2e:	90 91 20 08 	lds	r25, 0x0820
     a32:	92 83       	std	Z+2, r25	; 0x02
     a34:	83 83       	std	Z+3, r24	; 0x03
    
    rtpSequence++;
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	90 93 20 08 	sts	0x0820, r25
     a3c:	80 93 1f 08 	sts	0x081F, r24
    
    onUdpRequest(handle,destNetAddr,srcPort);  
     a40:	c5 01       	movw	r24, r10
     a42:	b4 01       	movw	r22, r8
     a44:	a3 01       	movw	r20, r6
     a46:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>
    
    return;
  }
     a4a:	1f 91       	pop	r17
     a4c:	0f 91       	pop	r16
     a4e:	ff 90       	pop	r15
     a50:	ef 90       	pop	r14
     a52:	df 90       	pop	r13
     a54:	cf 90       	pop	r12
     a56:	bf 90       	pop	r11
     a58:	af 90       	pop	r10
     a5a:	9f 90       	pop	r9
     a5c:	8f 90       	pop	r8
     a5e:	7f 90       	pop	r7
     a60:	6f 90       	pop	r6
     a62:	08 95       	ret

00000a64 <rtpSendCommand>:


 
  void rtpSendCommand(char* data, uint16_t len, 
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
     a64:	6f 92       	push	r6
     a66:	7f 92       	push	r7
     a68:	8f 92       	push	r8
     a6a:	9f 92       	push	r9
     a6c:	af 92       	push	r10
     a6e:	bf 92       	push	r11
     a70:	cf 92       	push	r12
     a72:	df 92       	push	r13
     a74:	ef 92       	push	r14
     a76:	ff 92       	push	r15
     a78:	0f 93       	push	r16
     a7a:	1f 93       	push	r17
     a7c:	cf 93       	push	r28
     a7e:	df 93       	push	r29
     a80:	8c 01       	movw	r16, r24
     a82:	eb 01       	movw	r28, r22
     a84:	4a 01       	movw	r8, r20
     a86:	39 01       	movw	r6, r18
    // create a new Packet, ...
    struct nicRequestHandle_t* handle = nicNewRequest();
     a88:	0e 94 44 19 	call	0x3288	; 0x3288 <nicNewRequest>
     a8c:	5c 01       	movw	r10, r24
    


	if(len!=0)
     a8e:	20 97       	sbiw	r28, 0x00	; 0
     a90:	09 f4       	brne	.+2      	; 0xa94 <rtpSendCommand+0x30>
     a92:	7e c0       	rjmp	.+252    	; 0xb90 <rtpSendCommand+0x12c>
	{
    // .... append the Payload...
	    char* buf = nicAddPacketHeader(handle,len+sizeof(struct cdpHeader_t));
     a94:	be 01       	movw	r22, r28
     a96:	66 5f       	subi	r22, 0xF6	; 246
     a98:	7f 4f       	sbci	r23, 0xFF	; 255
     a9a:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     a9e:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = len;
     aa0:	c0 83       	st	Z, r28
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     aa2:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     aa4:	12 82       	std	Z+2, r1	; 0x02
     aa6:	13 82       	std	Z+3, r1	; 0x03
     aa8:	14 82       	std	Z+4, r1	; 0x04
     aaa:	15 82       	std	Z+5, r1	; 0x05
     aac:	16 82       	std	Z+6, r1	; 0x06
     aae:	17 82       	std	Z+7, r1	; 0x07
     ab0:	10 86       	std	Z+8, r1	; 0x08
     ab2:	11 86       	std	Z+9, r1	; 0x09
     ab4:	9e 01       	movw	r18, r28
     ab6:	21 50       	subi	r18, 0x01	; 1
     ab8:	30 40       	sbci	r19, 0x00	; 0
     aba:	d8 01       	movw	r26, r16
     abc:	a2 0f       	add	r26, r18
     abe:	b3 1f       	adc	r27, r19
     ac0:	ec 0f       	add	r30, r28
     ac2:	fd 1f       	adc	r31, r29
     ac4:	02 c0       	rjmp	.+4      	; 0xaca <rtpSendCommand+0x66>
     ac6:	21 50       	subi	r18, 0x01	; 1
     ac8:	30 40       	sbci	r19, 0x00	; 0
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    while(len--)
	    {
	      buf[len] = data[len];
     aca:	8c 91       	ld	r24, X
     acc:	81 87       	std	Z+9, r24	; 0x09
     ace:	11 97       	sbiw	r26, 0x01	; 1
     ad0:	31 97       	sbiw	r30, 0x01	; 1
	    ((struct cdpHeader_t*)buf)->reserved = 0;
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    while(len--)
     ad2:	21 15       	cp	r18, r1
     ad4:	31 05       	cpc	r19, r1
     ad6:	b9 f7       	brne	.-18     	; 0xac6 <rtpSendCommand+0x62>
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     ad8:	c5 01       	movw	r24, r10
     ada:	6c e0       	ldi	r22, 0x0C	; 12
     adc:	70 e0       	ldi	r23, 0x00	; 0
     ade:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     ae2:	6c 01       	movw	r12, r24
    
    header->version = 0x80;
     ae4:	80 e8       	ldi	r24, 0x80	; 128
     ae6:	f6 01       	movw	r30, r12
     ae8:	80 83       	st	Z, r24
    header->type = type;     
     aea:	85 e2       	ldi	r24, 0x25	; 37
     aec:	81 83       	std	Z+1, r24	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     aee:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     af2:	16 2f       	mov	r17, r22
     af4:	00 27       	eor	r16, r16
     af6:	ff 24       	eor	r15, r15
     af8:	ee 24       	eor	r14, r14
     afa:	29 2f       	mov	r18, r25
     afc:	33 27       	eor	r19, r19
     afe:	44 27       	eor	r20, r20
     b00:	55 27       	eor	r21, r21
     b02:	e2 2a       	or	r14, r18
     b04:	f3 2a       	or	r15, r19
     b06:	04 2b       	or	r16, r20
     b08:	15 2b       	or	r17, r21
     b0a:	9b 01       	movw	r18, r22
     b0c:	ac 01       	movw	r20, r24
     b0e:	20 70       	andi	r18, 0x00	; 0
     b10:	30 70       	andi	r19, 0x00	; 0
     b12:	50 70       	andi	r21, 0x00	; 0
     b14:	23 2f       	mov	r18, r19
     b16:	34 2f       	mov	r19, r20
     b18:	45 2f       	mov	r20, r21
     b1a:	55 27       	eor	r21, r21
     b1c:	e2 2a       	or	r14, r18
     b1e:	f3 2a       	or	r15, r19
     b20:	04 2b       	or	r16, r20
     b22:	15 2b       	or	r17, r21
     b24:	60 70       	andi	r22, 0x00	; 0
     b26:	80 70       	andi	r24, 0x00	; 0
     b28:	90 70       	andi	r25, 0x00	; 0
     b2a:	98 2f       	mov	r25, r24
     b2c:	87 2f       	mov	r24, r23
     b2e:	76 2f       	mov	r23, r22
     b30:	66 27       	eor	r22, r22
     b32:	e6 2a       	or	r14, r22
     b34:	f7 2a       	or	r15, r23
     b36:	08 2b       	or	r16, r24
     b38:	19 2b       	or	r17, r25
     b3a:	d6 01       	movw	r26, r12
     b3c:	14 96       	adiw	r26, 0x04	; 4
     b3e:	ed 92       	st	X+, r14
     b40:	fd 92       	st	X+, r15
     b42:	0d 93       	st	X+, r16
     b44:	1c 93       	st	X, r17
     b46:	17 97       	sbiw	r26, 0x07	; 7
    header->ssrc = 0x00;
     b48:	e6 01       	movw	r28, r12
     b4a:	18 86       	std	Y+8, r1	; 0x08
     b4c:	19 86       	std	Y+9, r1	; 0x09
     b4e:	1a 86       	std	Y+10, r1	; 0x0a
     b50:	1b 86       	std	Y+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     b52:	80 91 1f 08 	lds	r24, 0x081F
     b56:	90 91 20 08 	lds	r25, 0x0820
     b5a:	9a 83       	std	Y+2, r25	; 0x02
     b5c:	8b 83       	std	Y+3, r24	; 0x03
    
    rtpSequence++;
     b5e:	01 96       	adiw	r24, 0x01	; 1
     b60:	90 93 20 08 	sts	0x0820, r25
     b64:	80 93 1f 08 	sts	0x081F, r24
    
    onUdpRequest(handle,destNetAddr,srcPort);  
     b68:	c5 01       	movw	r24, r10
     b6a:	b4 01       	movw	r22, r8
     b6c:	a3 01       	movw	r20, r6
     b6e:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>
  
    // ...and add the RTP Header...
    onRtpRequest(handle,0x25,destNetAddr,srcPort);
    
    return;
  }
     b72:	df 91       	pop	r29
     b74:	cf 91       	pop	r28
     b76:	1f 91       	pop	r17
     b78:	0f 91       	pop	r16
     b7a:	ff 90       	pop	r15
     b7c:	ef 90       	pop	r14
     b7e:	df 90       	pop	r13
     b80:	cf 90       	pop	r12
     b82:	bf 90       	pop	r11
     b84:	af 90       	pop	r10
     b86:	9f 90       	pop	r9
     b88:	8f 90       	pop	r8
     b8a:	7f 90       	pop	r7
     b8c:	6f 90       	pop	r6
     b8e:	08 95       	ret
	    }
	}
	else //iamalive paket
	{
		len=9;
		char* buf = nicAddPacketHeader(handle,len+sizeof(struct cdpHeader_t));
     b90:	63 e1       	ldi	r22, 0x13	; 19
     b92:	70 e0       	ldi	r23, 0x00	; 0
     b94:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     b98:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = 0;	//here 0 because it is not a real command answer
     b9a:	10 82       	st	Z, r1
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     b9c:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     b9e:	12 82       	std	Z+2, r1	; 0x02
     ba0:	13 82       	std	Z+3, r1	; 0x03
     ba2:	14 82       	std	Z+4, r1	; 0x04
     ba4:	15 82       	std	Z+5, r1	; 0x05
     ba6:	16 82       	std	Z+6, r1	; 0x06
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	10 86       	std	Z+8, r1	; 0x08
     bac:	11 86       	std	Z+9, r1	; 0x09
    
	    buf = buf+sizeof(struct cdpHeader_t);
     bae:	dc 01       	movw	r26, r24
     bb0:	1a 96       	adiw	r26, 0x0a	; 10
    
	    while(len--)
	    {
	      buf[len] = data[len];
     bb2:	e8 01       	movw	r28, r16
     bb4:	88 85       	ldd	r24, Y+8	; 0x08
     bb6:	18 96       	adiw	r26, 0x08	; 8
     bb8:	8c 93       	st	X, r24
     bba:	18 97       	sbiw	r26, 0x08	; 8
     bbc:	8f 81       	ldd	r24, Y+7	; 0x07
     bbe:	17 96       	adiw	r26, 0x07	; 7
     bc0:	8c 93       	st	X, r24
     bc2:	17 97       	sbiw	r26, 0x07	; 7
     bc4:	8e 81       	ldd	r24, Y+6	; 0x06
     bc6:	16 96       	adiw	r26, 0x06	; 6
     bc8:	8c 93       	st	X, r24
     bca:	16 97       	sbiw	r26, 0x06	; 6
     bcc:	8d 81       	ldd	r24, Y+5	; 0x05
     bce:	15 96       	adiw	r26, 0x05	; 5
     bd0:	8c 93       	st	X, r24
     bd2:	15 97       	sbiw	r26, 0x05	; 5
     bd4:	8c 81       	ldd	r24, Y+4	; 0x04
     bd6:	14 96       	adiw	r26, 0x04	; 4
     bd8:	8c 93       	st	X, r24
     bda:	14 97       	sbiw	r26, 0x04	; 4
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	13 96       	adiw	r26, 0x03	; 3
     be0:	8c 93       	st	X, r24
     be2:	13 97       	sbiw	r26, 0x03	; 3
     be4:	8a 81       	ldd	r24, Y+2	; 0x02
     be6:	12 96       	adiw	r26, 0x02	; 2
     be8:	8c 93       	st	X, r24
     bea:	12 97       	sbiw	r26, 0x02	; 2
     bec:	89 81       	ldd	r24, Y+1	; 0x01
     bee:	11 96       	adiw	r26, 0x01	; 1
     bf0:	8c 93       	st	X, r24
     bf2:	88 81       	ld	r24, Y
     bf4:	82 87       	std	Z+10, r24	; 0x0a
     bf6:	70 cf       	rjmp	.-288    	; 0xad8 <rtpSendCommand+0x74>

00000bf8 <rtpSendCDPData>:


  
  void rtpSendCDPData(char* data, uint16_t len, 
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
     bf8:	6f 92       	push	r6
     bfa:	7f 92       	push	r7
     bfc:	8f 92       	push	r8
     bfe:	9f 92       	push	r9
     c00:	af 92       	push	r10
     c02:	bf 92       	push	r11
     c04:	cf 92       	push	r12
     c06:	df 92       	push	r13
     c08:	ef 92       	push	r14
     c0a:	ff 92       	push	r15
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	8c 01       	movw	r16, r24
     c16:	eb 01       	movw	r28, r22
     c18:	4a 01       	movw	r8, r20
     c1a:	39 01       	movw	r6, r18

  
    	if(len!=0)
     c1c:	61 15       	cp	r22, r1
     c1e:	71 05       	cpc	r23, r1
     c20:	09 f4       	brne	.+2      	; 0xc24 <rtpSendCDPData+0x2c>
     c22:	7d c0       	rjmp	.+250    	; 0xd1e <rtpSendCDPData+0x126>
	{ 
  
  
  
    // create a new Packet, ...
    struct nicRequestHandle_t* handle = nicNewRequest();
     c24:	0e 94 44 19 	call	0x3288	; 0x3288 <nicNewRequest>
     c28:	5c 01       	movw	r10, r24

 
	    // ... append the Payload
	    char* buf = nicAddPacketHeader(handle,150+sizeof(struct cdpHeader_t));
     c2a:	60 ea       	ldi	r22, 0xA0	; 160
     c2c:	70 e0       	ldi	r23, 0x00	; 0
     c2e:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     c32:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = len;
     c34:	c0 83       	st	Z, r28
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     c36:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     c38:	12 82       	std	Z+2, r1	; 0x02
     c3a:	13 82       	std	Z+3, r1	; 0x03
     c3c:	14 82       	std	Z+4, r1	; 0x04
     c3e:	15 82       	std	Z+5, r1	; 0x05
     c40:	16 82       	std	Z+6, r1	; 0x06
     c42:	17 82       	std	Z+7, r1	; 0x07
     c44:	10 86       	std	Z+8, r1	; 0x08
     c46:	11 86       	std	Z+9, r1	; 0x09
     c48:	9e 01       	movw	r18, r28
     c4a:	21 50       	subi	r18, 0x01	; 1
     c4c:	30 40       	sbci	r19, 0x00	; 0
     c4e:	d8 01       	movw	r26, r16
     c50:	a2 0f       	add	r26, r18
     c52:	b3 1f       	adc	r27, r19
     c54:	ec 0f       	add	r30, r28
     c56:	fd 1f       	adc	r31, r29
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <rtpSendCDPData+0x66>
     c5a:	21 50       	subi	r18, 0x01	; 1
     c5c:	30 40       	sbci	r19, 0x00	; 0
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    while(len--)
	    {
	      buf[len] = data[len];
     c5e:	8c 91       	ld	r24, X
     c60:	81 87       	std	Z+9, r24	; 0x09
     c62:	11 97       	sbiw	r26, 0x01	; 1
     c64:	31 97       	sbiw	r30, 0x01	; 1
	    ((struct cdpHeader_t*)buf)->reserved = 0;
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    while(len--)
     c66:	21 15       	cp	r18, r1
     c68:	31 05       	cpc	r19, r1
     c6a:	b9 f7       	brne	.-18     	; 0xc5a <rtpSendCDPData+0x62>
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     c6c:	c5 01       	movw	r24, r10
     c6e:	6c e0       	ldi	r22, 0x0C	; 12
     c70:	70 e0       	ldi	r23, 0x00	; 0
     c72:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     c76:	6c 01       	movw	r12, r24
    
    header->version = 0x80;
     c78:	80 e8       	ldi	r24, 0x80	; 128
     c7a:	f6 01       	movw	r30, r12
     c7c:	80 83       	st	Z, r24
    header->type = type;     
     c7e:	8d e4       	ldi	r24, 0x4D	; 77
     c80:	81 83       	std	Z+1, r24	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     c82:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     c86:	16 2f       	mov	r17, r22
     c88:	00 27       	eor	r16, r16
     c8a:	ff 24       	eor	r15, r15
     c8c:	ee 24       	eor	r14, r14
     c8e:	29 2f       	mov	r18, r25
     c90:	33 27       	eor	r19, r19
     c92:	44 27       	eor	r20, r20
     c94:	55 27       	eor	r21, r21
     c96:	e2 2a       	or	r14, r18
     c98:	f3 2a       	or	r15, r19
     c9a:	04 2b       	or	r16, r20
     c9c:	15 2b       	or	r17, r21
     c9e:	9b 01       	movw	r18, r22
     ca0:	ac 01       	movw	r20, r24
     ca2:	20 70       	andi	r18, 0x00	; 0
     ca4:	30 70       	andi	r19, 0x00	; 0
     ca6:	50 70       	andi	r21, 0x00	; 0
     ca8:	23 2f       	mov	r18, r19
     caa:	34 2f       	mov	r19, r20
     cac:	45 2f       	mov	r20, r21
     cae:	55 27       	eor	r21, r21
     cb0:	e2 2a       	or	r14, r18
     cb2:	f3 2a       	or	r15, r19
     cb4:	04 2b       	or	r16, r20
     cb6:	15 2b       	or	r17, r21
     cb8:	60 70       	andi	r22, 0x00	; 0
     cba:	80 70       	andi	r24, 0x00	; 0
     cbc:	90 70       	andi	r25, 0x00	; 0
     cbe:	98 2f       	mov	r25, r24
     cc0:	87 2f       	mov	r24, r23
     cc2:	76 2f       	mov	r23, r22
     cc4:	66 27       	eor	r22, r22
     cc6:	e6 2a       	or	r14, r22
     cc8:	f7 2a       	or	r15, r23
     cca:	08 2b       	or	r16, r24
     ccc:	19 2b       	or	r17, r25
     cce:	f6 01       	movw	r30, r12
     cd0:	e4 82       	std	Z+4, r14	; 0x04
     cd2:	f5 82       	std	Z+5, r15	; 0x05
     cd4:	06 83       	std	Z+6, r16	; 0x06
     cd6:	17 83       	std	Z+7, r17	; 0x07
    header->ssrc = 0x00;
     cd8:	10 86       	std	Z+8, r1	; 0x08
     cda:	11 86       	std	Z+9, r1	; 0x09
     cdc:	12 86       	std	Z+10, r1	; 0x0a
     cde:	13 86       	std	Z+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     ce0:	80 91 1f 08 	lds	r24, 0x081F
     ce4:	90 91 20 08 	lds	r25, 0x0820
     ce8:	92 83       	std	Z+2, r25	; 0x02
     cea:	83 83       	std	Z+3, r24	; 0x03
    
    rtpSequence++;
     cec:	01 96       	adiw	r24, 0x01	; 1
     cee:	90 93 20 08 	sts	0x0820, r25
     cf2:	80 93 1f 08 	sts	0x081F, r24
    
    onUdpRequest(handle,destNetAddr,srcPort);  
     cf6:	c5 01       	movw	r24, r10
     cf8:	b4 01       	movw	r22, r8
     cfa:	a3 01       	movw	r20, r6
     cfc:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>



  
    return;
  }
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	1f 91       	pop	r17
     d06:	0f 91       	pop	r16
     d08:	ff 90       	pop	r15
     d0a:	ef 90       	pop	r14
     d0c:	df 90       	pop	r13
     d0e:	cf 90       	pop	r12
     d10:	bf 90       	pop	r11
     d12:	af 90       	pop	r10
     d14:	9f 90       	pop	r9
     d16:	8f 90       	pop	r8
     d18:	7f 90       	pop	r7
     d1a:	6f 90       	pop	r6
     d1c:	08 95       	ret
	else //iam alive len=0
	{

	
    // create a new Packet, ...
    struct nicRequestHandle_t* handle = nicNewRequest();
     d1e:	0e 94 44 19 	call	0x3288	; 0x3288 <nicNewRequest>
     d22:	ec 01       	movw	r28, r24

 
	    // ... append the Payload
	    char* buf = nicAddPacketHeader(handle,150+sizeof(struct cdpHeader_t));
     d24:	60 ea       	ldi	r22, 0xA0	; 160
     d26:	70 e0       	ldi	r23, 0x00	; 0
     d28:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     d2c:	fc 01       	movw	r30, r24
	    ((struct cdpHeader_t*)buf)->length = 0;
     d2e:	10 82       	st	Z, r1
	    ((struct cdpHeader_t*)buf)->reserved = 0;
     d30:	11 82       	std	Z+1, r1	; 0x01
	    ((struct cdpHeader_t*)buf)->timestamp = 0;
     d32:	12 82       	std	Z+2, r1	; 0x02
     d34:	13 82       	std	Z+3, r1	; 0x03
     d36:	14 82       	std	Z+4, r1	; 0x04
     d38:	15 82       	std	Z+5, r1	; 0x05
     d3a:	16 82       	std	Z+6, r1	; 0x06
     d3c:	17 82       	std	Z+7, r1	; 0x07
     d3e:	10 86       	std	Z+8, r1	; 0x08
     d40:	11 86       	std	Z+9, r1	; 0x09
    
	    buf = buf+sizeof(struct cdpHeader_t);
    
	    strcpy(buf,"iamalive\0");
     d42:	3a 96       	adiw	r30, 0x0a	; 10
     d44:	ae e0       	ldi	r26, 0x0E	; 14
     d46:	b1 e0       	ldi	r27, 0x01	; 1
     d48:	89 e0       	ldi	r24, 0x09	; 9
     d4a:	0d 90       	ld	r0, X+
     d4c:	01 92       	st	Z+, r0
     d4e:	81 50       	subi	r24, 0x01	; 1
     d50:	e1 f7       	brne	.-8      	; 0xd4a <rtpSendCDPData+0x152>
  
  void onRtpRequest(struct nicRequestHandle_t* handle, uint8_t type,
      struct netAddress_t* destNetAddr, portAddress_t* srcPort)
  {
    struct soRtpHeader_t* header 
       = (struct soRtpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soRtpHeader_t));
     d52:	ce 01       	movw	r24, r28
     d54:	6c e0       	ldi	r22, 0x0C	; 12
     d56:	70 e0       	ldi	r23, 0x00	; 0
     d58:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     d5c:	6c 01       	movw	r12, r24
    
    header->version = 0x80;
     d5e:	80 e8       	ldi	r24, 0x80	; 128
     d60:	f6 01       	movw	r30, r12
     d62:	80 83       	st	Z, r24
    header->type = type;     
     d64:	8d e4       	ldi	r24, 0x4D	; 77
     d66:	81 83       	std	Z+1, r24	; 0x01
    header->timestamp = clockGetShortTimeStamp();
     d68:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <clockGetShortTimeStamp>
    // swap bytes by preprocessor macro...
    header->timestamp = htonl(header->timestamp);
     d6c:	16 2f       	mov	r17, r22
     d6e:	00 27       	eor	r16, r16
     d70:	ff 24       	eor	r15, r15
     d72:	ee 24       	eor	r14, r14
     d74:	29 2f       	mov	r18, r25
     d76:	33 27       	eor	r19, r19
     d78:	44 27       	eor	r20, r20
     d7a:	55 27       	eor	r21, r21
     d7c:	e2 2a       	or	r14, r18
     d7e:	f3 2a       	or	r15, r19
     d80:	04 2b       	or	r16, r20
     d82:	15 2b       	or	r17, r21
     d84:	9b 01       	movw	r18, r22
     d86:	ac 01       	movw	r20, r24
     d88:	20 70       	andi	r18, 0x00	; 0
     d8a:	30 70       	andi	r19, 0x00	; 0
     d8c:	50 70       	andi	r21, 0x00	; 0
     d8e:	23 2f       	mov	r18, r19
     d90:	34 2f       	mov	r19, r20
     d92:	45 2f       	mov	r20, r21
     d94:	55 27       	eor	r21, r21
     d96:	e2 2a       	or	r14, r18
     d98:	f3 2a       	or	r15, r19
     d9a:	04 2b       	or	r16, r20
     d9c:	15 2b       	or	r17, r21
     d9e:	60 70       	andi	r22, 0x00	; 0
     da0:	80 70       	andi	r24, 0x00	; 0
     da2:	90 70       	andi	r25, 0x00	; 0
     da4:	98 2f       	mov	r25, r24
     da6:	87 2f       	mov	r24, r23
     da8:	76 2f       	mov	r23, r22
     daa:	66 27       	eor	r22, r22
     dac:	e6 2a       	or	r14, r22
     dae:	f7 2a       	or	r15, r23
     db0:	08 2b       	or	r16, r24
     db2:	19 2b       	or	r17, r25
     db4:	f6 01       	movw	r30, r12
     db6:	e4 82       	std	Z+4, r14	; 0x04
     db8:	f5 82       	std	Z+5, r15	; 0x05
     dba:	06 83       	std	Z+6, r16	; 0x06
     dbc:	17 83       	std	Z+7, r17	; 0x07
    header->ssrc = 0x00;
     dbe:	10 86       	std	Z+8, r1	; 0x08
     dc0:	11 86       	std	Z+9, r1	; 0x09
     dc2:	12 86       	std	Z+10, r1	; 0x0a
     dc4:	13 86       	std	Z+11, r1	; 0x0b
    header->sequence = htons(rtpSequence);
     dc6:	80 91 1f 08 	lds	r24, 0x081F
     dca:	90 91 20 08 	lds	r25, 0x0820
     dce:	92 83       	std	Z+2, r25	; 0x02
     dd0:	83 83       	std	Z+3, r24	; 0x03
    
    rtpSequence++;
     dd2:	01 96       	adiw	r24, 0x01	; 1
     dd4:	90 93 20 08 	sts	0x0820, r25
     dd8:	80 93 1f 08 	sts	0x081F, r24
    
    onUdpRequest(handle,destNetAddr,srcPort);  
     ddc:	ce 01       	movw	r24, r28
     dde:	b4 01       	movw	r22, r8
     de0:	a3 01       	movw	r20, r6
     de2:	0e 94 ca 0b 	call	0x1794	; 0x1794 <onUdpRequest>
     de6:	8c cf       	rjmp	.-232    	; 0xd00 <rtpSendCDPData+0x108>

00000de8 <getHardwareAddress>:
// yes you realy get a pointer, this is for performance consideration
// never ever change the value of this pointer!
struct macAddress_t* getHardwareAddress()
{
  return &hEthernetAddress;
}
     de8:	88 e1       	ldi	r24, 0x18	; 24
     dea:	91 e0       	ldi	r25, 0x01	; 1
     dec:	08 95       	ret

00000dee <ethernetEepromGetConfig>:

  EepromWriteConfig((void*)MAC_EEPROM, &buf, sizeof(buf));
}

void ethernetEepromGetConfig(uint8_t * mac)
{
     dee:	ef 92       	push	r14
     df0:	ff 92       	push	r15
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
     df6:	df 93       	push	r29
     df8:	cf 93       	push	r28
     dfa:	00 d0       	rcall	.+0      	; 0xdfc <ethernetEepromGetConfig+0xe>
     dfc:	00 d0       	rcall	.+0      	; 0xdfe <ethernetEepromGetConfig+0x10>
     dfe:	00 d0       	rcall	.+0      	; 0xe00 <ethernetEepromGetConfig+0x12>
     e00:	cd b7       	in	r28, 0x3d	; 61
     e02:	de b7       	in	r29, 0x3e	; 62
     e04:	8c 01       	movw	r16, r24
  netEthernetEeprom_t buf;
  if ( !EepromReadConfig((void*)MAC_EEPROM, &buf, sizeof(buf)) ) {
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	92 e0       	ldi	r25, 0x02	; 2
     e0a:	7e 01       	movw	r14, r28
     e0c:	08 94       	sec
     e0e:	e1 1c       	adc	r14, r1
     e10:	f1 1c       	adc	r15, r1
     e12:	b7 01       	movw	r22, r14
     e14:	46 e0       	ldi	r20, 0x06	; 6
     e16:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
     e1a:	88 23       	and	r24, r24
     e1c:	41 f4       	brne	.+16     	; 0xe2e <ethernetEepromGetConfig+0x40>
    buf.mac = hEthernetAddress;
     e1e:	d7 01       	movw	r26, r14
     e20:	e8 e1       	ldi	r30, 0x18	; 24
     e22:	f1 e0       	ldi	r31, 0x01	; 1
     e24:	86 e0       	ldi	r24, 0x06	; 6
     e26:	01 90       	ld	r0, Z+
     e28:	0d 92       	st	X+, r0
     e2a:	81 50       	subi	r24, 0x01	; 1
     e2c:	e1 f7       	brne	.-8      	; 0xe26 <ethernetEepromGetConfig+0x38>
  }
  mac[0] = buf.mac.octet1;
     e2e:	89 81       	ldd	r24, Y+1	; 0x01
     e30:	f8 01       	movw	r30, r16
     e32:	80 83       	st	Z, r24
  mac[1] = buf.mac.octet2;
     e34:	8a 81       	ldd	r24, Y+2	; 0x02
     e36:	81 83       	std	Z+1, r24	; 0x01
  mac[2] = buf.mac.octet3;
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	82 83       	std	Z+2, r24	; 0x02
  mac[3] = buf.mac.octet4;
     e3c:	8c 81       	ldd	r24, Y+4	; 0x04
     e3e:	83 83       	std	Z+3, r24	; 0x03
  mac[4] = buf.mac.octet5;
     e40:	8d 81       	ldd	r24, Y+5	; 0x05
     e42:	84 83       	std	Z+4, r24	; 0x04
  mac[5] = buf.mac.octet6;
     e44:	8e 81       	ldd	r24, Y+6	; 0x06
     e46:	85 83       	std	Z+5, r24	; 0x05
}
     e48:	26 96       	adiw	r28, 0x06	; 6
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	f8 94       	cli
     e4e:	de bf       	out	0x3e, r29	; 62
     e50:	0f be       	out	0x3f, r0	; 63
     e52:	cd bf       	out	0x3d, r28	; 61
     e54:	cf 91       	pop	r28
     e56:	df 91       	pop	r29
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	08 95       	ret

00000e62 <ethernetEepromSetConfig>:
}

#ifdef REQUIRES_RCFG

void ethernetEepromSetConfig(uint8_t * mac)
{
     e62:	df 93       	push	r29
     e64:	cf 93       	push	r28
     e66:	00 d0       	rcall	.+0      	; 0xe68 <ethernetEepromSetConfig+0x6>
     e68:	00 d0       	rcall	.+0      	; 0xe6a <ethernetEepromSetConfig+0x8>
     e6a:	00 d0       	rcall	.+0      	; 0xe6c <ethernetEepromSetConfig+0xa>
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
     e70:	fc 01       	movw	r30, r24
  netEthernetEeprom_t buf;
  buf.mac.octet1 = mac[0];
     e72:	80 81       	ld	r24, Z
     e74:	89 83       	std	Y+1, r24	; 0x01
  buf.mac.octet2 = mac[1];
     e76:	81 81       	ldd	r24, Z+1	; 0x01
     e78:	8a 83       	std	Y+2, r24	; 0x02
  buf.mac.octet3 = mac[2];
     e7a:	82 81       	ldd	r24, Z+2	; 0x02
     e7c:	8b 83       	std	Y+3, r24	; 0x03
  buf.mac.octet4 = mac[3];
     e7e:	83 81       	ldd	r24, Z+3	; 0x03
     e80:	8c 83       	std	Y+4, r24	; 0x04
  buf.mac.octet5 = mac[4];
     e82:	84 81       	ldd	r24, Z+4	; 0x04
     e84:	8d 83       	std	Y+5, r24	; 0x05
  buf.mac.octet6 = mac[5];
     e86:	85 81       	ldd	r24, Z+5	; 0x05
     e88:	8e 83       	std	Y+6, r24	; 0x06

  EepromWriteConfig((void*)MAC_EEPROM, &buf, sizeof(buf));
     e8a:	80 e0       	ldi	r24, 0x00	; 0
     e8c:	92 e0       	ldi	r25, 0x02	; 2
     e8e:	be 01       	movw	r22, r28
     e90:	6f 5f       	subi	r22, 0xFF	; 255
     e92:	7f 4f       	sbci	r23, 0xFF	; 255
     e94:	46 e0       	ldi	r20, 0x06	; 6
     e96:	0e 94 38 29 	call	0x5270	; 0x5270 <EepromWriteConfig>
}
     e9a:	26 96       	adiw	r28, 0x06	; 6
     e9c:	0f b6       	in	r0, 0x3f	; 63
     e9e:	f8 94       	cli
     ea0:	de bf       	out	0x3e, r29	; 62
     ea2:	0f be       	out	0x3f, r0	; 63
     ea4:	cd bf       	out	0x3d, r28	; 61
     ea6:	cf 91       	pop	r28
     ea8:	df 91       	pop	r29
     eaa:	08 95       	ret

00000eac <onInitEthernet>:
  onEthernetResponse(response);
  nicFreeResponse(response);
}

void onInitEthernet()
{
     eac:	0f 93       	push	r16
     eae:	1f 93       	push	r17
     eb0:	df 93       	push	r29
     eb2:	cf 93       	push	r28
     eb4:	00 d0       	rcall	.+0      	; 0xeb6 <onInitEthernet+0xa>
     eb6:	00 d0       	rcall	.+0      	; 0xeb8 <onInitEthernet+0xc>
     eb8:	00 d0       	rcall	.+0      	; 0xeba <onInitEthernet+0xe>
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62

  // define a struct for the configuration...
  netEthernetEeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)MAC_EEPROM, &buf, sizeof(buf)) ) {
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	92 e0       	ldi	r25, 0x02	; 2
     ec2:	8e 01       	movw	r16, r28
     ec4:	0f 5f       	subi	r16, 0xFF	; 255
     ec6:	1f 4f       	sbci	r17, 0xFF	; 255
     ec8:	b8 01       	movw	r22, r16
     eca:	46 e0       	ldi	r20, 0x06	; 6
     ecc:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
     ed0:	88 23       	and	r24, r24
     ed2:	41 f0       	breq	.+16     	; 0xee4 <onInitEthernet+0x38>
    hEthernetAddress = buf.mac;
     ed4:	a8 e1       	ldi	r26, 0x18	; 24
     ed6:	b1 e0       	ldi	r27, 0x01	; 1
     ed8:	f8 01       	movw	r30, r16
     eda:	86 e0       	ldi	r24, 0x06	; 6
     edc:	01 90       	ld	r0, Z+
     ede:	0d 92       	st	X+, r0
     ee0:	81 50       	subi	r24, 0x01	; 1
     ee2:	e1 f7       	brne	.-8      	; 0xedc <onInitEthernet+0x30>
  }
  // else hEthernetAddress keeps the fallback settings

  nicInitialize(&hEthernetAddress);
     ee4:	88 e1       	ldi	r24, 0x18	; 24
     ee6:	91 e0       	ldi	r25, 0x01	; 1
     ee8:	0e 94 6e 19 	call	0x32dc	; 0x32dc <nicInitialize>
  
  onInitArp();
     eec:	0e 94 4f 01 	call	0x29e	; 0x29e <onInitArp>
  onInitIPv4();  
     ef0:	0e 94 22 09 	call	0x1244	; 0x1244 <onInitIPv4>



  return;
}
     ef4:	26 96       	adiw	r28, 0x06	; 6
     ef6:	0f b6       	in	r0, 0x3f	; 63
     ef8:	f8 94       	cli
     efa:	de bf       	out	0x3e, r29	; 62
     efc:	0f be       	out	0x3f, r0	; 63
     efe:	cd bf       	out	0x3d, r28	; 61
     f00:	cf 91       	pop	r28
     f02:	df 91       	pop	r29
     f04:	1f 91       	pop	r17
     f06:	0f 91       	pop	r16
     f08:	08 95       	ret

00000f0a <onEthernetResponse>:
	
  return 0;
}
  
void onEthernetResponse(struct nicResponseHandle_t* handle)
{
     f0a:	0f 93       	push	r16
     f0c:	1f 93       	push	r17
     f0e:	df 93       	push	r29
     f10:	cf 93       	push	r28
     f12:	cd b7       	in	r28, 0x3d	; 61
     f14:	de b7       	in	r29, 0x3e	; 62
     f16:	2e 97       	sbiw	r28, 0x0e	; 14
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	f8 94       	cli
     f1c:	de bf       	out	0x3e, r29	; 62
     f1e:	0f be       	out	0x3f, r0	; 63
     f20:	cd bf       	out	0x3d, r28	; 61
     f22:	8c 01       	movw	r16, r24

// putString("Ether-Empfangen");


  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
     f24:	0e 94 95 18 	call	0x312a	; 0x312a <nicResponseSize>
     f28:	0e 97       	sbiw	r24, 0x0e	; 14
     f2a:	58 f4       	brcc	.+22     	; 0xf42 <onEthernetResponse+0x38>
      onArpResponse(handle,&(header.source));
      break;
  }

  return;	
}                      
     f2c:	2e 96       	adiw	r28, 0x0e	; 14
     f2e:	0f b6       	in	r0, 0x3f	; 63
     f30:	f8 94       	cli
     f32:	de bf       	out	0x3e, r29	; 62
     f34:	0f be       	out	0x3f, r0	; 63
     f36:	cd bf       	out	0x3d, r28	; 61
     f38:	cf 91       	pop	r28
     f3a:	df 91       	pop	r29
     f3c:	1f 91       	pop	r17
     f3e:	0f 91       	pop	r16
     f40:	08 95       	ret
  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
	  return;
	
  struct netEthernetHeader_t header;
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
     f42:	c8 01       	movw	r24, r16
     f44:	be 01       	movw	r22, r28
     f46:	6f 5f       	subi	r22, 0xFF	; 255
     f48:	7f 4f       	sbci	r23, 0xFF	; 255
     f4a:	4e e0       	ldi	r20, 0x0E	; 14
     f4c:	50 e0       	ldi	r21, 0x00	; 0
     f4e:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
	
  switch (header.etherType)
     f52:	8d 85       	ldd	r24, Y+13	; 0x0d
     f54:	9e 85       	ldd	r25, Y+14	; 0x0e
     f56:	88 30       	cpi	r24, 0x08	; 8
     f58:	91 05       	cpc	r25, r1
     f5a:	51 f0       	breq	.+20     	; 0xf70 <onEthernetResponse+0x66>
     f5c:	88 50       	subi	r24, 0x08	; 8
     f5e:	96 40       	sbci	r25, 0x06	; 6
     f60:	29 f7       	brne	.-54     	; 0xf2c <onEthernetResponse+0x22>
//	  putString("IP-Empfangen");

      break;
    case ETHERTYPE_ARP:

      onArpResponse(handle,&(header.source));
     f62:	c8 01       	movw	r24, r16
     f64:	be 01       	movw	r22, r28
     f66:	69 5f       	subi	r22, 0xF9	; 249
     f68:	7f 4f       	sbci	r23, 0xFF	; 255
     f6a:	0e 94 98 02 	call	0x530	; 0x530 <onArpResponse>
     f6e:	de cf       	rjmp	.-68     	; 0xf2c <onEthernetResponse+0x22>
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
	
  switch (header.etherType)
  {
    case ETHERTYPE_IP4: 
      onIPv4Response(handle,&(header.source));
     f70:	c8 01       	movw	r24, r16
     f72:	be 01       	movw	r22, r28
     f74:	69 5f       	subi	r22, 0xF9	; 249
     f76:	7f 4f       	sbci	r23, 0xFF	; 255
     f78:	0e 94 14 0b 	call	0x1628	; 0x1628 <onIPv4Response>
     f7c:	d7 cf       	rjmp	.-82     	; 0xf2c <onEthernetResponse+0x22>

00000f7e <onEthernetRequest>:
  return &hEthernetAddress;
}

uint8_t onEthernetRequest(struct nicRequestHandle_t* handle, uint16_t type, 
                        struct macAddress_t* destMac)
{
     f7e:	cf 92       	push	r12
     f80:	df 92       	push	r13
     f82:	ef 92       	push	r14
     f84:	ff 92       	push	r15
     f86:	0f 93       	push	r16
     f88:	1f 93       	push	r17
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	7c 01       	movw	r14, r24
     f90:	6b 01       	movw	r12, r22
     f92:	14 2f       	mov	r17, r20
     f94:	05 2f       	mov	r16, r21
	struct netEthernetHeader_t* header
	    = (struct netEthernetHeader_t*) nicAddPacketHeader(handle,sizeof(struct netEthernetHeader_t));
     f96:	6e e0       	ldi	r22, 0x0E	; 14
     f98:	70 e0       	ldi	r23, 0x00	; 0
     f9a:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
     f9e:	fc 01       	movw	r30, r24
	
	header->destination = *destMac;
     fa0:	ec 01       	movw	r28, r24
     fa2:	21 2f       	mov	r18, r17
     fa4:	30 2f       	mov	r19, r16
     fa6:	c9 01       	movw	r24, r18
     fa8:	dc 01       	movw	r26, r24
     faa:	86 e0       	ldi	r24, 0x06	; 6
     fac:	0d 90       	ld	r0, X+
     fae:	09 92       	st	Y+, r0
     fb0:	81 50       	subi	r24, 0x01	; 1
     fb2:	e1 f7       	brne	.-8      	; 0xfac <onEthernetRequest+0x2e>
	header->source      = *(getHardwareAddress());
     fb4:	ef 01       	movw	r28, r30
     fb6:	26 96       	adiw	r28, 0x06	; 6
     fb8:	a8 e1       	ldi	r26, 0x18	; 24
     fba:	b1 e0       	ldi	r27, 0x01	; 1
     fbc:	86 e0       	ldi	r24, 0x06	; 6
     fbe:	0d 90       	ld	r0, X+
     fc0:	09 92       	st	Y+, r0
     fc2:	81 50       	subi	r24, 0x01	; 1
     fc4:	e1 f7       	brne	.-8      	; 0xfbe <onEthernetRequest+0x40>
	header->etherType   = type;
     fc6:	d5 86       	std	Z+13, r13	; 0x0d
     fc8:	c4 86       	std	Z+12, r12	; 0x0c

	

	nicSendPacket(handle,0x00);
     fca:	c7 01       	movw	r24, r14
     fcc:	60 e0       	ldi	r22, 0x00	; 0
     fce:	0e 94 0d 1a 	call	0x341a	; 0x341a <nicSendPacket>
	
	nicFreeRequest(handle);
     fd2:	c7 01       	movw	r24, r14
     fd4:	0e 94 e1 18 	call	0x31c2	; 0x31c2 <nicFreeRequest>


	
  return 0;
}
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	df 91       	pop	r29
     fdc:	cf 91       	pop	r28
     fde:	1f 91       	pop	r17
     fe0:	0f 91       	pop	r16
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	df 90       	pop	r13
     fe8:	cf 90       	pop	r12
     fea:	08 95       	ret

00000fec <onEthernet>:

  return;	
}                      

void onEthernet()
{
     fec:	0f 93       	push	r16
     fee:	1f 93       	push	r17
     ff0:	df 93       	push	r29
     ff2:	cf 93       	push	r28
     ff4:	cd b7       	in	r28, 0x3d	; 61
     ff6:	de b7       	in	r29, 0x3e	; 62
     ff8:	2e 97       	sbiw	r28, 0x0e	; 14
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	f8 94       	cli
     ffe:	de bf       	out	0x3e, r29	; 62
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	cd bf       	out	0x3d, r28	; 61
  struct nicResponseHandle_t* response
      = nicReceiveResponse();
    1004:	0e 94 4c 19 	call	0x3298	; 0x3298 <nicReceiveResponse>
    1008:	8c 01       	movw	r16, r24
        
  if (response == NULL)
    100a:	00 97       	sbiw	r24, 0x00	; 0
    100c:	39 f0       	breq	.+14     	; 0x101c <onEthernet+0x30>

// putString("Ether-Empfangen");


  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
    100e:	0e 94 95 18 	call	0x312a	; 0x312a <nicResponseSize>
    1012:	0e 97       	sbiw	r24, 0x0e	; 14
    1014:	70 f4       	brcc	.+28     	; 0x1032 <onEthernet+0x46>
        
  if (response == NULL)
    return;
    
  onEthernetResponse(response);
  nicFreeResponse(response);
    1016:	c8 01       	movw	r24, r16
    1018:	0e 94 be 18 	call	0x317c	; 0x317c <nicFreeResponse>
}
    101c:	2e 96       	adiw	r28, 0x0e	; 14
    101e:	0f b6       	in	r0, 0x3f	; 63
    1020:	f8 94       	cli
    1022:	de bf       	out	0x3e, r29	; 62
    1024:	0f be       	out	0x3f, r0	; 63
    1026:	cd bf       	out	0x3d, r28	; 61
    1028:	cf 91       	pop	r28
    102a:	df 91       	pop	r29
    102c:	1f 91       	pop	r17
    102e:	0f 91       	pop	r16
    1030:	08 95       	ret
  // drop tiny packets...
  if (nicResponseSize(handle) < sizeof(struct netEthernetHeader_t))
	  return;
	
  struct netEthernetHeader_t header;
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
    1032:	c8 01       	movw	r24, r16
    1034:	be 01       	movw	r22, r28
    1036:	6f 5f       	subi	r22, 0xFF	; 255
    1038:	7f 4f       	sbci	r23, 0xFF	; 255
    103a:	4e e0       	ldi	r20, 0x0E	; 14
    103c:	50 e0       	ldi	r21, 0x00	; 0
    103e:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
	
  switch (header.etherType)
    1042:	8d 85       	ldd	r24, Y+13	; 0x0d
    1044:	9e 85       	ldd	r25, Y+14	; 0x0e
    1046:	88 30       	cpi	r24, 0x08	; 8
    1048:	91 05       	cpc	r25, r1
    104a:	51 f0       	breq	.+20     	; 0x1060 <onEthernet+0x74>
    104c:	88 50       	subi	r24, 0x08	; 8
    104e:	96 40       	sbci	r25, 0x06	; 6
    1050:	11 f7       	brne	.-60     	; 0x1016 <onEthernet+0x2a>
//	  putString("IP-Empfangen");

      break;
    case ETHERTYPE_ARP:

      onArpResponse(handle,&(header.source));
    1052:	c8 01       	movw	r24, r16
    1054:	be 01       	movw	r22, r28
    1056:	69 5f       	subi	r22, 0xF9	; 249
    1058:	7f 4f       	sbci	r23, 0xFF	; 255
    105a:	0e 94 98 02 	call	0x530	; 0x530 <onArpResponse>
    105e:	db cf       	rjmp	.-74     	; 0x1016 <onEthernet+0x2a>
  nicResponseRead(handle,(char*)&header,sizeof(struct netEthernetHeader_t));
	
  switch (header.etherType)
  {
    case ETHERTYPE_IP4: 
      onIPv4Response(handle,&(header.source));
    1060:	c8 01       	movw	r24, r16
    1062:	be 01       	movw	r22, r28
    1064:	69 5f       	subi	r22, 0xF9	; 249
    1066:	7f 4f       	sbci	r23, 0xFF	; 255
    1068:	0e 94 14 0b 	call	0x1628	; 0x1628 <onIPv4Response>
    106c:	d4 cf       	rjmp	.-88     	; 0x1016 <onEthernet+0x2a>

0000106e <ipGetAddress>:
}

ipAddress_t* ipGetAddress()
{
  return &(hIPv4.host);
}
    106e:	8e e1       	ldi	r24, 0x1E	; 30
    1070:	91 e0       	ldi	r25, 0x01	; 1
    1072:	08 95       	ret

00001074 <ipEepromGetConfig>:

  return;
}

void ipEepromGetConfig(ipAddress_t * ip, ipAddress_t * nm, ipAddress_t * gw)
{
    1074:	8f 92       	push	r8
    1076:	9f 92       	push	r9
    1078:	af 92       	push	r10
    107a:	bf 92       	push	r11
    107c:	cf 92       	push	r12
    107e:	df 92       	push	r13
    1080:	ef 92       	push	r14
    1082:	ff 92       	push	r15
    1084:	0f 93       	push	r16
    1086:	1f 93       	push	r17
    1088:	df 93       	push	r29
    108a:	cf 93       	push	r28
    108c:	cd b7       	in	r28, 0x3d	; 61
    108e:	de b7       	in	r29, 0x3e	; 62
    1090:	2c 97       	sbiw	r28, 0x0c	; 12
    1092:	0f b6       	in	r0, 0x3f	; 63
    1094:	f8 94       	cli
    1096:	de bf       	out	0x3e, r29	; 62
    1098:	0f be       	out	0x3f, r0	; 63
    109a:	cd bf       	out	0x3d, r28	; 61
    109c:	6c 01       	movw	r12, r24
    109e:	5b 01       	movw	r10, r22
    10a0:	4a 01       	movw	r8, r20
  netIPv4Eeprom_t buf;
  if ( !EepromReadConfig((void*)IP4_EEPROM, &buf, sizeof(buf)) ) {
    10a2:	80 e0       	ldi	r24, 0x00	; 0
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	be 01       	movw	r22, r28
    10a8:	6f 5f       	subi	r22, 0xFF	; 255
    10aa:	7f 4f       	sbci	r23, 0xFF	; 255
    10ac:	4c e0       	ldi	r20, 0x0C	; 12
    10ae:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
    10b2:	88 23       	and	r24, r24
    10b4:	21 f5       	brne	.+72     	; 0x10fe <ipEepromGetConfig+0x8a>
    // return fallback settings, if eeprom data is invalid
    buf.host = hIPv4.host;
    10b6:	80 91 1e 01 	lds	r24, 0x011E
    10ba:	90 91 1f 01 	lds	r25, 0x011F
    10be:	a0 91 20 01 	lds	r26, 0x0120
    10c2:	b0 91 21 01 	lds	r27, 0x0121
    10c6:	89 83       	std	Y+1, r24	; 0x01
    10c8:	9a 83       	std	Y+2, r25	; 0x02
    10ca:	ab 83       	std	Y+3, r26	; 0x03
    10cc:	bc 83       	std	Y+4, r27	; 0x04
    buf.subnet = hIPv4.subnet;
    10ce:	80 91 26 01 	lds	r24, 0x0126
    10d2:	90 91 27 01 	lds	r25, 0x0127
    10d6:	a0 91 28 01 	lds	r26, 0x0128
    10da:	b0 91 29 01 	lds	r27, 0x0129
    10de:	8d 83       	std	Y+5, r24	; 0x05
    10e0:	9e 83       	std	Y+6, r25	; 0x06
    10e2:	af 83       	std	Y+7, r26	; 0x07
    10e4:	b8 87       	std	Y+8, r27	; 0x08
    buf.gateway = hIPv4.gateway;
    10e6:	80 91 22 01 	lds	r24, 0x0122
    10ea:	90 91 23 01 	lds	r25, 0x0123
    10ee:	a0 91 24 01 	lds	r26, 0x0124
    10f2:	b0 91 25 01 	lds	r27, 0x0125
    10f6:	89 87       	std	Y+9, r24	; 0x09
    10f8:	9a 87       	std	Y+10, r25	; 0x0a
    10fa:	ab 87       	std	Y+11, r26	; 0x0b
    10fc:	bc 87       	std	Y+12, r27	; 0x0c
  }

  // convert to host-byte-order and only assign values
  // if pointer != NULL
  if (ip)
    10fe:	c1 14       	cp	r12, r1
    1100:	d1 04       	cpc	r13, r1
    1102:	69 f1       	breq	.+90     	; 0x115e <__stack+0x5f>
  	*ip = ntohl(buf.host);
    1104:	29 81       	ldd	r18, Y+1	; 0x01
    1106:	3a 81       	ldd	r19, Y+2	; 0x02
    1108:	4b 81       	ldd	r20, Y+3	; 0x03
    110a:	5c 81       	ldd	r21, Y+4	; 0x04
    110c:	12 2f       	mov	r17, r18
    110e:	00 27       	eor	r16, r16
    1110:	ff 24       	eor	r15, r15
    1112:	ee 24       	eor	r14, r14
    1114:	85 2f       	mov	r24, r21
    1116:	99 27       	eor	r25, r25
    1118:	aa 27       	eor	r26, r26
    111a:	bb 27       	eor	r27, r27
    111c:	e8 2a       	or	r14, r24
    111e:	f9 2a       	or	r15, r25
    1120:	0a 2b       	or	r16, r26
    1122:	1b 2b       	or	r17, r27
    1124:	da 01       	movw	r26, r20
    1126:	c9 01       	movw	r24, r18
    1128:	80 70       	andi	r24, 0x00	; 0
    112a:	90 70       	andi	r25, 0x00	; 0
    112c:	b0 70       	andi	r27, 0x00	; 0
    112e:	89 2f       	mov	r24, r25
    1130:	9a 2f       	mov	r25, r26
    1132:	ab 2f       	mov	r26, r27
    1134:	bb 27       	eor	r27, r27
    1136:	e8 2a       	or	r14, r24
    1138:	f9 2a       	or	r15, r25
    113a:	0a 2b       	or	r16, r26
    113c:	1b 2b       	or	r17, r27
    113e:	20 70       	andi	r18, 0x00	; 0
    1140:	40 70       	andi	r20, 0x00	; 0
    1142:	50 70       	andi	r21, 0x00	; 0
    1144:	54 2f       	mov	r21, r20
    1146:	43 2f       	mov	r20, r19
    1148:	32 2f       	mov	r19, r18
    114a:	22 27       	eor	r18, r18
    114c:	e2 2a       	or	r14, r18
    114e:	f3 2a       	or	r15, r19
    1150:	04 2b       	or	r16, r20
    1152:	15 2b       	or	r17, r21
    1154:	f6 01       	movw	r30, r12
    1156:	e0 82       	st	Z, r14
    1158:	f1 82       	std	Z+1, r15	; 0x01
    115a:	02 83       	std	Z+2, r16	; 0x02
    115c:	13 83       	std	Z+3, r17	; 0x03
  if (nm)
    115e:	a1 14       	cp	r10, r1
    1160:	b1 04       	cpc	r11, r1
    1162:	69 f1       	breq	.+90     	; 0x11be <__stack+0xbf>
    *nm = ntohl(buf.subnet);
    1164:	2d 81       	ldd	r18, Y+5	; 0x05
    1166:	3e 81       	ldd	r19, Y+6	; 0x06
    1168:	4f 81       	ldd	r20, Y+7	; 0x07
    116a:	58 85       	ldd	r21, Y+8	; 0x08
    116c:	12 2f       	mov	r17, r18
    116e:	00 27       	eor	r16, r16
    1170:	ff 24       	eor	r15, r15
    1172:	ee 24       	eor	r14, r14
    1174:	85 2f       	mov	r24, r21
    1176:	99 27       	eor	r25, r25
    1178:	aa 27       	eor	r26, r26
    117a:	bb 27       	eor	r27, r27
    117c:	e8 2a       	or	r14, r24
    117e:	f9 2a       	or	r15, r25
    1180:	0a 2b       	or	r16, r26
    1182:	1b 2b       	or	r17, r27
    1184:	da 01       	movw	r26, r20
    1186:	c9 01       	movw	r24, r18
    1188:	80 70       	andi	r24, 0x00	; 0
    118a:	90 70       	andi	r25, 0x00	; 0
    118c:	b0 70       	andi	r27, 0x00	; 0
    118e:	89 2f       	mov	r24, r25
    1190:	9a 2f       	mov	r25, r26
    1192:	ab 2f       	mov	r26, r27
    1194:	bb 27       	eor	r27, r27
    1196:	e8 2a       	or	r14, r24
    1198:	f9 2a       	or	r15, r25
    119a:	0a 2b       	or	r16, r26
    119c:	1b 2b       	or	r17, r27
    119e:	20 70       	andi	r18, 0x00	; 0
    11a0:	40 70       	andi	r20, 0x00	; 0
    11a2:	50 70       	andi	r21, 0x00	; 0
    11a4:	54 2f       	mov	r21, r20
    11a6:	43 2f       	mov	r20, r19
    11a8:	32 2f       	mov	r19, r18
    11aa:	22 27       	eor	r18, r18
    11ac:	e2 2a       	or	r14, r18
    11ae:	f3 2a       	or	r15, r19
    11b0:	04 2b       	or	r16, r20
    11b2:	15 2b       	or	r17, r21
    11b4:	f5 01       	movw	r30, r10
    11b6:	e0 82       	st	Z, r14
    11b8:	f1 82       	std	Z+1, r15	; 0x01
    11ba:	02 83       	std	Z+2, r16	; 0x02
    11bc:	13 83       	std	Z+3, r17	; 0x03
  if (gw)
    11be:	81 14       	cp	r8, r1
    11c0:	91 04       	cpc	r9, r1
    11c2:	69 f1       	breq	.+90     	; 0x121e <__stack+0x11f>
  	*gw = ntohl(buf.gateway);
    11c4:	29 85       	ldd	r18, Y+9	; 0x09
    11c6:	3a 85       	ldd	r19, Y+10	; 0x0a
    11c8:	4b 85       	ldd	r20, Y+11	; 0x0b
    11ca:	5c 85       	ldd	r21, Y+12	; 0x0c
    11cc:	12 2f       	mov	r17, r18
    11ce:	00 27       	eor	r16, r16
    11d0:	ff 24       	eor	r15, r15
    11d2:	ee 24       	eor	r14, r14
    11d4:	85 2f       	mov	r24, r21
    11d6:	99 27       	eor	r25, r25
    11d8:	aa 27       	eor	r26, r26
    11da:	bb 27       	eor	r27, r27
    11dc:	e8 2a       	or	r14, r24
    11de:	f9 2a       	or	r15, r25
    11e0:	0a 2b       	or	r16, r26
    11e2:	1b 2b       	or	r17, r27
    11e4:	da 01       	movw	r26, r20
    11e6:	c9 01       	movw	r24, r18
    11e8:	80 70       	andi	r24, 0x00	; 0
    11ea:	90 70       	andi	r25, 0x00	; 0
    11ec:	b0 70       	andi	r27, 0x00	; 0
    11ee:	89 2f       	mov	r24, r25
    11f0:	9a 2f       	mov	r25, r26
    11f2:	ab 2f       	mov	r26, r27
    11f4:	bb 27       	eor	r27, r27
    11f6:	e8 2a       	or	r14, r24
    11f8:	f9 2a       	or	r15, r25
    11fa:	0a 2b       	or	r16, r26
    11fc:	1b 2b       	or	r17, r27
    11fe:	20 70       	andi	r18, 0x00	; 0
    1200:	40 70       	andi	r20, 0x00	; 0
    1202:	50 70       	andi	r21, 0x00	; 0
    1204:	54 2f       	mov	r21, r20
    1206:	43 2f       	mov	r20, r19
    1208:	32 2f       	mov	r19, r18
    120a:	22 27       	eor	r18, r18
    120c:	e2 2a       	or	r14, r18
    120e:	f3 2a       	or	r15, r19
    1210:	04 2b       	or	r16, r20
    1212:	15 2b       	or	r17, r21
    1214:	f4 01       	movw	r30, r8
    1216:	e0 82       	st	Z, r14
    1218:	f1 82       	std	Z+1, r15	; 0x01
    121a:	02 83       	std	Z+2, r16	; 0x02
    121c:	13 83       	std	Z+3, r17	; 0x03

  return;
}
    121e:	2c 96       	adiw	r28, 0x0c	; 12
    1220:	0f b6       	in	r0, 0x3f	; 63
    1222:	f8 94       	cli
    1224:	de bf       	out	0x3e, r29	; 62
    1226:	0f be       	out	0x3f, r0	; 63
    1228:	cd bf       	out	0x3d, r28	; 61
    122a:	cf 91       	pop	r28
    122c:	df 91       	pop	r29
    122e:	1f 91       	pop	r17
    1230:	0f 91       	pop	r16
    1232:	ff 90       	pop	r15
    1234:	ef 90       	pop	r14
    1236:	df 90       	pop	r13
    1238:	cf 90       	pop	r12
    123a:	bf 90       	pop	r11
    123c:	af 90       	pop	r10
    123e:	9f 90       	pop	r9
    1240:	8f 90       	pop	r8
    1242:	08 95       	ret

00001244 <onInitIPv4>:
{
  return &(hIPv4.host);
}

void onInitIPv4()
{
    1244:	df 93       	push	r29
    1246:	cf 93       	push	r28
    1248:	cd b7       	in	r28, 0x3d	; 61
    124a:	de b7       	in	r29, 0x3e	; 62
    124c:	2c 97       	sbiw	r28, 0x0c	; 12
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	f8 94       	cli
    1252:	de bf       	out	0x3e, r29	; 62
    1254:	0f be       	out	0x3f, r0	; 63
    1256:	cd bf       	out	0x3d, r28	; 61
  // define a struct for the configuration...
  netIPv4Eeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)IP4_EEPROM, &buf, sizeof(buf)) ) { 
    1258:	80 e0       	ldi	r24, 0x00	; 0
    125a:	91 e0       	ldi	r25, 0x01	; 1
    125c:	be 01       	movw	r22, r28
    125e:	6f 5f       	subi	r22, 0xFF	; 255
    1260:	7f 4f       	sbci	r23, 0xFF	; 255
    1262:	4c e0       	ldi	r20, 0x0C	; 12
    1264:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
    1268:	88 23       	and	r24, r24
    126a:	21 f1       	breq	.+72     	; 0x12b4 <onInitIPv4+0x70>
    hIPv4.host    = buf.host;
    126c:	89 81       	ldd	r24, Y+1	; 0x01
    126e:	9a 81       	ldd	r25, Y+2	; 0x02
    1270:	ab 81       	ldd	r26, Y+3	; 0x03
    1272:	bc 81       	ldd	r27, Y+4	; 0x04
    1274:	80 93 1e 01 	sts	0x011E, r24
    1278:	90 93 1f 01 	sts	0x011F, r25
    127c:	a0 93 20 01 	sts	0x0120, r26
    1280:	b0 93 21 01 	sts	0x0121, r27
    hIPv4.gateway = buf.gateway;
    1284:	89 85       	ldd	r24, Y+9	; 0x09
    1286:	9a 85       	ldd	r25, Y+10	; 0x0a
    1288:	ab 85       	ldd	r26, Y+11	; 0x0b
    128a:	bc 85       	ldd	r27, Y+12	; 0x0c
    128c:	80 93 22 01 	sts	0x0122, r24
    1290:	90 93 23 01 	sts	0x0123, r25
    1294:	a0 93 24 01 	sts	0x0124, r26
    1298:	b0 93 25 01 	sts	0x0125, r27
    hIPv4.subnet  = buf.subnet;
    129c:	8d 81       	ldd	r24, Y+5	; 0x05
    129e:	9e 81       	ldd	r25, Y+6	; 0x06
    12a0:	af 81       	ldd	r26, Y+7	; 0x07
    12a2:	b8 85       	ldd	r27, Y+8	; 0x08
    12a4:	80 93 26 01 	sts	0x0126, r24
    12a8:	90 93 27 01 	sts	0x0127, r25
    12ac:	a0 93 28 01 	sts	0x0128, r26
    12b0:	b0 93 29 01 	sts	0x0129, r27
  }
  // else hIPv4 keeps the fallback settings
    
  return;
}
    12b4:	2c 96       	adiw	r28, 0x0c	; 12
    12b6:	0f b6       	in	r0, 0x3f	; 63
    12b8:	f8 94       	cli
    12ba:	de bf       	out	0x3e, r29	; 62
    12bc:	0f be       	out	0x3f, r0	; 63
    12be:	cd bf       	out	0x3d, r28	; 61
    12c0:	cf 91       	pop	r28
    12c2:	df 91       	pop	r29
    12c4:	08 95       	ret

000012c6 <ipEepromSetConfig>:

#ifdef REQUIRES_RCFG

void ipEepromSetConfig(ipAddress_t ip, ipAddress_t nm, ipAddress_t gw)
{
    12c6:	4f 92       	push	r4
    12c8:	5f 92       	push	r5
    12ca:	6f 92       	push	r6
    12cc:	7f 92       	push	r7
    12ce:	8f 92       	push	r8
    12d0:	9f 92       	push	r9
    12d2:	af 92       	push	r10
    12d4:	bf 92       	push	r11
    12d6:	cf 92       	push	r12
    12d8:	df 92       	push	r13
    12da:	ef 92       	push	r14
    12dc:	ff 92       	push	r15
    12de:	0f 93       	push	r16
    12e0:	1f 93       	push	r17
    12e2:	df 93       	push	r29
    12e4:	cf 93       	push	r28
    12e6:	cd b7       	in	r28, 0x3d	; 61
    12e8:	de b7       	in	r29, 0x3e	; 62
    12ea:	2c 97       	sbiw	r28, 0x0c	; 12
    12ec:	0f b6       	in	r0, 0x3f	; 63
    12ee:	f8 94       	cli
    12f0:	de bf       	out	0x3e, r29	; 62
    12f2:	0f be       	out	0x3f, r0	; 63
    12f4:	cd bf       	out	0x3d, r28	; 61
    12f6:	5b 01       	movw	r10, r22
    12f8:	6c 01       	movw	r12, r24
    12fa:	39 01       	movw	r6, r18
    12fc:	4a 01       	movw	r8, r20
  netIPv4Eeprom_t buf;
  if ( !EepromReadConfig((void*)IP4_EEPROM, &buf, sizeof(buf)) )
    12fe:	80 e0       	ldi	r24, 0x00	; 0
    1300:	91 e0       	ldi	r25, 0x01	; 1
    1302:	2e 01       	movw	r4, r28
    1304:	08 94       	sec
    1306:	41 1c       	adc	r4, r1
    1308:	51 1c       	adc	r5, r1
    130a:	b2 01       	movw	r22, r4
    130c:	4c e0       	ldi	r20, 0x0C	; 12
    130e:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
    1312:	88 23       	and	r24, r24
    1314:	21 f5       	brne	.+72     	; 0x135e <ipEepromSetConfig+0x98>
  {
    // if eeprom data is invalid,
    // create new configuration based upon the fallback settings
    buf.host = hIPv4.host;
    1316:	80 91 1e 01 	lds	r24, 0x011E
    131a:	90 91 1f 01 	lds	r25, 0x011F
    131e:	a0 91 20 01 	lds	r26, 0x0120
    1322:	b0 91 21 01 	lds	r27, 0x0121
    1326:	89 83       	std	Y+1, r24	; 0x01
    1328:	9a 83       	std	Y+2, r25	; 0x02
    132a:	ab 83       	std	Y+3, r26	; 0x03
    132c:	bc 83       	std	Y+4, r27	; 0x04
    buf.subnet = hIPv4.subnet;
    132e:	80 91 26 01 	lds	r24, 0x0126
    1332:	90 91 27 01 	lds	r25, 0x0127
    1336:	a0 91 28 01 	lds	r26, 0x0128
    133a:	b0 91 29 01 	lds	r27, 0x0129
    133e:	8d 83       	std	Y+5, r24	; 0x05
    1340:	9e 83       	std	Y+6, r25	; 0x06
    1342:	af 83       	std	Y+7, r26	; 0x07
    1344:	b8 87       	std	Y+8, r27	; 0x08
    buf.gateway = hIPv4.gateway;
    1346:	80 91 22 01 	lds	r24, 0x0122
    134a:	90 91 23 01 	lds	r25, 0x0123
    134e:	a0 91 24 01 	lds	r26, 0x0124
    1352:	b0 91 25 01 	lds	r27, 0x0125
    1356:	89 87       	std	Y+9, r24	; 0x09
    1358:	9a 87       	std	Y+10, r25	; 0x0a
    135a:	ab 87       	std	Y+11, r26	; 0x0b
    135c:	bc 87       	std	Y+12, r27	; 0x0c
  }

  // set new values (network-byte-order!)
  if (ip != 0)
    135e:	a1 14       	cp	r10, r1
    1360:	b1 04       	cpc	r11, r1
    1362:	c1 04       	cpc	r12, r1
    1364:	d1 04       	cpc	r13, r1
    1366:	69 f1       	breq	.+90     	; 0x13c2 <ipEepromSetConfig+0xfc>
    buf.host = htonl(ip);
    1368:	5a 2d       	mov	r21, r10
    136a:	44 27       	eor	r20, r20
    136c:	33 27       	eor	r19, r19
    136e:	22 27       	eor	r18, r18
    1370:	8d 2d       	mov	r24, r13
    1372:	99 27       	eor	r25, r25
    1374:	aa 27       	eor	r26, r26
    1376:	bb 27       	eor	r27, r27
    1378:	28 2b       	or	r18, r24
    137a:	39 2b       	or	r19, r25
    137c:	4a 2b       	or	r20, r26
    137e:	5b 2b       	or	r21, r27
    1380:	d6 01       	movw	r26, r12
    1382:	c5 01       	movw	r24, r10
    1384:	80 70       	andi	r24, 0x00	; 0
    1386:	90 70       	andi	r25, 0x00	; 0
    1388:	b0 70       	andi	r27, 0x00	; 0
    138a:	89 2f       	mov	r24, r25
    138c:	9a 2f       	mov	r25, r26
    138e:	ab 2f       	mov	r26, r27
    1390:	bb 27       	eor	r27, r27
    1392:	28 2b       	or	r18, r24
    1394:	39 2b       	or	r19, r25
    1396:	4a 2b       	or	r20, r26
    1398:	5b 2b       	or	r21, r27
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	9f ef       	ldi	r25, 0xFF	; 255
    139e:	a0 e0       	ldi	r26, 0x00	; 0
    13a0:	b0 e0       	ldi	r27, 0x00	; 0
    13a2:	a8 22       	and	r10, r24
    13a4:	b9 22       	and	r11, r25
    13a6:	ca 22       	and	r12, r26
    13a8:	db 22       	and	r13, r27
    13aa:	bc 2d       	mov	r27, r12
    13ac:	ab 2d       	mov	r26, r11
    13ae:	9a 2d       	mov	r25, r10
    13b0:	88 27       	eor	r24, r24
    13b2:	28 2b       	or	r18, r24
    13b4:	39 2b       	or	r19, r25
    13b6:	4a 2b       	or	r20, r26
    13b8:	5b 2b       	or	r21, r27
    13ba:	29 83       	std	Y+1, r18	; 0x01
    13bc:	3a 83       	std	Y+2, r19	; 0x02
    13be:	4b 83       	std	Y+3, r20	; 0x03
    13c0:	5c 83       	std	Y+4, r21	; 0x04

  if (nm != 0)
    13c2:	61 14       	cp	r6, r1
    13c4:	71 04       	cpc	r7, r1
    13c6:	81 04       	cpc	r8, r1
    13c8:	91 04       	cpc	r9, r1
    13ca:	69 f1       	breq	.+90     	; 0x1426 <ipEepromSetConfig+0x160>
    buf.subnet = htonl(nm);
    13cc:	56 2d       	mov	r21, r6
    13ce:	44 27       	eor	r20, r20
    13d0:	33 27       	eor	r19, r19
    13d2:	22 27       	eor	r18, r18
    13d4:	89 2d       	mov	r24, r9
    13d6:	99 27       	eor	r25, r25
    13d8:	aa 27       	eor	r26, r26
    13da:	bb 27       	eor	r27, r27
    13dc:	28 2b       	or	r18, r24
    13de:	39 2b       	or	r19, r25
    13e0:	4a 2b       	or	r20, r26
    13e2:	5b 2b       	or	r21, r27
    13e4:	d4 01       	movw	r26, r8
    13e6:	c3 01       	movw	r24, r6
    13e8:	80 70       	andi	r24, 0x00	; 0
    13ea:	90 70       	andi	r25, 0x00	; 0
    13ec:	b0 70       	andi	r27, 0x00	; 0
    13ee:	89 2f       	mov	r24, r25
    13f0:	9a 2f       	mov	r25, r26
    13f2:	ab 2f       	mov	r26, r27
    13f4:	bb 27       	eor	r27, r27
    13f6:	28 2b       	or	r18, r24
    13f8:	39 2b       	or	r19, r25
    13fa:	4a 2b       	or	r20, r26
    13fc:	5b 2b       	or	r21, r27
    13fe:	80 e0       	ldi	r24, 0x00	; 0
    1400:	9f ef       	ldi	r25, 0xFF	; 255
    1402:	a0 e0       	ldi	r26, 0x00	; 0
    1404:	b0 e0       	ldi	r27, 0x00	; 0
    1406:	68 22       	and	r6, r24
    1408:	79 22       	and	r7, r25
    140a:	8a 22       	and	r8, r26
    140c:	9b 22       	and	r9, r27
    140e:	b8 2d       	mov	r27, r8
    1410:	a7 2d       	mov	r26, r7
    1412:	96 2d       	mov	r25, r6
    1414:	88 27       	eor	r24, r24
    1416:	28 2b       	or	r18, r24
    1418:	39 2b       	or	r19, r25
    141a:	4a 2b       	or	r20, r26
    141c:	5b 2b       	or	r21, r27
    141e:	2d 83       	std	Y+5, r18	; 0x05
    1420:	3e 83       	std	Y+6, r19	; 0x06
    1422:	4f 83       	std	Y+7, r20	; 0x07
    1424:	58 87       	std	Y+8, r21	; 0x08

  if (gw != 0)
    1426:	e1 14       	cp	r14, r1
    1428:	f1 04       	cpc	r15, r1
    142a:	01 05       	cpc	r16, r1
    142c:	11 05       	cpc	r17, r1
    142e:	69 f1       	breq	.+90     	; 0x148a <ipEepromSetConfig+0x1c4>
    buf.gateway = htonl(gw);
    1430:	5e 2d       	mov	r21, r14
    1432:	44 27       	eor	r20, r20
    1434:	33 27       	eor	r19, r19
    1436:	22 27       	eor	r18, r18
    1438:	81 2f       	mov	r24, r17
    143a:	99 27       	eor	r25, r25
    143c:	aa 27       	eor	r26, r26
    143e:	bb 27       	eor	r27, r27
    1440:	28 2b       	or	r18, r24
    1442:	39 2b       	or	r19, r25
    1444:	4a 2b       	or	r20, r26
    1446:	5b 2b       	or	r21, r27
    1448:	d8 01       	movw	r26, r16
    144a:	c7 01       	movw	r24, r14
    144c:	80 70       	andi	r24, 0x00	; 0
    144e:	90 70       	andi	r25, 0x00	; 0
    1450:	b0 70       	andi	r27, 0x00	; 0
    1452:	89 2f       	mov	r24, r25
    1454:	9a 2f       	mov	r25, r26
    1456:	ab 2f       	mov	r26, r27
    1458:	bb 27       	eor	r27, r27
    145a:	28 2b       	or	r18, r24
    145c:	39 2b       	or	r19, r25
    145e:	4a 2b       	or	r20, r26
    1460:	5b 2b       	or	r21, r27
    1462:	80 e0       	ldi	r24, 0x00	; 0
    1464:	9f ef       	ldi	r25, 0xFF	; 255
    1466:	a0 e0       	ldi	r26, 0x00	; 0
    1468:	b0 e0       	ldi	r27, 0x00	; 0
    146a:	e8 22       	and	r14, r24
    146c:	f9 22       	and	r15, r25
    146e:	0a 23       	and	r16, r26
    1470:	1b 23       	and	r17, r27
    1472:	b0 2f       	mov	r27, r16
    1474:	af 2d       	mov	r26, r15
    1476:	9e 2d       	mov	r25, r14
    1478:	88 27       	eor	r24, r24
    147a:	28 2b       	or	r18, r24
    147c:	39 2b       	or	r19, r25
    147e:	4a 2b       	or	r20, r26
    1480:	5b 2b       	or	r21, r27
    1482:	29 87       	std	Y+9, r18	; 0x09
    1484:	3a 87       	std	Y+10, r19	; 0x0a
    1486:	4b 87       	std	Y+11, r20	; 0x0b
    1488:	5c 87       	std	Y+12, r21	; 0x0c

  EepromWriteConfig((void*)IP4_EEPROM, &buf, sizeof(buf));
    148a:	80 e0       	ldi	r24, 0x00	; 0
    148c:	91 e0       	ldi	r25, 0x01	; 1
    148e:	b2 01       	movw	r22, r4
    1490:	4c e0       	ldi	r20, 0x0C	; 12
    1492:	0e 94 38 29 	call	0x5270	; 0x5270 <EepromWriteConfig>

  return;
}
    1496:	2c 96       	adiw	r28, 0x0c	; 12
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	cf 91       	pop	r28
    14a4:	df 91       	pop	r29
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	ff 90       	pop	r15
    14ac:	ef 90       	pop	r14
    14ae:	df 90       	pop	r13
    14b0:	cf 90       	pop	r12
    14b2:	bf 90       	pop	r11
    14b4:	af 90       	pop	r10
    14b6:	9f 90       	pop	r9
    14b8:	8f 90       	pop	r8
    14ba:	7f 90       	pop	r7
    14bc:	6f 90       	pop	r6
    14be:	5f 90       	pop	r5
    14c0:	4f 90       	pop	r4
    14c2:	08 95       	ret

000014c4 <onIPv4Request>:
  
  return;
}

uint8_t onIPv4Request(struct nicRequestHandle_t* handle, ipAddress_t* destIP, uint8_t protocol)
{
    14c4:	8f 92       	push	r8
    14c6:	9f 92       	push	r9
    14c8:	af 92       	push	r10
    14ca:	bf 92       	push	r11
    14cc:	cf 92       	push	r12
    14ce:	df 92       	push	r13
    14d0:	ef 92       	push	r14
    14d2:	ff 92       	push	r15
    14d4:	0f 93       	push	r16
    14d6:	1f 93       	push	r17
    14d8:	df 93       	push	r29
    14da:	cf 93       	push	r28
    14dc:	00 d0       	rcall	.+0      	; 0x14de <onIPv4Request+0x1a>
    14de:	00 d0       	rcall	.+0      	; 0x14e0 <onIPv4Request+0x1c>
    14e0:	00 d0       	rcall	.+0      	; 0x14e2 <onIPv4Request+0x1e>
    14e2:	cd b7       	in	r28, 0x3d	; 61
    14e4:	de b7       	in	r29, 0x3e	; 62
    14e6:	5c 01       	movw	r10, r24
    14e8:	6b 01       	movw	r12, r22
    14ea:	e4 2e       	mov	r14, r20
  struct macAddress_t mac;
  
  // check if destination address is within the subnet...
  // ... in case it is not, we have to send the packet to the gateway ...
  // ... yes this nested if is nasty, but we need the performance.
  if (arpLookupMacByIPv4(
    14ec:	fb 01       	movw	r30, r22
    14ee:	80 81       	ld	r24, Z
    14f0:	91 81       	ldd	r25, Z+1	; 0x01
    14f2:	a2 81       	ldd	r26, Z+2	; 0x02
    14f4:	b3 81       	ldd	r27, Z+3	; 0x03
    14f6:	20 91 22 01 	lds	r18, 0x0122
    14fa:	30 91 23 01 	lds	r19, 0x0123
    14fe:	40 91 24 01 	lds	r20, 0x0124
    1502:	50 91 25 01 	lds	r21, 0x0125
    1506:	82 27       	eor	r24, r18
    1508:	93 27       	eor	r25, r19
    150a:	a4 27       	eor	r26, r20
    150c:	b5 27       	eor	r27, r21
    150e:	20 91 26 01 	lds	r18, 0x0126
    1512:	30 91 27 01 	lds	r19, 0x0127
    1516:	40 91 28 01 	lds	r20, 0x0128
    151a:	50 91 29 01 	lds	r21, 0x0129
    151e:	82 23       	and	r24, r18
    1520:	93 23       	and	r25, r19
    1522:	a4 23       	and	r26, r20
    1524:	b5 23       	and	r27, r21
    1526:	00 97       	sbiw	r24, 0x00	; 0
    1528:	a1 05       	cpc	r26, r1
    152a:	b1 05       	cpc	r27, r1
    152c:	09 f0       	breq	.+2      	; 0x1530 <onIPv4Request+0x6c>
    152e:	74 c0       	rjmp	.+232    	; 0x1618 <onIPv4Request+0x154>
    1530:	cb 01       	movw	r24, r22
    1532:	4e 01       	movw	r8, r28
    1534:	08 94       	sec
    1536:	81 1c       	adc	r8, r1
    1538:	91 1c       	adc	r9, r1
    153a:	b4 01       	movw	r22, r8
    153c:	0e 94 6f 03 	call	0x6de	; 0x6de <arpLookupMacByIPv4>
    1540:	88 23       	and	r24, r24
    1542:	09 f0       	breq	.+2      	; 0x1546 <onIPv4Request+0x82>
    1544:	6c c0       	rjmp	.+216    	; 0x161e <onIPv4Request+0x15a>
    return 1;    
  }
  
  // we passed the lookup, so it is save to assemble the IP header... 
  struct netIPv4Header_t* header
    = (struct netIPv4Header_t*) nicAddPacketHeader(handle,sizeof(struct netIPv4Header_t));
    1546:	c5 01       	movw	r24, r10
    1548:	64 e1       	ldi	r22, 0x14	; 20
    154a:	70 e0       	ldi	r23, 0x00	; 0
    154c:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
    1550:	8c 01       	movw	r16, r24
  
    // generate the IP Header...
  header->version        = ((0x4 << 4) & 0xF0 )| ( sizeof(struct netIPv4Header_t) >> 2 );
    1552:	85 e4       	ldi	r24, 0x45	; 69
    1554:	f8 01       	movw	r30, r16
    1556:	80 83       	st	Z, r24
  header->typeOfService  = 0x00;
    1558:	11 82       	std	Z+1, r1	; 0x01
  header->totalLength    = htons(nicGetPacketSize(handle));
    155a:	c5 01       	movw	r24, r10
    155c:	0e 94 86 18 	call	0x310c	; 0x310c <nicGetPacketSize>
    1560:	f9 2e       	mov	r15, r25
    1562:	c5 01       	movw	r24, r10
    1564:	0e 94 86 18 	call	0x310c	; 0x310c <nicGetPacketSize>
    1568:	38 2f       	mov	r19, r24
    156a:	20 e0       	ldi	r18, 0x00	; 0
    156c:	8f 2d       	mov	r24, r15
    156e:	90 e0       	ldi	r25, 0x00	; 0
    1570:	28 2b       	or	r18, r24
    1572:	39 2b       	or	r19, r25
    1574:	f8 01       	movw	r30, r16
    1576:	33 83       	std	Z+3, r19	; 0x03
    1578:	22 83       	std	Z+2, r18	; 0x02
  header->identification = htons(hIPv4.identification);
    157a:	90 91 2a 01 	lds	r25, 0x012A
    157e:	80 91 2b 01 	lds	r24, 0x012B
    1582:	84 83       	std	Z+4, r24	; 0x04
    1584:	95 83       	std	Z+5, r25	; 0x05
  
  header->destIP = *destIP;
    1586:	f6 01       	movw	r30, r12
    1588:	80 81       	ld	r24, Z
    158a:	91 81       	ldd	r25, Z+1	; 0x01
    158c:	a2 81       	ldd	r26, Z+2	; 0x02
    158e:	b3 81       	ldd	r27, Z+3	; 0x03
    1590:	f8 01       	movw	r30, r16
    1592:	80 8b       	std	Z+16, r24	; 0x10
    1594:	91 8b       	std	Z+17, r25	; 0x11
    1596:	a2 8b       	std	Z+18, r26	; 0x12
    1598:	b3 8b       	std	Z+19, r27	; 0x13
  header->srcIP  = *ipGetAddress();
    159a:	80 91 1e 01 	lds	r24, 0x011E
    159e:	90 91 1f 01 	lds	r25, 0x011F
    15a2:	a0 91 20 01 	lds	r26, 0x0120
    15a6:	b0 91 21 01 	lds	r27, 0x0121
    15aa:	84 87       	std	Z+12, r24	; 0x0c
    15ac:	95 87       	std	Z+13, r25	; 0x0d
    15ae:	a6 87       	std	Z+14, r26	; 0x0e
    15b0:	b7 87       	std	Z+15, r27	; 0x0f
  
  hIPv4.identification++;
    15b2:	80 91 2a 01 	lds	r24, 0x012A
    15b6:	90 91 2b 01 	lds	r25, 0x012B
    15ba:	01 96       	adiw	r24, 0x01	; 1
    15bc:	90 93 2b 01 	sts	0x012B, r25
    15c0:	80 93 2a 01 	sts	0x012A, r24
  
  header->fragmentation  = htons(0x4000);
    15c4:	80 e4       	ldi	r24, 0x40	; 64
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	97 83       	std	Z+7, r25	; 0x07
    15ca:	86 83       	std	Z+6, r24	; 0x06
  header->timeToLive     = 128;
    15cc:	80 e8       	ldi	r24, 0x80	; 128
    15ce:	80 87       	std	Z+8, r24	; 0x08
  header->protocol       = protocol;
    15d0:	e1 86       	std	Z+9, r14	; 0x09
 
  // when calculation the header checksum, it is assumed, that... 
  // ... the checksum itself is set to 0x00 
  header->headerCheckSum = 0x00;
    15d2:	13 86       	std	Z+11, r1	; 0x0b
    15d4:	12 86       	std	Z+10, r1	; 0x0a
  header->headerCheckSum 
    15d6:	c8 01       	movw	r24, r16
    15d8:	64 e1       	ldi	r22, 0x14	; 20
    15da:	70 e0       	ldi	r23, 0x00	; 0
    15dc:	0e 94 9b 1a 	call	0x3536	; 0x3536 <calculateCheckSum>
    15e0:	f8 01       	movw	r30, r16
    15e2:	93 87       	std	Z+11, r25	; 0x0b
    15e4:	82 87       	std	Z+10, r24	; 0x0a
      = calculateCheckSum(header,sizeof(struct netIPv4Header_t));
    
  return onEthernetRequest(handle,ETHERTYPE_IP4, &mac);
    15e6:	c5 01       	movw	r24, r10
    15e8:	68 e0       	ldi	r22, 0x08	; 8
    15ea:	70 e0       	ldi	r23, 0x00	; 0
    15ec:	a4 01       	movw	r20, r8
    15ee:	0e 94 bf 07 	call	0xf7e	; 0xf7e <onEthernetRequest>
}
    15f2:	26 96       	adiw	r28, 0x06	; 6
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	f8 94       	cli
    15f8:	de bf       	out	0x3e, r29	; 62
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	cd bf       	out	0x3d, r28	; 61
    15fe:	cf 91       	pop	r28
    1600:	df 91       	pop	r29
    1602:	1f 91       	pop	r17
    1604:	0f 91       	pop	r16
    1606:	ff 90       	pop	r15
    1608:	ef 90       	pop	r14
    160a:	df 90       	pop	r13
    160c:	cf 90       	pop	r12
    160e:	bf 90       	pop	r11
    1610:	af 90       	pop	r10
    1612:	9f 90       	pop	r9
    1614:	8f 90       	pop	r8
    1616:	08 95       	ret
  struct macAddress_t mac;
  
  // check if destination address is within the subnet...
  // ... in case it is not, we have to send the packet to the gateway ...
  // ... yes this nested if is nasty, but we need the performance.
  if (arpLookupMacByIPv4(
    1618:	82 e2       	ldi	r24, 0x22	; 34
    161a:	91 e0       	ldi	r25, 0x01	; 1
    161c:	8a cf       	rjmp	.-236    	; 0x1532 <onIPv4Request+0x6e>
      ((((*destIP) & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))?destIP:&hIPv4.gateway),
      &mac) != 0)
  {
    nicFreeRequest(handle);
    161e:	c5 01       	movw	r24, r10
    1620:	0e 94 e1 18 	call	0x31c2	; 0x31c2 <nicFreeRequest>
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	e5 cf       	rjmp	.-54     	; 0x15f2 <onIPv4Request+0x12e>

00001628 <onIPv4Response>:
  ipAddress_t subnet;
  ipAddress_t gateway;
} netIPv4Eeprom_t;

void onIPv4Response(struct nicResponseHandle_t* handle, struct macAddress_t* source)
{
    1628:	ef 92       	push	r14
    162a:	ff 92       	push	r15
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	df 93       	push	r29
    1632:	cf 93       	push	r28
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
    1638:	64 97       	sbiw	r28, 0x14	; 20
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	de bf       	out	0x3e, r29	; 62
    1640:	0f be       	out	0x3f, r0	; 63
    1642:	cd bf       	out	0x3d, r28	; 61
    1644:	8c 01       	movw	r16, r24
    1646:	7b 01       	movw	r14, r22



  // if the packet length beyond expectation, drop it...
  if (nicResponseSize(handle) < sizeof(struct netIPv4Header_t))
    1648:	0e 94 95 18 	call	0x312a	; 0x312a <nicResponseSize>
    164c:	44 97       	sbiw	r24, 0x14	; 20
    164e:	68 f4       	brcc	.+26     	; 0x166a <onIPv4Response+0x42>
      onUdpResponse(handle, &header.srcIP);
      break;
  }
  
  return;
}
    1650:	64 96       	adiw	r28, 0x14	; 20
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	f8 94       	cli
    1656:	de bf       	out	0x3e, r29	; 62
    1658:	0f be       	out	0x3f, r0	; 63
    165a:	cd bf       	out	0x3d, r28	; 61
    165c:	cf 91       	pop	r28
    165e:	df 91       	pop	r29
    1660:	1f 91       	pop	r17
    1662:	0f 91       	pop	r16
    1664:	ff 90       	pop	r15
    1666:	ef 90       	pop	r14
    1668:	08 95       	ret
  if (nicResponseSize(handle) < sizeof(struct netIPv4Header_t))
    return;
  
  struct netIPv4Header_t header;
  
  nicResponseRead(handle,(char*)(&header),sizeof(struct netIPv4Header_t));
    166a:	c8 01       	movw	r24, r16
    166c:	be 01       	movw	r22, r28
    166e:	6f 5f       	subi	r22, 0xFF	; 255
    1670:	7f 4f       	sbci	r23, 0xFF	; 255
    1672:	44 e1       	ldi	r20, 0x14	; 20
    1674:	50 e0       	ldi	r21, 0x00	; 0
    1676:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
  
  // if the sender thinks, we have a different IP address...
  // ... we should definitivly drop the packet.
  if (header.destIP != *ipGetAddress())
    167a:	29 89       	ldd	r18, Y+17	; 0x11
    167c:	3a 89       	ldd	r19, Y+18	; 0x12
    167e:	4b 89       	ldd	r20, Y+19	; 0x13
    1680:	5c 89       	ldd	r21, Y+20	; 0x14
    1682:	80 91 1e 01 	lds	r24, 0x011E
    1686:	90 91 1f 01 	lds	r25, 0x011F
    168a:	a0 91 20 01 	lds	r26, 0x0120
    168e:	b0 91 21 01 	lds	r27, 0x0121
    1692:	28 17       	cp	r18, r24
    1694:	39 07       	cpc	r19, r25
    1696:	4a 07       	cpc	r20, r26
    1698:	5b 07       	cpc	r21, r27
    169a:	d1 f6       	brne	.-76     	; 0x1650 <onIPv4Response+0x28>
    return;
    
  // if knows our IP we should add him to our Arp Cache...
  // ... but ignore all MAC Multi-/Boradcasts Packets...
  // ... otherwise we could poisen our Arp Cache.  
  if ( ! (source->octet1 & (1 << 0)))
    169c:	f7 01       	movw	r30, r14
    169e:	80 81       	ld	r24, Z
    16a0:	80 fd       	sbrc	r24, 0
    16a2:	25 c0       	rjmp	.+74     	; 0x16ee <onIPv4Response+0xc6>
  {
    // we should not lean the ip address if, its not within our subnet... 
    // ... instead we should update the arp entry for the gateway
    if ((header.srcIP & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))
    16a4:	80 91 22 01 	lds	r24, 0x0122
    16a8:	90 91 23 01 	lds	r25, 0x0123
    16ac:	a0 91 24 01 	lds	r26, 0x0124
    16b0:	b0 91 25 01 	lds	r27, 0x0125
    16b4:	2d 85       	ldd	r18, Y+13	; 0x0d
    16b6:	3e 85       	ldd	r19, Y+14	; 0x0e
    16b8:	4f 85       	ldd	r20, Y+15	; 0x0f
    16ba:	58 89       	ldd	r21, Y+16	; 0x10
    16bc:	82 27       	eor	r24, r18
    16be:	93 27       	eor	r25, r19
    16c0:	a4 27       	eor	r26, r20
    16c2:	b5 27       	eor	r27, r21
    16c4:	20 91 26 01 	lds	r18, 0x0126
    16c8:	30 91 27 01 	lds	r19, 0x0127
    16cc:	40 91 28 01 	lds	r20, 0x0128
    16d0:	50 91 29 01 	lds	r21, 0x0129
    16d4:	82 23       	and	r24, r18
    16d6:	93 23       	and	r25, r19
    16d8:	a4 23       	and	r26, r20
    16da:	b5 23       	and	r27, r21
    16dc:	00 97       	sbiw	r24, 0x00	; 0
    16de:	a1 05       	cpc	r26, r1
    16e0:	b1 05       	cpc	r27, r1
    16e2:	81 f4       	brne	.+32     	; 0x1704 <onIPv4Response+0xdc>
      arpAddMacByIPv4(&header.srcIP,source);
    16e4:	ce 01       	movw	r24, r28
    16e6:	0d 96       	adiw	r24, 0x0d	; 13
    16e8:	b7 01       	movw	r22, r14
    16ea:	0e 94 93 00 	call	0x126	; 0x126 <arpAddMacByIPv4>
      arpAddMacByIPv4(&hIPv4.gateway,source);
  }
     

     
  switch (header.protocol)
    16ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    16f0:	81 31       	cpi	r24, 0x11	; 17
    16f2:	09 f0       	breq	.+2      	; 0x16f6 <onIPv4Response+0xce>
    16f4:	ad cf       	rjmp	.-166    	; 0x1650 <onIPv4Response+0x28>
  {
    case 0x11:      
	
      onUdpResponse(handle, &header.srcIP);
    16f6:	c8 01       	movw	r24, r16
    16f8:	be 01       	movw	r22, r28
    16fa:	63 5f       	subi	r22, 0xF3	; 243
    16fc:	7f 4f       	sbci	r23, 0xFF	; 255
    16fe:	0e 94 88 0b 	call	0x1710	; 0x1710 <onUdpResponse>
    1702:	a6 cf       	rjmp	.-180    	; 0x1650 <onIPv4Response+0x28>
    // we should not lean the ip address if, its not within our subnet... 
    // ... instead we should update the arp entry for the gateway
    if ((header.srcIP & hIPv4.subnet) == ( hIPv4.gateway & hIPv4.subnet))
      arpAddMacByIPv4(&header.srcIP,source);
    else
      arpAddMacByIPv4(&hIPv4.gateway,source);
    1704:	82 e2       	ldi	r24, 0x22	; 34
    1706:	91 e0       	ldi	r25, 0x01	; 1
    1708:	b7 01       	movw	r22, r14
    170a:	0e 94 93 00 	call	0x126	; 0x126 <arpAddMacByIPv4>
    170e:	ef cf       	rjmp	.-34     	; 0x16ee <onIPv4Response+0xc6>

00001710 <onUdpResponse>:
  onIPv4Request(handle,&(dest->ip),0x11);
  return;
}

void onUdpResponse(struct nicResponseHandle_t* handle, ipAddress_t* ipAddress)
{
    1710:	ef 92       	push	r14
    1712:	ff 92       	push	r15
    1714:	0f 93       	push	r16
    1716:	1f 93       	push	r17
    1718:	df 93       	push	r29
    171a:	cf 93       	push	r28
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	2e 97       	sbiw	r28, 0x0e	; 14
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	8c 01       	movw	r16, r24
    172e:	7b 01       	movw	r14, r22
  // drop if header invalid...
  if (nicResponseSize(handle) < sizeof(struct soUdpHeader_t))
    1730:	0e 94 95 18 	call	0x312a	; 0x312a <nicResponseSize>
    1734:	08 97       	sbiw	r24, 0x08	; 8
    1736:	68 f4       	brcc	.+26     	; 0x1752 <onUdpResponse+0x42>
      onTftpResponse(handle, &netAdr);
      break;
    #endif
  } 
  return;
}
    1738:	2e 96       	adiw	r28, 0x0e	; 14
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	de bf       	out	0x3e, r29	; 62
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	cd bf       	out	0x3d, r28	; 61
    1744:	cf 91       	pop	r28
    1746:	df 91       	pop	r29
    1748:	1f 91       	pop	r17
    174a:	0f 91       	pop	r16
    174c:	ff 90       	pop	r15
    174e:	ef 90       	pop	r14
    1750:	08 95       	ret
  // drop if header invalid...
  if (nicResponseSize(handle) < sizeof(struct soUdpHeader_t))
    return;  
  
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
    1752:	c8 01       	movw	r24, r16
    1754:	be 01       	movw	r22, r28
    1756:	69 5f       	subi	r22, 0xF9	; 249
    1758:	7f 4f       	sbci	r23, 0xFF	; 255
    175a:	48 e0       	ldi	r20, 0x08	; 8
    175c:	50 e0       	ldi	r21, 0x00	; 0
    175e:	0e 94 a0 18 	call	0x3140	; 0x3140 <nicResponseRead>
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
    1762:	f7 01       	movw	r30, r14
    1764:	20 81       	ld	r18, Z
    1766:	31 81       	ldd	r19, Z+1	; 0x01
    1768:	42 81       	ldd	r20, Z+2	; 0x02
    176a:	53 81       	ldd	r21, Z+3	; 0x03
  netAdr.port = ntohs(header.srcPort); 
    176c:	7f 81       	ldd	r23, Y+7	; 0x07
    176e:	68 85       	ldd	r22, Y+8	; 0x08


  
  switch (ntohs(header.destPort))
    1770:	99 85       	ldd	r25, Y+9	; 0x09
    1772:	8a 85       	ldd	r24, Y+10	; 0x0a
    1774:	81 56       	subi	r24, 0x61	; 97
    1776:	9e 41       	sbci	r25, 0x1E	; 30
    1778:	f9 f6       	brne	.-66     	; 0x1738 <onUdpResponse+0x28>
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
  netAdr.port = ntohs(header.srcPort); 
    177a:	6d 83       	std	Y+5, r22	; 0x05
    177c:	7e 83       	std	Y+6, r23	; 0x06
  
  struct soUdpHeader_t header;  
  nicResponseRead(handle,(char*)(&header),sizeof(header));
  
  struct netAddress_t netAdr;
  netAdr.ip = *ipAddress;
    177e:	29 83       	std	Y+1, r18	; 0x01
    1780:	3a 83       	std	Y+2, r19	; 0x02
    1782:	4b 83       	std	Y+3, r20	; 0x03
    1784:	5c 83       	std	Y+4, r21	; 0x04
  {
	

    #ifdef REQUIRES_RTP
    case RTP_SERVER_PORT  : 
      onRtpResponse(handle, &netAdr);
    1786:	c8 01       	movw	r24, r16
    1788:	be 01       	movw	r22, r28
    178a:	6f 5f       	subi	r22, 0xFF	; 255
    178c:	7f 4f       	sbci	r23, 0xFF	; 255
    178e:	0e 94 5d 04 	call	0x8ba	; 0x8ba <onRtpResponse>
    1792:	d2 cf       	rjmp	.-92     	; 0x1738 <onUdpResponse+0x28>

00001794 <onUdpRequest>:



void onUdpRequest(struct nicRequestHandle_t* handle,
    struct netAddress_t* dest, portAddress_t* srcPort)
{
    1794:	af 92       	push	r10
    1796:	bf 92       	push	r11
    1798:	cf 92       	push	r12
    179a:	df 92       	push	r13
    179c:	ef 92       	push	r14
    179e:	ff 92       	push	r15
    17a0:	0f 93       	push	r16
    17a2:	1f 93       	push	r17
    17a4:	6c 01       	movw	r12, r24
    17a6:	5b 01       	movw	r10, r22
    17a8:	7a 01       	movw	r14, r20
  // ...generate the UDP Header...
  struct soUdpHeader_t* header 
     = (struct soUdpHeader_t*)nicAddPacketHeader(handle,sizeof(struct soUdpHeader_t));
    17aa:	68 e0       	ldi	r22, 0x08	; 8
    17ac:	70 e0       	ldi	r23, 0x00	; 0
    17ae:	0e 94 04 19 	call	0x3208	; 0x3208 <nicAddPacketHeader>
    17b2:	8c 01       	movw	r16, r24
  
  header->srcPort  = htons(*srcPort);  
    17b4:	f7 01       	movw	r30, r14
    17b6:	90 81       	ld	r25, Z
    17b8:	81 81       	ldd	r24, Z+1	; 0x01
    17ba:	f8 01       	movw	r30, r16
    17bc:	80 83       	st	Z, r24
    17be:	91 83       	std	Z+1, r25	; 0x01
  header->destPort = htons(dest->port);
    17c0:	f5 01       	movw	r30, r10
    17c2:	94 81       	ldd	r25, Z+4	; 0x04
    17c4:	85 81       	ldd	r24, Z+5	; 0x05
    17c6:	f8 01       	movw	r30, r16
    17c8:	82 83       	std	Z+2, r24	; 0x02
    17ca:	93 83       	std	Z+3, r25	; 0x03
  header->checksum = 0x00;
    17cc:	17 82       	std	Z+7, r1	; 0x07
    17ce:	16 82       	std	Z+6, r1	; 0x06
  header->length   = htons(nicGetPacketSize(handle));
    17d0:	c6 01       	movw	r24, r12
    17d2:	0e 94 86 18 	call	0x310c	; 0x310c <nicGetPacketSize>
    17d6:	f9 2e       	mov	r15, r25
    17d8:	c6 01       	movw	r24, r12
    17da:	0e 94 86 18 	call	0x310c	; 0x310c <nicGetPacketSize>
    17de:	38 2f       	mov	r19, r24
    17e0:	20 e0       	ldi	r18, 0x00	; 0
    17e2:	8f 2d       	mov	r24, r15
    17e4:	90 e0       	ldi	r25, 0x00	; 0
    17e6:	28 2b       	or	r18, r24
    17e8:	39 2b       	or	r19, r25
    17ea:	f8 01       	movw	r30, r16
    17ec:	35 83       	std	Z+5, r19	; 0x05
    17ee:	24 83       	std	Z+4, r18	; 0x04
  
  onIPv4Request(handle,&(dest->ip),0x11);
    17f0:	c6 01       	movw	r24, r12
    17f2:	b5 01       	movw	r22, r10
    17f4:	41 e1       	ldi	r20, 0x11	; 17
    17f6:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <onIPv4Request>
  return;
}
    17fa:	1f 91       	pop	r17
    17fc:	0f 91       	pop	r16
    17fe:	ff 90       	pop	r15
    1800:	ef 90       	pop	r14
    1802:	df 90       	pop	r13
    1804:	cf 90       	pop	r12
    1806:	bf 90       	pop	r11
    1808:	af 90       	pop	r10
    180a:	08 95       	ret

0000180c <serialEepromGetConfig>:

  return;
}

void serialEepromGetConfig(uint16_t * prescaler, uint8_t * parity, uint8_t * stop_bits, uint8_t * data_bits)
{
    180c:	af 92       	push	r10
    180e:	bf 92       	push	r11
    1810:	cf 92       	push	r12
    1812:	df 92       	push	r13
    1814:	ef 92       	push	r14
    1816:	ff 92       	push	r15
    1818:	0f 93       	push	r16
    181a:	1f 93       	push	r17
    181c:	df 93       	push	r29
    181e:	cf 93       	push	r28
    1820:	00 d0       	rcall	.+0      	; 0x1822 <serialEepromGetConfig+0x16>
    1822:	00 d0       	rcall	.+0      	; 0x1824 <serialEepromGetConfig+0x18>
    1824:	00 d0       	rcall	.+0      	; 0x1826 <serialEepromGetConfig+0x1a>
    1826:	cd b7       	in	r28, 0x3d	; 61
    1828:	de b7       	in	r29, 0x3e	; 62
    182a:	8c 01       	movw	r16, r24
    182c:	7b 01       	movw	r14, r22
    182e:	6a 01       	movw	r12, r20
    1830:	59 01       	movw	r10, r18
  serialEeprom_t buf;
  if ( !EepromReadConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf)) ) {
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	93 e0       	ldi	r25, 0x03	; 3
    1836:	be 01       	movw	r22, r28
    1838:	6f 5f       	subi	r22, 0xFF	; 255
    183a:	7f 4f       	sbci	r23, 0xFF	; 255
    183c:	46 e0       	ldi	r20, 0x06	; 6
    183e:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
    1842:	88 23       	and	r24, r24
    1844:	79 f4       	brne	.+30     	; 0x1864 <serialEepromGetConfig+0x58>
    // return fallback settings, if eeprom data is invalid
    buf.prescaler 	= serialSettings.prescaler;
    1846:	80 91 2c 01 	lds	r24, 0x012C
    184a:	90 91 2d 01 	lds	r25, 0x012D
    184e:	9a 83       	std	Y+2, r25	; 0x02
    1850:	89 83       	std	Y+1, r24	; 0x01
   	buf.parity  	= serialSettings.parity;
    1852:	80 91 2e 01 	lds	r24, 0x012E
    1856:	8b 83       	std	Y+3, r24	; 0x03
	buf.stop_bits 	= serialSettings.stop_bits;
    1858:	80 91 2f 01 	lds	r24, 0x012F
    185c:	8c 83       	std	Y+4, r24	; 0x04
    buf.data_bits  	= serialSettings.data_bits;
    185e:	80 91 30 01 	lds	r24, 0x0130
    1862:	8d 83       	std	Y+5, r24	; 0x05
  }

  // BAUD = CLOCK_FREQUENCY / (16 * (UBBR + 1))
  //      = (CLOCK_FREQUENCY / 16) / (UBBR + 1)
  *prescaler=buf.prescaler;
    1864:	89 81       	ldd	r24, Y+1	; 0x01
    1866:	9a 81       	ldd	r25, Y+2	; 0x02
    1868:	f8 01       	movw	r30, r16
    186a:	91 83       	std	Z+1, r25	; 0x01
    186c:	80 83       	st	Z, r24
  *parity=buf.parity;
    186e:	8b 81       	ldd	r24, Y+3	; 0x03
    1870:	f7 01       	movw	r30, r14
    1872:	80 83       	st	Z, r24
  *stop_bits=buf.stop_bits;
    1874:	8c 81       	ldd	r24, Y+4	; 0x04
    1876:	f6 01       	movw	r30, r12
    1878:	80 83       	st	Z, r24
  *data_bits=buf.data_bits;
    187a:	8d 81       	ldd	r24, Y+5	; 0x05
    187c:	f5 01       	movw	r30, r10
    187e:	80 83       	st	Z, r24

}
    1880:	26 96       	adiw	r28, 0x06	; 6
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	de bf       	out	0x3e, r29	; 62
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	cd bf       	out	0x3d, r28	; 61
    188c:	cf 91       	pop	r28
    188e:	df 91       	pop	r29
    1890:	1f 91       	pop	r17
    1892:	0f 91       	pop	r16
    1894:	ff 90       	pop	r15
    1896:	ef 90       	pop	r14
    1898:	df 90       	pop	r13
    189a:	cf 90       	pop	r12
    189c:	bf 90       	pop	r11
    189e:	af 90       	pop	r10
    18a0:	08 95       	ret

000018a2 <serialEepromSetConfig>:
}

#ifdef REQUIRES_RCFG

void serialEepromSetConfig(uint16_t prescaler, uint8_t parity, uint8_t stop_bits, uint8_t data_bits)
{
    18a2:	bf 92       	push	r11
    18a4:	cf 92       	push	r12
    18a6:	df 92       	push	r13
    18a8:	ef 92       	push	r14
    18aa:	ff 92       	push	r15
    18ac:	0f 93       	push	r16
    18ae:	1f 93       	push	r17
    18b0:	df 93       	push	r29
    18b2:	cf 93       	push	r28
    18b4:	00 d0       	rcall	.+0      	; 0x18b6 <serialEepromSetConfig+0x14>
    18b6:	00 d0       	rcall	.+0      	; 0x18b8 <serialEepromSetConfig+0x16>
    18b8:	00 d0       	rcall	.+0      	; 0x18ba <serialEepromSetConfig+0x18>
    18ba:	cd b7       	in	r28, 0x3d	; 61
    18bc:	de b7       	in	r29, 0x3e	; 62
    18be:	8c 01       	movw	r16, r24
    18c0:	d6 2e       	mov	r13, r22
    18c2:	c4 2e       	mov	r12, r20
    18c4:	b2 2e       	mov	r11, r18
  serialEeprom_t buf;
  if ( !EepromReadConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf)) ) {
    18c6:	80 e0       	ldi	r24, 0x00	; 0
    18c8:	93 e0       	ldi	r25, 0x03	; 3
    18ca:	7e 01       	movw	r14, r28
    18cc:	08 94       	sec
    18ce:	e1 1c       	adc	r14, r1
    18d0:	f1 1c       	adc	r15, r1
    18d2:	b7 01       	movw	r22, r14
    18d4:	46 e0       	ldi	r20, 0x06	; 6
    18d6:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
	buf.stop_bits 	= serialSettings.stop_bits;
    buf.data_bits  	= serialSettings.data_bits;
  }


	buf.prescaler 	= prescaler;
    18da:	1a 83       	std	Y+2, r17	; 0x02
    18dc:	09 83       	std	Y+1, r16	; 0x01
	buf.parity  	= parity;
    18de:	db 82       	std	Y+3, r13	; 0x03
	buf.stop_bits 	= stop_bits;
    18e0:	cc 82       	std	Y+4, r12	; 0x04
	buf.data_bits  	= data_bits;
    18e2:	bd 82       	std	Y+5, r11	; 0x05

  EepromWriteConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf));
    18e4:	80 e0       	ldi	r24, 0x00	; 0
    18e6:	93 e0       	ldi	r25, 0x03	; 3
    18e8:	b7 01       	movw	r22, r14
    18ea:	46 e0       	ldi	r20, 0x06	; 6
    18ec:	0e 94 38 29 	call	0x5270	; 0x5270 <EepromWriteConfig>

  return;
}
    18f0:	26 96       	adiw	r28, 0x06	; 6
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	f8 94       	cli
    18f6:	de bf       	out	0x3e, r29	; 62
    18f8:	0f be       	out	0x3f, r0	; 63
    18fa:	cd bf       	out	0x3d, r28	; 61
    18fc:	cf 91       	pop	r28
    18fe:	df 91       	pop	r29
    1900:	1f 91       	pop	r17
    1902:	0f 91       	pop	r16
    1904:	ff 90       	pop	r15
    1906:	ef 90       	pop	r14
    1908:	df 90       	pop	r13
    190a:	cf 90       	pop	r12
    190c:	bf 90       	pop	r11
    190e:	08 95       	ret

00001910 <onSerial>:


}
  
void onSerial()
{ 
    1910:	df 93       	push	r29
    1912:	cf 93       	push	r28
    1914:	00 d0       	rcall	.+0      	; 0x1916 <onSerial+0x6>
    1916:	0f 92       	push	r0
    1918:	cd b7       	in	r28, 0x3d	; 61
    191a:	de b7       	in	r29, 0x3e	; 62


  if(CommandBuffer.NewCommand==1)
    191c:	80 91 60 09 	lds	r24, 0x0960
    1920:	81 30       	cpi	r24, 0x01	; 1
    1922:	e9 f0       	breq	.+58     	; 0x195e <onSerial+0x4e>
  	CommandBuffer.NewCommand=0;
	onRtpControl(CommandBuffer.recvCommand, CommandBuffer.len);	
  }


  if (com0HasBytes() == 0)
    1924:	0e 94 cf 10 	call	0x219e	; 0x219e <com0HasBytes>
    1928:	88 23       	and	r24, r24
    192a:	99 f0       	breq	.+38     	; 0x1952 <onSerial+0x42>
    return;
       
  
  char* buf = NULL;
    192c:	1b 82       	std	Y+3, r1	; 0x03
    192e:	1a 82       	std	Y+2, r1	; 0x02
  uint8_t len = 0;
    1930:	19 82       	std	Y+1, r1	; 0x01
    
  com0RecvBytes(&buf,&len); 
    1932:	ce 01       	movw	r24, r28
    1934:	02 96       	adiw	r24, 0x02	; 2
    1936:	be 01       	movw	r22, r28
    1938:	6f 5f       	subi	r22, 0xFF	; 255
    193a:	7f 4f       	sbci	r23, 0xFF	; 255
    193c:	0e 94 0f 11 	call	0x221e	; 0x221e <com0RecvBytes>
  
   
  onSerialData(buf,len);
    1940:	8a 81       	ldd	r24, Y+2	; 0x02
    1942:	9b 81       	ldd	r25, Y+3	; 0x03
    1944:	69 81       	ldd	r22, Y+1	; 0x01
    1946:	0e 94 8b 1a 	call	0x3516	; 0x3516 <onSerialData>
    
  free(buf);
    194a:	8a 81       	ldd	r24, Y+2	; 0x02
    194c:	9b 81       	ldd	r25, Y+3	; 0x03
    194e:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>


  return;
}
    1952:	0f 90       	pop	r0
    1954:	0f 90       	pop	r0
    1956:	0f 90       	pop	r0
    1958:	cf 91       	pop	r28
    195a:	df 91       	pop	r29
    195c:	08 95       	ret
{ 


  if(CommandBuffer.NewCommand==1)
  {
  	CommandBuffer.NewCommand=0;
    195e:	10 92 60 09 	sts	0x0960, r1
	onRtpControl(CommandBuffer.recvCommand, CommandBuffer.len);	
    1962:	88 e3       	ldi	r24, 0x38	; 56
    1964:	99 e0       	ldi	r25, 0x09	; 9
    1966:	60 91 61 09 	lds	r22, 0x0961
    196a:	0e 94 43 28 	call	0x5086	; 0x5086 <onRtpControl>
    196e:	da cf       	rjmp	.-76     	; 0x1924 <onSerial+0x14>

00001970 <serialSendBytes>:
void serialSendBytes(char* buf, uint8_t len)
{


  //com0SendBytes(buf,len);
  com0putBuffer(buf, len);
    1970:	0e 94 bb 10 	call	0x2176	; 0x2176 <com0putBuffer>


}
    1974:	08 95       	ret

00001976 <onInitSerial>:




void onInitSerial()
{
    1976:	df 93       	push	r29
    1978:	cf 93       	push	r28
    197a:	00 d0       	rcall	.+0      	; 0x197c <onInitSerial+0x6>
    197c:	00 d0       	rcall	.+0      	; 0x197e <onInitSerial+0x8>
    197e:	00 d0       	rcall	.+0      	; 0x1980 <onInitSerial+0xa>
    1980:	cd b7       	in	r28, 0x3d	; 61
    1982:	de b7       	in	r29, 0x3e	; 62
  // define a struct for the configuration...
  serialEeprom_t buf;

  // use eeprom settings if they are valid
  if ( EepromReadConfig((void*)SERIAL_EEPROM, &buf, sizeof(buf)) ) {
    1984:	80 e0       	ldi	r24, 0x00	; 0
    1986:	93 e0       	ldi	r25, 0x03	; 3
    1988:	be 01       	movw	r22, r28
    198a:	6f 5f       	subi	r22, 0xFF	; 255
    198c:	7f 4f       	sbci	r23, 0xFF	; 255
    198e:	46 e0       	ldi	r20, 0x06	; 6
    1990:	0e 94 77 29 	call	0x52ee	; 0x52ee <EepromReadConfig>
    1994:	88 23       	and	r24, r24
    1996:	79 f0       	breq	.+30     	; 0x19b6 <onInitSerial+0x40>
    serialSettings.prescaler 	= buf.prescaler;
    1998:	89 81       	ldd	r24, Y+1	; 0x01
    199a:	9a 81       	ldd	r25, Y+2	; 0x02
    199c:	90 93 2d 01 	sts	0x012D, r25
    19a0:	80 93 2c 01 	sts	0x012C, r24
    serialSettings.parity  		= buf.parity;
    19a4:	8b 81       	ldd	r24, Y+3	; 0x03
    19a6:	80 93 2e 01 	sts	0x012E, r24
	serialSettings.stop_bits 	= buf.stop_bits;
    19aa:	8c 81       	ldd	r24, Y+4	; 0x04
    19ac:	80 93 2f 01 	sts	0x012F, r24
    serialSettings.data_bits  	= buf.data_bits;
    19b0:	8d 81       	ldd	r24, Y+5	; 0x05
    19b2:	80 93 30 01 	sts	0x0130, r24
  }
  // else serialSettings keeps the fallback settings

  // bitrate parity stop bits
  //com0Initialize(serialSettings.prescaler,serialSettings.settings);  //old one
  com0Initialize(serialSettings.prescaler,serialSettings.parity,serialSettings.stop_bits,serialSettings.data_bits);
    19b6:	80 91 2c 01 	lds	r24, 0x012C
    19ba:	90 91 2d 01 	lds	r25, 0x012D
    19be:	60 91 2e 01 	lds	r22, 0x012E
    19c2:	40 91 2f 01 	lds	r20, 0x012F
    19c6:	20 91 30 01 	lds	r18, 0x0130
    19ca:	0e 94 3a 11 	call	0x2274	; 0x2274 <com0Initialize>
  com1Initialize(0,0);
    19ce:	80 e0       	ldi	r24, 0x00	; 0
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	60 e0       	ldi	r22, 0x00	; 0
    19d4:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <com1Initialize>
  return;
}
    19d8:	26 96       	adiw	r28, 0x06	; 6
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	f8 94       	cli
    19de:	de bf       	out	0x3e, r29	; 62
    19e0:	0f be       	out	0x3f, r0	; 63
    19e2:	cd bf       	out	0x3d, r28	; 61
    19e4:	cf 91       	pop	r28
    19e6:	df 91       	pop	r29
    19e8:	08 95       	ret

000019ea <onInitClock>:
  return rtcGetTime32();
}

void onInitClock()
{
  rtcInitialize();
    19ea:	0e 94 50 10 	call	0x20a0	; 0x20a0 <rtcInitialize>
  return;
}
    19ee:	08 95       	ret

000019f0 <clockGetShortTimeStamp>:
  return rtcGetTime64();
}

uint32_t clockGetShortTimeStamp()
{
  return rtcGetTime32();
    19f0:	0e 94 94 10 	call	0x2128	; 0x2128 <rtcGetTime32>
}
    19f4:	08 95       	ret

000019f6 <clockGetTimeStamp>:
#include "./../../hal/rtc/rtc.h"
#include "./clock.h"

uint64_t clockGetTimeStamp()
{
  return rtcGetTime64();
    19f6:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <rtcGetTime64>
}
    19fa:	08 95       	ret

000019fc <onInitTimer>:
}

void onInitTimer()
{
  // Initalize Scheduler
  timerList.firstNode = NULL;
    19fc:	10 92 22 08 	sts	0x0822, r1
    1a00:	10 92 21 08 	sts	0x0821, r1
  timerList.lastNode = NULL;
    1a04:	10 92 24 08 	sts	0x0824, r1
    1a08:	10 92 23 08 	sts	0x0823, r1
}
    1a0c:	08 95       	ret

00001a0e <timerClearTimeout>:


// after any timeout or calling this function it is essential to NULL 
// the element variable
void timerClearTimeout(struct timerElement_t* element)
{
    1a0e:	0f 93       	push	r16
    1a10:	1f 93       	push	r17
    1a12:	8c 01       	movw	r16, r24
    
  removeDlNode(&timerList,(struct dlNode_t*)element);
    1a14:	81 e2       	ldi	r24, 0x21	; 33
    1a16:	98 e0       	ldi	r25, 0x08	; 8
    1a18:	b8 01       	movw	r22, r16
    1a1a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <removeDlNode>
  free(element);
    1a1e:	c8 01       	movw	r24, r16
    1a20:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
}
    1a24:	1f 91       	pop	r17
    1a26:	0f 91       	pop	r16
    1a28:	08 95       	ret

00001a2a <timerAddTimeout>:
// which is damm close to 1000ms


struct timerElement_t* timerAddTimeout(uint16_t delay, 
    void (*callback)())
{
    1a2a:	8f 92       	push	r8
    1a2c:	9f 92       	push	r9
    1a2e:	af 92       	push	r10
    1a30:	bf 92       	push	r11
    1a32:	cf 92       	push	r12
    1a34:	df 92       	push	r13
    1a36:	ef 92       	push	r14
    1a38:	ff 92       	push	r15
    1a3a:	0f 93       	push	r16
    1a3c:	1f 93       	push	r17
    1a3e:	cf 93       	push	r28
    1a40:	df 93       	push	r29
    1a42:	8c 01       	movw	r16, r24
    1a44:	4b 01       	movw	r8, r22


  struct timerElement_t* newNode
    = (struct timerElement_t*) malloc(sizeof(struct timerElement_t));
    1a46:	8e e0       	ldi	r24, 0x0E	; 14
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    1a4e:	ec 01       	movw	r28, r24


	//alx free --> timerClearTimeout
  
  // timestamp = now(in ms) + delay
  newNode->timebomb = clockGetTimeStamp()+delay;
    1a50:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <clockGetTimeStamp>
    1a54:	f4 2e       	mov	r15, r20
    1a56:	e5 2e       	mov	r14, r21
    1a58:	d6 2e       	mov	r13, r22
    1a5a:	c7 2e       	mov	r12, r23
    1a5c:	b8 2e       	mov	r11, r24
    1a5e:	a9 2e       	mov	r10, r25
    1a60:	a8 01       	movw	r20, r16
    1a62:	12 2f       	mov	r17, r18
    1a64:	14 0f       	add	r17, r20
    1a66:	f1 e0       	ldi	r31, 0x01	; 1
    1a68:	12 17       	cp	r17, r18
    1a6a:	08 f0       	brcs	.+2      	; 0x1a6e <timerAddTimeout+0x44>
    1a6c:	f0 e0       	ldi	r31, 0x00	; 0
    1a6e:	03 2f       	mov	r16, r19
    1a70:	05 0f       	add	r16, r21
    1a72:	e1 e0       	ldi	r30, 0x01	; 1
    1a74:	03 17       	cp	r16, r19
    1a76:	08 f0       	brcs	.+2      	; 0x1a7a <timerAddTimeout+0x50>
    1a78:	e0 e0       	ldi	r30, 0x00	; 0
    1a7a:	7f 2f       	mov	r23, r31
    1a7c:	70 0f       	add	r23, r16
    1a7e:	21 e0       	ldi	r18, 0x01	; 1
    1a80:	70 17       	cp	r23, r16
    1a82:	08 f0       	brcs	.+2      	; 0x1a86 <timerAddTimeout+0x5c>
    1a84:	20 e0       	ldi	r18, 0x00	; 0
    1a86:	3e 2f       	mov	r19, r30
    1a88:	32 2b       	or	r19, r18
    1a8a:	3f 0d       	add	r19, r15
    1a8c:	21 e0       	ldi	r18, 0x01	; 1
    1a8e:	3f 15       	cp	r19, r15
    1a90:	08 f0       	brcs	.+2      	; 0x1a94 <timerAddTimeout+0x6a>
    1a92:	20 e0       	ldi	r18, 0x00	; 0
    1a94:	62 2f       	mov	r22, r18
    1a96:	6e 0d       	add	r22, r14
    1a98:	21 e0       	ldi	r18, 0x01	; 1
    1a9a:	6e 15       	cp	r22, r14
    1a9c:	08 f0       	brcs	.+2      	; 0x1aa0 <timerAddTimeout+0x76>
    1a9e:	20 e0       	ldi	r18, 0x00	; 0
    1aa0:	52 2f       	mov	r21, r18
    1aa2:	5d 0d       	add	r21, r13
    1aa4:	21 e0       	ldi	r18, 0x01	; 1
    1aa6:	5d 15       	cp	r21, r13
    1aa8:	08 f0       	brcs	.+2      	; 0x1aac <timerAddTimeout+0x82>
    1aaa:	20 e0       	ldi	r18, 0x00	; 0
    1aac:	42 2f       	mov	r20, r18
    1aae:	4c 0d       	add	r20, r12
    1ab0:	21 e0       	ldi	r18, 0x01	; 1
    1ab2:	4c 15       	cp	r20, r12
    1ab4:	08 f0       	brcs	.+2      	; 0x1ab8 <timerAddTimeout+0x8e>
    1ab6:	20 e0       	ldi	r18, 0x00	; 0
    1ab8:	2b 0d       	add	r18, r11
    1aba:	91 e0       	ldi	r25, 0x01	; 1
    1abc:	2b 15       	cp	r18, r11
    1abe:	08 f0       	brcs	.+2      	; 0x1ac2 <timerAddTimeout+0x98>
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	9a 0d       	add	r25, r10
    1ac4:	1c 83       	std	Y+4, r17	; 0x04
    1ac6:	7d 83       	std	Y+5, r23	; 0x05
    1ac8:	3e 83       	std	Y+6, r19	; 0x06
    1aca:	6f 83       	std	Y+7, r22	; 0x07
    1acc:	58 87       	std	Y+8, r21	; 0x08
    1ace:	49 87       	std	Y+9, r20	; 0x09
    1ad0:	2a 87       	std	Y+10, r18	; 0x0a
    1ad2:	9b 87       	std	Y+11, r25	; 0x0b
  newNode->callback = callback;
    1ad4:	9d 86       	std	Y+13, r9	; 0x0d
    1ad6:	8c 86       	std	Y+12, r8	; 0x0c
 
  // If the list is empty, we can do a shortcut...
  if (timerList.firstNode == NULL)
    1ad8:	e0 91 21 08 	lds	r30, 0x0821
    1adc:	f0 91 22 08 	lds	r31, 0x0822
    1ae0:	30 97       	sbiw	r30, 0x00	; 0
    1ae2:	09 f4       	brne	.+2      	; 0x1ae6 <timerAddTimeout+0xbc>
    1ae4:	47 c0       	rjmp	.+142    	; 0x1b74 <timerAddTimeout+0x14a>
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
  {
    if (((struct timerElement_t*)node)->timebomb > newNode->timebomb)
    1ae6:	83 85       	ldd	r24, Z+11	; 0x0b
    1ae8:	98 17       	cp	r25, r24
    1aea:	a0 f4       	brcc	.+40     	; 0x1b14 <timerAddTimeout+0xea>
    return newNode;
  }
  


  insertDlNodeBefore(&timerList,node,(struct dlNode_t*)newNode);
    1aec:	81 e2       	ldi	r24, 0x21	; 33
    1aee:	98 e0       	ldi	r25, 0x08	; 8
    1af0:	bf 01       	movw	r22, r30
    1af2:	ae 01       	movw	r20, r28
    1af4:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <insertDlNodeBefore>

 
  return newNode;  
  
    
}
    1af8:	ce 01       	movw	r24, r28
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	ff 90       	pop	r15
    1b04:	ef 90       	pop	r14
    1b06:	df 90       	pop	r13
    1b08:	cf 90       	pop	r12
    1b0a:	bf 90       	pop	r11
    1b0c:	af 90       	pop	r10
    1b0e:	9f 90       	pop	r9
    1b10:	8f 90       	pop	r8
    1b12:	08 95       	ret
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
  {
    if (((struct timerElement_t*)node)->timebomb > newNode->timebomb)
    1b14:	89 17       	cp	r24, r25
    1b16:	59 f0       	breq	.+22     	; 0x1b2e <timerAddTimeout+0x104>
      break;
    node = node->next;
    1b18:	02 80       	ldd	r0, Z+2	; 0x02
    1b1a:	f3 81       	ldd	r31, Z+3	; 0x03
    1b1c:	e0 2d       	mov	r30, r0

  // ... otherise we have to add the entry into the sorted list
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
    1b1e:	30 97       	sbiw	r30, 0x00	; 0
    1b20:	11 f7       	brne	.-60     	; 0x1ae6 <timerAddTimeout+0xbc>

  
  // We reached the end of the list without a hit?
  if (node == NULL)
  {
    insertDlNodeLast(&timerList,(struct dlNode_t*)newNode);    
    1b22:	81 e2       	ldi	r24, 0x21	; 33
    1b24:	98 e0       	ldi	r25, 0x08	; 8
    1b26:	be 01       	movw	r22, r28
    1b28:	0e 94 75 0f 	call	0x1eea	; 0x1eea <insertDlNodeLast>
    1b2c:	e5 cf       	rjmp	.-54     	; 0x1af8 <timerAddTimeout+0xce>
  // ... therefore we compare the timestamp...
  struct dlNode_t* node = timerList.firstNode;
 
  while (node != NULL)
  {
    if (((struct timerElement_t*)node)->timebomb > newNode->timebomb)
    1b2e:	82 85       	ldd	r24, Z+10	; 0x0a
    1b30:	28 17       	cp	r18, r24
    1b32:	e0 f2       	brcs	.-72     	; 0x1aec <timerAddTimeout+0xc2>
    1b34:	82 17       	cp	r24, r18
    1b36:	81 f7       	brne	.-32     	; 0x1b18 <timerAddTimeout+0xee>
    1b38:	81 85       	ldd	r24, Z+9	; 0x09
    1b3a:	48 17       	cp	r20, r24
    1b3c:	b8 f2       	brcs	.-82     	; 0x1aec <timerAddTimeout+0xc2>
    1b3e:	84 17       	cp	r24, r20
    1b40:	59 f7       	brne	.-42     	; 0x1b18 <timerAddTimeout+0xee>
    1b42:	80 85       	ldd	r24, Z+8	; 0x08
    1b44:	58 17       	cp	r21, r24
    1b46:	90 f2       	brcs	.-92     	; 0x1aec <timerAddTimeout+0xc2>
    1b48:	85 17       	cp	r24, r21
    1b4a:	31 f7       	brne	.-52     	; 0x1b18 <timerAddTimeout+0xee>
    1b4c:	87 81       	ldd	r24, Z+7	; 0x07
    1b4e:	68 17       	cp	r22, r24
    1b50:	68 f2       	brcs	.-102    	; 0x1aec <timerAddTimeout+0xc2>
    1b52:	86 17       	cp	r24, r22
    1b54:	09 f7       	brne	.-62     	; 0x1b18 <timerAddTimeout+0xee>
    1b56:	86 81       	ldd	r24, Z+6	; 0x06
    1b58:	38 17       	cp	r19, r24
    1b5a:	40 f2       	brcs	.-112    	; 0x1aec <timerAddTimeout+0xc2>
    1b5c:	83 17       	cp	r24, r19
    1b5e:	e1 f6       	brne	.-72     	; 0x1b18 <timerAddTimeout+0xee>
    1b60:	85 81       	ldd	r24, Z+5	; 0x05
    1b62:	78 17       	cp	r23, r24
    1b64:	18 f2       	brcs	.-122    	; 0x1aec <timerAddTimeout+0xc2>
    1b66:	87 17       	cp	r24, r23
    1b68:	b9 f6       	brne	.-82     	; 0x1b18 <timerAddTimeout+0xee>
    1b6a:	84 81       	ldd	r24, Z+4	; 0x04
    1b6c:	18 17       	cp	r17, r24
    1b6e:	08 f4       	brcc	.+2      	; 0x1b72 <timerAddTimeout+0x148>
    1b70:	bd cf       	rjmp	.-134    	; 0x1aec <timerAddTimeout+0xc2>
    1b72:	d2 cf       	rjmp	.-92     	; 0x1b18 <timerAddTimeout+0xee>
  newNode->callback = callback;
 
  // If the list is empty, we can do a shortcut...
  if (timerList.firstNode == NULL)
  {
    insertDlNodeBeginning(&timerList,(struct dlNode_t*)newNode);    
    1b74:	81 e2       	ldi	r24, 0x21	; 33
    1b76:	98 e0       	ldi	r25, 0x08	; 8
    1b78:	be 01       	movw	r22, r28
    1b7a:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <insertDlNodeBeginning>
    1b7e:	bc cf       	rjmp	.-136    	; 0x1af8 <timerAddTimeout+0xce>

00001b80 <onTimer>:
  free(element);
}


void onTimer()
{
    1b80:	af 92       	push	r10
    1b82:	bf 92       	push	r11
    1b84:	cf 92       	push	r12
    1b86:	df 92       	push	r13
    1b88:	ef 92       	push	r14
    1b8a:	ff 92       	push	r15
    1b8c:	0f 93       	push	r16
    1b8e:	1f 93       	push	r17
  if (timerList.firstNode == NULL)
    1b90:	e0 91 21 08 	lds	r30, 0x0821
    1b94:	f0 91 22 08 	lds	r31, 0x0822
    1b98:	30 97       	sbiw	r30, 0x00	; 0
    1b9a:	f9 f0       	breq	.+62     	; 0x1bda <onTimer+0x5a>
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1b9c:	a4 80       	ldd	r10, Z+4	; 0x04
    1b9e:	b5 80       	ldd	r11, Z+5	; 0x05
    1ba0:	c6 80       	ldd	r12, Z+6	; 0x06
    1ba2:	d7 80       	ldd	r13, Z+7	; 0x07
    1ba4:	f0 84       	ldd	r15, Z+8	; 0x08
    1ba6:	11 85       	ldd	r17, Z+9	; 0x09
    1ba8:	e2 84       	ldd	r14, Z+10	; 0x0a
    1baa:	03 85       	ldd	r16, Z+11	; 0x0b
    1bac:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <clockGetTimeStamp>
    1bb0:	90 17       	cp	r25, r16
    1bb2:	98 f0       	brcs	.+38     	; 0x1bda <onTimer+0x5a>
    1bb4:	09 17       	cp	r16, r25
    1bb6:	d1 f0       	breq	.+52     	; 0x1bec <onTimer+0x6c>
//	putString("\r\nAUSGELOESSSST:");
  
  
  // we need to remove the obsolete timer entry...
  // ... before we do the callback!
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
    1bb8:	60 91 21 08 	lds	r22, 0x0821
    1bbc:	70 91 22 08 	lds	r23, 0x0822
    1bc0:	8b 01       	movw	r16, r22
    1bc2:	f8 01       	movw	r30, r16
    1bc4:	e4 84       	ldd	r14, Z+12	; 0x0c
    1bc6:	f5 84       	ldd	r15, Z+13	; 0x0d
// after any timeout or calling this function it is essential to NULL 
// the element variable
void timerClearTimeout(struct timerElement_t* element)
{
    
  removeDlNode(&timerList,(struct dlNode_t*)element);
    1bc8:	81 e2       	ldi	r24, 0x21	; 33
    1bca:	98 e0       	ldi	r25, 0x08	; 8
    1bcc:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <removeDlNode>
  free(element);
    1bd0:	c8 01       	movw	r24, r16
    1bd2:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
  timerClearTimeout(((struct timerElement_t*)(timerList.firstNode)));
  
  // as the entry is removed, we have to use...
  // ...our temporary variable to do the callback
  ((void(*) ()) (callback)) ();
    1bd6:	f7 01       	movw	r30, r14
    1bd8:	09 95       	icall
  
  return; 
}
    1bda:	1f 91       	pop	r17
    1bdc:	0f 91       	pop	r16
    1bde:	ff 90       	pop	r15
    1be0:	ef 90       	pop	r14
    1be2:	df 90       	pop	r13
    1be4:	cf 90       	pop	r12
    1be6:	bf 90       	pop	r11
    1be8:	af 90       	pop	r10
    1bea:	08 95       	ret
void onTimer()
{
  if (timerList.firstNode == NULL)
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1bec:	8e 15       	cp	r24, r14
    1bee:	a8 f3       	brcs	.-22     	; 0x1bda <onTimer+0x5a>
    1bf0:	e8 16       	cp	r14, r24
    1bf2:	11 f7       	brne	.-60     	; 0x1bb8 <onTimer+0x38>
    1bf4:	71 17       	cp	r23, r17
    1bf6:	88 f3       	brcs	.-30     	; 0x1bda <onTimer+0x5a>
    1bf8:	17 17       	cp	r17, r23
    1bfa:	f1 f6       	brne	.-68     	; 0x1bb8 <onTimer+0x38>
    1bfc:	6f 15       	cp	r22, r15
    1bfe:	68 f3       	brcs	.-38     	; 0x1bda <onTimer+0x5a>
    1c00:	f6 16       	cp	r15, r22
    1c02:	d1 f6       	brne	.-76     	; 0x1bb8 <onTimer+0x38>
    1c04:	5d 15       	cp	r21, r13
    1c06:	48 f3       	brcs	.-46     	; 0x1bda <onTimer+0x5a>
    1c08:	d5 16       	cp	r13, r21
    1c0a:	b1 f6       	brne	.-84     	; 0x1bb8 <onTimer+0x38>
    1c0c:	4c 15       	cp	r20, r12
    1c0e:	28 f3       	brcs	.-54     	; 0x1bda <onTimer+0x5a>
    1c10:	c4 16       	cp	r12, r20
    1c12:	91 f6       	brne	.-92     	; 0x1bb8 <onTimer+0x38>
    1c14:	3b 15       	cp	r19, r11
    1c16:	08 f3       	brcs	.-62     	; 0x1bda <onTimer+0x5a>
    1c18:	b3 16       	cp	r11, r19
    1c1a:	71 f6       	brne	.-100    	; 0x1bb8 <onTimer+0x38>
    1c1c:	2a 15       	cp	r18, r10
    1c1e:	e8 f2       	brcs	.-70     	; 0x1bda <onTimer+0x5a>
    1c20:	cb cf       	rjmp	.-106    	; 0x1bb8 <onTimer+0x38>

00001c22 <DebugTimerList>:
    
}


void DebugTimerList()
{
    1c22:	9f 92       	push	r9
    1c24:	af 92       	push	r10
    1c26:	bf 92       	push	r11
    1c28:	cf 92       	push	r12
    1c2a:	df 92       	push	r13
    1c2c:	ef 92       	push	r14
    1c2e:	ff 92       	push	r15
    1c30:	0f 93       	push	r16
    1c32:	1f 93       	push	r17
    1c34:	cf 93       	push	r28
    1c36:	df 93       	push	r29


// If the list is empty, we can do a shortcut...
	if (timerList.firstNode == NULL)
    1c38:	c0 91 21 08 	lds	r28, 0x0821
    1c3c:	d0 91 22 08 	lds	r29, 0x0822
    1c40:	20 97       	sbiw	r28, 0x00	; 0
    1c42:	09 f4       	brne	.+2      	; 0x1c46 <DebugTimerList+0x24>
    1c44:	8b c0       	rjmp	.+278    	; 0x1d5c <DebugTimerList+0x13a>

	else
	{
		struct dlNode_t* node = timerList.firstNode;
		uint8_t anzahlTimer=0;
		char *x1=malloc(16);
    1c46:	80 e1       	ldi	r24, 0x10	; 16
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    1c4e:	8c 01       	movw	r16, r24
		itoa(clockGetTimeStamp(),x1,10);
    1c50:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <clockGetTimeStamp>
    1c54:	c9 01       	movw	r24, r18
    1c56:	b8 01       	movw	r22, r16
    1c58:	4a e0       	ldi	r20, 0x0A	; 10
    1c5a:	50 e0       	ldi	r21, 0x00	; 0
    1c5c:	0e 94 93 2e 	call	0x5d26	; 0x5d26 <itoa>

		putString("\r\nclockGetTimeStamp:");
    1c60:	86 e4       	ldi	r24, 0x46	; 70
    1c62:	91 e0       	ldi	r25, 0x01	; 1
    1c64:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
		putString(x1);
    1c68:	c8 01       	movw	r24, r16
    1c6a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    1c6e:	dd 24       	eor	r13, r13
 
		while (node != NULL)
		{	    
			anzahlTimer+=1;
    1c70:	d3 94       	inc	r13

			
			itoa(((struct timerElement_t*)node)->timebomb,x1,10);
    1c72:	8c 81       	ldd	r24, Y+4	; 0x04
    1c74:	9d 81       	ldd	r25, Y+5	; 0x05
    1c76:	b8 01       	movw	r22, r16
    1c78:	4a e0       	ldi	r20, 0x0A	; 10
    1c7a:	50 e0       	ldi	r21, 0x00	; 0
    1c7c:	0e 94 93 2e 	call	0x5d26	; 0x5d26 <itoa>
			putString("\r\nTB:");
    1c80:	8b e5       	ldi	r24, 0x5B	; 91
    1c82:	91 e0       	ldi	r25, 0x01	; 1
    1c84:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
			putString(x1);
    1c88:	c8 01       	movw	r24, r16
    1c8a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
			node = node->next;
    1c8e:	0a 80       	ldd	r0, Y+2	; 0x02
    1c90:	db 81       	ldd	r29, Y+3	; 0x03
    1c92:	c0 2d       	mov	r28, r0
		itoa(clockGetTimeStamp(),x1,10);

		putString("\r\nclockGetTimeStamp:");
		putString(x1);
 
		while (node != NULL)
    1c94:	20 97       	sbiw	r28, 0x00	; 0
    1c96:	61 f7       	brne	.-40     	; 0x1c70 <DebugTimerList+0x4e>
			putString(x1);
			node = node->next;
			
		}

		if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1c98:	e0 91 21 08 	lds	r30, 0x0821
    1c9c:	f0 91 22 08 	lds	r31, 0x0822
    1ca0:	94 80       	ldd	r9, Z+4	; 0x04
    1ca2:	a5 80       	ldd	r10, Z+5	; 0x05
    1ca4:	b6 80       	ldd	r11, Z+6	; 0x06
    1ca6:	c7 80       	ldd	r12, Z+7	; 0x07
    1ca8:	f0 84       	ldd	r15, Z+8	; 0x08
    1caa:	e1 84       	ldd	r14, Z+9	; 0x09
    1cac:	02 85       	ldd	r16, Z+10	; 0x0a
    1cae:	13 85       	ldd	r17, Z+11	; 0x0b
    1cb0:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <clockGetTimeStamp>
    1cb4:	91 17       	cp	r25, r17
    1cb6:	30 f5       	brcc	.+76     	; 0x1d04 <DebugTimerList+0xe2>
			putString("\r\ntimebomp groesser noch net erreicht:");
    1cb8:	81 e6       	ldi	r24, 0x61	; 97
    1cba:	91 e0       	ldi	r25, 0x01	; 1
    1cbc:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
		}

    	

		
		char *x2=malloc(2);
    1cc0:	82 e0       	ldi	r24, 0x02	; 2
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    1cc8:	18 2f       	mov	r17, r24
    1cca:	09 2f       	mov	r16, r25

		itoa(anzahlTimer,x2,10);
    1ccc:	8d 2d       	mov	r24, r13
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	61 2f       	mov	r22, r17
    1cd2:	70 2f       	mov	r23, r16
    1cd4:	4a e0       	ldi	r20, 0x0A	; 10
    1cd6:	50 e0       	ldi	r21, 0x00	; 0
    1cd8:	0e 94 93 2e 	call	0x5d26	; 0x5d26 <itoa>
		

		putString("\r\nAnzahlTimer:");
    1cdc:	87 ea       	ldi	r24, 0xA7	; 167
    1cde:	91 e0       	ldi	r25, 0x01	; 1
    1ce0:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
		putString(x2);
    1ce4:	81 2f       	mov	r24, r17
    1ce6:	90 2f       	mov	r25, r16
    1ce8:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	}

}
    1cec:	df 91       	pop	r29
    1cee:	cf 91       	pop	r28
    1cf0:	1f 91       	pop	r17
    1cf2:	0f 91       	pop	r16
    1cf4:	ff 90       	pop	r15
    1cf6:	ef 90       	pop	r14
    1cf8:	df 90       	pop	r13
    1cfa:	cf 90       	pop	r12
    1cfc:	bf 90       	pop	r11
    1cfe:	af 90       	pop	r10
    1d00:	9f 90       	pop	r9
    1d02:	08 95       	ret
			putString(x1);
			node = node->next;
			
		}

		if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1d04:	19 17       	cp	r17, r25
    1d06:	79 f1       	breq	.+94     	; 0x1d66 <DebugTimerList+0x144>
			putString("\r\ntimebomp groesser noch net erreicht:");
		else
		{
			putString("\r\ntimebomp kleiner AUSSloesen:");
    1d08:	88 e8       	ldi	r24, 0x88	; 136
    1d0a:	91 e0       	ldi	r25, 0x01	; 1
    1d0c:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
}


void onTimer()
{
  if (timerList.firstNode == NULL)
    1d10:	e0 91 21 08 	lds	r30, 0x0821
    1d14:	f0 91 22 08 	lds	r31, 0x0822
    1d18:	30 97       	sbiw	r30, 0x00	; 0
    1d1a:	91 f2       	breq	.-92     	; 0x1cc0 <DebugTimerList+0x9e>
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1d1c:	94 80       	ldd	r9, Z+4	; 0x04
    1d1e:	a5 80       	ldd	r10, Z+5	; 0x05
    1d20:	b6 80       	ldd	r11, Z+6	; 0x06
    1d22:	c7 80       	ldd	r12, Z+7	; 0x07
    1d24:	e0 84       	ldd	r14, Z+8	; 0x08
    1d26:	f1 84       	ldd	r15, Z+9	; 0x09
    1d28:	02 85       	ldd	r16, Z+10	; 0x0a
    1d2a:	13 85       	ldd	r17, Z+11	; 0x0b
    1d2c:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <clockGetTimeStamp>
    1d30:	91 17       	cp	r25, r17
    1d32:	30 f2       	brcs	.-116    	; 0x1cc0 <DebugTimerList+0x9e>
    1d34:	19 17       	cp	r17, r25
    1d36:	e1 f1       	breq	.+120    	; 0x1db0 <DebugTimerList+0x18e>
//	putString("\r\nAUSGELOESSSST:");
  
  
  // we need to remove the obsolete timer entry...
  // ... before we do the callback!
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
    1d38:	60 91 21 08 	lds	r22, 0x0821
    1d3c:	70 91 22 08 	lds	r23, 0x0822
    1d40:	8b 01       	movw	r16, r22
    1d42:	f8 01       	movw	r30, r16
    1d44:	e4 84       	ldd	r14, Z+12	; 0x0c
    1d46:	f5 84       	ldd	r15, Z+13	; 0x0d
// after any timeout or calling this function it is essential to NULL 
// the element variable
void timerClearTimeout(struct timerElement_t* element)
{
    
  removeDlNode(&timerList,(struct dlNode_t*)element);
    1d48:	81 e2       	ldi	r24, 0x21	; 33
    1d4a:	98 e0       	ldi	r25, 0x08	; 8
    1d4c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <removeDlNode>
  free(element);
    1d50:	c8 01       	movw	r24, r16
    1d52:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
  void* callback = ((struct timerElement_t*)(timerList.firstNode))->callback ;
  timerClearTimeout(((struct timerElement_t*)(timerList.firstNode)));
  
  // as the entry is removed, we have to use...
  // ...our temporary variable to do the callback
  ((void(*) ()) (callback)) ();
    1d56:	f7 01       	movw	r30, r14
    1d58:	09 95       	icall
    1d5a:	b2 cf       	rjmp	.-156    	; 0x1cc0 <DebugTimerList+0x9e>


// If the list is empty, we can do a shortcut...
	if (timerList.firstNode == NULL)
	{
		putString("\r\nTimer-Liste leer!!");
    1d5c:	81 e3       	ldi	r24, 0x31	; 49
    1d5e:	91 e0       	ldi	r25, 0x01	; 1
    1d60:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    1d64:	c3 cf       	rjmp	.-122    	; 0x1cec <DebugTimerList+0xca>
			putString(x1);
			node = node->next;
			
		}

		if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1d66:	80 17       	cp	r24, r16
    1d68:	08 f4       	brcc	.+2      	; 0x1d6c <DebugTimerList+0x14a>
    1d6a:	a6 cf       	rjmp	.-180    	; 0x1cb8 <DebugTimerList+0x96>
    1d6c:	08 17       	cp	r16, r24
    1d6e:	61 f6       	brne	.-104    	; 0x1d08 <DebugTimerList+0xe6>
    1d70:	7e 15       	cp	r23, r14
    1d72:	08 f4       	brcc	.+2      	; 0x1d76 <DebugTimerList+0x154>
    1d74:	a1 cf       	rjmp	.-190    	; 0x1cb8 <DebugTimerList+0x96>
    1d76:	e7 16       	cp	r14, r23
    1d78:	39 f6       	brne	.-114    	; 0x1d08 <DebugTimerList+0xe6>
    1d7a:	6f 15       	cp	r22, r15
    1d7c:	08 f4       	brcc	.+2      	; 0x1d80 <DebugTimerList+0x15e>
    1d7e:	9c cf       	rjmp	.-200    	; 0x1cb8 <DebugTimerList+0x96>
    1d80:	f6 16       	cp	r15, r22
    1d82:	11 f6       	brne	.-124    	; 0x1d08 <DebugTimerList+0xe6>
    1d84:	5c 15       	cp	r21, r12
    1d86:	08 f4       	brcc	.+2      	; 0x1d8a <DebugTimerList+0x168>
    1d88:	97 cf       	rjmp	.-210    	; 0x1cb8 <DebugTimerList+0x96>
    1d8a:	c5 16       	cp	r12, r21
    1d8c:	09 f0       	breq	.+2      	; 0x1d90 <DebugTimerList+0x16e>
    1d8e:	bc cf       	rjmp	.-136    	; 0x1d08 <DebugTimerList+0xe6>
    1d90:	4b 15       	cp	r20, r11
    1d92:	08 f4       	brcc	.+2      	; 0x1d96 <DebugTimerList+0x174>
    1d94:	91 cf       	rjmp	.-222    	; 0x1cb8 <DebugTimerList+0x96>
    1d96:	b4 16       	cp	r11, r20
    1d98:	09 f0       	breq	.+2      	; 0x1d9c <DebugTimerList+0x17a>
    1d9a:	b6 cf       	rjmp	.-148    	; 0x1d08 <DebugTimerList+0xe6>
    1d9c:	3a 15       	cp	r19, r10
    1d9e:	08 f4       	brcc	.+2      	; 0x1da2 <DebugTimerList+0x180>
    1da0:	8b cf       	rjmp	.-234    	; 0x1cb8 <DebugTimerList+0x96>
    1da2:	a3 16       	cp	r10, r19
    1da4:	09 f0       	breq	.+2      	; 0x1da8 <DebugTimerList+0x186>
    1da6:	b0 cf       	rjmp	.-160    	; 0x1d08 <DebugTimerList+0xe6>
    1da8:	29 15       	cp	r18, r9
    1daa:	08 f0       	brcs	.+2      	; 0x1dae <DebugTimerList+0x18c>
    1dac:	ad cf       	rjmp	.-166    	; 0x1d08 <DebugTimerList+0xe6>
    1dae:	84 cf       	rjmp	.-248    	; 0x1cb8 <DebugTimerList+0x96>
void onTimer()
{
  if (timerList.firstNode == NULL)
    return;

  if (((struct timerElement_t*)(timerList.firstNode))->timebomb > clockGetTimeStamp())
    1db0:	80 17       	cp	r24, r16
    1db2:	08 f4       	brcc	.+2      	; 0x1db6 <DebugTimerList+0x194>
    1db4:	85 cf       	rjmp	.-246    	; 0x1cc0 <DebugTimerList+0x9e>
    1db6:	08 17       	cp	r16, r24
    1db8:	09 f0       	breq	.+2      	; 0x1dbc <DebugTimerList+0x19a>
    1dba:	be cf       	rjmp	.-132    	; 0x1d38 <DebugTimerList+0x116>
    1dbc:	7f 15       	cp	r23, r15
    1dbe:	08 f4       	brcc	.+2      	; 0x1dc2 <DebugTimerList+0x1a0>
    1dc0:	7f cf       	rjmp	.-258    	; 0x1cc0 <DebugTimerList+0x9e>
    1dc2:	f7 16       	cp	r15, r23
    1dc4:	09 f0       	breq	.+2      	; 0x1dc8 <DebugTimerList+0x1a6>
    1dc6:	b8 cf       	rjmp	.-144    	; 0x1d38 <DebugTimerList+0x116>
    1dc8:	6e 15       	cp	r22, r14
    1dca:	08 f4       	brcc	.+2      	; 0x1dce <DebugTimerList+0x1ac>
    1dcc:	79 cf       	rjmp	.-270    	; 0x1cc0 <DebugTimerList+0x9e>
    1dce:	e6 16       	cp	r14, r22
    1dd0:	09 f0       	breq	.+2      	; 0x1dd4 <DebugTimerList+0x1b2>
    1dd2:	b2 cf       	rjmp	.-156    	; 0x1d38 <DebugTimerList+0x116>
    1dd4:	5c 15       	cp	r21, r12
    1dd6:	08 f4       	brcc	.+2      	; 0x1dda <DebugTimerList+0x1b8>
    1dd8:	73 cf       	rjmp	.-282    	; 0x1cc0 <DebugTimerList+0x9e>
    1dda:	c5 16       	cp	r12, r21
    1ddc:	09 f0       	breq	.+2      	; 0x1de0 <DebugTimerList+0x1be>
    1dde:	ac cf       	rjmp	.-168    	; 0x1d38 <DebugTimerList+0x116>
    1de0:	4b 15       	cp	r20, r11
    1de2:	08 f4       	brcc	.+2      	; 0x1de6 <DebugTimerList+0x1c4>
    1de4:	6d cf       	rjmp	.-294    	; 0x1cc0 <DebugTimerList+0x9e>
    1de6:	b4 16       	cp	r11, r20
    1de8:	09 f0       	breq	.+2      	; 0x1dec <DebugTimerList+0x1ca>
    1dea:	a6 cf       	rjmp	.-180    	; 0x1d38 <DebugTimerList+0x116>
    1dec:	3a 15       	cp	r19, r10
    1dee:	08 f4       	brcc	.+2      	; 0x1df2 <DebugTimerList+0x1d0>
    1df0:	67 cf       	rjmp	.-306    	; 0x1cc0 <DebugTimerList+0x9e>
    1df2:	a3 16       	cp	r10, r19
    1df4:	09 f0       	breq	.+2      	; 0x1df8 <DebugTimerList+0x1d6>
    1df6:	a0 cf       	rjmp	.-192    	; 0x1d38 <DebugTimerList+0x116>
    1df8:	29 15       	cp	r18, r9
    1dfa:	08 f4       	brcc	.+2      	; 0x1dfe <DebugTimerList+0x1dc>
    1dfc:	61 cf       	rjmp	.-318    	; 0x1cc0 <DebugTimerList+0x9e>
    1dfe:	9c cf       	rjmp	.-200    	; 0x1d38 <DebugTimerList+0x116>

00001e00 <insertDlNodeAfter>:
  #include "./doublyLinkedList.h"
  #include <stdlib.h>
  
  
  void insertDlNodeAfter(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    1e00:	cf 93       	push	r28
    1e02:	df 93       	push	r29
    1e04:	9c 01       	movw	r18, r24
    1e06:	db 01       	movw	r26, r22
    1e08:	fa 01       	movw	r30, r20
    newNode->prev = node;
    1e0a:	71 83       	std	Z+1, r23	; 0x01
    1e0c:	60 83       	st	Z, r22
    newNode->next = node->next;
    1e0e:	12 96       	adiw	r26, 0x02	; 2
    1e10:	8d 91       	ld	r24, X+
    1e12:	9c 91       	ld	r25, X
    1e14:	13 97       	sbiw	r26, 0x03	; 3
    1e16:	93 83       	std	Z+3, r25	; 0x03
    1e18:	82 83       	std	Z+2, r24	; 0x02
    
    if (node->next == NULL)
    1e1a:	12 96       	adiw	r26, 0x02	; 2
    1e1c:	cd 91       	ld	r28, X+
    1e1e:	dc 91       	ld	r29, X
    1e20:	13 97       	sbiw	r26, 0x03	; 3
    1e22:	20 97       	sbiw	r28, 0x00	; 0
    1e24:	49 f0       	breq	.+18     	; 0x1e38 <insertDlNodeAfter+0x38>
      list->lastNode = newNode;
    else
      node->next->prev = newNode;
    1e26:	59 83       	std	Y+1, r21	; 0x01
    1e28:	48 83       	st	Y, r20
    
    node->next = newNode;
    1e2a:	13 96       	adiw	r26, 0x03	; 3
    1e2c:	fc 93       	st	X, r31
    1e2e:	ee 93       	st	-X, r30
    1e30:	12 97       	sbiw	r26, 0x02	; 2
  }
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	08 95       	ret
  {
    newNode->prev = node;
    newNode->next = node->next;
    
    if (node->next == NULL)
      list->lastNode = newNode;
    1e38:	e9 01       	movw	r28, r18
    1e3a:	5b 83       	std	Y+3, r21	; 0x03
    1e3c:	4a 83       	std	Y+2, r20	; 0x02
    else
      node->next->prev = newNode;
    
    node->next = newNode;
    1e3e:	13 96       	adiw	r26, 0x03	; 3
    1e40:	fc 93       	st	X, r31
    1e42:	ee 93       	st	-X, r30
    1e44:	12 97       	sbiw	r26, 0x02	; 2
  }
    1e46:	df 91       	pop	r29
    1e48:	cf 91       	pop	r28
    1e4a:	08 95       	ret

00001e4c <insertDlNodeBefore>:
  
  void insertDlNodeBefore(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    1e4c:	cf 93       	push	r28
    1e4e:	df 93       	push	r29
    1e50:	9c 01       	movw	r18, r24
    1e52:	db 01       	movw	r26, r22
    1e54:	fa 01       	movw	r30, r20
    newNode->prev = node->prev;
    1e56:	8d 91       	ld	r24, X+
    1e58:	9c 91       	ld	r25, X
    1e5a:	11 97       	sbiw	r26, 0x01	; 1
    1e5c:	91 83       	std	Z+1, r25	; 0x01
    1e5e:	80 83       	st	Z, r24
    newNode->next = node;
    1e60:	73 83       	std	Z+3, r23	; 0x03
    1e62:	62 83       	std	Z+2, r22	; 0x02
    
    
    if (node->prev == NULL)
    1e64:	cd 91       	ld	r28, X+
    1e66:	dc 91       	ld	r29, X
    1e68:	11 97       	sbiw	r26, 0x01	; 1
    1e6a:	20 97       	sbiw	r28, 0x00	; 0
    1e6c:	39 f0       	breq	.+14     	; 0x1e7c <insertDlNodeBefore+0x30>
      list->firstNode = newNode;
    else
      node->prev->next = newNode;
    1e6e:	5b 83       	std	Y+3, r21	; 0x03
    1e70:	4a 83       	std	Y+2, r20	; 0x02
    
    node->prev = newNode;
    1e72:	ed 93       	st	X+, r30
    1e74:	fc 93       	st	X, r31
  }
    1e76:	df 91       	pop	r29
    1e78:	cf 91       	pop	r28
    1e7a:	08 95       	ret
    newNode->prev = node->prev;
    newNode->next = node;
    
    
    if (node->prev == NULL)
      list->firstNode = newNode;
    1e7c:	e9 01       	movw	r28, r18
    1e7e:	59 83       	std	Y+1, r21	; 0x01
    1e80:	48 83       	st	Y, r20
    else
      node->prev->next = newNode;
    
    node->prev = newNode;
    1e82:	ed 93       	st	X+, r30
    1e84:	fc 93       	st	X, r31
  }
    1e86:	df 91       	pop	r29
    1e88:	cf 91       	pop	r28
    1e8a:	08 95       	ret

00001e8c <insertDlNodeBeginning>:
  
  void insertDlNodeBeginning(struct dlList_t* list, struct dlNode_t* newNode)
  {
    1e8c:	cf 93       	push	r28
    1e8e:	df 93       	push	r29
    1e90:	9c 01       	movw	r18, r24
    1e92:	db 01       	movw	r26, r22
    if (list->firstNode == NULL)
    1e94:	ec 01       	movw	r28, r24
    1e96:	e8 81       	ld	r30, Y
    1e98:	f9 81       	ldd	r31, Y+1	; 0x01
    1e9a:	30 97       	sbiw	r30, 0x00	; 0
    1e9c:	a1 f0       	breq	.+40     	; 0x1ec6 <insertDlNodeBeginning+0x3a>
    node->next = newNode;
  }
  
  void insertDlNodeBefore(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    newNode->prev = node->prev;
    1e9e:	80 81       	ld	r24, Z
    1ea0:	91 81       	ldd	r25, Z+1	; 0x01
    1ea2:	11 96       	adiw	r26, 0x01	; 1
    1ea4:	9c 93       	st	X, r25
    1ea6:	8e 93       	st	-X, r24
    newNode->next = node;
    1ea8:	13 96       	adiw	r26, 0x03	; 3
    1eaa:	fc 93       	st	X, r31
    1eac:	ee 93       	st	-X, r30
    1eae:	12 97       	sbiw	r26, 0x02	; 2
    
    
    if (node->prev == NULL)
    1eb0:	c0 81       	ld	r28, Z
    1eb2:	d1 81       	ldd	r29, Z+1	; 0x01
    1eb4:	20 97       	sbiw	r28, 0x00	; 0
    1eb6:	a9 f0       	breq	.+42     	; 0x1ee2 <insertDlNodeBeginning+0x56>
      list->firstNode = newNode;
    else
      node->prev->next = newNode;
    1eb8:	7b 83       	std	Y+3, r23	; 0x03
    1eba:	6a 83       	std	Y+2, r22	; 0x02
    
    node->prev = newNode;
    1ebc:	b1 83       	std	Z+1, r27	; 0x01
    1ebe:	a0 83       	st	Z, r26
      newNode->next = NULL;
    }
    else
      insertDlNodeBefore(list,list->firstNode,newNode);
    
  }
    1ec0:	df 91       	pop	r29
    1ec2:	cf 91       	pop	r28
    1ec4:	08 95       	ret
  
  void insertDlNodeBeginning(struct dlList_t* list, struct dlNode_t* newNode)
  {
    if (list->firstNode == NULL)
    {
      list->firstNode = newNode;
    1ec6:	79 83       	std	Y+1, r23	; 0x01
    1ec8:	68 83       	st	Y, r22
      list->lastNode = newNode;
    1eca:	7b 83       	std	Y+3, r23	; 0x03
    1ecc:	6a 83       	std	Y+2, r22	; 0x02
      
      newNode->prev = NULL;
    1ece:	11 96       	adiw	r26, 0x01	; 1
    1ed0:	1c 92       	st	X, r1
    1ed2:	1e 92       	st	-X, r1
      newNode->next = NULL;
    1ed4:	13 96       	adiw	r26, 0x03	; 3
    1ed6:	1c 92       	st	X, r1
    1ed8:	1e 92       	st	-X, r1
    1eda:	12 97       	sbiw	r26, 0x02	; 2
    }
    else
      insertDlNodeBefore(list,list->firstNode,newNode);
    
  }
    1edc:	df 91       	pop	r29
    1ede:	cf 91       	pop	r28
    1ee0:	08 95       	ret
    newNode->prev = node->prev;
    newNode->next = node;
    
    
    if (node->prev == NULL)
      list->firstNode = newNode;
    1ee2:	e9 01       	movw	r28, r18
    1ee4:	79 83       	std	Y+1, r23	; 0x01
    1ee6:	68 83       	st	Y, r22
    1ee8:	e9 cf       	rjmp	.-46     	; 0x1ebc <insertDlNodeBeginning+0x30>

00001eea <insertDlNodeLast>:
      insertDlNodeBefore(list,list->firstNode,newNode);
    
  }
  
  void insertDlNodeLast(struct dlList_t* list, struct dlNode_t* newNode)
  {
    1eea:	cf 93       	push	r28
    1eec:	df 93       	push	r29
    1eee:	9c 01       	movw	r18, r24
    1ef0:	eb 01       	movw	r28, r22
    if (list->lastNode == NULL)
    1ef2:	dc 01       	movw	r26, r24
    1ef4:	12 96       	adiw	r26, 0x02	; 2
    1ef6:	ed 91       	ld	r30, X+
    1ef8:	fc 91       	ld	r31, X
    1efa:	13 97       	sbiw	r26, 0x03	; 3
    1efc:	30 97       	sbiw	r30, 0x00	; 0
    1efe:	89 f0       	breq	.+34     	; 0x1f22 <insertDlNodeLast+0x38>
  #include <stdlib.h>
  
  
  void insertDlNodeAfter(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    newNode->prev = node;
    1f00:	f9 83       	std	Y+1, r31	; 0x01
    1f02:	e8 83       	st	Y, r30
    newNode->next = node->next;
    1f04:	82 81       	ldd	r24, Z+2	; 0x02
    1f06:	93 81       	ldd	r25, Z+3	; 0x03
    1f08:	9b 83       	std	Y+3, r25	; 0x03
    1f0a:	8a 83       	std	Y+2, r24	; 0x02
    
    if (node->next == NULL)
    1f0c:	a2 81       	ldd	r26, Z+2	; 0x02
    1f0e:	b3 81       	ldd	r27, Z+3	; 0x03
    1f10:	10 97       	sbiw	r26, 0x00	; 0
    1f12:	f9 f0       	breq	.+62     	; 0x1f52 <insertDlNodeLast+0x68>
      list->lastNode = newNode;
    else
      node->next->prev = newNode;
    1f14:	6d 93       	st	X+, r22
    1f16:	7c 93       	st	X, r23
    
    node->next = newNode;
    1f18:	d3 83       	std	Z+3, r29	; 0x03
    1f1a:	c2 83       	std	Z+2, r28	; 0x02
  {
    if (list->lastNode == NULL)
      insertDlNodeBeginning(list,newNode);
    else
      insertDlNodeAfter(list,list->lastNode,newNode);
  }
    1f1c:	df 91       	pop	r29
    1f1e:	cf 91       	pop	r28
    1f20:	08 95       	ret
    node->prev = newNode;
  }
  
  void insertDlNodeBeginning(struct dlList_t* list, struct dlNode_t* newNode)
  {
    if (list->firstNode == NULL)
    1f22:	ed 91       	ld	r30, X+
    1f24:	fc 91       	ld	r31, X
    1f26:	11 97       	sbiw	r26, 0x01	; 1
    1f28:	30 97       	sbiw	r30, 0x00	; 0
    1f2a:	c9 f0       	breq	.+50     	; 0x1f5e <insertDlNodeLast+0x74>
    node->next = newNode;
  }
  
  void insertDlNodeBefore(struct dlList_t* list, struct dlNode_t* node, struct dlNode_t* newNode)
  {
    newNode->prev = node->prev;
    1f2c:	80 81       	ld	r24, Z
    1f2e:	91 81       	ldd	r25, Z+1	; 0x01
    1f30:	99 83       	std	Y+1, r25	; 0x01
    1f32:	88 83       	st	Y, r24
    newNode->next = node;
    1f34:	fb 83       	std	Y+3, r31	; 0x03
    1f36:	ea 83       	std	Y+2, r30	; 0x02
    
    
    if (node->prev == NULL)
    1f38:	a0 81       	ld	r26, Z
    1f3a:	b1 81       	ldd	r27, Z+1	; 0x01
    1f3c:	10 97       	sbiw	r26, 0x00	; 0
    1f3e:	d9 f0       	breq	.+54     	; 0x1f76 <insertDlNodeLast+0x8c>
      list->firstNode = newNode;
    else
      node->prev->next = newNode;
    1f40:	13 96       	adiw	r26, 0x03	; 3
    1f42:	7c 93       	st	X, r23
    1f44:	6e 93       	st	-X, r22
    1f46:	12 97       	sbiw	r26, 0x02	; 2
    
    node->prev = newNode;
    1f48:	d1 83       	std	Z+1, r29	; 0x01
    1f4a:	c0 83       	st	Z, r28
  {
    if (list->lastNode == NULL)
      insertDlNodeBeginning(list,newNode);
    else
      insertDlNodeAfter(list,list->lastNode,newNode);
  }
    1f4c:	df 91       	pop	r29
    1f4e:	cf 91       	pop	r28
    1f50:	08 95       	ret
  {
    newNode->prev = node;
    newNode->next = node->next;
    
    if (node->next == NULL)
      list->lastNode = newNode;
    1f52:	d9 01       	movw	r26, r18
    1f54:	13 96       	adiw	r26, 0x03	; 3
    1f56:	7c 93       	st	X, r23
    1f58:	6e 93       	st	-X, r22
    1f5a:	12 97       	sbiw	r26, 0x02	; 2
    1f5c:	dd cf       	rjmp	.-70     	; 0x1f18 <insertDlNodeLast+0x2e>
  
  void insertDlNodeBeginning(struct dlList_t* list, struct dlNode_t* newNode)
  {
    if (list->firstNode == NULL)
    {
      list->firstNode = newNode;
    1f5e:	11 96       	adiw	r26, 0x01	; 1
    1f60:	7c 93       	st	X, r23
    1f62:	6e 93       	st	-X, r22
      list->lastNode = newNode;
    1f64:	13 96       	adiw	r26, 0x03	; 3
    1f66:	7c 93       	st	X, r23
    1f68:	6e 93       	st	-X, r22
    1f6a:	12 97       	sbiw	r26, 0x02	; 2
      
      newNode->prev = NULL;
    1f6c:	19 82       	std	Y+1, r1	; 0x01
    1f6e:	18 82       	st	Y, r1
      newNode->next = NULL;
    1f70:	1b 82       	std	Y+3, r1	; 0x03
    1f72:	1a 82       	std	Y+2, r1	; 0x02
    1f74:	d3 cf       	rjmp	.-90     	; 0x1f1c <insertDlNodeLast+0x32>
    newNode->prev = node->prev;
    newNode->next = node;
    
    
    if (node->prev == NULL)
      list->firstNode = newNode;
    1f76:	d9 01       	movw	r26, r18
    1f78:	6d 93       	st	X+, r22
    1f7a:	7c 93       	st	X, r23
    1f7c:	e5 cf       	rjmp	.-54     	; 0x1f48 <insertDlNodeLast+0x5e>

00001f7e <removeDlNode>:
    else
      insertDlNodeAfter(list,list->lastNode,newNode);
  }
  
  void removeDlNode(struct dlList_t* list, struct dlNode_t* node)
  {
    1f7e:	cf 93       	push	r28
    1f80:	df 93       	push	r29
    1f82:	ec 01       	movw	r28, r24
    1f84:	fb 01       	movw	r30, r22
    if (node->prev == NULL)
    1f86:	a0 81       	ld	r26, Z
    1f88:	b1 81       	ldd	r27, Z+1	; 0x01
    1f8a:	10 97       	sbiw	r26, 0x00	; 0
    1f8c:	81 f0       	breq	.+32     	; 0x1fae <removeDlNode+0x30>
      list->firstNode = node->next;
    else
      node->prev->next = node->next;
    1f8e:	82 81       	ldd	r24, Z+2	; 0x02
    1f90:	93 81       	ldd	r25, Z+3	; 0x03
    1f92:	13 96       	adiw	r26, 0x03	; 3
    1f94:	9c 93       	st	X, r25
    1f96:	8e 93       	st	-X, r24
    1f98:	12 97       	sbiw	r26, 0x02	; 2
    
    if (node->next == NULL)
    1f9a:	02 80       	ldd	r0, Z+2	; 0x02
    1f9c:	f3 81       	ldd	r31, Z+3	; 0x03
    1f9e:	e0 2d       	mov	r30, r0
    1fa0:	30 97       	sbiw	r30, 0x00	; 0
    1fa2:	71 f0       	breq	.+28     	; 0x1fc0 <removeDlNode+0x42>
      list->lastNode = node->prev;
    else
      node->next->prev = node->prev;  
    1fa4:	b1 83       	std	Z+1, r27	; 0x01
    1fa6:	a0 83       	st	Z, r26
  }
    1fa8:	df 91       	pop	r29
    1faa:	cf 91       	pop	r28
    1fac:	08 95       	ret
  }
  
  void removeDlNode(struct dlList_t* list, struct dlNode_t* node)
  {
    if (node->prev == NULL)
      list->firstNode = node->next;
    1fae:	82 81       	ldd	r24, Z+2	; 0x02
    1fb0:	93 81       	ldd	r25, Z+3	; 0x03
    1fb2:	99 83       	std	Y+1, r25	; 0x01
    1fb4:	88 83       	st	Y, r24
    else
      node->prev->next = node->next;
    
    if (node->next == NULL)
    1fb6:	02 80       	ldd	r0, Z+2	; 0x02
    1fb8:	f3 81       	ldd	r31, Z+3	; 0x03
    1fba:	e0 2d       	mov	r30, r0
    1fbc:	30 97       	sbiw	r30, 0x00	; 0
    1fbe:	91 f7       	brne	.-28     	; 0x1fa4 <removeDlNode+0x26>
      list->lastNode = node->prev;
    1fc0:	bb 83       	std	Y+3, r27	; 0x03
    1fc2:	aa 83       	std	Y+2, r26	; 0x02
    else
      node->next->prev = node->prev;  
  }
    1fc4:	df 91       	pop	r29
    1fc6:	cf 91       	pop	r28
    1fc8:	08 95       	ret

00001fca <pushQueueEntry>:
  
  // a queue has a limited size, therefore allways call queueIsFull before 
  // adding a node. Adding a node to a full is, will be rejected.
  // Inorder to prevent memory holes always make sure that the node has been added.
  uint8_t pushQueueEntry(struct queue_t* queue, struct queueNode_t* node)
  {
    1fca:	cf 93       	push	r28
    1fcc:	df 93       	push	r29
    1fce:	fc 01       	movw	r30, r24
    1fd0:	db 01       	movw	r26, r22
    // reject adding elements to a full queue...
    if (queue->elements == 0)      
    1fd2:	84 81       	ldd	r24, Z+4	; 0x04
    1fd4:	88 23       	and	r24, r24
    1fd6:	91 f0       	breq	.+36     	; 0x1ffc <pushQueueEntry+0x32>
      return 1;
    
    // when pushing a new Entry ontop of the queue...
    // ... therefore the node can't have a successor.
    node->prev = NULL;
    1fd8:	11 96       	adiw	r26, 0x01	; 1
    1fda:	1c 92       	st	X, r1
    1fdc:	1e 92       	st	-X, r1
                 
    if (queue->first == NULL)
    1fde:	c0 81       	ld	r28, Z
    1fe0:	d1 81       	ldd	r29, Z+1	; 0x01
    1fe2:	20 97       	sbiw	r28, 0x00	; 0
    1fe4:	79 f0       	breq	.+30     	; 0x2004 <pushQueueEntry+0x3a>
      queue->last = node;
    else        
      queue->first->prev = node;
    1fe6:	79 83       	std	Y+1, r23	; 0x01
    1fe8:	68 83       	st	Y, r22
          
    queue->first = node;
    1fea:	b1 83       	std	Z+1, r27	; 0x01
    1fec:	a0 83       	st	Z, r26
    
    queue->elements--;
    1fee:	84 81       	ldd	r24, Z+4	; 0x04
    1ff0:	81 50       	subi	r24, 0x01	; 1
    1ff2:	84 83       	std	Z+4, r24	; 0x04
    1ff4:	80 e0       	ldi	r24, 0x00	; 0
    
    return 0;
  }
    1ff6:	df 91       	pop	r29
    1ff8:	cf 91       	pop	r28
    1ffa:	08 95       	ret
  // adding a node. Adding a node to a full is, will be rejected.
  // Inorder to prevent memory holes always make sure that the node has been added.
  uint8_t pushQueueEntry(struct queue_t* queue, struct queueNode_t* node)
  {
    // reject adding elements to a full queue...
    if (queue->elements == 0)      
    1ffc:	81 e0       	ldi	r24, 0x01	; 1
    queue->first = node;
    
    queue->elements--;
    
    return 0;
  }
    1ffe:	df 91       	pop	r29
    2000:	cf 91       	pop	r28
    2002:	08 95       	ret
    // when pushing a new Entry ontop of the queue...
    // ... therefore the node can't have a successor.
    node->prev = NULL;
                 
    if (queue->first == NULL)
      queue->last = node;
    2004:	73 83       	std	Z+3, r23	; 0x03
    2006:	62 83       	std	Z+2, r22	; 0x02
    2008:	f0 cf       	rjmp	.-32     	; 0x1fea <pushQueueEntry+0x20>

0000200a <queueIsEmpty>:
    
    return 0;
  }
  
  uint8_t queueIsEmpty(struct queue_t* queue)
  {
    200a:	20 e0       	ldi	r18, 0x00	; 0
    200c:	fc 01       	movw	r30, r24
    200e:	82 81       	ldd	r24, Z+2	; 0x02
    2010:	93 81       	ldd	r25, Z+3	; 0x03
    2012:	89 2b       	or	r24, r25
    2014:	09 f0       	breq	.+2      	; 0x2018 <queueIsEmpty+0xe>
    2016:	21 e0       	ldi	r18, 0x01	; 1
    if (queue->last == NULL)
      return 0;
    
    return 1;    
  }
    2018:	82 2f       	mov	r24, r18
    201a:	08 95       	ret

0000201c <queueIsFull>:

  uint8_t queueIsFull(struct queue_t* queue)
  {
    201c:	20 e0       	ldi	r18, 0x00	; 0
    201e:	fc 01       	movw	r30, r24
    2020:	84 81       	ldd	r24, Z+4	; 0x04
    2022:	88 23       	and	r24, r24
    2024:	09 f4       	brne	.+2      	; 0x2028 <queueIsFull+0xc>
    2026:	21 e0       	ldi	r18, 0x01	; 1
    if (queue->elements > 0)
      return 0;
    
    return 1;    
  }
    2028:	82 2f       	mov	r24, r18
    202a:	08 95       	ret

0000202c <popQueueEntry>:
  
  struct queueNode_t* popQueueEntry(struct queue_t* queue)
  {
    202c:	fc 01       	movw	r30, r24
    if (queue->last == NULL)
    202e:	a2 81       	ldd	r26, Z+2	; 0x02
    2030:	b3 81       	ldd	r27, Z+3	; 0x03
    2032:	10 97       	sbiw	r26, 0x00	; 0
    2034:	51 f0       	breq	.+20     	; 0x204a <popQueueEntry+0x1e>
      return NULL;
    
    struct queueNode_t* node = queue->last;
    
    queue->last = queue->last->prev;
    2036:	8d 91       	ld	r24, X+
    2038:	9c 91       	ld	r25, X
    203a:	11 97       	sbiw	r26, 0x01	; 1
    203c:	93 83       	std	Z+3, r25	; 0x03
    203e:	82 83       	std	Z+2, r24	; 0x02
    
    if (queue->last == NULL)
    2040:	89 2b       	or	r24, r25
    2042:	29 f0       	breq	.+10     	; 0x204e <popQueueEntry+0x22>
      queue->first = NULL;
    
    queue->elements++;
    2044:	84 81       	ldd	r24, Z+4	; 0x04
    2046:	8f 5f       	subi	r24, 0xFF	; 255
    2048:	84 83       	std	Z+4, r24	; 0x04
    
    return node;
  }
    204a:	cd 01       	movw	r24, r26
    204c:	08 95       	ret
    struct queueNode_t* node = queue->last;
    
    queue->last = queue->last->prev;
    
    if (queue->last == NULL)
      queue->first = NULL;
    204e:	11 82       	std	Z+1, r1	; 0x01
    2050:	10 82       	st	Z, r1
    2052:	f8 cf       	rjmp	.-16     	; 0x2044 <popQueueEntry+0x18>

00002054 <__vector_16>:




ISR(TIMER0_OVF_vect)
{
    2054:	1f 92       	push	r1
    2056:	0f 92       	push	r0
    2058:	0f b6       	in	r0, 0x3f	; 63
    205a:	0f 92       	push	r0
    205c:	11 24       	eor	r1, r1
    205e:	8f 93       	push	r24
    2060:	9f 93       	push	r25
    2062:	af 93       	push	r26
    2064:	bf 93       	push	r27
  // we should get 4 interrupts per Second... 
  TCNT0 = 0;
    2066:	12 be       	out	0x32, r1	; 50
  overflows++;
    2068:	80 91 25 08 	lds	r24, 0x0825
    206c:	90 91 26 08 	lds	r25, 0x0826
    2070:	a0 91 27 08 	lds	r26, 0x0827
    2074:	b0 91 28 08 	lds	r27, 0x0828
    2078:	01 96       	adiw	r24, 0x01	; 1
    207a:	a1 1d       	adc	r26, r1
    207c:	b1 1d       	adc	r27, r1
    207e:	80 93 25 08 	sts	0x0825, r24
    2082:	90 93 26 08 	sts	0x0826, r25
    2086:	a0 93 27 08 	sts	0x0827, r26
    208a:	b0 93 28 08 	sts	0x0828, r27
}
    208e:	bf 91       	pop	r27
    2090:	af 91       	pop	r26
    2092:	9f 91       	pop	r25
    2094:	8f 91       	pop	r24
    2096:	0f 90       	pop	r0
    2098:	0f be       	out	0x3f, r0	; 63
    209a:	0f 90       	pop	r0
    209c:	1f 90       	pop	r1
    209e:	18 95       	reti

000020a0 <rtcInitialize>:
void rtcInitialize()
{



  overflows = 0;
    20a0:	10 92 25 08 	sts	0x0825, r1
    20a4:	10 92 26 08 	sts	0x0826, r1
    20a8:	10 92 27 08 	sts	0x0827, r1
    20ac:	10 92 28 08 	sts	0x0828, r1
  // ...the timer is asynchronous to out system clock...
  // ... according to the ATMega manual, the following...
  // ... precausions are mandatory.
  
  // Disable interrputs OCIE0 and TOIE0...
  TIMSK &= ~( (1<<OCIE0) | (1<<TOIE0) );
    20b0:	87 b7       	in	r24, 0x37	; 55
    20b2:	8c 7f       	andi	r24, 0xFC	; 252
    20b4:	87 bf       	out	0x37, r24	; 55
  // ... switch to asynchronous mode...
  ASSR |= (1 << AS0);
    20b6:	80 b7       	in	r24, 0x30	; 48
    20b8:	88 60       	ori	r24, 0x08	; 8
    20ba:	80 bf       	out	0x30, r24	; 48
  // ... clear TCNT0, OCR0 ...
  TCNT0 = 0;
    20bc:	12 be       	out	0x32, r1	; 50
  OCR0 = 0;
    20be:	11 be       	out	0x31, r1	; 49
  // ... clear and set TCCR0 to the 32 prescal divider
  TCCR0 = (1 << CS00) |  (1<<CS01);
    20c0:	83 e0       	ldi	r24, 0x03	; 3
    20c2:	83 bf       	out	0x33, r24	; 51
  
  // now wait for TCN0UB
  while (!(ASSR & (1<< TCN0UB)));
    20c4:	00 b6       	in	r0, 0x30	; 48
    20c6:	02 fe       	sbrs	r0, 2
    20c8:	fd cf       	rjmp	.-6      	; 0x20c4 <rtcInitialize+0x24>
  
  // Clear Timer Infterrput flags...
  TIFR &= ~( (1<<OCF0) | (1<<TOV0));  
    20ca:	86 b7       	in	r24, 0x36	; 54
    20cc:	8c 7f       	andi	r24, 0xFC	; 252
    20ce:	86 bf       	out	0x36, r24	; 54
  
  // Enable Overflow Interrupt 
  TIMSK |= (1 << TOIE0); 
    20d0:	87 b7       	in	r24, 0x37	; 55
    20d2:	81 60       	ori	r24, 0x01	; 1
    20d4:	87 bf       	out	0x37, r24	; 55


  
}
    20d6:	08 95       	ret

000020d8 <rtcGetTime64>:

uint64_t rtcGetTime64()
{
    20d8:	af 92       	push	r10
    20da:	bf 92       	push	r11
    20dc:	cf 92       	push	r12
    20de:	df 92       	push	r13
    20e0:	ef 92       	push	r14
    20e2:	ff 92       	push	r15
    20e4:	0f 93       	push	r16
    20e6:	1f 93       	push	r17
  return (overflows << 8) + TCNT0;
    20e8:	a0 90 25 08 	lds	r10, 0x0825
    20ec:	b0 90 26 08 	lds	r11, 0x0826
    20f0:	c0 90 27 08 	lds	r12, 0x0827
    20f4:	d0 90 28 08 	lds	r13, 0x0828
    20f8:	82 b7       	in	r24, 0x32	; 50
    20fa:	dc 2c       	mov	r13, r12
    20fc:	cb 2c       	mov	r12, r11
    20fe:	ba 2c       	mov	r11, r10
    2100:	aa 24       	eor	r10, r10
    2102:	a8 0e       	add	r10, r24
    2104:	b1 1c       	adc	r11, r1
    2106:	c1 1c       	adc	r12, r1
    2108:	d1 1c       	adc	r13, r1
}
    210a:	95 01       	movw	r18, r10
    210c:	a6 01       	movw	r20, r12
    210e:	60 e0       	ldi	r22, 0x00	; 0
    2110:	70 e0       	ldi	r23, 0x00	; 0
    2112:	80 e0       	ldi	r24, 0x00	; 0
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	1f 91       	pop	r17
    2118:	0f 91       	pop	r16
    211a:	ff 90       	pop	r15
    211c:	ef 90       	pop	r14
    211e:	df 90       	pop	r13
    2120:	cf 90       	pop	r12
    2122:	bf 90       	pop	r11
    2124:	af 90       	pop	r10
    2126:	08 95       	ret

00002128 <rtcGetTime32>:

uint32_t rtcGetTime32()
{
  // will cut of the upper 8 bits...
  return (overflows << 8) + TCNT0;
    2128:	20 91 25 08 	lds	r18, 0x0825
    212c:	30 91 26 08 	lds	r19, 0x0826
    2130:	40 91 27 08 	lds	r20, 0x0827
    2134:	50 91 28 08 	lds	r21, 0x0828
    2138:	82 b7       	in	r24, 0x32	; 50
    213a:	54 2f       	mov	r21, r20
    213c:	43 2f       	mov	r20, r19
    213e:	32 2f       	mov	r19, r18
    2140:	22 27       	eor	r18, r18
    2142:	28 0f       	add	r18, r24
    2144:	31 1d       	adc	r19, r1
    2146:	41 1d       	adc	r20, r1
    2148:	51 1d       	adc	r21, r1
}
    214a:	b9 01       	movw	r22, r18
    214c:	ca 01       	movw	r24, r20
    214e:	08 95       	ret

00002150 <rtcGetTime16>:

uint16_t rtcGetTime16()
{
  // will cut of the upper 8 bits...
  return (overflows << 8) + TCNT0;
    2150:	20 91 25 08 	lds	r18, 0x0825
    2154:	30 91 26 08 	lds	r19, 0x0826
    2158:	40 91 27 08 	lds	r20, 0x0827
    215c:	50 91 28 08 	lds	r21, 0x0828
    2160:	82 b7       	in	r24, 0x32	; 50
    2162:	32 2f       	mov	r19, r18
    2164:	22 27       	eor	r18, r18
    2166:	28 0f       	add	r18, r24
    2168:	31 1d       	adc	r19, r1
}
    216a:	c9 01       	movw	r24, r18
    216c:	08 95       	ret

0000216e <com0putChar>:
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR0A&32));
    216e:	5d 9b       	sbis	0x0b, 5	; 11
    2170:	fe cf       	rjmp	.-4      	; 0x216e <com0putChar>
	//sende
	UDR0=data;
    2172:	8c b9       	out	0x0c, r24	; 12
}
    2174:	08 95       	ret

00002176 <com0putBuffer>:
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putBuffer(char *buffer,uint8_t len)
{
int i=0;
	for (i=0; i<len ;i++) com0putChar (buffer[i]);
    2176:	70 e0       	ldi	r23, 0x00	; 0
    2178:	61 15       	cp	r22, r1
    217a:	71 05       	cpc	r23, r1
    217c:	71 f0       	breq	.+28     	; 0x219a <com0putBuffer+0x24>
    217e:	20 e0       	ldi	r18, 0x00	; 0
    2180:	30 e0       	ldi	r19, 0x00	; 0
    2182:	fc 01       	movw	r30, r24
    2184:	e2 0f       	add	r30, r18
    2186:	f3 1f       	adc	r31, r19
    2188:	e0 81       	ld	r30, Z
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR0A&32));
    218a:	5d 9b       	sbis	0x0b, 5	; 11
    218c:	fe cf       	rjmp	.-4      	; 0x218a <com0putBuffer+0x14>
	//sende
	UDR0=data;
    218e:	ec b9       	out	0x0c, r30	; 12
// OUT 	 	: ...
//----------------------------------------------------------------------
void com0putBuffer(char *buffer,uint8_t len)
{
int i=0;
	for (i=0; i<len ;i++) com0putChar (buffer[i]);
    2190:	2f 5f       	subi	r18, 0xFF	; 255
    2192:	3f 4f       	sbci	r19, 0xFF	; 255
    2194:	26 17       	cp	r18, r22
    2196:	37 07       	cpc	r19, r23
    2198:	a4 f3       	brlt	.-24     	; 0x2182 <com0putBuffer+0xc>
    219a:	08 95       	ret

0000219c <com0SendBytes>:
    UCSR0B |= (1 << UDRIE0);

	*/
      
    return;
  }
    219c:	08 95       	ret

0000219e <com0HasBytes>:
    return;
  }
  
  uint8_t com0HasBytes()
  {
    return queueIsEmpty(&hUsart0.recvFiFo);
    219e:	8d e1       	ldi	r24, 0x1D	; 29
    21a0:	99 e0       	ldi	r25, 0x09	; 9
    21a2:	0e 94 05 10 	call	0x200a	; 0x200a <queueIsEmpty>
  }
    21a6:	08 95       	ret

000021a8 <com0RotateSendBuffer>:
    UCSR0B |= (1 << RXCIE0);

  }
  
  void com0RotateSendBuffer()
  {
    21a8:	cf 93       	push	r28
    21aa:	df 93       	push	r29
    
    /* !!! IF YOU MOFIFY THIS BLOCK ALWAYS SYNC IT WITH THE CODE !!! */ 
    /* !!! IN com0SendBytes()                                    !!! */
    
    // in order to ayoid timing issues, disable TX Interrupt
    UCSR0B &= ~ (1 << UDRIE0);
    21ac:	55 98       	cbi	0x0a, 5	; 10
   
    struct queueElement_t* node
      = (struct queueElement_t*) popQueueEntry(&hUsart0.sendFiFo);
    21ae:	82 e2       	ldi	r24, 0x22	; 34
    21b0:	99 e0       	ldi	r25, 0x09	; 9
    21b2:	0e 94 16 10 	call	0x202c	; 0x202c <popQueueEntry>
    21b6:	ec 01       	movw	r28, r24
    
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    21b8:	8c 81       	ldd	r24, Y+4	; 0x04
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    21ba:	48 e7       	ldi	r20, 0x78	; 120
    21bc:	50 e0       	ldi	r21, 0x00	; 0
    21be:	48 1b       	sub	r20, r24
    21c0:	51 09       	sbc	r21, r1
    21c2:	4d 55       	subi	r20, 0x5D	; 93
    21c4:	57 4f       	sbci	r21, 0xF7	; 247
    
    while (len--)
    21c6:	88 23       	and	r24, r24
    21c8:	19 f1       	breq	.+70     	; 0x2210 <com0RotateSendBuffer+0x68>
    21ca:	28 2f       	mov	r18, r24
    21cc:	21 50       	subi	r18, 0x01	; 1
    {
      worker[len] = node->buffer[len];
    21ce:	82 2f       	mov	r24, r18
    21d0:	90 e0       	ldi	r25, 0x00	; 0
    21d2:	da 01       	movw	r26, r20
    21d4:	a8 0f       	add	r26, r24
    21d6:	b9 1f       	adc	r27, r25
    21d8:	ea 81       	ldd	r30, Y+2	; 0x02
    21da:	fb 81       	ldd	r31, Y+3	; 0x03
    21dc:	e8 0f       	add	r30, r24
    21de:	f9 1f       	adc	r31, r25
    21e0:	80 81       	ld	r24, Z
    21e2:	8c 93       	st	X, r24
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    
    while (len--)
    21e4:	21 50       	subi	r18, 0x01	; 1
    21e6:	98 f7       	brcc	.-26     	; 0x21ce <com0RotateSendBuffer+0x26>
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    21e8:	8c e1       	ldi	r24, 0x1C	; 28
    21ea:	98 e0       	ldi	r25, 0x08	; 8
    21ec:	90 93 1c 09 	sts	0x091C, r25
    21f0:	80 93 1b 09 	sts	0x091B, r24
    
    if (node->len > 0) 
    21f4:	8c 81       	ldd	r24, Y+4	; 0x04
    21f6:	88 23       	and	r24, r24
    21f8:	21 f0       	breq	.+8      	; 0x2202 <com0RotateSendBuffer+0x5a>
      free(node->buffer);
    21fa:	8a 81       	ldd	r24, Y+2	; 0x02
    21fc:	9b 81       	ldd	r25, Y+3	; 0x03
    21fe:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
    free(node);
    2202:	ce 01       	movw	r24, r28
    2204:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
  
    // reenable TX Interrupts...
    UCSR0B |= (1 << UDRIE0);
    2208:	55 9a       	sbi	0x0a, 5	; 10
  }
    220a:	df 91       	pop	r29
    220c:	cf 91       	pop	r28
    220e:	08 95       	ret
    while (len--)
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    2210:	8c e1       	ldi	r24, 0x1C	; 28
    2212:	98 e0       	ldi	r25, 0x08	; 8
    2214:	90 93 1c 09 	sts	0x091C, r25
    2218:	80 93 1b 09 	sts	0x091B, r24
    221c:	f2 cf       	rjmp	.-28     	; 0x2202 <com0RotateSendBuffer+0x5a>

0000221e <com0RecvBytes>:
  
  // reveives bytes, any reveived bytes will be written to the buffer...
  // ... memory will be automatially allocated memory, therefore make sure
  // that your free it!;
  void com0RecvBytes(char** buffer, uint8_t* len)
  {
    221e:	ef 92       	push	r14
    2220:	ff 92       	push	r15
    2222:	0f 93       	push	r16
    2224:	1f 93       	push	r17
    2226:	7c 01       	movw	r14, r24
    2228:	8b 01       	movw	r16, r22


    struct queueElement_t* node
      = (struct queueElement_t*) popQueueEntry(&hUsart0.recvFiFo);
    222a:	8d e1       	ldi	r24, 0x1D	; 29
    222c:	99 e0       	ldi	r25, 0x09	; 9
    222e:	0e 94 16 10 	call	0x202c	; 0x202c <popQueueEntry>
    2232:	fc 01       	movw	r30, r24


    *len = node->len;   
    2234:	84 81       	ldd	r24, Z+4	; 0x04
    2236:	d8 01       	movw	r26, r16
    2238:	8c 93       	st	X, r24
    *buffer = node->buffer;     
    223a:	82 81       	ldd	r24, Z+2	; 0x02
    223c:	93 81       	ldd	r25, Z+3	; 0x03
    223e:	d7 01       	movw	r26, r14
    2240:	8d 93       	st	X+, r24
    2242:	9c 93       	st	X, r25
    
    free(node);
    2244:	cf 01       	movw	r24, r30
    2246:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
    // TODO: Etwas suboptimal, in onCom0Timeout wird der timer auch
    // neu gesetzt. Und auf einen onCom0Timeout wird in den meisten
    // fllen auch ein com0RecvBytes aufruf folgen...


    timerClearTimeout(hUsart0.timeout); //alx EINGEFGT	
    224a:	80 91 27 09 	lds	r24, 0x0927
    224e:	90 91 28 09 	lds	r25, 0x0928
    2252:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <timerClearTimeout>


    hUsart0.timeout = timerAddTimeout(COM0_TIMEOUT,onCom0Timeout); 
    2256:	80 e0       	ldi	r24, 0x00	; 0
    2258:	92 e0       	ldi	r25, 0x02	; 2
    225a:	61 ee       	ldi	r22, 0xE1	; 225
    225c:	71 e1       	ldi	r23, 0x11	; 17
    225e:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <timerAddTimeout>
    2262:	90 93 28 09 	sts	0x0928, r25
    2266:	80 93 27 09 	sts	0x0927, r24



	
    return;
  }
    226a:	1f 91       	pop	r17
    226c:	0f 91       	pop	r16
    226e:	ff 90       	pop	r15
    2270:	ef 90       	pop	r14
    2272:	08 95       	ret

00002274 <com0Initialize>:
  {
    
	//init USART0 ( for data)

   	    // TX0 = OUT;
    DDRE = (1<<PE1 );
    2274:	32 e0       	ldi	r19, 0x02	; 2
    2276:	32 b9       	out	0x02, r19	; 2
  
    // RX0 = IN
    DDRE &= ~(1<<PE0);
    2278:	10 98       	cbi	0x02, 0	; 2

    /* Set baud rate */
    UBRR0H = (unsigned char)(prescaler>>8);
    227a:	90 93 90 00 	sts	0x0090, r25
    UBRR0L = (unsigned char)prescaler;
    227e:	89 b9       	out	0x09, r24	; 9
    
    // disable double speed, as we don't need it 
    UCSR0A &= ~(1 << U2X0);
    2280:	59 98       	cbi	0x0b, 1	; 11
    // Enable receiver and transmitter module, as well as RX Interrupt..
    // ... tx interrupt will be activated when needed.    
    UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1 << RXCIE0) /*| (1 << UDRIE0)*/;
    2282:	88 e9       	ldi	r24, 0x98	; 152
    2284:	8a b9       	out	0x0a, r24	; 10

	//das muss gendert werden
    /* Set frame format: 8data, 2stop bit */


	UCSR0C |= (parity<<UPM0);
    2286:	e5 e9       	ldi	r30, 0x95	; 149
    2288:	f0 e0       	ldi	r31, 0x00	; 0
    228a:	80 81       	ld	r24, Z
    228c:	62 95       	swap	r22
    228e:	60 7f       	andi	r22, 0xF0	; 240
    2290:	86 2b       	or	r24, r22
    2292:	80 83       	st	Z, r24
    UCSR0C |= (stop_bits<<USBS0);
    2294:	80 81       	ld	r24, Z
    2296:	44 0f       	add	r20, r20
    2298:	44 0f       	add	r20, r20
    229a:	44 0f       	add	r20, r20
    229c:	84 2b       	or	r24, r20
    229e:	80 83       	st	Z, r24
	UCSR0C |= (data_bits<<UCSZ0);
    22a0:	80 81       	ld	r24, Z
    22a2:	22 0f       	add	r18, r18
    22a4:	82 2b       	or	r24, r18
    22a6:	80 83       	st	Z, r24
    

    
    hUsart0.recvFiFo.first = NULL;
    22a8:	10 92 1e 09 	sts	0x091E, r1
    22ac:	10 92 1d 09 	sts	0x091D, r1
    hUsart0.recvFiFo.last  = NULL;
    22b0:	10 92 20 09 	sts	0x0920, r1
    22b4:	10 92 1f 09 	sts	0x091F, r1
    hUsart0.recvFiFo.elements = 5;    
    22b8:	25 e0       	ldi	r18, 0x05	; 5
    22ba:	20 93 21 09 	sts	0x0921, r18
    hUsart0.recvCount  = hUsart0.recvBuffer;
    22be:	89 e2       	ldi	r24, 0x29	; 41
    22c0:	98 e0       	ldi	r25, 0x08	; 8
    22c2:	90 93 a2 08 	sts	0x08A2, r25
    22c6:	80 93 a1 08 	sts	0x08A1, r24
    
    hUsart0.sendFiFo.first = NULL;
    22ca:	10 92 23 09 	sts	0x0923, r1
    22ce:	10 92 22 09 	sts	0x0922, r1
    hUsart0.sendFiFo.last  = NULL;
    22d2:	10 92 25 09 	sts	0x0925, r1
    22d6:	10 92 24 09 	sts	0x0924, r1
    hUsart0.sendFiFo.elements = 5;
    22da:	20 93 26 09 	sts	0x0926, r18
    hUsart0.sendCount  = hUsart0.sendBuffer+COM0_MAX_TX_BUF;
    22de:	8b e1       	ldi	r24, 0x1B	; 27
    22e0:	99 e0       	ldi	r25, 0x09	; 9
    22e2:	90 93 1c 09 	sts	0x091C, r25
    22e6:	80 93 1b 09 	sts	0x091B, r24
    
    hUsart0.timeout = timerAddTimeout(COM0_TIMEOUT,onCom0Timeout);
    22ea:	80 e0       	ldi	r24, 0x00	; 0
    22ec:	92 e0       	ldi	r25, 0x02	; 2
    22ee:	61 ee       	ldi	r22, 0xE1	; 225
    22f0:	71 e1       	ldi	r23, 0x11	; 17
    22f2:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <timerAddTimeout>
    22f6:	90 93 28 09 	sts	0x0928, r25
    22fa:	80 93 27 09 	sts	0x0927, r24
    
    return;
  }
    22fe:	08 95       	ret

00002300 <com0RotateRecvBuffer>:




  void com0RotateRecvBuffer()
  {
    2300:	ef 92       	push	r14
    2302:	ff 92       	push	r15
    2304:	1f 93       	push	r17
    2306:	cf 93       	push	r28
    2308:	df 93       	push	r29
    // We should rotate the Recv Buffers, therefore we have to disable...
    // ...the RX interrupt. If a interrupt would fire, while we rotate the
    // ... Buffer, we would mostlikely endup in a crash due to illeagal... 
    // ... memory allocations.
    UCSR0B &= ~(1 << RXCIE0);
    230a:	57 98       	cbi	0x0a, 7	; 10


    
    // Reject adding to queue, if it is full..
    if (queueIsFull(&hUsart0.recvFiFo) == 0)
    230c:	8d e1       	ldi	r24, 0x1D	; 29
    230e:	99 e0       	ldi	r25, 0x09	; 9
    2310:	0e 94 0e 10 	call	0x201c	; 0x201c <queueIsFull>
    2314:	88 23       	and	r24, r24
    2316:	81 f5       	brne	.+96     	; 0x2378 <com0RotateRecvBuffer+0x78>
    {


      // create a new queue element
      struct queueElement_t* node 
        = (struct queueElement_t*) malloc(sizeof(struct queueElement_t));
    2318:	85 e0       	ldi	r24, 0x05	; 5
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    2320:	ec 01       	movw	r28, r24

    
      // ... if the buffer is empty we can do a short cut...
      if (hUsart0.recvCount != hUsart0.recvBuffer)
    2322:	80 91 a1 08 	lds	r24, 0x08A1
    2326:	90 91 a2 08 	lds	r25, 0x08A2
    232a:	29 e2       	ldi	r18, 0x29	; 41
    232c:	e2 2e       	mov	r14, r18
    232e:	28 e0       	ldi	r18, 0x08	; 8
    2330:	f2 2e       	mov	r15, r18
    2332:	8e 15       	cp	r24, r14
    2334:	9f 05       	cpc	r25, r15
    2336:	99 f1       	breq	.+102    	; 0x239e <com0RotateRecvBuffer+0x9e>
      {
        // calculate the length
        uint8_t len = hUsart0.recvCount-hUsart0.recvBuffer;
    2338:	18 2f       	mov	r17, r24
    233a:	1e 19       	sub	r17, r14
      
        node->len = len;
    233c:	1c 83       	std	Y+4, r17	; 0x04
        node->buffer = (char*) malloc(len);
    233e:	81 2f       	mov	r24, r17
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    2346:	8a 83       	std	Y+2, r24	; 0x02
    2348:	9b 83       	std	Y+3, r25	; 0x03
      
        // copy buffer
        while (len--)
    234a:	11 23       	and	r17, r17
    234c:	79 f0       	breq	.+30     	; 0x236c <com0RotateRecvBuffer+0x6c>
    234e:	31 2f       	mov	r19, r17
    2350:	31 50       	subi	r19, 0x01	; 1
        {
          node->buffer[len] = hUsart0.recvBuffer[len];
    2352:	83 2f       	mov	r24, r19
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	fc 01       	movw	r30, r24
    2358:	e7 5d       	subi	r30, 0xD7	; 215
    235a:	f7 4f       	sbci	r31, 0xF7	; 247
    235c:	20 81       	ld	r18, Z
    235e:	ea 81       	ldd	r30, Y+2	; 0x02
    2360:	fb 81       	ldd	r31, Y+3	; 0x03
    2362:	e8 0f       	add	r30, r24
    2364:	f9 1f       	adc	r31, r25
    2366:	20 83       	st	Z, r18
      
        node->len = len;
        node->buffer = (char*) malloc(len);
      
        // copy buffer
        while (len--)
    2368:	31 50       	subi	r19, 0x01	; 1
    236a:	98 f7       	brcc	.-26     	; 0x2352 <com0RotateRecvBuffer+0x52>
      }
     
    	
    
      // enqueue the recevived data
      pushQueueEntry(&hUsart0.recvFiFo,(struct queueNode_t*)node);
    236c:	8d e1       	ldi	r24, 0x1D	; 29
    236e:	99 e0       	ldi	r25, 0x09	; 9
    2370:	be 01       	movw	r22, r28
    2372:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <pushQueueEntry>
    2376:	08 c0       	rjmp	.+16     	; 0x2388 <com0RotateRecvBuffer+0x88>

	  
    }//if(queu is full)
	else
	{
		putString("achtung zu vile daten");
    2378:	8f eb       	ldi	r24, 0xBF	; 191
    237a:	91 e0       	ldi	r25, 0x01	; 1
    237c:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    2380:	89 e2       	ldi	r24, 0x29	; 41
    2382:	e8 2e       	mov	r14, r24
    2384:	88 e0       	ldi	r24, 0x08	; 8
    2386:	f8 2e       	mov	r15, r24
	}
      
      // ... finally don't forget to reset our helper to the base address
    hUsart0.recvCount = hUsart0.recvBuffer;
    2388:	f0 92 a2 08 	sts	0x08A2, r15
    238c:	e0 92 a1 08 	sts	0x08A1, r14
    
    // As we are done with the RX Buffer it's now save to reenable the interrupt
    UCSR0B |= (1 << RXCIE0);
    2390:	57 9a       	sbi	0x0a, 7	; 10

  }
    2392:	df 91       	pop	r29
    2394:	cf 91       	pop	r28
    2396:	1f 91       	pop	r17
    2398:	ff 90       	pop	r15
    239a:	ef 90       	pop	r14
    239c:	08 95       	ret

      }
      else
      {
        // thats the short cut for empty buffers
        node->len = 0;
    239e:	1c 82       	std	Y+4, r1	; 0x04
        node->buffer = NULL;
    23a0:	1b 82       	std	Y+3, r1	; 0x03
    23a2:	1a 82       	std	Y+2, r1	; 0x02

		//here we send an iamalive paket over config channel too
		//but only if there is not stored an commandanswer already

		if(CommandBuffer.NewCommand==0)
    23a4:	80 91 60 09 	lds	r24, 0x0960
    23a8:	88 23       	and	r24, r24
    23aa:	01 f7       	brne	.-64     	; 0x236c <com0RotateRecvBuffer+0x6c>
		{
			rtpSendCommand("iamalive", 0, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    23ac:	86 eb       	ldi	r24, 0xB6	; 182
    23ae:	91 e0       	ldi	r25, 0x01	; 1
    23b0:	60 e0       	ldi	r22, 0x00	; 0
    23b2:	70 e0       	ldi	r23, 0x00	; 0
    23b4:	40 e3       	ldi	r20, 0x30	; 48
    23b6:	59 e0       	ldi	r21, 0x09	; 9
    23b8:	26 e3       	ldi	r18, 0x36	; 54
    23ba:	39 e0       	ldi	r19, 0x09	; 9
    23bc:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
    23c0:	d5 cf       	rjmp	.-86     	; 0x236c <com0RotateRecvBuffer+0x6c>

000023c2 <onCom0Timeout>:


    // If we are here, we obviously have to rotate the buffers.

	
    com0RotateRecvBuffer();
    23c2:	0e 94 80 11 	call	0x2300	; 0x2300 <com0RotateRecvBuffer>


        
    //Keep the timer up and running...
    hUsart0.timeout = timerAddTimeout(COM0_TIMEOUT,onCom0Timeout);
    23c6:	80 e0       	ldi	r24, 0x00	; 0
    23c8:	92 e0       	ldi	r25, 0x02	; 2
    23ca:	61 ee       	ldi	r22, 0xE1	; 225
    23cc:	71 e1       	ldi	r23, 0x11	; 17
    23ce:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <timerAddTimeout>
    23d2:	90 93 28 09 	sts	0x0928, r25
    23d6:	80 93 27 09 	sts	0x0927, r24
	
  }
    23da:	08 95       	ret

000023dc <__vector_18>:
    UCSR0B |= (1 << UDRIE0);
  }
  
  
  ISR (USART0_RX_vect)
  {
    23dc:	1f 92       	push	r1
    23de:	0f 92       	push	r0
    23e0:	0f b6       	in	r0, 0x3f	; 63
    23e2:	0f 92       	push	r0
    23e4:	0b b6       	in	r0, 0x3b	; 59
    23e6:	0f 92       	push	r0
    23e8:	11 24       	eor	r1, r1
    23ea:	2f 93       	push	r18
    23ec:	3f 93       	push	r19
    23ee:	4f 93       	push	r20
    23f0:	5f 93       	push	r21
    23f2:	6f 93       	push	r22
    23f4:	7f 93       	push	r23
    23f6:	8f 93       	push	r24
    23f8:	9f 93       	push	r25
    23fa:	af 93       	push	r26
    23fc:	bf 93       	push	r27
    23fe:	ef 93       	push	r30
    2400:	ff 93       	push	r31

	

	while (!(UCSR0A&32));
    2402:	5d 9b       	sbis	0x0b, 5	; 11
    2404:	fe cf       	rjmp	.-4      	; 0x2402 <__vector_18+0x26>
	char x=UDR0;
    2406:	8c b1       	in	r24, 0x0c	; 12
    // Save the received byte...
    hUsart0.recvCount[0] = x;
    2408:	e0 91 a1 08 	lds	r30, 0x08A1
    240c:	f0 91 a2 08 	lds	r31, 0x08A2
    2410:	80 83       	st	Z, r24


    // increase our helper...
    hUsart0.recvCount++;
    2412:	80 91 a1 08 	lds	r24, 0x08A1
    2416:	90 91 a2 08 	lds	r25, 0x08A2
    241a:	01 96       	adiw	r24, 0x01	; 1
    241c:	90 93 a2 08 	sts	0x08A2, r25
    2420:	80 93 a1 08 	sts	0x08A1, r24
    
    // ... and check, if we need to rotate the buffer
    if (hUsart0.recvCount < (hUsart0.recvBuffer+COM0_MAX_RX_BUF))
    2424:	81 5a       	subi	r24, 0xA1	; 161
    2426:	98 40       	sbci	r25, 0x08	; 8
    2428:	10 f0       	brcs	.+4      	; 0x242e <__vector_18+0x52>
      return;
  
    com0RotateRecvBuffer();
    242a:	0e 94 80 11 	call	0x2300	; 0x2300 <com0RotateRecvBuffer>
    
    return;
  }
    242e:	ff 91       	pop	r31
    2430:	ef 91       	pop	r30
    2432:	bf 91       	pop	r27
    2434:	af 91       	pop	r26
    2436:	9f 91       	pop	r25
    2438:	8f 91       	pop	r24
    243a:	7f 91       	pop	r23
    243c:	6f 91       	pop	r22
    243e:	5f 91       	pop	r21
    2440:	4f 91       	pop	r20
    2442:	3f 91       	pop	r19
    2444:	2f 91       	pop	r18
    2446:	0f 90       	pop	r0
    2448:	0b be       	out	0x3b, r0	; 59
    244a:	0f 90       	pop	r0
    244c:	0f be       	out	0x3f, r0	; 63
    244e:	0f 90       	pop	r0
    2450:	1f 90       	pop	r1
    2452:	18 95       	reti

00002454 <__vector_19>:

  ISR (USART0_UDRE_vect )
  {
    2454:	1f 92       	push	r1
    2456:	0f 92       	push	r0
    2458:	0f b6       	in	r0, 0x3f	; 63
    245a:	0f 92       	push	r0
    245c:	0b b6       	in	r0, 0x3b	; 59
    245e:	0f 92       	push	r0
    2460:	11 24       	eor	r1, r1
    2462:	2f 93       	push	r18
    2464:	3f 93       	push	r19
    2466:	4f 93       	push	r20
    2468:	5f 93       	push	r21
    246a:	6f 93       	push	r22
    246c:	7f 93       	push	r23
    246e:	8f 93       	push	r24
    2470:	9f 93       	push	r25
    2472:	af 93       	push	r26
    2474:	bf 93       	push	r27
    2476:	cf 93       	push	r28
    2478:	df 93       	push	r29
    247a:	ef 93       	push	r30
    247c:	ff 93       	push	r31
    // we actually do here something nasty...
    // ... we are referencing against the top address instead of the base address
    UDR0 = hUsart0.sendCount[0];
    247e:	e0 91 1b 09 	lds	r30, 0x091B
    2482:	f0 91 1c 09 	lds	r31, 0x091C
    2486:	80 81       	ld	r24, Z
    2488:	8c b9       	out	0x0c, r24	; 12
    
    // check if we need to rotate buffers...
    if (hUsart0.sendCount < (hUsart0.sendBuffer+COM0_MAX_TX_BUF-1))
    248a:	89 e0       	ldi	r24, 0x09	; 9
    248c:	ea 31       	cpi	r30, 0x1A	; 26
    248e:	f8 07       	cpc	r31, r24
    2490:	d0 f4       	brcc	.+52     	; 0x24c6 <__vector_19+0x72>
    {
      
      hUsart0.sendCount++;
    2492:	31 96       	adiw	r30, 0x01	; 1
    2494:	f0 93 1c 09 	sts	0x091C, r31
    2498:	e0 93 1b 09 	sts	0x091B, r30
   
    
    com0RotateSendBuffer();
        
    return;
  }    
    249c:	ff 91       	pop	r31
    249e:	ef 91       	pop	r30
    24a0:	df 91       	pop	r29
    24a2:	cf 91       	pop	r28
    24a4:	bf 91       	pop	r27
    24a6:	af 91       	pop	r26
    24a8:	9f 91       	pop	r25
    24aa:	8f 91       	pop	r24
    24ac:	7f 91       	pop	r23
    24ae:	6f 91       	pop	r22
    24b0:	5f 91       	pop	r21
    24b2:	4f 91       	pop	r20
    24b4:	3f 91       	pop	r19
    24b6:	2f 91       	pop	r18
    24b8:	0f 90       	pop	r0
    24ba:	0b be       	out	0x3b, r0	; 59
    24bc:	0f 90       	pop	r0
    24be:	0f be       	out	0x3f, r0	; 63
    24c0:	0f 90       	pop	r0
    24c2:	1f 90       	pop	r1
    24c4:	18 95       	reti
      hUsart0.sendCount++;
      return;
    }
      
    // nothing to rotate?
    if (queueIsEmpty(&hUsart0.sendFiFo))    
    24c6:	82 e2       	ldi	r24, 0x22	; 34
    24c8:	99 e0       	ldi	r25, 0x09	; 9
    24ca:	0e 94 05 10 	call	0x200a	; 0x200a <queueIsEmpty>
    24ce:	88 23       	and	r24, r24
    24d0:	11 f0       	breq	.+4      	; 0x24d6 <__vector_19+0x82>
    {
      // so disable the send interrupt...
      UCSR0B &= ~ (1 << UDRIE0);
    24d2:	55 98       	cbi	0x0a, 5	; 10
    24d4:	e3 cf       	rjmp	.-58     	; 0x249c <__vector_19+0x48>
    
    /* !!! IF YOU MOFIFY THIS BLOCK ALWAYS SYNC IT WITH THE CODE !!! */ 
    /* !!! IN com0SendBytes()                                    !!! */
    
    // in order to ayoid timing issues, disable TX Interrupt
    UCSR0B &= ~ (1 << UDRIE0);
    24d6:	55 98       	cbi	0x0a, 5	; 10
   
    struct queueElement_t* node
      = (struct queueElement_t*) popQueueEntry(&hUsart0.sendFiFo);
    24d8:	82 e2       	ldi	r24, 0x22	; 34
    24da:	99 e0       	ldi	r25, 0x09	; 9
    24dc:	0e 94 16 10 	call	0x202c	; 0x202c <popQueueEntry>
    24e0:	ec 01       	movw	r28, r24
    
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    24e2:	8c 81       	ldd	r24, Y+4	; 0x04
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    24e4:	48 e7       	ldi	r20, 0x78	; 120
    24e6:	50 e0       	ldi	r21, 0x00	; 0
    24e8:	48 1b       	sub	r20, r24
    24ea:	51 09       	sbc	r21, r1
    24ec:	4d 55       	subi	r20, 0x5D	; 93
    24ee:	57 4f       	sbci	r21, 0xF7	; 247
    
    while (len--)
    24f0:	88 23       	and	r24, r24
    24f2:	09 f1       	breq	.+66     	; 0x2536 <__vector_19+0xe2>
    24f4:	28 2f       	mov	r18, r24
    24f6:	21 50       	subi	r18, 0x01	; 1
    {
      worker[len] = node->buffer[len];
    24f8:	82 2f       	mov	r24, r18
    24fa:	90 e0       	ldi	r25, 0x00	; 0
    24fc:	da 01       	movw	r26, r20
    24fe:	a8 0f       	add	r26, r24
    2500:	b9 1f       	adc	r27, r25
    2502:	ea 81       	ldd	r30, Y+2	; 0x02
    2504:	fb 81       	ldd	r31, Y+3	; 0x03
    2506:	e8 0f       	add	r30, r24
    2508:	f9 1f       	adc	r31, r25
    250a:	80 81       	ld	r24, Z
    250c:	8c 93       	st	X, r24
    // we use top aligned blocks, this saves lots of processing time...
    // ... but makes live more complicated
    uint8_t len = node->len;
    char* worker = (char*) (hUsart0.sendBuffer+COM0_MAX_TX_BUF-len);    
    
    while (len--)
    250e:	21 50       	subi	r18, 0x01	; 1
    2510:	98 f7       	brcc	.-26     	; 0x24f8 <__vector_19+0xa4>
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    2512:	8c e1       	ldi	r24, 0x1C	; 28
    2514:	98 e0       	ldi	r25, 0x08	; 8
    2516:	90 93 1c 09 	sts	0x091C, r25
    251a:	80 93 1b 09 	sts	0x091B, r24
    
    if (node->len > 0) 
    251e:	8c 81       	ldd	r24, Y+4	; 0x04
    2520:	88 23       	and	r24, r24
    2522:	21 f0       	breq	.+8      	; 0x252c <__vector_19+0xd8>
      free(node->buffer);
    2524:	8a 81       	ldd	r24, Y+2	; 0x02
    2526:	9b 81       	ldd	r25, Y+3	; 0x03
    2528:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
    free(node);
    252c:	ce 01       	movw	r24, r28
    252e:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
  
    // reenable TX Interrupts...
    UCSR0B |= (1 << UDRIE0);
    2532:	55 9a       	sbi	0x0a, 5	; 10
    2534:	b3 cf       	rjmp	.-154    	; 0x249c <__vector_19+0x48>
    while (len--)
    {
      worker[len] = node->buffer[len];
    }   

    hUsart0.sendCount = hUsart0.sendBuffer+COM0_MAX_TX_BUF-len;
    2536:	8c e1       	ldi	r24, 0x1C	; 28
    2538:	98 e0       	ldi	r25, 0x08	; 8
    253a:	90 93 1c 09 	sts	0x091C, r25
    253e:	80 93 1b 09 	sts	0x091B, r24
    2542:	f4 cf       	rjmp	.-24     	; 0x252c <__vector_19+0xd8>

00002544 <enc28j60_write>:
  uint8_t bank;
} hEnc28j60;


void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
    2544:	fb 01       	movw	r30, r22
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2546:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2548:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    254a:	77 9b       	sbis	0x0e, 7	; 14
    254c:	fe cf       	rjmp	.-4      	; 0x254a <enc28j60_write+0x6>

  while(length--)
    254e:	41 15       	cp	r20, r1
    2550:	51 05       	cpc	r21, r1
    2552:	41 f0       	breq	.+16     	; 0x2564 <enc28j60_write+0x20>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2554:	80 81       	ld	r24, Z
    2556:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2558:	77 9b       	sbis	0x0e, 7	; 14
    255a:	fe cf       	rjmp	.-4      	; 0x2558 <enc28j60_write+0x14>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    255c:	31 96       	adiw	r30, 0x01	; 1
    255e:	41 50       	subi	r20, 0x01	; 1
    2560:	50 40       	sbci	r21, 0x00	; 0
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2562:	c1 f7       	brne	.-16     	; 0x2554 <enc28j60_write+0x10>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2564:	c0 9a       	sbi	0x18, 0	; 24
  
  return;
}
    2566:	08 95       	ret

00002568 <enc28j60_write_byte>:

// generate some inline helper functions, which is pretty much the same 
// ... as a macro, except they can't cause syntax errors...
void enc28j60_write_byte(uint8_t command, uint8_t buffer)
{
    2568:	df 93       	push	r29
    256a:	cf 93       	push	r28
    256c:	0f 92       	push	r0
    256e:	cd b7       	in	r28, 0x3d	; 61
    2570:	de b7       	in	r29, 0x3e	; 62
    2572:	69 83       	std	Y+1, r22	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2574:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2576:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2578:	77 9b       	sbis	0x0e, 7	; 14
    257a:	fe cf       	rjmp	.-4      	; 0x2578 <enc28j60_write_byte+0x10>
    257c:	fe 01       	movw	r30, r28
    257e:	31 96       	adiw	r30, 0x01	; 1
    2580:	9e 01       	movw	r18, r28
    2582:	2e 5f       	subi	r18, 0xFE	; 254
    2584:	3f 4f       	sbci	r19, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2586:	81 91       	ld	r24, Z+
    2588:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    258a:	77 9b       	sbis	0x0e, 7	; 14
    258c:	fe cf       	rjmp	.-4      	; 0x258a <enc28j60_write_byte+0x22>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    258e:	e2 17       	cp	r30, r18
    2590:	f3 07       	cpc	r31, r19
    2592:	c9 f7       	brne	.-14     	; 0x2586 <enc28j60_write_byte+0x1e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2594:	c0 9a       	sbi	0x18, 0	; 24
// generate some inline helper functions, which is pretty much the same 
// ... as a macro, except they can't cause syntax errors...
void enc28j60_write_byte(uint8_t command, uint8_t buffer)
{
  return enc28j60_write(command, &buffer, 1);
}
    2596:	0f 90       	pop	r0
    2598:	cf 91       	pop	r28
    259a:	df 91       	pop	r29
    259c:	08 95       	ret

0000259e <enc28j60_read>:


void enc28j60_read(uint8_t command, void* buffer, uint16_t length, uint8_t offset)
{
    259e:	fb 01       	movw	r30, r22

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    25a0:	c0 98       	cbi	0x18, 0	; 24

  //start read cmd:
  SPDR = command;
    25a2:	8f b9       	out	0x0f, r24	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    25a4:	77 9b       	sbis	0x0e, 7	; 14
    25a6:	fe cf       	rjmp	.-4      	; 0x25a4 <enc28j60_read+0x6>

  // Ignore dummy bytes...
  while(offset--) 
    25a8:	22 23       	and	r18, r18
    25aa:	29 f0       	breq	.+10     	; 0x25b6 <enc28j60_read+0x18>
  {
    SPDR = 0x00;
    25ac:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    25ae:	77 9b       	sbis	0x0e, 7	; 14
    25b0:	fe cf       	rjmp	.-4      	; 0x25ae <enc28j60_read+0x10>
    25b2:	21 50       	subi	r18, 0x01	; 1
  SPDR = command;
  //wait for completion
  while(!(SPSR & (1<<SPIF)));

  // Ignore dummy bytes...
  while(offset--) 
    25b4:	d9 f7       	brne	.-10     	; 0x25ac <enc28j60_read+0xe>
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    25b6:	41 15       	cp	r20, r1
    25b8:	51 05       	cpc	r21, r1
    25ba:	51 f0       	breq	.+20     	; 0x25d0 <enc28j60_read+0x32>
  {    
    SPDR = 0x00;
    25bc:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    25be:	77 9b       	sbis	0x0e, 7	; 14
    25c0:	fe cf       	rjmp	.-4      	; 0x25be <enc28j60_read+0x20>
    *((uint8_t*)(buffer++)) = SPDR;
    25c2:	8f b1       	in	r24, 0x0f	; 15
    25c4:	80 83       	st	Z, r24
    25c6:	41 50       	subi	r20, 0x01	; 1
    25c8:	50 40       	sbci	r21, 0x00	; 0
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    25ca:	11 f0       	breq	.+4      	; 0x25d0 <enc28j60_read+0x32>
  {    
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
    25cc:	31 96       	adiw	r30, 0x01	; 1
    25ce:	f6 cf       	rjmp	.-20     	; 0x25bc <enc28j60_read+0x1e>
  }

  // CS auf high
  PORTB |= (1<<PB0);
    25d0:	c0 9a       	sbi	0x18, 0	; 24
	
  return;
}
    25d2:	08 95       	ret

000025d4 <enc28j60_select_bank>:


void enc28j60_select_bank(uint8_t address)
{
    25d4:	df 93       	push	r29
    25d6:	cf 93       	push	r28
    25d8:	0f 92       	push	r0
    25da:	cd b7       	in	r28, 0x3d	; 61
    25dc:	de b7       	in	r29, 0x3e	; 62
    25de:	48 2f       	mov	r20, r24

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    25e0:	87 fd       	sbrc	r24, 7
    25e2:	3b c0       	rjmp	.+118    	; 0x265a <enc28j60_select_bank+0x86>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    25e4:	28 2f       	mov	r18, r24
    25e6:	30 e0       	ldi	r19, 0x00	; 0
    25e8:	20 76       	andi	r18, 0x60	; 96
    25ea:	30 70       	andi	r19, 0x00	; 0
    25ec:	80 91 29 09 	lds	r24, 0x0929
    25f0:	90 e0       	ldi	r25, 0x00	; 0
    25f2:	82 17       	cp	r24, r18
    25f4:	93 07       	cpc	r25, r19
    25f6:	89 f1       	breq	.+98     	; 0x265a <enc28j60_select_bank+0x86>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    25f8:	83 e0       	ldi	r24, 0x03	; 3
    25fa:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    25fc:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    25fe:	8f eb       	ldi	r24, 0xBF	; 191
    2600:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2602:	77 9b       	sbis	0x0e, 7	; 14
    2604:	fe cf       	rjmp	.-4      	; 0x2602 <enc28j60_select_bank+0x2e>
    2606:	be 01       	movw	r22, r28
    2608:	6f 5f       	subi	r22, 0xFF	; 255
    260a:	7f 4f       	sbci	r23, 0xFF	; 255
    260c:	fb 01       	movw	r30, r22
    260e:	de 01       	movw	r26, r28
    2610:	12 96       	adiw	r26, 0x02	; 2

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2612:	81 91       	ld	r24, Z+
    2614:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2616:	77 9b       	sbis	0x0e, 7	; 14
    2618:	fe cf       	rjmp	.-4      	; 0x2616 <enc28j60_select_bank+0x42>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    261a:	ea 17       	cp	r30, r26
    261c:	fb 07       	cpc	r31, r27
    261e:	c9 f7       	brne	.-14     	; 0x2612 <enc28j60_select_bank+0x3e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2620:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2622:	35 95       	asr	r19
    2624:	27 95       	ror	r18
    2626:	35 95       	asr	r19
    2628:	27 95       	ror	r18
    262a:	35 95       	asr	r19
    262c:	27 95       	ror	r18
    262e:	35 95       	asr	r19
    2630:	27 95       	ror	r18
    2632:	35 95       	asr	r19
    2634:	27 95       	ror	r18
    2636:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2638:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    263a:	8f e9       	ldi	r24, 0x9F	; 159
    263c:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    263e:	77 9b       	sbis	0x0e, 7	; 14
    2640:	fe cf       	rjmp	.-4      	; 0x263e <enc28j60_select_bank+0x6a>
    2642:	fb 01       	movw	r30, r22

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2644:	81 91       	ld	r24, Z+
    2646:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2648:	77 9b       	sbis	0x0e, 7	; 14
    264a:	fe cf       	rjmp	.-4      	; 0x2648 <enc28j60_select_bank+0x74>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    264c:	ea 17       	cp	r30, r26
    264e:	fb 07       	cpc	r31, r27
    2650:	c9 f7       	brne	.-14     	; 0x2644 <enc28j60_select_bank+0x70>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2652:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2654:	40 76       	andi	r20, 0x60	; 96
    2656:	40 93 29 09 	sts	0x0929, r20

  return;
}
    265a:	0f 90       	pop	r0
    265c:	cf 91       	pop	r28
    265e:	df 91       	pop	r29
    2660:	08 95       	ret

00002662 <enc28j60_init>:
 
  // Als erstes den SPI Bus aktivieren

  // Set MOSI, SS and SCK output, all others input
  //DDRB = (1<<DDB2)|(1<<DDB1) | (1 << PB4);
  DDRB = (1<<PB2 ) | (1<<PB1) | (1<<PB0);
    2662:	87 e0       	ldi	r24, 0x07	; 7
    2664:	87 bb       	out	0x17, r24	; 23

  // MISO = IN
  DDRB &= ~(1<<PB3); 
    2666:	bb 98       	cbi	0x17, 3	; 23

  // Pull up Chipselect to high...
  PORTB |= (1<<PB0);
    2668:	c0 9a       	sbi	0x18, 0	; 24

  // Enable SPI, Master, set clock rate 
  SPCR = (0<<CPOL)|(1<<MSTR)|(0<<DORD)/*|(0<<SPR1)|(0<<SPR0)*/|(1<<SPE);
    266a:	80 e5       	ldi	r24, 0x50	; 80
    266c:	8d b9       	out	0x0d, r24	; 13

  // Double SPI clock
  SPSR = (1<<SPI2X);
    266e:	81 e0       	ldi	r24, 0x01	; 1
    2670:	8e b9       	out	0x0e, r24	; 14

  // TODO: Werden structs nicht automatisch genullt?
  hEnc28j60.bank = 0;
    2672:	10 92 29 09 	sts	0x0929, r1

  return;
}
    2676:	08 95       	ret

00002678 <enc28j60_calcOffset>:
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    2678:	90 e0       	ldi	r25, 0x00	; 0
    267a:	80 76       	andi	r24, 0x60	; 96
    267c:	90 70       	andi	r25, 0x00	; 0
    267e:	80 34       	cpi	r24, 0x40	; 64
    2680:	91 05       	cpc	r25, r1
    2682:	31 f0       	breq	.+12     	; 0x2690 <enc28j60_calcOffset+0x18>
    2684:	20 e0       	ldi	r18, 0x00	; 0
    2686:	80 36       	cpi	r24, 0x60	; 96
    2688:	91 05       	cpc	r25, r1
    268a:	11 f0       	breq	.+4      	; 0x2690 <enc28j60_calcOffset+0x18>
  {
    return 1;
  }

  return 0;  
}
    268c:	82 2f       	mov	r24, r18
    268e:	08 95       	ret
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    2690:	21 e0       	ldi	r18, 0x01	; 1
  {
    return 1;
  }

  return 0;  
}
    2692:	82 2f       	mov	r24, r18
    2694:	08 95       	ret

00002696 <enc28j60_bmputs>:



// Write Buffer Register, the byte order is not swaped!
void enc28j60_bmputs(const void* buffer, uint16_t len)
{
    2696:	fc 01       	movw	r30, r24

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2698:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    269a:	8a e7       	ldi	r24, 0x7A	; 122
    269c:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    269e:	77 9b       	sbis	0x0e, 7	; 14
    26a0:	fe cf       	rjmp	.-4      	; 0x269e <enc28j60_bmputs+0x8>

  while(length--)
    26a2:	61 15       	cp	r22, r1
    26a4:	71 05       	cpc	r23, r1
    26a6:	41 f0       	breq	.+16     	; 0x26b8 <enc28j60_bmputs+0x22>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    26a8:	80 81       	ld	r24, Z
    26aa:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    26ac:	77 9b       	sbis	0x0e, 7	; 14
    26ae:	fe cf       	rjmp	.-4      	; 0x26ac <enc28j60_bmputs+0x16>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    26b0:	31 96       	adiw	r30, 0x01	; 1
    26b2:	61 50       	subi	r22, 0x01	; 1
    26b4:	70 40       	sbci	r23, 0x00	; 0
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    26b6:	c1 f7       	brne	.-16     	; 0x26a8 <enc28j60_bmputs+0x12>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    26b8:	c0 9a       	sbi	0x18, 0	; 24
// Write Buffer Register, the byte order is not swaped!
void enc28j60_bmputs(const void* buffer, uint16_t len)
{
  enc28j60_write(ENC_OP_WBM,buffer, len);
  return;
}
    26ba:	08 95       	ret

000026bc <enc28j60_reset>:

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    26bc:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    26be:	8f ef       	ldi	r24, 0xFF	; 255
    26c0:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    26c2:	77 9b       	sbis	0x0e, 7	; 14
    26c4:	fe cf       	rjmp	.-4      	; 0x26c2 <enc28j60_reset+0x6>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    26c6:	c0 9a       	sbi	0x18, 0	; 24
// Soft Reset
void enc28j60_reset()
{ 
  enc28j60_write(0xFF,0,0);
  return;
}
    26c8:	08 95       	ret

000026ca <enc28j60_bmgetc>:
******************************************************************************************/


// Read a char from Buffer Memory
uint8_t  enc28j60_bmgetc()
{
    26ca:	df 93       	push	r29
    26cc:	cf 93       	push	r28
    26ce:	0f 92       	push	r0
    26d0:	cd b7       	in	r28, 0x3d	; 61
    26d2:	de b7       	in	r29, 0x3e	; 62

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    26d4:	c0 98       	cbi	0x18, 0	; 24

  //start read cmd:
  SPDR = command;
    26d6:	8a e3       	ldi	r24, 0x3A	; 58
    26d8:	8f b9       	out	0x0f, r24	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    26da:	77 9b       	sbis	0x0e, 7	; 14
    26dc:	fe cf       	rjmp	.-4      	; 0x26da <enc28j60_bmgetc+0x10>
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
  {    
    SPDR = 0x00;
    26de:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    26e0:	77 9b       	sbis	0x0e, 7	; 14
    26e2:	fe cf       	rjmp	.-4      	; 0x26e0 <enc28j60_bmgetc+0x16>
    *((uint8_t*)(buffer++)) = SPDR;
    26e4:	8f b1       	in	r24, 0x0f	; 15
    26e6:	89 83       	std	Y+1, r24	; 0x01
  }

  // CS auf high
  PORTB |= (1<<PB0);
    26e8:	c0 9a       	sbi	0x18, 0	; 24
uint8_t  enc28j60_bmgetc()
{
  uint8_t buffer;
  enc28j60_read(ENC_OP_RBM ,&buffer, 1,0);
  return buffer;
}
    26ea:	89 81       	ldd	r24, Y+1	; 0x01
    26ec:	0f 90       	pop	r0
    26ee:	cf 91       	pop	r28
    26f0:	df 91       	pop	r29
    26f2:	08 95       	ret

000026f4 <enc28j60_bmgetw>:
// Read a word from Buffer Memory
uint16_t enc28j60_bmgetw()
{
    26f4:	df 93       	push	r29
    26f6:	cf 93       	push	r28
    26f8:	00 d0       	rcall	.+0      	; 0x26fa <enc28j60_bmgetw+0x6>
    26fa:	cd b7       	in	r28, 0x3d	; 61
    26fc:	de b7       	in	r29, 0x3e	; 62

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    26fe:	c0 98       	cbi	0x18, 0	; 24

  //start read cmd:
  SPDR = command;
    2700:	8a e3       	ldi	r24, 0x3A	; 58
    2702:	8f b9       	out	0x0f, r24	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    2704:	77 9b       	sbis	0x0e, 7	; 14
    2706:	fe cf       	rjmp	.-4      	; 0x2704 <enc28j60_bmgetw+0x10>
    2708:	fe 01       	movw	r30, r28
    270a:	31 96       	adiw	r30, 0x01	; 1
    270c:	9e 01       	movw	r18, r28
    270e:	2e 5f       	subi	r18, 0xFE	; 254
    2710:	3f 4f       	sbci	r19, 0xFF	; 255
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
  {    
    SPDR = 0x00;
    2712:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2714:	77 9b       	sbis	0x0e, 7	; 14
    2716:	fe cf       	rjmp	.-4      	; 0x2714 <enc28j60_bmgetw+0x20>
    *((uint8_t*)(buffer++)) = SPDR;
    2718:	8f b1       	in	r24, 0x0f	; 15
    271a:	80 83       	st	Z, r24
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    271c:	e2 17       	cp	r30, r18
    271e:	f3 07       	cpc	r31, r19
    2720:	11 f0       	breq	.+4      	; 0x2726 <enc28j60_bmgetw+0x32>
  {    
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
    2722:	31 96       	adiw	r30, 0x01	; 1
    2724:	f6 cf       	rjmp	.-20     	; 0x2712 <enc28j60_bmgetw+0x1e>
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2726:	c0 9a       	sbi	0x18, 0	; 24
uint16_t enc28j60_bmgetw()
{
  uint16_t buffer;
  enc28j60_read(ENC_OP_RBM ,&buffer, 2,0);
  return buffer;
}
    2728:	89 81       	ldd	r24, Y+1	; 0x01
    272a:	9a 81       	ldd	r25, Y+2	; 0x02
    272c:	0f 90       	pop	r0
    272e:	0f 90       	pop	r0
    2730:	cf 91       	pop	r28
    2732:	df 91       	pop	r29
    2734:	08 95       	ret

00002736 <enc28j60_bmgets>:
// Read a string from Buffer Memory
void* enc28j60_bmgets(void* buffer, uint16_t len)
{
    2736:	ac 01       	movw	r20, r24

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    2738:	c0 98       	cbi	0x18, 0	; 24

  //start read cmd:
  SPDR = command;
    273a:	8a e3       	ldi	r24, 0x3A	; 58
    273c:	8f b9       	out	0x0f, r24	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    273e:	77 9b       	sbis	0x0e, 7	; 14
    2740:	fe cf       	rjmp	.-4      	; 0x273e <enc28j60_bmgets+0x8>
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    2742:	61 15       	cp	r22, r1
    2744:	71 05       	cpc	r23, r1
    2746:	59 f0       	breq	.+22     	; 0x275e <enc28j60_bmgets+0x28>
    2748:	fa 01       	movw	r30, r20
  {    
    SPDR = 0x00;
    274a:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    274c:	77 9b       	sbis	0x0e, 7	; 14
    274e:	fe cf       	rjmp	.-4      	; 0x274c <enc28j60_bmgets+0x16>
    *((uint8_t*)(buffer++)) = SPDR;
    2750:	8f b1       	in	r24, 0x0f	; 15
    2752:	80 83       	st	Z, r24
    2754:	61 50       	subi	r22, 0x01	; 1
    2756:	70 40       	sbci	r23, 0x00	; 0
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    2758:	11 f0       	breq	.+4      	; 0x275e <enc28j60_bmgets+0x28>
  {    
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
    275a:	31 96       	adiw	r30, 0x01	; 1
    275c:	f6 cf       	rjmp	.-20     	; 0x274a <enc28j60_bmgets+0x14>
  }

  // CS auf high
  PORTB |= (1<<PB0);
    275e:	c0 9a       	sbi	0x18, 0	; 24
// Read a string from Buffer Memory
void* enc28j60_bmgets(void* buffer, uint16_t len)
{
  enc28j60_read(ENC_OP_RBM ,buffer, len,0);
  return buffer;
}
    2760:	ca 01       	movw	r24, r20
    2762:	08 95       	ret

00002764 <enc28j60_rcr2>:
}

// This function is beeing called from the crget* functions.
// It is inline in order to speedup calling and saving stack memeory
void* enc28j60_rcr2(uint8_t address,  void* buffer, uint16_t len)
{
    2764:	ff 92       	push	r15
    2766:	0f 93       	push	r16
    2768:	1f 93       	push	r17
    276a:	df 93       	push	r29
    276c:	cf 93       	push	r28
    276e:	0f 92       	push	r0
    2770:	cd b7       	in	r28, 0x3d	; 61
    2772:	de b7       	in	r29, 0x3e	; 62
    2774:	a8 2f       	mov	r26, r24
    2776:	b6 2f       	mov	r27, r22
    2778:	f7 2e       	mov	r15, r23
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    277a:	87 fd       	sbrc	r24, 7
    277c:	6c c0       	rjmp	.+216    	; 0x2856 <enc28j60_rcr2+0xf2>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    277e:	28 2f       	mov	r18, r24
    2780:	30 e0       	ldi	r19, 0x00	; 0
    2782:	20 76       	andi	r18, 0x60	; 96
    2784:	30 70       	andi	r19, 0x00	; 0
    2786:	80 91 29 09 	lds	r24, 0x0929
    278a:	90 e0       	ldi	r25, 0x00	; 0
    278c:	82 17       	cp	r24, r18
    278e:	93 07       	cpc	r25, r19
    2790:	a1 f1       	breq	.+104    	; 0x27fa <enc28j60_rcr2+0x96>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2792:	83 e0       	ldi	r24, 0x03	; 3
    2794:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2796:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2798:	8f eb       	ldi	r24, 0xBF	; 191
    279a:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    279c:	77 9b       	sbis	0x0e, 7	; 14
    279e:	fe cf       	rjmp	.-4      	; 0x279c <enc28j60_rcr2+0x38>
    27a0:	be 01       	movw	r22, r28
    27a2:	6f 5f       	subi	r22, 0xFF	; 255
    27a4:	7f 4f       	sbci	r23, 0xFF	; 255
    27a6:	fb 01       	movw	r30, r22
    27a8:	8e 01       	movw	r16, r28
    27aa:	0e 5f       	subi	r16, 0xFE	; 254
    27ac:	1f 4f       	sbci	r17, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    27ae:	81 91       	ld	r24, Z+
    27b0:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    27b2:	77 9b       	sbis	0x0e, 7	; 14
    27b4:	fe cf       	rjmp	.-4      	; 0x27b2 <enc28j60_rcr2+0x4e>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    27b6:	e0 17       	cp	r30, r16
    27b8:	f1 07       	cpc	r31, r17
    27ba:	c9 f7       	brne	.-14     	; 0x27ae <enc28j60_rcr2+0x4a>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    27bc:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    27be:	c9 01       	movw	r24, r18
    27c0:	95 95       	asr	r25
    27c2:	87 95       	ror	r24
    27c4:	95 95       	asr	r25
    27c6:	87 95       	ror	r24
    27c8:	95 95       	asr	r25
    27ca:	87 95       	ror	r24
    27cc:	95 95       	asr	r25
    27ce:	87 95       	ror	r24
    27d0:	95 95       	asr	r25
    27d2:	87 95       	ror	r24
    27d4:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    27d6:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    27d8:	8f e9       	ldi	r24, 0x9F	; 159
    27da:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    27dc:	77 9b       	sbis	0x0e, 7	; 14
    27de:	fe cf       	rjmp	.-4      	; 0x27dc <enc28j60_rcr2+0x78>
    27e0:	fb 01       	movw	r30, r22

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    27e2:	81 91       	ld	r24, Z+
    27e4:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    27e6:	77 9b       	sbis	0x0e, 7	; 14
    27e8:	fe cf       	rjmp	.-4      	; 0x27e6 <enc28j60_rcr2+0x82>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    27ea:	e0 17       	cp	r30, r16
    27ec:	f1 07       	cpc	r31, r17
    27ee:	c9 f7       	brne	.-14     	; 0x27e2 <enc28j60_rcr2+0x7e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    27f0:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    27f2:	8a 2f       	mov	r24, r26
    27f4:	80 76       	andi	r24, 0x60	; 96
    27f6:	80 93 29 09 	sts	0x0929, r24
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    27fa:	20 34       	cpi	r18, 0x40	; 64
    27fc:	31 05       	cpc	r19, r1
    27fe:	f9 f0       	breq	.+62     	; 0x283e <enc28j60_rcr2+0xda>
    2800:	80 e0       	ldi	r24, 0x00	; 0
    2802:	20 36       	cpi	r18, 0x60	; 96
    2804:	31 05       	cpc	r19, r1
    2806:	d9 f0       	breq	.+54     	; 0x283e <enc28j60_rcr2+0xda>

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    2808:	c0 98       	cbi	0x18, 0	; 24
{
  // switch to the corresponding memory bank
  enc28j60_select_bank(address);  
  
  // ... then start reading...
  enc28j60_read(ENC_OP_RCR | (address & ENC_MASK_REGADR), buffer, len, enc28j60_calcOffset(address));
    280a:	af 71       	andi	r26, 0x1F	; 31

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);

  //start read cmd:
  SPDR = command;
    280c:	af b9       	out	0x0f, r26	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    280e:	77 9b       	sbis	0x0e, 7	; 14
    2810:	fe cf       	rjmp	.-4      	; 0x280e <enc28j60_rcr2+0xaa>

  // Ignore dummy bytes...
  while(offset--) 
    2812:	88 23       	and	r24, r24
    2814:	19 f0       	breq	.+6      	; 0x281c <enc28j60_rcr2+0xb8>
  {
    SPDR = 0x00;
    2816:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2818:	77 9b       	sbis	0x0e, 7	; 14
    281a:	fe cf       	rjmp	.-4      	; 0x2818 <enc28j60_rcr2+0xb4>
  }

  while(length--)
    281c:	41 15       	cp	r20, r1
    281e:	51 05       	cpc	r21, r1
    2820:	81 f0       	breq	.+32     	; 0x2842 <enc28j60_rcr2+0xde>
    2822:	8b 2f       	mov	r24, r27
    2824:	9f 2d       	mov	r25, r15
    2826:	9c 01       	movw	r18, r24
    2828:	f9 01       	movw	r30, r18
  {    
    SPDR = 0x00;
    282a:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    282c:	77 9b       	sbis	0x0e, 7	; 14
    282e:	fe cf       	rjmp	.-4      	; 0x282c <enc28j60_rcr2+0xc8>
    *((uint8_t*)(buffer++)) = SPDR;
    2830:	8f b1       	in	r24, 0x0f	; 15
    2832:	80 83       	st	Z, r24
    2834:	41 50       	subi	r20, 0x01	; 1
    2836:	50 40       	sbci	r21, 0x00	; 0
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    2838:	21 f0       	breq	.+8      	; 0x2842 <enc28j60_rcr2+0xde>
  {    
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
    283a:	31 96       	adiw	r30, 0x01	; 1
    283c:	f6 cf       	rjmp	.-20     	; 0x282a <enc28j60_rcr2+0xc6>
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    283e:	81 e0       	ldi	r24, 0x01	; 1
    2840:	e3 cf       	rjmp	.-58     	; 0x2808 <enc28j60_rcr2+0xa4>
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2842:	c0 9a       	sbi	0x18, 0	; 24
  // ... then start reading...
  enc28j60_read(ENC_OP_RCR | (address & ENC_MASK_REGADR), buffer, len, enc28j60_calcOffset(address));
  
  // now return pointer to the buffer for better usability
  return buffer;
}
    2844:	8b 2f       	mov	r24, r27
    2846:	9f 2d       	mov	r25, r15
    2848:	0f 90       	pop	r0
    284a:	cf 91       	pop	r28
    284c:	df 91       	pop	r29
    284e:	1f 91       	pop	r17
    2850:	0f 91       	pop	r16
    2852:	ff 90       	pop	r15
    2854:	08 95       	ret
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2856:	28 2f       	mov	r18, r24
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	20 76       	andi	r18, 0x60	; 96
    285c:	30 70       	andi	r19, 0x00	; 0
    285e:	cd cf       	rjmp	.-102    	; 0x27fa <enc28j60_rcr2+0x96>

00002860 <enc28j60_crbfs>:

******************************************************************************************/

// Bit Field Set
void enc28j60_crbfs(uint8_t address, char flags)
{
    2860:	df 93       	push	r29
    2862:	cf 93       	push	r28
    2864:	00 d0       	rcall	.+0      	; 0x2866 <enc28j60_crbfs+0x6>
    2866:	cd b7       	in	r28, 0x3d	; 61
    2868:	de b7       	in	r29, 0x3e	; 62
    286a:	48 2f       	mov	r20, r24
    286c:	6a 83       	std	Y+2, r22	; 0x02
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    286e:	87 fd       	sbrc	r24, 7
    2870:	54 c0       	rjmp	.+168    	; 0x291a <enc28j60_crbfs+0xba>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2872:	28 2f       	mov	r18, r24
    2874:	30 e0       	ldi	r19, 0x00	; 0
    2876:	20 76       	andi	r18, 0x60	; 96
    2878:	30 70       	andi	r19, 0x00	; 0
    287a:	80 91 29 09 	lds	r24, 0x0929
    287e:	90 e0       	ldi	r25, 0x00	; 0
    2880:	82 17       	cp	r24, r18
    2882:	93 07       	cpc	r25, r19
    2884:	09 f4       	brne	.+2      	; 0x2888 <enc28j60_crbfs+0x28>
    2886:	49 c0       	rjmp	.+146    	; 0x291a <enc28j60_crbfs+0xba>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2888:	83 e0       	ldi	r24, 0x03	; 3
    288a:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    288c:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    288e:	8f eb       	ldi	r24, 0xBF	; 191
    2890:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2892:	77 9b       	sbis	0x0e, 7	; 14
    2894:	fe cf       	rjmp	.-4      	; 0x2892 <enc28j60_crbfs+0x32>
    2896:	de 01       	movw	r26, r28
    2898:	11 96       	adiw	r26, 0x01	; 1
    289a:	fd 01       	movw	r30, r26
    289c:	be 01       	movw	r22, r28
    289e:	6e 5f       	subi	r22, 0xFE	; 254
    28a0:	7f 4f       	sbci	r23, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    28a2:	81 91       	ld	r24, Z+
    28a4:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    28a6:	77 9b       	sbis	0x0e, 7	; 14
    28a8:	fe cf       	rjmp	.-4      	; 0x28a6 <enc28j60_crbfs+0x46>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    28aa:	e6 17       	cp	r30, r22
    28ac:	f7 07       	cpc	r31, r23
    28ae:	c9 f7       	brne	.-14     	; 0x28a2 <enc28j60_crbfs+0x42>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    28b0:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    28b2:	35 95       	asr	r19
    28b4:	27 95       	ror	r18
    28b6:	35 95       	asr	r19
    28b8:	27 95       	ror	r18
    28ba:	35 95       	asr	r19
    28bc:	27 95       	ror	r18
    28be:	35 95       	asr	r19
    28c0:	27 95       	ror	r18
    28c2:	35 95       	asr	r19
    28c4:	27 95       	ror	r18
    28c6:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    28c8:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    28ca:	8f e9       	ldi	r24, 0x9F	; 159
    28cc:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    28ce:	77 9b       	sbis	0x0e, 7	; 14
    28d0:	fe cf       	rjmp	.-4      	; 0x28ce <enc28j60_crbfs+0x6e>
    28d2:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    28d4:	81 91       	ld	r24, Z+
    28d6:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    28d8:	77 9b       	sbis	0x0e, 7	; 14
    28da:	fe cf       	rjmp	.-4      	; 0x28d8 <enc28j60_crbfs+0x78>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    28dc:	e6 17       	cp	r30, r22
    28de:	f7 07       	cpc	r31, r23
    28e0:	c9 f7       	brne	.-14     	; 0x28d4 <enc28j60_crbfs+0x74>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    28e2:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    28e4:	84 2f       	mov	r24, r20
    28e6:	80 76       	andi	r24, 0x60	; 96
    28e8:	80 93 29 09 	sts	0x0929, r24

// Bit Field Set
void enc28j60_crbfs(uint8_t address, char flags)
{
  enc28j60_select_bank(address);
  enc28j60_write(ENC_OP_BFS | (address & ENC_MASK_REGADR),&flags,1);
    28ec:	4f 71       	andi	r20, 0x1F	; 31
    28ee:	40 68       	ori	r20, 0x80	; 128

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    28f0:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    28f2:	4f b9       	out	0x0f, r20	; 15

  while(!(SPSR & (1<<SPIF)));
    28f4:	77 9b       	sbis	0x0e, 7	; 14
    28f6:	fe cf       	rjmp	.-4      	; 0x28f4 <enc28j60_crbfs+0x94>
    28f8:	fb 01       	movw	r30, r22
    28fa:	9e 01       	movw	r18, r28
    28fc:	2d 5f       	subi	r18, 0xFD	; 253
    28fe:	3f 4f       	sbci	r19, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2900:	81 91       	ld	r24, Z+
    2902:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2904:	77 9b       	sbis	0x0e, 7	; 14
    2906:	fe cf       	rjmp	.-4      	; 0x2904 <enc28j60_crbfs+0xa4>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2908:	e2 17       	cp	r30, r18
    290a:	f3 07       	cpc	r31, r19
    290c:	c9 f7       	brne	.-14     	; 0x2900 <enc28j60_crbfs+0xa0>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    290e:	c0 9a       	sbi	0x18, 0	; 24
void enc28j60_crbfs(uint8_t address, char flags)
{
  enc28j60_select_bank(address);
  enc28j60_write(ENC_OP_BFS | (address & ENC_MASK_REGADR),&flags,1);
  return;
}
    2910:	0f 90       	pop	r0
    2912:	0f 90       	pop	r0
    2914:	cf 91       	pop	r28
    2916:	df 91       	pop	r29
    2918:	08 95       	ret
    291a:	be 01       	movw	r22, r28
    291c:	6e 5f       	subi	r22, 0xFE	; 254
    291e:	7f 4f       	sbci	r23, 0xFF	; 255
    2920:	e5 cf       	rjmp	.-54     	; 0x28ec <enc28j60_crbfs+0x8c>

00002922 <enc28j60_crbfc>:

// Bit Field Clear
void enc28j60_crbfc(uint8_t address, char flags)
{
    2922:	df 93       	push	r29
    2924:	cf 93       	push	r28
    2926:	00 d0       	rcall	.+0      	; 0x2928 <enc28j60_crbfc+0x6>
    2928:	cd b7       	in	r28, 0x3d	; 61
    292a:	de b7       	in	r29, 0x3e	; 62
    292c:	48 2f       	mov	r20, r24
    292e:	6a 83       	std	Y+2, r22	; 0x02
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2930:	87 fd       	sbrc	r24, 7
    2932:	54 c0       	rjmp	.+168    	; 0x29dc <enc28j60_crbfc+0xba>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2934:	28 2f       	mov	r18, r24
    2936:	30 e0       	ldi	r19, 0x00	; 0
    2938:	20 76       	andi	r18, 0x60	; 96
    293a:	30 70       	andi	r19, 0x00	; 0
    293c:	80 91 29 09 	lds	r24, 0x0929
    2940:	90 e0       	ldi	r25, 0x00	; 0
    2942:	82 17       	cp	r24, r18
    2944:	93 07       	cpc	r25, r19
    2946:	09 f4       	brne	.+2      	; 0x294a <enc28j60_crbfc+0x28>
    2948:	49 c0       	rjmp	.+146    	; 0x29dc <enc28j60_crbfc+0xba>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    294a:	83 e0       	ldi	r24, 0x03	; 3
    294c:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    294e:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2950:	8f eb       	ldi	r24, 0xBF	; 191
    2952:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2954:	77 9b       	sbis	0x0e, 7	; 14
    2956:	fe cf       	rjmp	.-4      	; 0x2954 <enc28j60_crbfc+0x32>
    2958:	de 01       	movw	r26, r28
    295a:	11 96       	adiw	r26, 0x01	; 1
    295c:	fd 01       	movw	r30, r26
    295e:	be 01       	movw	r22, r28
    2960:	6e 5f       	subi	r22, 0xFE	; 254
    2962:	7f 4f       	sbci	r23, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2964:	81 91       	ld	r24, Z+
    2966:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2968:	77 9b       	sbis	0x0e, 7	; 14
    296a:	fe cf       	rjmp	.-4      	; 0x2968 <enc28j60_crbfc+0x46>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    296c:	e6 17       	cp	r30, r22
    296e:	f7 07       	cpc	r31, r23
    2970:	c9 f7       	brne	.-14     	; 0x2964 <enc28j60_crbfc+0x42>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2972:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2974:	35 95       	asr	r19
    2976:	27 95       	ror	r18
    2978:	35 95       	asr	r19
    297a:	27 95       	ror	r18
    297c:	35 95       	asr	r19
    297e:	27 95       	ror	r18
    2980:	35 95       	asr	r19
    2982:	27 95       	ror	r18
    2984:	35 95       	asr	r19
    2986:	27 95       	ror	r18
    2988:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    298a:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    298c:	8f e9       	ldi	r24, 0x9F	; 159
    298e:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2990:	77 9b       	sbis	0x0e, 7	; 14
    2992:	fe cf       	rjmp	.-4      	; 0x2990 <enc28j60_crbfc+0x6e>
    2994:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2996:	81 91       	ld	r24, Z+
    2998:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    299a:	77 9b       	sbis	0x0e, 7	; 14
    299c:	fe cf       	rjmp	.-4      	; 0x299a <enc28j60_crbfc+0x78>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    299e:	e6 17       	cp	r30, r22
    29a0:	f7 07       	cpc	r31, r23
    29a2:	c9 f7       	brne	.-14     	; 0x2996 <enc28j60_crbfc+0x74>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    29a4:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    29a6:	84 2f       	mov	r24, r20
    29a8:	80 76       	andi	r24, 0x60	; 96
    29aa:	80 93 29 09 	sts	0x0929, r24

// Bit Field Clear
void enc28j60_crbfc(uint8_t address, char flags)
{
  enc28j60_select_bank(address);
  enc28j60_write(ENC_OP_BFC | (address & ENC_MASK_REGADR),&flags,1);
    29ae:	4f 71       	andi	r20, 0x1F	; 31
    29b0:	40 6a       	ori	r20, 0xA0	; 160

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    29b2:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    29b4:	4f b9       	out	0x0f, r20	; 15

  while(!(SPSR & (1<<SPIF)));
    29b6:	77 9b       	sbis	0x0e, 7	; 14
    29b8:	fe cf       	rjmp	.-4      	; 0x29b6 <enc28j60_crbfc+0x94>
    29ba:	fb 01       	movw	r30, r22
    29bc:	9e 01       	movw	r18, r28
    29be:	2d 5f       	subi	r18, 0xFD	; 253
    29c0:	3f 4f       	sbci	r19, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    29c2:	81 91       	ld	r24, Z+
    29c4:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    29c6:	77 9b       	sbis	0x0e, 7	; 14
    29c8:	fe cf       	rjmp	.-4      	; 0x29c6 <enc28j60_crbfc+0xa4>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    29ca:	e2 17       	cp	r30, r18
    29cc:	f3 07       	cpc	r31, r19
    29ce:	c9 f7       	brne	.-14     	; 0x29c2 <enc28j60_crbfc+0xa0>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    29d0:	c0 9a       	sbi	0x18, 0	; 24
void enc28j60_crbfc(uint8_t address, char flags)
{
  enc28j60_select_bank(address);
  enc28j60_write(ENC_OP_BFC | (address & ENC_MASK_REGADR),&flags,1);
  return;
}
    29d2:	0f 90       	pop	r0
    29d4:	0f 90       	pop	r0
    29d6:	cf 91       	pop	r28
    29d8:	df 91       	pop	r29
    29da:	08 95       	ret
    29dc:	be 01       	movw	r22, r28
    29de:	6e 5f       	subi	r22, 0xFE	; 254
    29e0:	7f 4f       	sbci	r23, 0xFF	; 255
    29e2:	e5 cf       	rjmp	.-54     	; 0x29ae <enc28j60_crbfc+0x8c>

000029e4 <enc28j60_wcr>:
******************************************************************************************/

// Write functions 
//  this function is explicitly declared inline in order to speedup calls
void enc28j60_wcr(uint8_t address, const void* buffer, uint16_t len)
{
    29e4:	ef 92       	push	r14
    29e6:	ff 92       	push	r15
    29e8:	1f 93       	push	r17
    29ea:	df 93       	push	r29
    29ec:	cf 93       	push	r28
    29ee:	0f 92       	push	r0
    29f0:	cd b7       	in	r28, 0x3d	; 61
    29f2:	de b7       	in	r29, 0x3e	; 62
    29f4:	18 2f       	mov	r17, r24
    29f6:	fb 01       	movw	r30, r22
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    29f8:	87 fd       	sbrc	r24, 7
    29fa:	3f c0       	rjmp	.+126    	; 0x2a7a <enc28j60_wcr+0x96>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    29fc:	28 2f       	mov	r18, r24
    29fe:	30 e0       	ldi	r19, 0x00	; 0
    2a00:	20 76       	andi	r18, 0x60	; 96
    2a02:	30 70       	andi	r19, 0x00	; 0
    2a04:	80 91 29 09 	lds	r24, 0x0929
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	82 17       	cp	r24, r18
    2a0c:	93 07       	cpc	r25, r19
    2a0e:	a9 f1       	breq	.+106    	; 0x2a7a <enc28j60_wcr+0x96>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2a10:	83 e0       	ldi	r24, 0x03	; 3
    2a12:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2a14:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2a16:	8f eb       	ldi	r24, 0xBF	; 191
    2a18:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2a1a:	77 9b       	sbis	0x0e, 7	; 14
    2a1c:	fe cf       	rjmp	.-4      	; 0x2a1a <enc28j60_wcr+0x36>
    2a1e:	be 01       	movw	r22, r28
    2a20:	6f 5f       	subi	r22, 0xFF	; 255
    2a22:	7f 4f       	sbci	r23, 0xFF	; 255
    2a24:	db 01       	movw	r26, r22
    2a26:	82 e0       	ldi	r24, 0x02	; 2
    2a28:	e8 2e       	mov	r14, r24
    2a2a:	f1 2c       	mov	r15, r1
    2a2c:	ec 0e       	add	r14, r28
    2a2e:	fd 1e       	adc	r15, r29

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2a30:	8d 91       	ld	r24, X+
    2a32:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2a34:	77 9b       	sbis	0x0e, 7	; 14
    2a36:	fe cf       	rjmp	.-4      	; 0x2a34 <enc28j60_wcr+0x50>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2a38:	ae 15       	cp	r26, r14
    2a3a:	bf 05       	cpc	r27, r15
    2a3c:	c9 f7       	brne	.-14     	; 0x2a30 <enc28j60_wcr+0x4c>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2a3e:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2a40:	35 95       	asr	r19
    2a42:	27 95       	ror	r18
    2a44:	35 95       	asr	r19
    2a46:	27 95       	ror	r18
    2a48:	35 95       	asr	r19
    2a4a:	27 95       	ror	r18
    2a4c:	35 95       	asr	r19
    2a4e:	27 95       	ror	r18
    2a50:	35 95       	asr	r19
    2a52:	27 95       	ror	r18
    2a54:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2a56:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2a58:	8f e9       	ldi	r24, 0x9F	; 159
    2a5a:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2a5c:	77 9b       	sbis	0x0e, 7	; 14
    2a5e:	fe cf       	rjmp	.-4      	; 0x2a5c <enc28j60_wcr+0x78>
    2a60:	db 01       	movw	r26, r22

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2a62:	8d 91       	ld	r24, X+
    2a64:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2a66:	77 9b       	sbis	0x0e, 7	; 14
    2a68:	fe cf       	rjmp	.-4      	; 0x2a66 <enc28j60_wcr+0x82>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2a6a:	ae 15       	cp	r26, r14
    2a6c:	bf 05       	cpc	r27, r15
    2a6e:	c9 f7       	brne	.-14     	; 0x2a62 <enc28j60_wcr+0x7e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2a70:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2a72:	81 2f       	mov	r24, r17
    2a74:	80 76       	andi	r24, 0x60	; 96
    2a76:	80 93 29 09 	sts	0x0929, r24
void enc28j60_wcr(uint8_t address, const void* buffer, uint16_t len)
{
  // Speicherbank auswhlen...
  enc28j60_select_bank(address);
  // ... und die Daten schreiben 
  enc28j60_write(ENC_OP_WCR | (address & ENC_MASK_REGADR),buffer, len);
    2a7a:	1f 71       	andi	r17, 0x1F	; 31
    2a7c:	10 64       	ori	r17, 0x40	; 64

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2a7e:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2a80:	1f b9       	out	0x0f, r17	; 15

  while(!(SPSR & (1<<SPIF)));
    2a82:	77 9b       	sbis	0x0e, 7	; 14
    2a84:	fe cf       	rjmp	.-4      	; 0x2a82 <enc28j60_wcr+0x9e>

  while(length--)
    2a86:	41 15       	cp	r20, r1
    2a88:	51 05       	cpc	r21, r1
    2a8a:	41 f0       	breq	.+16     	; 0x2a9c <enc28j60_wcr+0xb8>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2a8c:	80 81       	ld	r24, Z
    2a8e:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2a90:	77 9b       	sbis	0x0e, 7	; 14
    2a92:	fe cf       	rjmp	.-4      	; 0x2a90 <enc28j60_wcr+0xac>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2a94:	31 96       	adiw	r30, 0x01	; 1
    2a96:	41 50       	subi	r20, 0x01	; 1
    2a98:	50 40       	sbci	r21, 0x00	; 0
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2a9a:	c1 f7       	brne	.-16     	; 0x2a8c <enc28j60_wcr+0xa8>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2a9c:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_select_bank(address);
  // ... und die Daten schreiben 
  enc28j60_write(ENC_OP_WCR | (address & ENC_MASK_REGADR),buffer, len);

  return;
}
    2a9e:	0f 90       	pop	r0
    2aa0:	cf 91       	pop	r28
    2aa2:	df 91       	pop	r29
    2aa4:	1f 91       	pop	r17
    2aa6:	ff 90       	pop	r15
    2aa8:	ef 90       	pop	r14
    2aaa:	08 95       	ret

00002aac <enc28j60_crputc>:

// write a single control register...
void enc28j60_crputc(uint8_t address, uint8_t buffer)
{
    2aac:	df 93       	push	r29
    2aae:	cf 93       	push	r28
    2ab0:	00 d0       	rcall	.+0      	; 0x2ab2 <enc28j60_crputc+0x6>
    2ab2:	cd b7       	in	r28, 0x3d	; 61
    2ab4:	de b7       	in	r29, 0x3e	; 62
    2ab6:	48 2f       	mov	r20, r24
    2ab8:	6a 83       	std	Y+2, r22	; 0x02
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2aba:	87 fd       	sbrc	r24, 7
    2abc:	54 c0       	rjmp	.+168    	; 0x2b66 <enc28j60_crputc+0xba>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2abe:	28 2f       	mov	r18, r24
    2ac0:	30 e0       	ldi	r19, 0x00	; 0
    2ac2:	20 76       	andi	r18, 0x60	; 96
    2ac4:	30 70       	andi	r19, 0x00	; 0
    2ac6:	80 91 29 09 	lds	r24, 0x0929
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	82 17       	cp	r24, r18
    2ace:	93 07       	cpc	r25, r19
    2ad0:	09 f4       	brne	.+2      	; 0x2ad4 <enc28j60_crputc+0x28>
    2ad2:	49 c0       	rjmp	.+146    	; 0x2b66 <enc28j60_crputc+0xba>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2ad4:	83 e0       	ldi	r24, 0x03	; 3
    2ad6:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2ad8:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2ada:	8f eb       	ldi	r24, 0xBF	; 191
    2adc:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2ade:	77 9b       	sbis	0x0e, 7	; 14
    2ae0:	fe cf       	rjmp	.-4      	; 0x2ade <enc28j60_crputc+0x32>
    2ae2:	de 01       	movw	r26, r28
    2ae4:	11 96       	adiw	r26, 0x01	; 1
    2ae6:	fd 01       	movw	r30, r26
    2ae8:	be 01       	movw	r22, r28
    2aea:	6e 5f       	subi	r22, 0xFE	; 254
    2aec:	7f 4f       	sbci	r23, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2aee:	81 91       	ld	r24, Z+
    2af0:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2af2:	77 9b       	sbis	0x0e, 7	; 14
    2af4:	fe cf       	rjmp	.-4      	; 0x2af2 <enc28j60_crputc+0x46>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2af6:	e6 17       	cp	r30, r22
    2af8:	f7 07       	cpc	r31, r23
    2afa:	c9 f7       	brne	.-14     	; 0x2aee <enc28j60_crputc+0x42>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2afc:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2afe:	35 95       	asr	r19
    2b00:	27 95       	ror	r18
    2b02:	35 95       	asr	r19
    2b04:	27 95       	ror	r18
    2b06:	35 95       	asr	r19
    2b08:	27 95       	ror	r18
    2b0a:	35 95       	asr	r19
    2b0c:	27 95       	ror	r18
    2b0e:	35 95       	asr	r19
    2b10:	27 95       	ror	r18
    2b12:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2b14:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2b16:	8f e9       	ldi	r24, 0x9F	; 159
    2b18:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2b1a:	77 9b       	sbis	0x0e, 7	; 14
    2b1c:	fe cf       	rjmp	.-4      	; 0x2b1a <enc28j60_crputc+0x6e>
    2b1e:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2b20:	81 91       	ld	r24, Z+
    2b22:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2b24:	77 9b       	sbis	0x0e, 7	; 14
    2b26:	fe cf       	rjmp	.-4      	; 0x2b24 <enc28j60_crputc+0x78>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2b28:	e6 17       	cp	r30, r22
    2b2a:	f7 07       	cpc	r31, r23
    2b2c:	c9 f7       	brne	.-14     	; 0x2b20 <enc28j60_crputc+0x74>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2b2e:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2b30:	84 2f       	mov	r24, r20
    2b32:	80 76       	andi	r24, 0x60	; 96
    2b34:	80 93 29 09 	sts	0x0929, r24
void enc28j60_wcr(uint8_t address, const void* buffer, uint16_t len)
{
  // Speicherbank auswhlen...
  enc28j60_select_bank(address);
  // ... und die Daten schreiben 
  enc28j60_write(ENC_OP_WCR | (address & ENC_MASK_REGADR),buffer, len);
    2b38:	4f 71       	andi	r20, 0x1F	; 31
    2b3a:	40 64       	ori	r20, 0x40	; 64

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2b3c:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2b3e:	4f b9       	out	0x0f, r20	; 15

  while(!(SPSR & (1<<SPIF)));
    2b40:	77 9b       	sbis	0x0e, 7	; 14
    2b42:	fe cf       	rjmp	.-4      	; 0x2b40 <enc28j60_crputc+0x94>
    2b44:	fb 01       	movw	r30, r22
    2b46:	9e 01       	movw	r18, r28
    2b48:	2d 5f       	subi	r18, 0xFD	; 253
    2b4a:	3f 4f       	sbci	r19, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2b4c:	81 91       	ld	r24, Z+
    2b4e:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2b50:	77 9b       	sbis	0x0e, 7	; 14
    2b52:	fe cf       	rjmp	.-4      	; 0x2b50 <enc28j60_crputc+0xa4>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2b54:	e2 17       	cp	r30, r18
    2b56:	f3 07       	cpc	r31, r19
    2b58:	c9 f7       	brne	.-14     	; 0x2b4c <enc28j60_crputc+0xa0>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2b5a:	c0 9a       	sbi	0x18, 0	; 24
// write a single control register...
void enc28j60_crputc(uint8_t address, uint8_t buffer)
{
  enc28j60_wcr(address, &buffer, 1);
  return;
}
    2b5c:	0f 90       	pop	r0
    2b5e:	0f 90       	pop	r0
    2b60:	cf 91       	pop	r28
    2b62:	df 91       	pop	r29
    2b64:	08 95       	ret
    2b66:	be 01       	movw	r22, r28
    2b68:	6e 5f       	subi	r22, 0xFE	; 254
    2b6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2b6c:	e5 cf       	rjmp	.-54     	; 0x2b38 <enc28j60_crputc+0x8c>

00002b6e <enc28j60_crputw>:

// write a word into a control registers (usefull for enc pointers)...
// ... the endianess is corrected!
void enc28j60_crputw(uint8_t address, uint16_t buffer)
{
    2b6e:	df 93       	push	r29
    2b70:	cf 93       	push	r28
    2b72:	00 d0       	rcall	.+0      	; 0x2b74 <enc28j60_crputw+0x6>
    2b74:	0f 92       	push	r0
    2b76:	cd b7       	in	r28, 0x3d	; 61
    2b78:	de b7       	in	r29, 0x3e	; 62
    2b7a:	48 2f       	mov	r20, r24
    2b7c:	7b 83       	std	Y+3, r23	; 0x03
    2b7e:	6a 83       	std	Y+2, r22	; 0x02
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2b80:	87 fd       	sbrc	r24, 7
    2b82:	55 c0       	rjmp	.+170    	; 0x2c2e <enc28j60_crputw+0xc0>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2b84:	28 2f       	mov	r18, r24
    2b86:	30 e0       	ldi	r19, 0x00	; 0
    2b88:	20 76       	andi	r18, 0x60	; 96
    2b8a:	30 70       	andi	r19, 0x00	; 0
    2b8c:	80 91 29 09 	lds	r24, 0x0929
    2b90:	90 e0       	ldi	r25, 0x00	; 0
    2b92:	82 17       	cp	r24, r18
    2b94:	93 07       	cpc	r25, r19
    2b96:	09 f4       	brne	.+2      	; 0x2b9a <enc28j60_crputw+0x2c>
    2b98:	4a c0       	rjmp	.+148    	; 0x2c2e <enc28j60_crputw+0xc0>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2b9a:	83 e0       	ldi	r24, 0x03	; 3
    2b9c:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2b9e:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2ba0:	8f eb       	ldi	r24, 0xBF	; 191
    2ba2:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2ba4:	77 9b       	sbis	0x0e, 7	; 14
    2ba6:	fe cf       	rjmp	.-4      	; 0x2ba4 <enc28j60_crputw+0x36>
    2ba8:	de 01       	movw	r26, r28
    2baa:	11 96       	adiw	r26, 0x01	; 1
    2bac:	fd 01       	movw	r30, r26
    2bae:	be 01       	movw	r22, r28
    2bb0:	6e 5f       	subi	r22, 0xFE	; 254
    2bb2:	7f 4f       	sbci	r23, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2bb4:	81 91       	ld	r24, Z+
    2bb6:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2bb8:	77 9b       	sbis	0x0e, 7	; 14
    2bba:	fe cf       	rjmp	.-4      	; 0x2bb8 <enc28j60_crputw+0x4a>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2bbc:	e6 17       	cp	r30, r22
    2bbe:	f7 07       	cpc	r31, r23
    2bc0:	c9 f7       	brne	.-14     	; 0x2bb4 <enc28j60_crputw+0x46>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2bc2:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2bc4:	35 95       	asr	r19
    2bc6:	27 95       	ror	r18
    2bc8:	35 95       	asr	r19
    2bca:	27 95       	ror	r18
    2bcc:	35 95       	asr	r19
    2bce:	27 95       	ror	r18
    2bd0:	35 95       	asr	r19
    2bd2:	27 95       	ror	r18
    2bd4:	35 95       	asr	r19
    2bd6:	27 95       	ror	r18
    2bd8:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2bda:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2bdc:	8f e9       	ldi	r24, 0x9F	; 159
    2bde:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2be0:	77 9b       	sbis	0x0e, 7	; 14
    2be2:	fe cf       	rjmp	.-4      	; 0x2be0 <enc28j60_crputw+0x72>
    2be4:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2be6:	81 91       	ld	r24, Z+
    2be8:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2bea:	77 9b       	sbis	0x0e, 7	; 14
    2bec:	fe cf       	rjmp	.-4      	; 0x2bea <enc28j60_crputw+0x7c>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2bee:	e6 17       	cp	r30, r22
    2bf0:	f7 07       	cpc	r31, r23
    2bf2:	c9 f7       	brne	.-14     	; 0x2be6 <enc28j60_crputw+0x78>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2bf4:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2bf6:	84 2f       	mov	r24, r20
    2bf8:	80 76       	andi	r24, 0x60	; 96
    2bfa:	80 93 29 09 	sts	0x0929, r24
void enc28j60_wcr(uint8_t address, const void* buffer, uint16_t len)
{
  // Speicherbank auswhlen...
  enc28j60_select_bank(address);
  // ... und die Daten schreiben 
  enc28j60_write(ENC_OP_WCR | (address & ENC_MASK_REGADR),buffer, len);
    2bfe:	4f 71       	andi	r20, 0x1F	; 31
    2c00:	40 64       	ori	r20, 0x40	; 64

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2c02:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2c04:	4f b9       	out	0x0f, r20	; 15

  while(!(SPSR & (1<<SPIF)));
    2c06:	77 9b       	sbis	0x0e, 7	; 14
    2c08:	fe cf       	rjmp	.-4      	; 0x2c06 <enc28j60_crputw+0x98>
    2c0a:	fb 01       	movw	r30, r22

  while(length--)
    2c0c:	9b 01       	movw	r18, r22
    2c0e:	2e 5f       	subi	r18, 0xFE	; 254
    2c10:	3f 4f       	sbci	r19, 0xFF	; 255
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2c12:	81 91       	ld	r24, Z+
    2c14:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2c16:	77 9b       	sbis	0x0e, 7	; 14
    2c18:	fe cf       	rjmp	.-4      	; 0x2c16 <enc28j60_crputw+0xa8>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2c1a:	e2 17       	cp	r30, r18
    2c1c:	f3 07       	cpc	r31, r19
    2c1e:	c9 f7       	brne	.-14     	; 0x2c12 <enc28j60_crputw+0xa4>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2c20:	c0 9a       	sbi	0x18, 0	; 24
{
  // correct the endianness, swap high an low byte
  // buffer = (((uint16_t)buffer &0x00FF) << 8) | (((uint16_t)buffer&0xFF00) >> 8);
  enc28j60_wcr(address, &buffer, 2);
  return;
}
    2c22:	0f 90       	pop	r0
    2c24:	0f 90       	pop	r0
    2c26:	0f 90       	pop	r0
    2c28:	cf 91       	pop	r28
    2c2a:	df 91       	pop	r29
    2c2c:	08 95       	ret
    2c2e:	be 01       	movw	r22, r28
    2c30:	6e 5f       	subi	r22, 0xFE	; 254
    2c32:	7f 4f       	sbci	r23, 0xFF	; 255
    2c34:	e4 cf       	rjmp	.-56     	; 0x2bfe <enc28j60_crputw+0x90>

00002c36 <enc28j60_crputs>:

void enc28j60_crputs(uint8_t address, const void* buffer, uint16_t len)
{
    2c36:	ef 92       	push	r14
    2c38:	ff 92       	push	r15
    2c3a:	1f 93       	push	r17
    2c3c:	df 93       	push	r29
    2c3e:	cf 93       	push	r28
    2c40:	0f 92       	push	r0
    2c42:	cd b7       	in	r28, 0x3d	; 61
    2c44:	de b7       	in	r29, 0x3e	; 62
    2c46:	18 2f       	mov	r17, r24
    2c48:	fb 01       	movw	r30, r22
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2c4a:	87 fd       	sbrc	r24, 7
    2c4c:	3f c0       	rjmp	.+126    	; 0x2ccc <enc28j60_crputs+0x96>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2c4e:	28 2f       	mov	r18, r24
    2c50:	30 e0       	ldi	r19, 0x00	; 0
    2c52:	20 76       	andi	r18, 0x60	; 96
    2c54:	30 70       	andi	r19, 0x00	; 0
    2c56:	80 91 29 09 	lds	r24, 0x0929
    2c5a:	90 e0       	ldi	r25, 0x00	; 0
    2c5c:	82 17       	cp	r24, r18
    2c5e:	93 07       	cpc	r25, r19
    2c60:	a9 f1       	breq	.+106    	; 0x2ccc <enc28j60_crputs+0x96>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2c62:	83 e0       	ldi	r24, 0x03	; 3
    2c64:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2c66:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2c68:	8f eb       	ldi	r24, 0xBF	; 191
    2c6a:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2c6c:	77 9b       	sbis	0x0e, 7	; 14
    2c6e:	fe cf       	rjmp	.-4      	; 0x2c6c <enc28j60_crputs+0x36>
    2c70:	be 01       	movw	r22, r28
    2c72:	6f 5f       	subi	r22, 0xFF	; 255
    2c74:	7f 4f       	sbci	r23, 0xFF	; 255
    2c76:	db 01       	movw	r26, r22
    2c78:	82 e0       	ldi	r24, 0x02	; 2
    2c7a:	e8 2e       	mov	r14, r24
    2c7c:	f1 2c       	mov	r15, r1
    2c7e:	ec 0e       	add	r14, r28
    2c80:	fd 1e       	adc	r15, r29

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2c82:	8d 91       	ld	r24, X+
    2c84:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2c86:	77 9b       	sbis	0x0e, 7	; 14
    2c88:	fe cf       	rjmp	.-4      	; 0x2c86 <enc28j60_crputs+0x50>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2c8a:	ae 15       	cp	r26, r14
    2c8c:	bf 05       	cpc	r27, r15
    2c8e:	c9 f7       	brne	.-14     	; 0x2c82 <enc28j60_crputs+0x4c>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2c90:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2c92:	35 95       	asr	r19
    2c94:	27 95       	ror	r18
    2c96:	35 95       	asr	r19
    2c98:	27 95       	ror	r18
    2c9a:	35 95       	asr	r19
    2c9c:	27 95       	ror	r18
    2c9e:	35 95       	asr	r19
    2ca0:	27 95       	ror	r18
    2ca2:	35 95       	asr	r19
    2ca4:	27 95       	ror	r18
    2ca6:	29 83       	std	Y+1, r18	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2ca8:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2caa:	8f e9       	ldi	r24, 0x9F	; 159
    2cac:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2cae:	77 9b       	sbis	0x0e, 7	; 14
    2cb0:	fe cf       	rjmp	.-4      	; 0x2cae <enc28j60_crputs+0x78>
    2cb2:	db 01       	movw	r26, r22

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2cb4:	8d 91       	ld	r24, X+
    2cb6:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2cb8:	77 9b       	sbis	0x0e, 7	; 14
    2cba:	fe cf       	rjmp	.-4      	; 0x2cb8 <enc28j60_crputs+0x82>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2cbc:	ae 15       	cp	r26, r14
    2cbe:	bf 05       	cpc	r27, r15
    2cc0:	c9 f7       	brne	.-14     	; 0x2cb4 <enc28j60_crputs+0x7e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2cc2:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2cc4:	81 2f       	mov	r24, r17
    2cc6:	80 76       	andi	r24, 0x60	; 96
    2cc8:	80 93 29 09 	sts	0x0929, r24
void enc28j60_wcr(uint8_t address, const void* buffer, uint16_t len)
{
  // Speicherbank auswhlen...
  enc28j60_select_bank(address);
  // ... und die Daten schreiben 
  enc28j60_write(ENC_OP_WCR | (address & ENC_MASK_REGADR),buffer, len);
    2ccc:	1f 71       	andi	r17, 0x1F	; 31
    2cce:	10 64       	ori	r17, 0x40	; 64

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2cd0:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2cd2:	1f b9       	out	0x0f, r17	; 15

  while(!(SPSR & (1<<SPIF)));
    2cd4:	77 9b       	sbis	0x0e, 7	; 14
    2cd6:	fe cf       	rjmp	.-4      	; 0x2cd4 <enc28j60_crputs+0x9e>

  while(length--)
    2cd8:	41 15       	cp	r20, r1
    2cda:	51 05       	cpc	r21, r1
    2cdc:	41 f0       	breq	.+16     	; 0x2cee <enc28j60_crputs+0xb8>
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2cde:	80 81       	ld	r24, Z
    2ce0:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2ce2:	77 9b       	sbis	0x0e, 7	; 14
    2ce4:	fe cf       	rjmp	.-4      	; 0x2ce2 <enc28j60_crputs+0xac>
  while(!(SPSR & (1<<SPIF)));

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2ce6:	31 96       	adiw	r30, 0x01	; 1
    2ce8:	41 50       	subi	r20, 0x01	; 1
    2cea:	50 40       	sbci	r21, 0x00	; 0
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2cec:	c1 f7       	brne	.-16     	; 0x2cde <enc28j60_crputs+0xa8>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2cee:	c0 9a       	sbi	0x18, 0	; 24

void enc28j60_crputs(uint8_t address, const void* buffer, uint16_t len)
{
  enc28j60_wcr(address, buffer, len);
  return;
}
    2cf0:	0f 90       	pop	r0
    2cf2:	cf 91       	pop	r28
    2cf4:	df 91       	pop	r29
    2cf6:	1f 91       	pop	r17
    2cf8:	ff 90       	pop	r15
    2cfa:	ef 90       	pop	r14
    2cfc:	08 95       	ret

00002cfe <enc28j60_prputw>:
  return;
}

// Write phy register
void enc28j60_prputw(uint8_t address, uint16_t buffer)
{
    2cfe:	df 93       	push	r29
    2d00:	cf 93       	push	r28
    2d02:	00 d0       	rcall	.+0      	; 0x2d04 <enc28j60_prputw+0x6>
    2d04:	cd b7       	in	r28, 0x3d	; 61
    2d06:	de b7       	in	r29, 0x3e	; 62
  enc28j60_crputc(ENC_REG_MIREGADR,address);
    2d08:	8a 83       	std	Y+2, r24	; 0x02
  if (address & ENC_MASK_BSEL_ALL)
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2d0a:	80 91 29 09 	lds	r24, 0x0929
    2d0e:	80 34       	cpi	r24, 0x40	; 64
    2d10:	09 f4       	brne	.+2      	; 0x2d14 <enc28j60_prputw+0x16>
    2d12:	92 c0       	rjmp	.+292    	; 0x2e38 <enc28j60_prputw+0x13a>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2d14:	83 e0       	ldi	r24, 0x03	; 3
    2d16:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2d18:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2d1a:	8f eb       	ldi	r24, 0xBF	; 191
    2d1c:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2d1e:	77 9b       	sbis	0x0e, 7	; 14
    2d20:	fe cf       	rjmp	.-4      	; 0x2d1e <enc28j60_prputw+0x20>
    2d22:	de 01       	movw	r26, r28
    2d24:	11 96       	adiw	r26, 0x01	; 1
    2d26:	fd 01       	movw	r30, r26
    2d28:	9e 01       	movw	r18, r28
    2d2a:	2e 5f       	subi	r18, 0xFE	; 254
    2d2c:	3f 4f       	sbci	r19, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2d2e:	81 91       	ld	r24, Z+
    2d30:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2d32:	77 9b       	sbis	0x0e, 7	; 14
    2d34:	fe cf       	rjmp	.-4      	; 0x2d32 <enc28j60_prputw+0x34>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2d36:	e2 17       	cp	r30, r18
    2d38:	f3 07       	cpc	r31, r19
    2d3a:	c9 f7       	brne	.-14     	; 0x2d2e <enc28j60_prputw+0x30>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2d3c:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2d3e:	82 e0       	ldi	r24, 0x02	; 2
    2d40:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2d42:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2d44:	8f e9       	ldi	r24, 0x9F	; 159
    2d46:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2d48:	77 9b       	sbis	0x0e, 7	; 14
    2d4a:	fe cf       	rjmp	.-4      	; 0x2d48 <enc28j60_prputw+0x4a>
    2d4c:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2d4e:	81 91       	ld	r24, Z+
    2d50:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2d52:	77 9b       	sbis	0x0e, 7	; 14
    2d54:	fe cf       	rjmp	.-4      	; 0x2d52 <enc28j60_prputw+0x54>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2d56:	e2 17       	cp	r30, r18
    2d58:	f3 07       	cpc	r31, r19
    2d5a:	c9 f7       	brne	.-14     	; 0x2d4e <enc28j60_prputw+0x50>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2d5c:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2d5e:	80 e4       	ldi	r24, 0x40	; 64
    2d60:	80 93 29 09 	sts	0x0929, r24

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2d64:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2d66:	84 e5       	ldi	r24, 0x54	; 84
    2d68:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2d6a:	77 9b       	sbis	0x0e, 7	; 14
    2d6c:	fe cf       	rjmp	.-4      	; 0x2d6a <enc28j60_prputw+0x6c>
    2d6e:	f9 01       	movw	r30, r18
    2d70:	ae 01       	movw	r20, r28
    2d72:	4d 5f       	subi	r20, 0xFD	; 253
    2d74:	5f 4f       	sbci	r21, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2d76:	81 91       	ld	r24, Z+
    2d78:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2d7a:	77 9b       	sbis	0x0e, 7	; 14
    2d7c:	fe cf       	rjmp	.-4      	; 0x2d7a <enc28j60_prputw+0x7c>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2d7e:	e4 17       	cp	r30, r20
    2d80:	f5 07       	cpc	r31, r21
    2d82:	c9 f7       	brne	.-14     	; 0x2d76 <enc28j60_prputw+0x78>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2d84:	c0 9a       	sbi	0x18, 0	; 24
// Write phy register
void enc28j60_prputw(uint8_t address, uint16_t buffer)
{
  enc28j60_crputc(ENC_REG_MIREGADR,address);

  enc28j60_crputc(ENC_REG_MIWRL, (buffer&0xFF));
    2d86:	69 83       	std	Y+1, r22	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2d88:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2d8a:	86 e5       	ldi	r24, 0x56	; 86
    2d8c:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2d8e:	77 9b       	sbis	0x0e, 7	; 14
    2d90:	fe cf       	rjmp	.-4      	; 0x2d8e <enc28j60_prputw+0x90>
    2d92:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2d94:	81 91       	ld	r24, Z+
    2d96:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2d98:	77 9b       	sbis	0x0e, 7	; 14
    2d9a:	fe cf       	rjmp	.-4      	; 0x2d98 <enc28j60_prputw+0x9a>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2d9c:	e2 17       	cp	r30, r18
    2d9e:	f3 07       	cpc	r31, r19
    2da0:	c9 f7       	brne	.-14     	; 0x2d94 <enc28j60_prputw+0x96>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2da2:	c0 9a       	sbi	0x18, 0	; 24
void enc28j60_prputw(uint8_t address, uint16_t buffer)
{
  enc28j60_crputc(ENC_REG_MIREGADR,address);

  enc28j60_crputc(ENC_REG_MIWRL, (buffer&0xFF));
  enc28j60_crputc(ENC_REG_MIWRH,  (buffer>> 8));
    2da4:	79 83       	std	Y+1, r23	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2da6:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2da8:	87 e5       	ldi	r24, 0x57	; 87
    2daa:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2dac:	77 9b       	sbis	0x0e, 7	; 14
    2dae:	fe cf       	rjmp	.-4      	; 0x2dac <enc28j60_prputw+0xae>
    2db0:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2db2:	81 91       	ld	r24, Z+
    2db4:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2db6:	77 9b       	sbis	0x0e, 7	; 14
    2db8:	fe cf       	rjmp	.-4      	; 0x2db6 <enc28j60_prputw+0xb8>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2dba:	e2 17       	cp	r30, r18
    2dbc:	f3 07       	cpc	r31, r19
    2dbe:	c9 f7       	brne	.-14     	; 0x2db2 <enc28j60_prputw+0xb4>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2dc0:	c0 9a       	sbi	0x18, 0	; 24
    2dc2:	90 e4       	ldi	r25, 0x40	; 64

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2dc4:	63 e0       	ldi	r22, 0x03	; 3
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);

  //send the Command to the ENC:
  SPDR = command;
    2dc6:	7f eb       	ldi	r23, 0xBF	; 191

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);

  //start read cmd:
  SPDR = command;
    2dc8:	af e9       	ldi	r26, 0x9F	; 159
    2dca:	ba e0       	ldi	r27, 0x0A	; 10
  if (address & ENC_MASK_BSEL_ALL)
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2dcc:	90 36       	cpi	r25, 0x60	; 96
    2dce:	e9 f0       	breq	.+58     	; 0x2e0a <enc28j60_prputw+0x10c>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2dd0:	6a 83       	std	Y+2, r22	; 0x02

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2dd2:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2dd4:	7f b9       	out	0x0f, r23	; 15

  while(!(SPSR & (1<<SPIF)));
    2dd6:	77 9b       	sbis	0x0e, 7	; 14
    2dd8:	fe cf       	rjmp	.-4      	; 0x2dd6 <enc28j60_prputw+0xd8>
    2dda:	f9 01       	movw	r30, r18

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2ddc:	81 91       	ld	r24, Z+
    2dde:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2de0:	77 9b       	sbis	0x0e, 7	; 14
    2de2:	fe cf       	rjmp	.-4      	; 0x2de0 <enc28j60_prputw+0xe2>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2de4:	e4 17       	cp	r30, r20
    2de6:	f5 07       	cpc	r31, r21
    2de8:	c9 f7       	brne	.-14     	; 0x2ddc <enc28j60_prputw+0xde>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2dea:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2dec:	6a 83       	std	Y+2, r22	; 0x02

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2dee:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2df0:	af b9       	out	0x0f, r26	; 15

  while(!(SPSR & (1<<SPIF)));
    2df2:	77 9b       	sbis	0x0e, 7	; 14
    2df4:	fe cf       	rjmp	.-4      	; 0x2df2 <enc28j60_prputw+0xf4>
    2df6:	f9 01       	movw	r30, r18

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2df8:	81 91       	ld	r24, Z+
    2dfa:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2dfc:	77 9b       	sbis	0x0e, 7	; 14
    2dfe:	fe cf       	rjmp	.-4      	; 0x2dfc <enc28j60_prputw+0xfe>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2e00:	e4 17       	cp	r30, r20
    2e02:	f5 07       	cpc	r31, r21
    2e04:	c9 f7       	brne	.-14     	; 0x2df8 <enc28j60_prputw+0xfa>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2e06:	c0 9a       	sbi	0x18, 0	; 24
    2e08:	90 e6       	ldi	r25, 0x60	; 96

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    2e0a:	c0 98       	cbi	0x18, 0	; 24

  //start read cmd:
  SPDR = command;
    2e0c:	bf b9       	out	0x0f, r27	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    2e0e:	77 9b       	sbis	0x0e, 7	; 14
    2e10:	fe cf       	rjmp	.-4      	; 0x2e0e <enc28j60_prputw+0x110>

  // Ignore dummy bytes...
  while(offset--) 
  {
    SPDR = 0x00;
    2e12:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2e14:	77 9b       	sbis	0x0e, 7	; 14
    2e16:	fe cf       	rjmp	.-4      	; 0x2e14 <enc28j60_prputw+0x116>
  }

  while(length--)
  {    
    SPDR = 0x00;
    2e18:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2e1a:	77 9b       	sbis	0x0e, 7	; 14
    2e1c:	fe cf       	rjmp	.-4      	; 0x2e1a <enc28j60_prputw+0x11c>
    *((uint8_t*)(buffer++)) = SPDR;
    2e1e:	8f b1       	in	r24, 0x0f	; 15
    2e20:	89 83       	std	Y+1, r24	; 0x01
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2e22:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_crputc(ENC_REG_MIREGADR,address);

  enc28j60_crputc(ENC_REG_MIWRL, (buffer&0xFF));
  enc28j60_crputc(ENC_REG_MIWRH,  (buffer>> 8));

  while (enc28j60_crgetc(ENC_REG_MISTAT) & ENC_REG_MISTAT_BUSY);
    2e24:	89 81       	ldd	r24, Y+1	; 0x01
    2e26:	80 fd       	sbrc	r24, 0
    2e28:	d1 cf       	rjmp	.-94     	; 0x2dcc <enc28j60_prputw+0xce>
    2e2a:	90 93 29 09 	sts	0x0929, r25

  return;
}
    2e2e:	0f 90       	pop	r0
    2e30:	0f 90       	pop	r0
    2e32:	cf 91       	pop	r28
    2e34:	df 91       	pop	r29
    2e36:	08 95       	ret
    2e38:	de 01       	movw	r26, r28
    2e3a:	11 96       	adiw	r26, 0x01	; 1
    2e3c:	9e 01       	movw	r18, r28
    2e3e:	2e 5f       	subi	r18, 0xFE	; 254
    2e40:	3f 4f       	sbci	r19, 0xFF	; 255
    2e42:	90 cf       	rjmp	.-224    	; 0x2d64 <enc28j60_prputw+0x66>

00002e44 <enc28j60_crgetw>:
  enc28j60_rcr2(address,&buffer,1);
  return buffer;
}

uint16_t enc28j60_crgetw(uint8_t address)
{
    2e44:	df 93       	push	r29
    2e46:	cf 93       	push	r28
    2e48:	00 d0       	rcall	.+0      	; 0x2e4a <enc28j60_crgetw+0x6>
    2e4a:	0f 92       	push	r0
    2e4c:	cd b7       	in	r28, 0x3d	; 61
    2e4e:	de b7       	in	r29, 0x3e	; 62
    2e50:	48 2f       	mov	r20, r24
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2e52:	87 fd       	sbrc	r24, 7
    2e54:	68 c0       	rjmp	.+208    	; 0x2f26 <enc28j60_crgetw+0xe2>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2e56:	28 2f       	mov	r18, r24
    2e58:	30 e0       	ldi	r19, 0x00	; 0
    2e5a:	20 76       	andi	r18, 0x60	; 96
    2e5c:	30 70       	andi	r19, 0x00	; 0
    2e5e:	80 91 29 09 	lds	r24, 0x0929
    2e62:	90 e0       	ldi	r25, 0x00	; 0
    2e64:	82 17       	cp	r24, r18
    2e66:	93 07       	cpc	r25, r19
    2e68:	09 f4       	brne	.+2      	; 0x2e6c <enc28j60_crgetw+0x28>
    2e6a:	65 c0       	rjmp	.+202    	; 0x2f36 <enc28j60_crgetw+0xf2>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2e6c:	83 e0       	ldi	r24, 0x03	; 3
    2e6e:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2e70:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2e72:	8f eb       	ldi	r24, 0xBF	; 191
    2e74:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2e76:	77 9b       	sbis	0x0e, 7	; 14
    2e78:	fe cf       	rjmp	.-4      	; 0x2e76 <enc28j60_crgetw+0x32>
    2e7a:	de 01       	movw	r26, r28
    2e7c:	11 96       	adiw	r26, 0x01	; 1
    2e7e:	fd 01       	movw	r30, r26
    2e80:	be 01       	movw	r22, r28
    2e82:	6e 5f       	subi	r22, 0xFE	; 254
    2e84:	7f 4f       	sbci	r23, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2e86:	81 91       	ld	r24, Z+
    2e88:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2e8a:	77 9b       	sbis	0x0e, 7	; 14
    2e8c:	fe cf       	rjmp	.-4      	; 0x2e8a <enc28j60_crgetw+0x46>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2e8e:	e6 17       	cp	r30, r22
    2e90:	f7 07       	cpc	r31, r23
    2e92:	c9 f7       	brne	.-14     	; 0x2e86 <enc28j60_crgetw+0x42>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2e94:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2e96:	c9 01       	movw	r24, r18
    2e98:	95 95       	asr	r25
    2e9a:	87 95       	ror	r24
    2e9c:	95 95       	asr	r25
    2e9e:	87 95       	ror	r24
    2ea0:	95 95       	asr	r25
    2ea2:	87 95       	ror	r24
    2ea4:	95 95       	asr	r25
    2ea6:	87 95       	ror	r24
    2ea8:	95 95       	asr	r25
    2eaa:	87 95       	ror	r24
    2eac:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2eae:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2eb0:	8f e9       	ldi	r24, 0x9F	; 159
    2eb2:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2eb4:	77 9b       	sbis	0x0e, 7	; 14
    2eb6:	fe cf       	rjmp	.-4      	; 0x2eb4 <enc28j60_crgetw+0x70>
    2eb8:	fd 01       	movw	r30, r26

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2eba:	81 91       	ld	r24, Z+
    2ebc:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2ebe:	77 9b       	sbis	0x0e, 7	; 14
    2ec0:	fe cf       	rjmp	.-4      	; 0x2ebe <enc28j60_crgetw+0x7a>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2ec2:	e6 17       	cp	r30, r22
    2ec4:	f7 07       	cpc	r31, r23
    2ec6:	c9 f7       	brne	.-14     	; 0x2eba <enc28j60_crgetw+0x76>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2ec8:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2eca:	84 2f       	mov	r24, r20
    2ecc:	80 76       	andi	r24, 0x60	; 96
    2ece:	80 93 29 09 	sts	0x0929, r24
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    2ed2:	20 34       	cpi	r18, 0x40	; 64
    2ed4:	31 05       	cpc	r19, r1
    2ed6:	e1 f0       	breq	.+56     	; 0x2f10 <enc28j60_crgetw+0xcc>
    2ed8:	80 e0       	ldi	r24, 0x00	; 0
    2eda:	20 36       	cpi	r18, 0x60	; 96
    2edc:	31 05       	cpc	r19, r1
    2ede:	c1 f0       	breq	.+48     	; 0x2f10 <enc28j60_crgetw+0xcc>

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    2ee0:	c0 98       	cbi	0x18, 0	; 24
{
  // switch to the corresponding memory bank
  enc28j60_select_bank(address);  
  
  // ... then start reading...
  enc28j60_read(ENC_OP_RCR | (address & ENC_MASK_REGADR), buffer, len, enc28j60_calcOffset(address));
    2ee2:	4f 71       	andi	r20, 0x1F	; 31

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);

  //start read cmd:
  SPDR = command;
    2ee4:	4f b9       	out	0x0f, r20	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    2ee6:	77 9b       	sbis	0x0e, 7	; 14
    2ee8:	fe cf       	rjmp	.-4      	; 0x2ee6 <enc28j60_crgetw+0xa2>

  // Ignore dummy bytes...
  while(offset--) 
    2eea:	88 23       	and	r24, r24
    2eec:	19 f0       	breq	.+6      	; 0x2ef4 <enc28j60_crgetw+0xb0>
  {
    SPDR = 0x00;
    2eee:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2ef0:	77 9b       	sbis	0x0e, 7	; 14
    2ef2:	fe cf       	rjmp	.-4      	; 0x2ef0 <enc28j60_crgetw+0xac>
  SPDR = command;
  //wait for completion
  while(!(SPSR & (1<<SPIF)));

  // Ignore dummy bytes...
  while(offset--) 
    2ef4:	fb 01       	movw	r30, r22
    2ef6:	9e 01       	movw	r18, r28
    2ef8:	2d 5f       	subi	r18, 0xFD	; 253
    2efa:	3f 4f       	sbci	r19, 0xFF	; 255
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
  {    
    SPDR = 0x00;
    2efc:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2efe:	77 9b       	sbis	0x0e, 7	; 14
    2f00:	fe cf       	rjmp	.-4      	; 0x2efe <enc28j60_crgetw+0xba>
    *((uint8_t*)(buffer++)) = SPDR;
    2f02:	8f b1       	in	r24, 0x0f	; 15
    2f04:	80 83       	st	Z, r24
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    2f06:	e2 17       	cp	r30, r18
    2f08:	f3 07       	cpc	r31, r19
    2f0a:	21 f0       	breq	.+8      	; 0x2f14 <enc28j60_crgetw+0xd0>
  {    
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
    2f0c:	31 96       	adiw	r30, 0x01	; 1
    2f0e:	f6 cf       	rjmp	.-20     	; 0x2efc <enc28j60_crgetw+0xb8>
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    2f10:	81 e0       	ldi	r24, 0x01	; 1
    2f12:	e6 cf       	rjmp	.-52     	; 0x2ee0 <enc28j60_crgetw+0x9c>
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2f14:	c0 9a       	sbi	0x18, 0	; 24
uint16_t enc28j60_crgetw(uint8_t address)
{
  uint16_t buffer;
  enc28j60_rcr2(address,&buffer,2);
  return ((buffer &0x00FF) << 8) | ((buffer&0xFF00) >> 8);
}
    2f16:	8b 81       	ldd	r24, Y+3	; 0x03
    2f18:	9a 81       	ldd	r25, Y+2	; 0x02
    2f1a:	0f 90       	pop	r0
    2f1c:	0f 90       	pop	r0
    2f1e:	0f 90       	pop	r0
    2f20:	cf 91       	pop	r28
    2f22:	df 91       	pop	r29
    2f24:	08 95       	ret
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2f26:	28 2f       	mov	r18, r24
    2f28:	30 e0       	ldi	r19, 0x00	; 0
    2f2a:	20 76       	andi	r18, 0x60	; 96
    2f2c:	30 70       	andi	r19, 0x00	; 0
    2f2e:	be 01       	movw	r22, r28
    2f30:	6e 5f       	subi	r22, 0xFE	; 254
    2f32:	7f 4f       	sbci	r23, 0xFF	; 255
    2f34:	ce cf       	rjmp	.-100    	; 0x2ed2 <enc28j60_crgetw+0x8e>
    2f36:	be 01       	movw	r22, r28
    2f38:	6e 5f       	subi	r22, 0xFE	; 254
    2f3a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f3c:	ca cf       	rjmp	.-108    	; 0x2ed2 <enc28j60_crgetw+0x8e>

00002f3e <enc28j60_crgetc>:
  return buffer;
}


uint8_t enc28j60_crgetc(uint8_t address)
{
    2f3e:	df 93       	push	r29
    2f40:	cf 93       	push	r28
    2f42:	00 d0       	rcall	.+0      	; 0x2f44 <enc28j60_crgetc+0x6>
    2f44:	cd b7       	in	r28, 0x3d	; 61
    2f46:	de b7       	in	r29, 0x3e	; 62
    2f48:	48 2f       	mov	r20, r24
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    2f4a:	87 fd       	sbrc	r24, 7
    2f4c:	5c c0       	rjmp	.+184    	; 0x3006 <enc28j60_crgetc+0xc8>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    2f4e:	28 2f       	mov	r18, r24
    2f50:	30 e0       	ldi	r19, 0x00	; 0
    2f52:	20 76       	andi	r18, 0x60	; 96
    2f54:	30 70       	andi	r19, 0x00	; 0
    2f56:	80 91 29 09 	lds	r24, 0x0929
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	82 17       	cp	r24, r18
    2f5e:	93 07       	cpc	r25, r19
    2f60:	99 f1       	breq	.+102    	; 0x2fc8 <enc28j60_crgetc+0x8a>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    2f62:	83 e0       	ldi	r24, 0x03	; 3
    2f64:	8a 83       	std	Y+2, r24	; 0x02

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2f66:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2f68:	8f eb       	ldi	r24, 0xBF	; 191
    2f6a:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2f6c:	77 9b       	sbis	0x0e, 7	; 14
    2f6e:	fe cf       	rjmp	.-4      	; 0x2f6c <enc28j60_crgetc+0x2e>
    2f70:	be 01       	movw	r22, r28
    2f72:	6e 5f       	subi	r22, 0xFE	; 254
    2f74:	7f 4f       	sbci	r23, 0xFF	; 255
    2f76:	fb 01       	movw	r30, r22
    2f78:	de 01       	movw	r26, r28
    2f7a:	13 96       	adiw	r26, 0x03	; 3

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2f7c:	81 91       	ld	r24, Z+
    2f7e:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2f80:	77 9b       	sbis	0x0e, 7	; 14
    2f82:	fe cf       	rjmp	.-4      	; 0x2f80 <enc28j60_crgetc+0x42>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2f84:	ea 17       	cp	r30, r26
    2f86:	fb 07       	cpc	r31, r27
    2f88:	c9 f7       	brne	.-14     	; 0x2f7c <enc28j60_crgetc+0x3e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2f8a:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    2f8c:	c9 01       	movw	r24, r18
    2f8e:	95 95       	asr	r25
    2f90:	87 95       	ror	r24
    2f92:	95 95       	asr	r25
    2f94:	87 95       	ror	r24
    2f96:	95 95       	asr	r25
    2f98:	87 95       	ror	r24
    2f9a:	95 95       	asr	r25
    2f9c:	87 95       	ror	r24
    2f9e:	95 95       	asr	r25
    2fa0:	87 95       	ror	r24
    2fa2:	8a 83       	std	Y+2, r24	; 0x02

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    2fa4:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    2fa6:	8f e9       	ldi	r24, 0x9F	; 159
    2fa8:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    2faa:	77 9b       	sbis	0x0e, 7	; 14
    2fac:	fe cf       	rjmp	.-4      	; 0x2faa <enc28j60_crgetc+0x6c>
    2fae:	fb 01       	movw	r30, r22

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    2fb0:	81 91       	ld	r24, Z+
    2fb2:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    2fb4:	77 9b       	sbis	0x0e, 7	; 14
    2fb6:	fe cf       	rjmp	.-4      	; 0x2fb4 <enc28j60_crgetc+0x76>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    2fb8:	ea 17       	cp	r30, r26
    2fba:	fb 07       	cpc	r31, r27
    2fbc:	c9 f7       	brne	.-14     	; 0x2fb0 <enc28j60_crgetc+0x72>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2fbe:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    2fc0:	84 2f       	mov	r24, r20
    2fc2:	80 76       	andi	r24, 0x60	; 96
    2fc4:	80 93 29 09 	sts	0x0929, r24
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    2fc8:	20 34       	cpi	r18, 0x40	; 64
    2fca:	31 05       	cpc	r19, r1
    2fcc:	d1 f0       	breq	.+52     	; 0x3002 <enc28j60_crgetc+0xc4>
    2fce:	80 e0       	ldi	r24, 0x00	; 0
    2fd0:	20 36       	cpi	r18, 0x60	; 96
    2fd2:	31 05       	cpc	r19, r1
    2fd4:	b1 f0       	breq	.+44     	; 0x3002 <enc28j60_crgetc+0xc4>

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    2fd6:	c0 98       	cbi	0x18, 0	; 24
{
  // switch to the corresponding memory bank
  enc28j60_select_bank(address);  
  
  // ... then start reading...
  enc28j60_read(ENC_OP_RCR | (address & ENC_MASK_REGADR), buffer, len, enc28j60_calcOffset(address));
    2fd8:	4f 71       	andi	r20, 0x1F	; 31

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);

  //start read cmd:
  SPDR = command;
    2fda:	4f b9       	out	0x0f, r20	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    2fdc:	77 9b       	sbis	0x0e, 7	; 14
    2fde:	fe cf       	rjmp	.-4      	; 0x2fdc <enc28j60_crgetc+0x9e>

  // Ignore dummy bytes...
  while(offset--) 
    2fe0:	88 23       	and	r24, r24
    2fe2:	19 f0       	breq	.+6      	; 0x2fea <enc28j60_crgetc+0xac>
  {
    SPDR = 0x00;
    2fe4:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2fe6:	77 9b       	sbis	0x0e, 7	; 14
    2fe8:	fe cf       	rjmp	.-4      	; 0x2fe6 <enc28j60_crgetc+0xa8>
  }

  while(length--)
  {    
    SPDR = 0x00;
    2fea:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    2fec:	77 9b       	sbis	0x0e, 7	; 14
    2fee:	fe cf       	rjmp	.-4      	; 0x2fec <enc28j60_crgetc+0xae>
    *((uint8_t*)(buffer++)) = SPDR;
    2ff0:	8f b1       	in	r24, 0x0f	; 15
    2ff2:	89 83       	std	Y+1, r24	; 0x01
  }

  // CS auf high
  PORTB |= (1<<PB0);
    2ff4:	c0 9a       	sbi	0x18, 0	; 24
uint8_t enc28j60_crgetc(uint8_t address)
{
  uint8_t buffer;
  enc28j60_rcr2(address,&buffer,1);
  return buffer;
}
    2ff6:	89 81       	ldd	r24, Y+1	; 0x01
    2ff8:	0f 90       	pop	r0
    2ffa:	0f 90       	pop	r0
    2ffc:	cf 91       	pop	r28
    2ffe:	df 91       	pop	r29
    3000:	08 95       	ret
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    3002:	81 e0       	ldi	r24, 0x01	; 1
    3004:	e8 cf       	rjmp	.-48     	; 0x2fd6 <enc28j60_crgetc+0x98>
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    3006:	28 2f       	mov	r18, r24
    3008:	30 e0       	ldi	r19, 0x00	; 0
    300a:	20 76       	andi	r18, 0x60	; 96
    300c:	30 70       	andi	r19, 0x00	; 0
    300e:	dc cf       	rjmp	.-72     	; 0x2fc8 <enc28j60_crgetc+0x8a>

00003010 <enc28j60_crgets>:
  enc28j60_rcr2(address,&buffer,2);
  return ((buffer &0x00FF) << 8) | ((buffer&0xFF00) >> 8);
}

void* enc28j60_crgets(uint8_t address, void* buffer, uint16_t len)
{
    3010:	ff 92       	push	r15
    3012:	0f 93       	push	r16
    3014:	1f 93       	push	r17
    3016:	df 93       	push	r29
    3018:	cf 93       	push	r28
    301a:	0f 92       	push	r0
    301c:	cd b7       	in	r28, 0x3d	; 61
    301e:	de b7       	in	r29, 0x3e	; 62
    3020:	a8 2f       	mov	r26, r24
    3022:	b6 2f       	mov	r27, r22
    3024:	f7 2e       	mov	r15, r23
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    3026:	87 fd       	sbrc	r24, 7
    3028:	6c c0       	rjmp	.+216    	; 0x3102 <enc28j60_crgets+0xf2>
    return;

  // the same applies if the bank is...
  // ... already selected
  if (hEnc28j60.bank == (address & ENC_MASK_BSEL))
    302a:	28 2f       	mov	r18, r24
    302c:	30 e0       	ldi	r19, 0x00	; 0
    302e:	20 76       	andi	r18, 0x60	; 96
    3030:	30 70       	andi	r19, 0x00	; 0
    3032:	80 91 29 09 	lds	r24, 0x0929
    3036:	90 e0       	ldi	r25, 0x00	; 0
    3038:	82 17       	cp	r24, r18
    303a:	93 07       	cpc	r25, r19
    303c:	a1 f1       	breq	.+104    	; 0x30a6 <enc28j60_crgets+0x96>

  // ! DO NOT CALL enc28j60_crbfc or bfs this will end up
  //   in an infinite loop...

  // clear bank select bits
  enc28j60_write_byte(
    303e:	83 e0       	ldi	r24, 0x03	; 3
    3040:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    3042:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    3044:	8f eb       	ldi	r24, 0xBF	; 191
    3046:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    3048:	77 9b       	sbis	0x0e, 7	; 14
    304a:	fe cf       	rjmp	.-4      	; 0x3048 <enc28j60_crgets+0x38>
    304c:	be 01       	movw	r22, r28
    304e:	6f 5f       	subi	r22, 0xFF	; 255
    3050:	7f 4f       	sbci	r23, 0xFF	; 255
    3052:	fb 01       	movw	r30, r22
    3054:	8e 01       	movw	r16, r28
    3056:	0e 5f       	subi	r16, 0xFE	; 254
    3058:	1f 4f       	sbci	r17, 0xFF	; 255

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    305a:	81 91       	ld	r24, Z+
    305c:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    305e:	77 9b       	sbis	0x0e, 7	; 14
    3060:	fe cf       	rjmp	.-4      	; 0x305e <enc28j60_crgets+0x4e>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    3062:	e0 17       	cp	r30, r16
    3064:	f1 07       	cpc	r31, r17
    3066:	c9 f7       	brne	.-14     	; 0x305a <enc28j60_crgets+0x4a>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    3068:	c0 9a       	sbi	0x18, 0	; 24
  enc28j60_write_byte(
      ENC_OP_BFC | ENC_REG_ECON1, 
      (ENC_REG_ECON1_BSEL0 | ENC_REG_ECON1_BSEL1) );

  // set the bank select bits
  enc28j60_write_byte(
    306a:	c9 01       	movw	r24, r18
    306c:	95 95       	asr	r25
    306e:	87 95       	ror	r24
    3070:	95 95       	asr	r25
    3072:	87 95       	ror	r24
    3074:	95 95       	asr	r25
    3076:	87 95       	ror	r24
    3078:	95 95       	asr	r25
    307a:	87 95       	ror	r24
    307c:	95 95       	asr	r25
    307e:	87 95       	ror	r24
    3080:	89 83       	std	Y+1, r24	; 0x01

void enc28j60_write(uint8_t command, const void* buffer, uint16_t length)
{
  
  // CS auf low ziehen -> bytes schreiben...
  PORTB &= ~(1<<PB0);
    3082:	c0 98       	cbi	0x18, 0	; 24

  //send the Command to the ENC:
  SPDR = command;
    3084:	8f e9       	ldi	r24, 0x9F	; 159
    3086:	8f b9       	out	0x0f, r24	; 15

  while(!(SPSR & (1<<SPIF)));
    3088:	77 9b       	sbis	0x0e, 7	; 14
    308a:	fe cf       	rjmp	.-4      	; 0x3088 <enc28j60_crgets+0x78>
    308c:	fb 01       	movw	r30, r22

  while(length--)
  {
    //send data
  	SPDR = *((uint8_t*)(buffer++));
    308e:	81 91       	ld	r24, Z+
    3090:	8f b9       	out	0x0f, r24	; 15
	  while(!(SPSR & (1<<SPIF)));
    3092:	77 9b       	sbis	0x0e, 7	; 14
    3094:	fe cf       	rjmp	.-4      	; 0x3092 <enc28j60_crgets+0x82>
  //send the Command to the ENC:
  SPDR = command;

  while(!(SPSR & (1<<SPIF)));

  while(length--)
    3096:	e0 17       	cp	r30, r16
    3098:	f1 07       	cpc	r31, r17
    309a:	c9 f7       	brne	.-14     	; 0x308e <enc28j60_crgets+0x7e>
  	SPDR = *((uint8_t*)(buffer++));
	  while(!(SPSR & (1<<SPIF)));
  }

  // CS auf high
  PORTB |= (1<<PB0);
    309c:	c0 9a       	sbi	0x18, 0	; 24
  // set the bank select bits
  enc28j60_write_byte(
      ENC_OP_BFS | ENC_REG_ECON1, 
      (address & ENC_MASK_BSEL) >> 5 );

  hEnc28j60.bank = (address & ENC_MASK_BSEL);
    309e:	8a 2f       	mov	r24, r26
    30a0:	80 76       	andi	r24, 0x60	; 96
    30a2:	80 93 29 09 	sts	0x0929, r24
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    30a6:	20 34       	cpi	r18, 0x40	; 64
    30a8:	31 05       	cpc	r19, r1
    30aa:	f9 f0       	breq	.+62     	; 0x30ea <enc28j60_crgets+0xda>
    30ac:	80 e0       	ldi	r24, 0x00	; 0
    30ae:	20 36       	cpi	r18, 0x60	; 96
    30b0:	31 05       	cpc	r19, r1
    30b2:	d9 f0       	breq	.+54     	; 0x30ea <enc28j60_crgets+0xda>

// mac und MII bentigen hier etwas spezielles...
// also prefix MA und MI

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);
    30b4:	c0 98       	cbi	0x18, 0	; 24
{
  // switch to the corresponding memory bank
  enc28j60_select_bank(address);  
  
  // ... then start reading...
  enc28j60_read(ENC_OP_RCR | (address & ENC_MASK_REGADR), buffer, len, enc28j60_calcOffset(address));
    30b6:	af 71       	andi	r26, 0x1F	; 31

  // Pull down CS Pin
  PORTB &= ~(1<<PB0);

  //start read cmd:
  SPDR = command;
    30b8:	af b9       	out	0x0f, r26	; 15
  //wait for completion
  while(!(SPSR & (1<<SPIF)));
    30ba:	77 9b       	sbis	0x0e, 7	; 14
    30bc:	fe cf       	rjmp	.-4      	; 0x30ba <enc28j60_crgets+0xaa>

  // Ignore dummy bytes...
  while(offset--) 
    30be:	88 23       	and	r24, r24
    30c0:	19 f0       	breq	.+6      	; 0x30c8 <enc28j60_crgets+0xb8>
  {
    SPDR = 0x00;
    30c2:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    30c4:	77 9b       	sbis	0x0e, 7	; 14
    30c6:	fe cf       	rjmp	.-4      	; 0x30c4 <enc28j60_crgets+0xb4>
  }

  while(length--)
    30c8:	41 15       	cp	r20, r1
    30ca:	51 05       	cpc	r21, r1
    30cc:	81 f0       	breq	.+32     	; 0x30ee <enc28j60_crgets+0xde>
    30ce:	8b 2f       	mov	r24, r27
    30d0:	9f 2d       	mov	r25, r15
    30d2:	9c 01       	movw	r18, r24
    30d4:	f9 01       	movw	r30, r18
  {    
    SPDR = 0x00;
    30d6:	1f b8       	out	0x0f, r1	; 15
    while(!((SPSR) & (1<<SPIF)));
    30d8:	77 9b       	sbis	0x0e, 7	; 14
    30da:	fe cf       	rjmp	.-4      	; 0x30d8 <enc28j60_crgets+0xc8>
    *((uint8_t*)(buffer++)) = SPDR;
    30dc:	8f b1       	in	r24, 0x0f	; 15
    30de:	80 83       	st	Z, r24
    30e0:	41 50       	subi	r20, 0x01	; 1
    30e2:	50 40       	sbci	r21, 0x00	; 0
  {
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
  }

  while(length--)
    30e4:	21 f0       	breq	.+8      	; 0x30ee <enc28j60_crgets+0xde>
  {    
    SPDR = 0x00;
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
    30e6:	31 96       	adiw	r30, 0x01	; 1
    30e8:	f6 cf       	rjmp	.-20     	; 0x30d6 <enc28j60_crgets+0xc6>
// this function determins the offset which should be used.
// as the previous function this is inline ...
uint8_t enc28j60_calcOffset(uint8_t address)
{
  // Bei den MI und MA Registern muss ein Dummybyte gelesen werden
  if ( ((address & ENC_MASK_BSEL) == ENC_BSEL_2) 
    30ea:	81 e0       	ldi	r24, 0x01	; 1
    30ec:	e3 cf       	rjmp	.-58     	; 0x30b4 <enc28j60_crgets+0xa4>
    while(!((SPSR) & (1<<SPIF)));
    *((uint8_t*)(buffer++)) = SPDR;
  }

  // CS auf high
  PORTB |= (1<<PB0);
    30ee:	c0 9a       	sbi	0x18, 0	; 24

void* enc28j60_crgets(uint8_t address, void* buffer, uint16_t len)
{
  enc28j60_rcr2(address,buffer,len);
  return buffer; 
}
    30f0:	8b 2f       	mov	r24, r27
    30f2:	9f 2d       	mov	r25, r15
    30f4:	0f 90       	pop	r0
    30f6:	cf 91       	pop	r28
    30f8:	df 91       	pop	r29
    30fa:	1f 91       	pop	r17
    30fc:	0f 91       	pop	r16
    30fe:	ff 90       	pop	r15
    3100:	08 95       	ret
void enc28j60_select_bank(uint8_t address)
{

  // some registers are in all banks same...
  //... so a bank select would be useless
  if (address & ENC_MASK_BSEL_ALL)
    3102:	28 2f       	mov	r18, r24
    3104:	30 e0       	ldi	r19, 0x00	; 0
    3106:	20 76       	andi	r18, 0x60	; 96
    3108:	30 70       	andi	r19, 0x00	; 0
    310a:	cd cf       	rjmp	.-102    	; 0x30a6 <enc28j60_crgets+0x96>

0000310c <nicGetPacketSize>:
}



uint16_t nicGetPacketSize(const struct nicRequestHandle_t* handle)
{
    310c:	fc 01       	movw	r30, r24
  if (handle->packet == NULL)
    310e:	01 90       	ld	r0, Z+
    3110:	f0 81       	ld	r31, Z
    3112:	e0 2d       	mov	r30, r0
    3114:	30 97       	sbiw	r30, 0x00	; 0
    3116:	29 f0       	breq	.+10     	; 0x3122 <nicGetPacketSize+0x16>
    return 0;

  return handle->packet->length;
    3118:	06 80       	ldd	r0, Z+6	; 0x06
    311a:	f7 81       	ldd	r31, Z+7	; 0x07
    311c:	e0 2d       	mov	r30, r0
}
    311e:	cf 01       	movw	r24, r30
    3120:	08 95       	ret



uint16_t nicGetPacketSize(const struct nicRequestHandle_t* handle)
{
  if (handle->packet == NULL)
    3122:	e0 e0       	ldi	r30, 0x00	; 0
    3124:	f0 e0       	ldi	r31, 0x00	; 0
    return 0;

  return handle->packet->length;
}
    3126:	cf 01       	movw	r24, r30
    3128:	08 95       	ret

0000312a <nicResponseSize>:

  return len;  
}

uint16_t nicResponseSize(struct nicResponseHandle_t* response)
{
    312a:	fc 01       	movw	r30, r24
  if (response == 0)
    312c:	00 97       	sbiw	r24, 0x00	; 0
    312e:	21 f0       	breq	.+8      	; 0x3138 <nicResponseSize+0xe>
    return 0;
   
  return response->length;
    3130:	20 81       	ld	r18, Z
    3132:	31 81       	ldd	r19, Z+1	; 0x01
}
    3134:	c9 01       	movw	r24, r18
    3136:	08 95       	ret
  return len;  
}

uint16_t nicResponseSize(struct nicResponseHandle_t* response)
{
  if (response == 0)
    3138:	20 e0       	ldi	r18, 0x00	; 0
    313a:	30 e0       	ldi	r19, 0x00	; 0
    return 0;
   
  return response->length;
}
    313c:	c9 01       	movw	r24, r18
    313e:	08 95       	ret

00003140 <nicResponseRead>:
  
  return;
}

uint16_t nicResponseRead(struct nicResponseHandle_t* response, char* buffer, uint16_t len)
{
    3140:	0f 93       	push	r16
    3142:	1f 93       	push	r17
    3144:	cf 93       	push	r28
    3146:	df 93       	push	r29
    3148:	8c 01       	movw	r16, r24
    314a:	dc 01       	movw	r26, r24
    314c:	ed 91       	ld	r30, X+
    314e:	fc 91       	ld	r31, X
    3150:	ea 01       	movw	r28, r20
    3152:	e4 17       	cp	r30, r20
    3154:	f5 07       	cpc	r31, r21
    3156:	08 f4       	brcc	.+2      	; 0x315a <nicResponseRead+0x1a>
    3158:	ef 01       	movw	r28, r30
  // adjust the length, if it is bigger than the received packet...
  if (response->length < len)
    len = response->length;
         
  // read enc packet...
  enc28j60_bmgets(buffer,len);
    315a:	cb 01       	movw	r24, r22
    315c:	be 01       	movw	r22, r28
    315e:	0e 94 9b 13 	call	0x2736	; 0x2736 <enc28j60_bmgets>
  
  // ...decrement length
  response->length -= len;
    3162:	f8 01       	movw	r30, r16
    3164:	80 81       	ld	r24, Z
    3166:	91 81       	ldd	r25, Z+1	; 0x01
    3168:	8c 1b       	sub	r24, r28
    316a:	9d 0b       	sbc	r25, r29
    316c:	91 83       	std	Z+1, r25	; 0x01
    316e:	80 83       	st	Z, r24

  return len;  
}
    3170:	ce 01       	movw	r24, r28
    3172:	df 91       	pop	r29
    3174:	cf 91       	pop	r28
    3176:	1f 91       	pop	r17
    3178:	0f 91       	pop	r16
    317a:	08 95       	ret

0000317c <nicFreeResponse>:
  
  return handle;  
}

void nicFreeResponse(struct nicResponseHandle_t* response)
{
    317c:	cf 93       	push	r28
    317e:	df 93       	push	r29
    3180:	ec 01       	movw	r28, r24
  
  //fix Packet Pointer (see Errata)
  if (((response->nextPacketPtr)-1 < ENC_ERXST) || ((response->nextPacketPtr)-1 > ENC_ERXND)) 
    3182:	6a 81       	ldd	r22, Y+2	; 0x02
    3184:	7b 81       	ldd	r23, Y+3	; 0x03
    3186:	61 50       	subi	r22, 0x01	; 1
    3188:	70 40       	sbci	r23, 0x00	; 0
    318a:	8a e1       	ldi	r24, 0x1A	; 26
    318c:	60 30       	cpi	r22, 0x00	; 0
    318e:	78 07       	cpc	r23, r24
    3190:	90 f4       	brcc	.+36     	; 0x31b6 <nicFreeResponse+0x3a>
    // TODO: WIRKLICH ENC_ERXND?
    enc28j60_crputw(ENC_REG_ERXRDPTL,ENC_ERXND);
  else
    enc28j60_crputw(ENC_REG_ERXRDPTL,(response->nextPacketPtr)-1); 
    3192:	8c e0       	ldi	r24, 0x0C	; 12
    3194:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>

  //decrement packet counter:
  enc28j60_crbfs(ENC_REG_ECON2,ENC_REG_ECON2_PKTDEC);
    3198:	8e e9       	ldi	r24, 0x9E	; 158
    319a:	60 e4       	ldi	r22, 0x40	; 64
    319c:	0e 94 30 14 	call	0x2860	; 0x2860 <enc28j60_crbfs>
  
  //update the next packet pointer
  enc28j60_crputw(ENC_REG_ERDPTL,(response->nextPacketPtr));  
    31a0:	6a 81       	ldd	r22, Y+2	; 0x02
    31a2:	7b 81       	ldd	r23, Y+3	; 0x03
    31a4:	80 e0       	ldi	r24, 0x00	; 0
    31a6:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>
  
  free(response);
    31aa:	ce 01       	movw	r24, r28
    31ac:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
  
  return;
}
    31b0:	df 91       	pop	r29
    31b2:	cf 91       	pop	r28
    31b4:	08 95       	ret
{
  
  //fix Packet Pointer (see Errata)
  if (((response->nextPacketPtr)-1 < ENC_ERXST) || ((response->nextPacketPtr)-1 > ENC_ERXND)) 
    // TODO: WIRKLICH ENC_ERXND?
    enc28j60_crputw(ENC_REG_ERXRDPTL,ENC_ERXND);
    31b6:	8c e0       	ldi	r24, 0x0C	; 12
    31b8:	6f ef       	ldi	r22, 0xFF	; 255
    31ba:	79 e1       	ldi	r23, 0x19	; 25
    31bc:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>
    31c0:	eb cf       	rjmp	.-42     	; 0x3198 <nicFreeResponse+0x1c>

000031c2 <nicFreeRequest>:
  return 1;  
}


void nicFreeRequest(struct nicRequestHandle_t* handle)
{
    31c2:	0f 93       	push	r16
    31c4:	1f 93       	push	r17
    31c6:	cf 93       	push	r28
    31c8:	df 93       	push	r29
    31ca:	8c 01       	movw	r16, r24
  if (handle == NULL)
    31cc:	00 97       	sbiw	r24, 0x00	; 0
    31ce:	79 f4       	brne	.+30     	; 0x31ee <nicFreeRequest+0x2c>
    31d0:	16 c0       	rjmp	.+44     	; 0x31fe <nicFreeRequest+0x3c>
      = handle->packet; 
       
  while(packet != NULL)
  {
    // free header if applicable
    if (packet->header.data != NULL)
    31d2:	88 81       	ld	r24, Y
    31d4:	99 81       	ldd	r25, Y+1	; 0x01
    31d6:	00 97       	sbiw	r24, 0x00	; 0
    31d8:	11 f0       	breq	.+4      	; 0x31de <nicFreeRequest+0x1c>
      free(packet->header.data);
    31da:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
    
    // update the handle...
    handle->packet = packet->payload;
    31de:	8c 81       	ldd	r24, Y+4	; 0x04
    31e0:	9d 81       	ldd	r25, Y+5	; 0x05
    31e2:	f8 01       	movw	r30, r16
    31e4:	91 83       	std	Z+1, r25	; 0x01
    31e6:	80 83       	st	Z, r24
    // then free the packet...
    free(packet);
    31e8:	ce 01       	movw	r24, r28
    31ea:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
    packet = handle->packet;             
    31ee:	f8 01       	movw	r30, r16
    31f0:	c0 81       	ld	r28, Z
    31f2:	d1 81       	ldd	r29, Z+1	; 0x01
    return;
	  
  struct soPacket_t *packet
      = handle->packet; 
       
  while(packet != NULL)
    31f4:	20 97       	sbiw	r28, 0x00	; 0
    31f6:	69 f7       	brne	.-38     	; 0x31d2 <nicFreeRequest+0x10>
    free(packet);
    packet = handle->packet;             
  }  

  // finally free the handle itself...
  free(handle); 
    31f8:	c8 01       	movw	r24, r16
    31fa:	0e 94 f3 2d 	call	0x5be6	; 0x5be6 <free>
  
  return;
}
    31fe:	df 91       	pop	r29
    3200:	cf 91       	pop	r28
    3202:	1f 91       	pop	r17
    3204:	0f 91       	pop	r16
    3206:	08 95       	ret

00003208 <nicAddPacketHeader>:
  return handle;  
}


void* nicAddPacketHeader(struct nicRequestHandle_t* handle, uint16_t len)
{
    3208:	ef 92       	push	r14
    320a:	ff 92       	push	r15
    320c:	0f 93       	push	r16
    320e:	1f 93       	push	r17
    3210:	cf 93       	push	r28
    3212:	df 93       	push	r29
    3214:	7c 01       	movw	r14, r24
    3216:	8b 01       	movw	r16, r22

  // construct the encapsulating packet/frame
  
  // first get memory for the packet/frame...
  struct soPacket_t *packet;
  packet = (struct soPacket_t*) malloc(sizeof(struct soPacket_t));
    3218:	88 e0       	ldi	r24, 0x08	; 8
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    3220:	ec 01       	movw	r28, r24

  // ... then for the nested header
  packet->header.length = len; 
    3222:	1b 83       	std	Y+3, r17	; 0x03
    3224:	0a 83       	std	Y+2, r16	; 0x02
  if (len == 0 )
    3226:	01 15       	cp	r16, r1
    3228:	11 05       	cpc	r17, r1
    322a:	e9 f4       	brne	.+58     	; 0x3266 <nicAddPacketHeader+0x5e>
    packet->header.data = NULL;
    322c:	19 82       	std	Y+1, r1	; 0x01
    322e:	18 82       	st	Y, r1
  else 
    packet->header.data = (char*)malloc(len);
  

  // now set and/or update the payload...
  packet->payload = handle->packet;
    3230:	d7 01       	movw	r26, r14
    3232:	ed 91       	ld	r30, X+
    3234:	fc 91       	ld	r31, X
    3236:	fd 83       	std	Y+5, r31	; 0x05
    3238:	ec 83       	std	Y+4, r30	; 0x04
   
  if (packet->payload == NULL)
    323a:	30 97       	sbiw	r30, 0x00	; 0
    323c:	01 f1       	breq	.+64     	; 0x327e <nicAddPacketHeader+0x76>
    packet->length = packet->header.length;
  else
  	packet->length  = packet->header.length + packet->payload->length;
    323e:	86 81       	ldd	r24, Z+6	; 0x06
    3240:	97 81       	ldd	r25, Z+7	; 0x07
    3242:	2a 81       	ldd	r18, Y+2	; 0x02
    3244:	3b 81       	ldd	r19, Y+3	; 0x03
    3246:	82 0f       	add	r24, r18
    3248:	93 1f       	adc	r25, r19
    324a:	9f 83       	std	Y+7, r25	; 0x07
    324c:	8e 83       	std	Y+6, r24	; 0x06
  
  // now update the packet handle
  handle->packet = packet;
    324e:	f7 01       	movw	r30, r14
    3250:	d1 83       	std	Z+1, r29	; 0x01
    3252:	c0 83       	st	Z, r28
  
  // everything done, so return the header 
  return packet->header.data;  
}
    3254:	88 81       	ld	r24, Y
    3256:	99 81       	ldd	r25, Y+1	; 0x01
    3258:	df 91       	pop	r29
    325a:	cf 91       	pop	r28
    325c:	1f 91       	pop	r17
    325e:	0f 91       	pop	r16
    3260:	ff 90       	pop	r15
    3262:	ef 90       	pop	r14
    3264:	08 95       	ret
  // ... then for the nested header
  packet->header.length = len; 
  if (len == 0 )
    packet->header.data = NULL;
  else 
    packet->header.data = (char*)malloc(len);
    3266:	c8 01       	movw	r24, r16
    3268:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    326c:	88 83       	st	Y, r24
    326e:	99 83       	std	Y+1, r25	; 0x01
  

  // now set and/or update the payload...
  packet->payload = handle->packet;
    3270:	d7 01       	movw	r26, r14
    3272:	ed 91       	ld	r30, X+
    3274:	fc 91       	ld	r31, X
    3276:	fd 83       	std	Y+5, r31	; 0x05
    3278:	ec 83       	std	Y+4, r30	; 0x04
   
  if (packet->payload == NULL)
    327a:	30 97       	sbiw	r30, 0x00	; 0
    327c:	01 f7       	brne	.-64     	; 0x323e <nicAddPacketHeader+0x36>
    packet->length = packet->header.length;
    327e:	8a 81       	ldd	r24, Y+2	; 0x02
    3280:	9b 81       	ldd	r25, Y+3	; 0x03
    3282:	9f 83       	std	Y+7, r25	; 0x07
    3284:	8e 83       	std	Y+6, r24	; 0x06
    3286:	e3 cf       	rjmp	.-58     	; 0x324e <nicAddPacketHeader+0x46>

00003288 <nicNewRequest>:
};

struct nicRequestHandle_t* nicNewRequest()
{
  struct nicRequestHandle_t* handle;
  handle = (struct nicRequestHandle_t*) malloc(sizeof(struct nicRequestHandle_t));
    3288:	82 e0       	ldi	r24, 0x02	; 2
    328a:	90 e0       	ldi	r25, 0x00	; 0
    328c:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    3290:	fc 01       	movw	r30, r24
  
  handle->packet = NULL;
    3292:	11 82       	std	Z+1, r1	; 0x01
    3294:	10 82       	st	Z, r1

  return handle;  
}
    3296:	08 95       	ret

00003298 <nicReceiveResponse>:

  return;
}

struct nicResponseHandle_t* nicReceiveResponse()
{  
    3298:	cf 93       	push	r28
    329a:	df 93       	push	r29

  // Check the Interruptflags for new Packkets...
  if ((enc28j60_crgetc(ENC_REG_EIR) & ENC_REG_EIR_PKTIF ) == 0)
    329c:	8c e9       	ldi	r24, 0x9C	; 156
    329e:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <enc28j60_crgetc>
    32a2:	86 ff       	sbrs	r24, 6
    32a4:	13 c0       	rjmp	.+38     	; 0x32cc <nicReceiveResponse+0x34>
      return NULL;
 
  // ... generate a handle with a dummy Packet header...
  
  struct nicResponseHandle_t* handle 
      = (struct nicResponseHandle_t*) malloc(sizeof(struct nicResponseHandle_t));
    32a6:	84 e0       	ldi	r24, 0x04	; 4
    32a8:	90 e0       	ldi	r25, 0x00	; 0
    32aa:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <malloc>
    32ae:	ec 01       	movw	r28, r24
  
  // ...now set and update the readpointer  
  handle->nextPacketPtr = enc28j60_bmgetw();  
    32b0:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <enc28j60_bmgetw>
    32b4:	9b 83       	std	Y+3, r25	; 0x03
    32b6:	8a 83       	std	Y+2, r24	; 0x02
  
  //update the length...
  handle->length = enc28j60_bmgetw();
    32b8:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <enc28j60_bmgetw>
    32bc:	99 83       	std	Y+1, r25	; 0x01
    32be:	88 83       	st	Y, r24

  // ignore the receive Vector   
  enc28j60_bmgetw();
    32c0:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <enc28j60_bmgetw>
  
  return handle;  
}
    32c4:	ce 01       	movw	r24, r28
    32c6:	df 91       	pop	r29
    32c8:	cf 91       	pop	r28
    32ca:	08 95       	ret
{  

  // Check the Interruptflags for new Packkets...
  if ((enc28j60_crgetc(ENC_REG_EIR) & ENC_REG_EIR_PKTIF ) == 0)
    //... and then consult the packet counter (due to bad silicon) 
    if (enc28j60_crgetc(ENC_REG_EPKTCNT) == 0)
    32cc:	89 e3       	ldi	r24, 0x39	; 57
    32ce:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <enc28j60_crgetc>
    32d2:	88 23       	and	r24, r24
    32d4:	41 f7       	brne	.-48     	; 0x32a6 <nicReceiveResponse+0xe>
    32d6:	c0 e0       	ldi	r28, 0x00	; 0
    32d8:	d0 e0       	ldi	r29, 0x00	; 0
    32da:	f4 cf       	rjmp	.-24     	; 0x32c4 <nicReceiveResponse+0x2c>

000032dc <nicInitialize>:
  
  return;
}

void nicInitialize(struct macAddress_t* mac)
{
    32dc:	cf 93       	push	r28
    32de:	df 93       	push	r29
    32e0:	ec 01       	movw	r28, r24
  //TODO Change to Full Duplex Settings...
  enc28j60_init();
    32e2:	0e 94 31 13 	call	0x2662	; 0x2662 <enc28j60_init>
  
  enc28j60_reset();
    32e6:	0e 94 5e 13 	call	0x26bc	; 0x26bc <enc28j60_reset>
    32ea:	20 e0       	ldi	r18, 0x00	; 0
    32ec:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    32ee:	40 e7       	ldi	r20, 0x70	; 112
    32f0:	51 e0       	ldi	r21, 0x01	; 1
    32f2:	ca 01       	movw	r24, r20
    32f4:	01 97       	sbiw	r24, 0x01	; 1
    32f6:	f1 f7       	brne	.-4      	; 0x32f4 <nicInitialize+0x18>
    32f8:	2f 5f       	subi	r18, 0xFF	; 255
    32fa:	3f 4f       	sbci	r19, 0xFF	; 255
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    32fc:	81 e0       	ldi	r24, 0x01	; 1
    32fe:	24 3f       	cpi	r18, 0xF4	; 244
    3300:	38 07       	cpc	r19, r24
    3302:	b9 f7       	brne	.-18     	; 0x32f2 <nicInitialize+0x16>
  _delay_ms(50);

  // Let's wait until the ENC28J60 is ready...
  while( (enc28j60_crgetc(ENC_REG_ESTAT) & ENC_REG_ESTAT_CLKRDY) == 0 );
    3304:	8d e9       	ldi	r24, 0x9D	; 157
    3306:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <enc28j60_crgetc>
    330a:	80 ff       	sbrs	r24, 0
    330c:	fb cf       	rjmp	.-10     	; 0x3304 <nicInitialize+0x28>
  
  // Setup RX buffers...
  enc28j60_crputc(ENC_REG_ERXSTL, 0x00);
    330e:	88 e0       	ldi	r24, 0x08	; 8
    3310:	60 e0       	ldi	r22, 0x00	; 0
    3312:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_ERXSTH, 0x00);
    3316:	89 e0       	ldi	r24, 0x09	; 9
    3318:	60 e0       	ldi	r22, 0x00	; 0
    331a:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  enc28j60_crputc(ENC_REG_ERXNDL, 0xFF);
    331e:	8a e0       	ldi	r24, 0x0A	; 10
    3320:	6f ef       	ldi	r22, 0xFF	; 255
    3322:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_ERXNDH, 0x19);
    3326:	8b e0       	ldi	r24, 0x0B	; 11
    3328:	69 e1       	ldi	r22, 0x19	; 25
    332a:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  // Setup TX Buffers...
  enc28j60_crputw(ENC_REG_ETXSTL, ENC_ETXST);
    332e:	84 e0       	ldi	r24, 0x04	; 4
    3330:	60 e0       	ldi	r22, 0x00	; 0
    3332:	7a e1       	ldi	r23, 0x1A	; 26
    3334:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXSTL, 0x00);
  //enc28j60_crputc(ENC_REG_ETXSTH, 0x1A);

  enc28j60_crputw(ENC_REG_ETXNDL, ENC_ETXND);
    3338:	86 e0       	ldi	r24, 0x06	; 6
    333a:	6f ef       	ldi	r22, 0xFF	; 255
    333c:	7f e1       	ldi	r23, 0x1F	; 31
    333e:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXNDL, 0xFF);
  //enc28j60_crputc(ENC_REG_ETXNDH, 0x1F);

  // Clear MARST in MACON2 to start Mac Module 
  enc28j60_crputc(ENC_REG_MACON2, 0x00);
    3342:	81 e4       	ldi	r24, 0x41	; 65
    3344:	60 e0       	ldi	r22, 0x00	; 0
    3346:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  // enabled MARXEN in MACON1 to enable receive ...
  // ...TXPAUS and RXPAUS for FullDuplex with FlowControl
  enc28j60_crputc(
    334a:	80 e4       	ldi	r24, 0x40	; 64
    334c:	6d e0       	ldi	r22, 0x0D	; 13
    334e:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
      ENC_REG_MACON1, 
      ENC_REG_MACON1_MARXEN | ENC_REG_MACON1_RXPAUS | ENC_REG_MACON1_TXPAUS);

  // enable automatic Padding (PADCFG) automatic CRC ...
  // .. (TXCRCEN) and Framelength Check in MACON3
  enc28j60_crputc(
    3352:	82 e4       	ldi	r24, 0x42	; 66
    3354:	62 e3       	ldi	r22, 0x32	; 50
    3356:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
      ENC_REG_MACON3,
      ENC_REG_MACON3_PADCFG0 | ENC_REG_MACON3_TXCRCEN  | ENC_REG_MACON3_FRMLEN);

  // set Maximum frame length
  // Programm MAMXFL regiserts to set maximum framelength. 1518 (0x5EE) are normal
  enc28j60_crputc(ENC_REG_MAMXFLL,0xEE);
    335a:	8a e4       	ldi	r24, 0x4A	; 74
    335c:	6e ee       	ldi	r22, 0xEE	; 238
    335e:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAMXFLH,0x05);
    3362:	8b e4       	ldi	r24, 0x4B	; 75
    3364:	65 e0       	ldi	r22, 0x05	; 5
    3366:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  // TODO ENC auf Full duplex setzen...
  // Set MABBIPG with 15h (recommended for Full Duplex)
  enc28j60_crputc(ENC_REG_MABBIPG, 0x12);
    336a:	84 e4       	ldi	r24, 0x44	; 68
    336c:	62 e1       	ldi	r22, 0x12	; 18
    336e:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  // set MAIPGL to 12h
  enc28j60_crputc(ENC_REG_MAIPGL, 0x12);
    3372:	86 e4       	ldi	r24, 0x46	; 70
    3374:	62 e1       	ldi	r22, 0x12	; 18
    3376:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  // set HAIPGH to 0h
  enc28j60_crputc(ENC_REG_MAIPGH, 0x0C);
    337a:	87 e4       	ldi	r24, 0x47	; 71
    337c:	6c e0       	ldi	r22, 0x0C	; 12
    337e:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  
  //10.) programm mac address: BYTE BACKWARD !
  enc28j60_crputc(ENC_REG_MAADR0,mac->octet6);
    3382:	81 e6       	ldi	r24, 0x61	; 97
    3384:	6d 81       	ldd	r22, Y+5	; 0x05
    3386:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR1,mac->octet5);
    338a:	80 e6       	ldi	r24, 0x60	; 96
    338c:	6c 81       	ldd	r22, Y+4	; 0x04
    338e:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR2,mac->octet4);
    3392:	83 e6       	ldi	r24, 0x63	; 99
    3394:	6b 81       	ldd	r22, Y+3	; 0x03
    3396:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR3,mac->octet3);
    339a:	82 e6       	ldi	r24, 0x62	; 98
    339c:	6a 81       	ldd	r22, Y+2	; 0x02
    339e:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR4,mac->octet2);
    33a2:	85 e6       	ldi	r24, 0x65	; 101
    33a4:	69 81       	ldd	r22, Y+1	; 0x01
    33a6:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>
  enc28j60_crputc(ENC_REG_MAADR5,mac->octet1);
    33aa:	84 e6       	ldi	r24, 0x64	; 100
    33ac:	68 81       	ld	r22, Y
    33ae:	0e 94 56 15 	call	0x2aac	; 0x2aac <enc28j60_crputc>

  // Initialize Phy
  // TODO PHY flags ber define festlegen...
  // disable loopback
  enc28j60_prputw(0x10,(1 << 8));
    33b2:	80 e1       	ldi	r24, 0x10	; 16
    33b4:	60 e0       	ldi	r22, 0x00	; 0
    33b6:	71 e0       	ldi	r23, 0x01	; 1
    33b8:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <enc28j60_prputw>

  // enable LEDs
  enc28j60_prputw(0x14,0x0472);
    33bc:	84 e1       	ldi	r24, 0x14	; 20
    33be:	62 e7       	ldi	r22, 0x72	; 114
    33c0:	74 e0       	ldi	r23, 0x04	; 4
    33c2:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <enc28j60_prputw>

  // enable receive
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_RXEN);
    33c6:	8f e9       	ldi	r24, 0x9F	; 159
    33c8:	64 e0       	ldi	r22, 0x04	; 4
    33ca:	0e 94 30 14 	call	0x2860	; 0x2860 <enc28j60_crbfs>
  
  // set next packet pointer to 0
  enc28j60_crputw(ENC_REG_ERDPTL,0);
    33ce:	80 e0       	ldi	r24, 0x00	; 0
    33d0:	60 e0       	ldi	r22, 0x00	; 0
    33d2:	70 e0       	ldi	r23, 0x00	; 0
    33d4:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>

  return;
}
    33d8:	df 91       	pop	r29
    33da:	cf 91       	pop	r28
    33dc:	08 95       	ret

000033de <nicWaitForSend>:

  return handle->packet->length;
}

void nicWaitForSend()
{
    33de:	1f 93       	push	r17
    33e0:	cf 93       	push	r28
    33e2:	df 93       	push	r29
    33e4:	11 e3       	ldi	r17, 0x31	; 49
    33e6:	c0 e0       	ldi	r28, 0x00	; 0
    33e8:	d0 e9       	ldi	r29, 0x90	; 144
    33ea:	06 c0       	rjmp	.+12     	; 0x33f8 <nicWaitForSend+0x1a>
    33ec:	ce 01       	movw	r24, r28
    33ee:	01 97       	sbiw	r24, 0x01	; 1
    33f0:	f1 f7       	brne	.-4      	; 0x33ee <nicWaitForSend+0x10>
    33f2:	11 50       	subi	r17, 0x01	; 1
  //still sending ?
  uint8_t i = 50;
  while( i-- )
    33f4:	1f 3f       	cpi	r17, 0xFF	; 255
    33f6:	49 f0       	breq	.+18     	; 0x340a <nicWaitForSend+0x2c>
  {
    // finished sending?
    if ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS))
    33f8:	8f e9       	ldi	r24, 0x9F	; 159
    33fa:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <enc28j60_crgetc>
    33fe:	83 fd       	sbrc	r24, 3
    3400:	f5 cf       	rjmp	.-22     	; 0x33ec <nicWaitForSend+0xe>

  putString("Waitedlong enough");
  
  // ...we waited long enough, continue anyway
  return;
}
    3402:	df 91       	pop	r29
    3404:	cf 91       	pop	r28
    3406:	1f 91       	pop	r17
    3408:	08 95       	ret
        
    // ... no - let's wait some more ms...  
    _delay_ms(10);    
  }

  putString("Waitedlong enough");
    340a:	85 ed       	ldi	r24, 0xD5	; 213
    340c:	91 e0       	ldi	r25, 0x01	; 1
    340e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  
  // ...we waited long enough, continue anyway
  return;
}
    3412:	df 91       	pop	r29
    3414:	cf 91       	pop	r28
    3416:	1f 91       	pop	r17
    3418:	08 95       	ret

0000341a <nicSendPacket>:

uint8_t nicSendPacket(const struct nicRequestHandle_t* handle, uint8_t flags)
{
    341a:	bf 92       	push	r11
    341c:	cf 92       	push	r12
    341e:	df 92       	push	r13
    3420:	ef 92       	push	r14
    3422:	ff 92       	push	r15
    3424:	0f 93       	push	r16
    3426:	1f 93       	push	r17
    3428:	df 93       	push	r29
    342a:	cf 93       	push	r28
    342c:	0f 92       	push	r0
    342e:	cd b7       	in	r28, 0x3d	; 61
    3430:	de b7       	in	r29, 0x3e	; 62
    3432:	6c 01       	movw	r12, r24
    3434:	b6 2e       	mov	r11, r22
    3436:	12 e3       	ldi	r17, 0x32	; 50
    3438:	e1 2c       	mov	r14, r1
    343a:	80 e9       	ldi	r24, 0x90	; 144
    343c:	f8 2e       	mov	r15, r24
    343e:	06 c0       	rjmp	.+12     	; 0x344c <nicSendPacket+0x32>
    3440:	c7 01       	movw	r24, r14
    3442:	01 97       	sbiw	r24, 0x01	; 1
    3444:	f1 f7       	brne	.-4      	; 0x3442 <nicSendPacket+0x28>
    3446:	11 50       	subi	r17, 0x01	; 1

void nicWaitForSend()
{
  //still sending ?
  uint8_t i = 50;
  while( i-- )
    3448:	09 f4       	brne	.+2      	; 0x344c <nicSendPacket+0x32>
    344a:	57 c0       	rjmp	.+174    	; 0x34fa <nicSendPacket+0xe0>
  {
    // finished sending?
    if ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS))
    344c:	8f e9       	ldi	r24, 0x9F	; 159
    344e:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <enc28j60_crgetc>
    3452:	83 fd       	sbrc	r24, 3
    3454:	f5 cf       	rjmp	.-22     	; 0x3440 <nicSendPacket+0x26>
{
  // Wait until we are ready to send...
  nicWaitForSend();

  // setup tx buffer start
  enc28j60_crputw(ENC_REG_ETXSTL,ENC_ETXST);
    3456:	84 e0       	ldi	r24, 0x04	; 4
    3458:	60 e0       	ldi	r22, 0x00	; 0
    345a:	7a e1       	ldi	r23, 0x1A	; 26
    345c:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXSTL,0x00);
  //enc28j60_crputc(ENC_REG_ETXSTH,0x1A);

  //setup write pointer
  enc28j60_crputw(ENC_REG_EWRPTL,ENC_ETXST);
    3460:	82 e0       	ldi	r24, 0x02	; 2
    3462:	60 e0       	ldi	r22, 0x00	; 0
    3464:	7a e1       	ldi	r23, 0x1A	; 26
    3466:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_EWRPTL,0x00);
  //enc28j60_crputc(ENC_REG_EWRPTH,0x1A);

  // write control block
  uint8_t dummy = 0;
    346a:	19 82       	std	Y+1, r1	; 0x01
  enc28j60_bmputs(&dummy,1);
    346c:	ce 01       	movw	r24, r28
    346e:	01 96       	adiw	r24, 0x01	; 1
    3470:	61 e0       	ldi	r22, 0x01	; 1
    3472:	70 e0       	ldi	r23, 0x00	; 0
    3474:	0e 94 4b 13 	call	0x2696	; 0x2696 <enc28j60_bmputs>
  
  // now start building the packet...
  
  struct soPacket_t* packet = handle->packet;
    3478:	f6 01       	movw	r30, r12
    347a:	00 81       	ld	r16, Z
    347c:	11 81       	ldd	r17, Z+1	; 0x01
 
       
  while( packet != NULL)
    347e:	01 15       	cp	r16, r1
    3480:	11 05       	cpc	r17, r1
    3482:	81 f0       	breq	.+32     	; 0x34a4 <nicSendPacket+0x8a>
  {    
    enc28j60_bmputs(packet->header.data,packet->header.length);   
    3484:	f8 01       	movw	r30, r16
    3486:	62 81       	ldd	r22, Z+2	; 0x02
    3488:	73 81       	ldd	r23, Z+3	; 0x03
    348a:	80 81       	ld	r24, Z
    348c:	91 81       	ldd	r25, Z+1	; 0x01
    348e:	0e 94 4b 13 	call	0x2696	; 0x2696 <enc28j60_bmputs>
    packet = packet->payload;
    3492:	f8 01       	movw	r30, r16
    3494:	04 81       	ldd	r16, Z+4	; 0x04
    3496:	15 81       	ldd	r17, Z+5	; 0x05
  // now start building the packet...
  
  struct soPacket_t* packet = handle->packet;
 
       
  while( packet != NULL)
    3498:	01 15       	cp	r16, r1
    349a:	11 05       	cpc	r17, r1
    349c:	99 f7       	brne	.-26     	; 0x3484 <nicSendPacket+0x6a>
    349e:	f6 01       	movw	r30, r12
    34a0:	00 81       	ld	r16, Z
    34a2:	11 81       	ldd	r17, Z+1	; 0x01
    enc28j60_bmputs(packet->header.data,packet->header.length);   
    packet = packet->payload;
  }
  
  // calculate the Packet length...
  enc28j60_crputw(ENC_REG_ETXNDL, ENC_ETXST + handle->packet->length);
    34a4:	f8 01       	movw	r30, r16
    34a6:	66 81       	ldd	r22, Z+6	; 0x06
    34a8:	77 81       	ldd	r23, Z+7	; 0x07
    34aa:	60 50       	subi	r22, 0x00	; 0
    34ac:	76 4e       	sbci	r23, 0xE6	; 230
    34ae:	86 e0       	ldi	r24, 0x06	; 6
    34b0:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <enc28j60_crputw>
  //enc28j60_crputc(ENC_REG_ETXNDL,0x4E);  
  //enc28j60_crputc(ENC_REG_ETXNDH,0x1A);
  
	// according to the Silicon Errata Document (10. Transmit Logic) ...
  // .. we need to reset the transmit logic...
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_TXRST); 
    34b4:	8f e9       	ldi	r24, 0x9F	; 159
    34b6:	60 e8       	ldi	r22, 0x80	; 128
    34b8:	0e 94 30 14 	call	0x2860	; 0x2860 <enc28j60_crbfs>
  enc28j60_crbfc(ENC_REG_ECON1,ENC_REG_ECON1_TXRST);
    34bc:	8f e9       	ldi	r24, 0x9F	; 159
    34be:	60 e8       	ldi	r22, 0x80	; 128
    34c0:	0e 94 91 14 	call	0x2922	; 0x2922 <enc28j60_crbfc>
  
  // transmit request...
  enc28j60_crbfs(ENC_REG_ECON1,ENC_REG_ECON1_TXRTS | ENC_REG_ECON1_RXEN);
    34c4:	8f e9       	ldi	r24, 0x9F	; 159
    34c6:	6c e0       	ldi	r22, 0x0C	; 12
    34c8:	0e 94 30 14 	call	0x2860	; 0x2860 <enc28j60_crbfs>

  // this is now debug only...
  // ... 
  
  if (flags & NIC_PACKET_SEND_NOWAIT)
    34cc:	1b 2d       	mov	r17, r11
    34ce:	b0 fc       	sbrc	r11, 0
    34d0:	07 c0       	rjmp	.+14     	; 0x34e0 <nicSendPacket+0xc6>
    return 0;
  
  // wait until transmit is completed...
  while ( ! (enc28j60_crgetc(ENC_REG_ECON1) & ENC_REG_ECON1_TXRTS) );
    34d2:	8f e9       	ldi	r24, 0x9F	; 159
    34d4:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <enc28j60_crgetc>
    34d8:	83 ff       	sbrs	r24, 3
    34da:	fb cf       	rjmp	.-10     	; 0x34d2 <nicSendPacket+0xb8>
  
  if (flags & NIC_PACKET_SEND_NOERRCHK)
    34dc:	11 ff       	sbrs	r17, 1
    34de:	12 c0       	rjmp	.+36     	; 0x3504 <nicSendPacket+0xea>
    return 0;

  // check ESTAT for send Errors...
  if ((enc28j60_crgetc(ENC_REG_ESTAT) 
    34e0:	90 e0       	ldi	r25, 0x00	; 0
  
  // parse Vector...
  
  
  return 1;  
}
    34e2:	89 2f       	mov	r24, r25
    34e4:	0f 90       	pop	r0
    34e6:	cf 91       	pop	r28
    34e8:	df 91       	pop	r29
    34ea:	1f 91       	pop	r17
    34ec:	0f 91       	pop	r16
    34ee:	ff 90       	pop	r15
    34f0:	ef 90       	pop	r14
    34f2:	df 90       	pop	r13
    34f4:	cf 90       	pop	r12
    34f6:	bf 90       	pop	r11
    34f8:	08 95       	ret
        
    // ... no - let's wait some more ms...  
    _delay_ms(10);    
  }

  putString("Waitedlong enough");
    34fa:	85 ed       	ldi	r24, 0xD5	; 213
    34fc:	91 e0       	ldi	r25, 0x01	; 1
    34fe:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    3502:	a9 cf       	rjmp	.-174    	; 0x3456 <nicSendPacket+0x3c>
  
  if (flags & NIC_PACKET_SEND_NOERRCHK)
    return 0;

  // check ESTAT for send Errors...
  if ((enc28j60_crgetc(ENC_REG_ESTAT) 
    3504:	8d e9       	ldi	r24, 0x9D	; 157
    3506:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <enc28j60_crgetc>
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	82 71       	andi	r24, 0x12	; 18
    350e:	49 f3       	breq	.-46     	; 0x34e2 <nicSendPacket+0xc8>
    3510:	91 e0       	ldi	r25, 0x01	; 1
    3512:	e7 cf       	rjmp	.-50     	; 0x34e2 <nicSendPacket+0xc8>

00003514 <onInitApplication>:
  #include "./../../hal/com/com1_debug.h"

  void onInitApplication()
  {
      return;
  }
    3514:	08 95       	ret

00003516 <onSerialData>:
	//hier perfomance test vom enc hat funktioniert!!!! alx
    //rtpSendCommand("Syntax Error\n", 13, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);

	//rtpSendCommand("egal\n", 6, &Config.IPv4.remoteAdrData, &Config.IPv4.localSrcPort);  

    rtpSendCDPData(buf, len, &Config.IPv4.remoteAdrData, &Config.IPv4.localSrcPort);  
    3516:	2a e2       	ldi	r18, 0x2A	; 42
    3518:	39 e0       	ldi	r19, 0x09	; 9
    351a:	70 e0       	ldi	r23, 0x00	; 0
    351c:	a9 01       	movw	r20, r18
    351e:	24 5f       	subi	r18, 0xF4	; 244
    3520:	3f 4f       	sbci	r19, 0xFF	; 255
    3522:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <rtpSendCDPData>
	//putString("\r\nSP");

    return 0;
  }
    3526:	80 e0       	ldi	r24, 0x00	; 0
    3528:	08 95       	ret

0000352a <onRtpData>:
  }


  void onRtpData(char* buf, uint8_t len)
  {    
    if (len > 0)
    352a:	66 23       	and	r22, r22
    352c:	09 f4       	brne	.+2      	; 0x3530 <onRtpData+0x6>
    352e:	08 95       	ret
      serialSendBytes(buf,len);
    3530:	0e 94 b8 0c 	call	0x1970	; 0x1970 <serialSendBytes>
    3534:	08 95       	ret

00003536 <calculateCheckSum>:
#include "./netlib.h"

  // Kann nur die checksummer ber ein e gerade anzahl berechen... 
  uint16_t calculateCheckSum(void* bytes, uint16_t len)
  {
    3536:	dc 01       	movw	r26, r24
   register uint32_t checksum = 0x00000000;
   
   // as we are processing full words, the length of the data ...
   // ... has to be odd. If it's even, we would loose the last byte 
   // ... so we have to take some precautions
   if (len & 0x00000001)
    3538:	60 fd       	sbrc	r22, 0
    353a:	34 c0       	rjmp	.+104    	; 0x35a4 <calculateCheckSum+0x6e>
    353c:	20 e0       	ldi	r18, 0x00	; 0
    353e:	30 e0       	ldi	r19, 0x00	; 0
    3540:	40 e0       	ldi	r20, 0x00	; 0
    3542:	50 e0       	ldi	r21, 0x00	; 0
     checksum+= (((uint8_t*)bytes)[len]);
   
   // now, as we ensured an odd length, we can convert the length...
   // ... from bytes to words  
   len = len >> 1;
    3544:	76 95       	lsr	r23
    3546:	67 95       	ror	r22

   // calculate the checksum, wordwise
   while (len--)
    3548:	61 15       	cp	r22, r1
    354a:	71 05       	cpc	r23, r1
    354c:	01 f1       	breq	.+64     	; 0x358e <calculateCheckSum+0x58>
    354e:	fb 01       	movw	r30, r22
    3550:	e1 50       	subi	r30, 0x01	; 1
    3552:	f0 48       	sbci	r31, 0x80	; 128
    3554:	ee 0f       	add	r30, r30
    3556:	ff 1f       	adc	r31, r31
    3558:	ea 0f       	add	r30, r26
    355a:	fb 1f       	adc	r31, r27
     checksum += (((uint16_t *)bytes)[len]);
    355c:	80 81       	ld	r24, Z
    355e:	91 81       	ldd	r25, Z+1	; 0x01
    3560:	a0 e0       	ldi	r26, 0x00	; 0
    3562:	b0 e0       	ldi	r27, 0x00	; 0
    3564:	28 0f       	add	r18, r24
    3566:	39 1f       	adc	r19, r25
    3568:	4a 1f       	adc	r20, r26
    356a:	5b 1f       	adc	r21, r27
    356c:	32 97       	sbiw	r30, 0x02	; 2
    356e:	61 50       	subi	r22, 0x01	; 1
    3570:	70 40       	sbci	r23, 0x00	; 0
   // now, as we ensured an odd length, we can convert the length...
   // ... from bytes to words  
   len = len >> 1;

   // calculate the checksum, wordwise
   while (len--)
    3572:	a1 f7       	brne	.-24     	; 0x355c <calculateCheckSum+0x26>
     checksum += (((uint16_t *)bytes)[len]);

   // add overflows to the checksum 
   while (checksum>>16)
    3574:	ca 01       	movw	r24, r20
    3576:	aa 27       	eor	r26, r26
    3578:	bb 27       	eor	r27, r27
    357a:	00 97       	sbiw	r24, 0x00	; 0
    357c:	a1 05       	cpc	r26, r1
    357e:	b1 05       	cpc	r27, r1
    3580:	69 f0       	breq	.+26     	; 0x359c <calculateCheckSum+0x66>
     checksum = (checksum & 0xffff) + (checksum >> 16);
    3582:	40 70       	andi	r20, 0x00	; 0
    3584:	50 70       	andi	r21, 0x00	; 0
    3586:	28 0f       	add	r18, r24
    3588:	39 1f       	adc	r19, r25
    358a:	4a 1f       	adc	r20, r26
    358c:	5b 1f       	adc	r21, r27
   // calculate the checksum, wordwise
   while (len--)
     checksum += (((uint16_t *)bytes)[len]);

   // add overflows to the checksum 
   while (checksum>>16)
    358e:	ca 01       	movw	r24, r20
    3590:	aa 27       	eor	r26, r26
    3592:	bb 27       	eor	r27, r27
    3594:	00 97       	sbiw	r24, 0x00	; 0
    3596:	a1 05       	cpc	r26, r1
    3598:	b1 05       	cpc	r27, r1
    359a:	99 f7       	brne	.-26     	; 0x3582 <calculateCheckSum+0x4c>
    359c:	20 95       	com	r18
    359e:	30 95       	com	r19
     checksum = (checksum & 0xffff) + (checksum >> 16);

   return ~((uint16_t)checksum);
 };
    35a0:	c9 01       	movw	r24, r18
    35a2:	08 95       	ret
   
   // as we are processing full words, the length of the data ...
   // ... has to be odd. If it's even, we would loose the last byte 
   // ... so we have to take some precautions
   if (len & 0x00000001)
     checksum+= (((uint8_t*)bytes)[len]);
    35a4:	fc 01       	movw	r30, r24
    35a6:	e6 0f       	add	r30, r22
    35a8:	f7 1f       	adc	r31, r23
    35aa:	80 81       	ld	r24, Z
    35ac:	28 2f       	mov	r18, r24
    35ae:	30 e0       	ldi	r19, 0x00	; 0
    35b0:	40 e0       	ldi	r20, 0x00	; 0
    35b2:	50 e0       	ldi	r21, 0x00	; 0
    35b4:	c7 cf       	rjmp	.-114    	; 0x3544 <calculateCheckSum+0xe>

000035b6 <stringLength>:
extern void serialEepromGetConfig(uint16_t * prescaler, uint8_t * parity, uint8_t * stop_bits, uint8_t * data_bits);

static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
    35b6:	fc 01       	movw	r30, r24
  uint8_t len = 0;
  while (*buf++)
    35b8:	80 81       	ld	r24, Z
    35ba:	88 23       	and	r24, r24
    35bc:	41 f0       	breq	.+16     	; 0x35ce <stringLength+0x18>
    35be:	90 e0       	ldi	r25, 0x00	; 0
    len++;
    35c0:	9f 5f       	subi	r25, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    35c2:	81 81       	ldd	r24, Z+1	; 0x01
    35c4:	31 96       	adiw	r30, 0x01	; 1
    35c6:	88 23       	and	r24, r24
    35c8:	d9 f7       	brne	.-10     	; 0x35c0 <stringLength+0xa>
    len++;
  return len;
}
    35ca:	89 2f       	mov	r24, r25
    35cc:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    35ce:	90 e0       	ldi	r25, 0x00	; 0
    35d0:	fc cf       	rjmp	.-8      	; 0x35ca <stringLength+0x14>

000035d2 <rcfg_Reboot>:


uint8_t rcfg_Reboot(char * buf)
{
  // disable interrupts
  cli();
    35d2:	f8 94       	cli

  // jump into bootloader
  asm volatile ("jmp 0x1e000");
    35d4:	0c 94 00 f0 	jmp	0x1e000	; 0x1e000 <__data_load_end+0x17a06>

  return RCFG_SUCCESS;
}
    35d8:	80 e0       	ldi	r24, 0x00	; 0
    35da:	08 95       	ret

000035dc <rcfg_Disable>:

uint8_t rcfg_Disable(char * buf)
{
  isDisabled = 1;
    35dc:	81 e0       	ldi	r24, 0x01	; 1
    35de:	80 93 e0 07 	sts	0x07E0, r24
  return RCFG_SUCCESS;
}
    35e2:	80 e0       	ldi	r24, 0x00	; 0
    35e4:	08 95       	ret

000035e6 <Config_is_Disabled>:

uint8_t Config_is_Disabled()
{
  return isDisabled;
}
    35e6:	80 91 e0 07 	lds	r24, 0x07E0
    35ea:	08 95       	ret

000035ec <rcfg_getDataBits>:
		return RCFG_FAIL;

  	
}
uint8_t rcfg_getDataBits(char * buf)
{
    35ec:	0f 93       	push	r16
    35ee:	1f 93       	push	r17
    35f0:	df 93       	push	r29
    35f2:	cf 93       	push	r28
    35f4:	cd b7       	in	r28, 0x3d	; 61
    35f6:	de b7       	in	r29, 0x3e	; 62
    35f8:	2b 97       	sbiw	r28, 0x0b	; 11
    35fa:	0f b6       	in	r0, 0x3f	; 63
    35fc:	f8 94       	cli
    35fe:	de bf       	out	0x3e, r29	; 62
    3600:	0f be       	out	0x3f, r0	; 63
    3602:	cd bf       	out	0x3d, r28	; 61

	uint8_t data_bits=0;
    3604:	19 82       	std	Y+1, r1	; 0x01
	char sendbuf[10] = {0}; // clear buffer;
    3606:	8e 01       	movw	r16, r28
    3608:	0e 5f       	subi	r16, 0xFE	; 254
    360a:	1f 4f       	sbci	r17, 0xFF	; 255
    360c:	8a e0       	ldi	r24, 0x0A	; 10
    360e:	f8 01       	movw	r30, r16
    3610:	11 92       	st	Z+, r1
    3612:	8a 95       	dec	r24
    3614:	e9 f7       	brne	.-6      	; 0x3610 <rcfg_getDataBits+0x24>

	serialEepromGetConfig(NULL,NULL,NULL,&data_bits);
    3616:	80 e0       	ldi	r24, 0x00	; 0
    3618:	90 e0       	ldi	r25, 0x00	; 0
    361a:	60 e0       	ldi	r22, 0x00	; 0
    361c:	70 e0       	ldi	r23, 0x00	; 0
    361e:	40 e0       	ldi	r20, 0x00	; 0
    3620:	50 e0       	ldi	r21, 0x00	; 0
    3622:	9e 01       	movw	r18, r28
    3624:	2f 5f       	subi	r18, 0xFF	; 255
    3626:	3f 4f       	sbci	r19, 0xFF	; 255
    3628:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	data_bits+=5;
    362c:	69 81       	ldd	r22, Y+1	; 0x01
    362e:	6b 5f       	subi	r22, 0xFB	; 251
    3630:	69 83       	std	Y+1, r22	; 0x01
	ultoa(data_bits, sendbuf, 10);
    3632:	70 e0       	ldi	r23, 0x00	; 0
    3634:	80 e0       	ldi	r24, 0x00	; 0
    3636:	90 e0       	ldi	r25, 0x00	; 0
    3638:	a8 01       	movw	r20, r16
    363a:	2a e0       	ldi	r18, 0x0A	; 10
    363c:	30 e0       	ldi	r19, 0x00	; 0
    363e:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3642:	8a 81       	ldd	r24, Y+2	; 0x02
    3644:	88 23       	and	r24, r24
    3646:	11 f1       	breq	.+68     	; 0x368c <rcfg_getDataBits+0xa0>
    3648:	60 e0       	ldi	r22, 0x00	; 0
    364a:	fe 01       	movw	r30, r28
    364c:	33 96       	adiw	r30, 0x03	; 3
    len++;
    364e:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3650:	81 91       	ld	r24, Z+
    3652:	88 23       	and	r24, r24
    3654:	e1 f7       	brne	.-8      	; 0x364e <rcfg_getDataBits+0x62>
    3656:	70 e0       	ldi	r23, 0x00	; 0
	serialEepromGetConfig(NULL,NULL,NULL,&data_bits);
	data_bits+=5;
	ultoa(data_bits, sendbuf, 10);
	

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3658:	c8 01       	movw	r24, r16
    365a:	40 e3       	ldi	r20, 0x30	; 48
    365c:	59 e0       	ldi	r21, 0x09	; 9
    365e:	26 e3       	ldi	r18, 0x36	; 54
    3660:	39 e0       	ldi	r19, 0x09	; 9
    3662:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString("\r\nDataBits: ");
    3666:	87 ee       	ldi	r24, 0xE7	; 231
    3668:	91 e0       	ldi	r25, 0x01	; 1
    366a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(sendbuf);
    366e:	c8 01       	movw	r24, r16
    3670:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

  return RCFG_SUCCESS;
}
    3674:	80 e0       	ldi	r24, 0x00	; 0
    3676:	2b 96       	adiw	r28, 0x0b	; 11
    3678:	0f b6       	in	r0, 0x3f	; 63
    367a:	f8 94       	cli
    367c:	de bf       	out	0x3e, r29	; 62
    367e:	0f be       	out	0x3f, r0	; 63
    3680:	cd bf       	out	0x3d, r28	; 61
    3682:	cf 91       	pop	r28
    3684:	df 91       	pop	r29
    3686:	1f 91       	pop	r17
    3688:	0f 91       	pop	r16
    368a:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    368c:	60 e0       	ldi	r22, 0x00	; 0
    368e:	70 e0       	ldi	r23, 0x00	; 0
    3690:	e3 cf       	rjmp	.-58     	; 0x3658 <rcfg_getDataBits+0x6c>

00003692 <rcfg_getStopBits>:
		return RCFG_FAIL;


}
uint8_t rcfg_getStopBits(char * buf)
{
    3692:	0f 93       	push	r16
    3694:	1f 93       	push	r17
    3696:	df 93       	push	r29
    3698:	cf 93       	push	r28
    369a:	cd b7       	in	r28, 0x3d	; 61
    369c:	de b7       	in	r29, 0x3e	; 62
    369e:	2b 97       	sbiw	r28, 0x0b	; 11
    36a0:	0f b6       	in	r0, 0x3f	; 63
    36a2:	f8 94       	cli
    36a4:	de bf       	out	0x3e, r29	; 62
    36a6:	0f be       	out	0x3f, r0	; 63
    36a8:	cd bf       	out	0x3d, r28	; 61

	uint8_t stop_bits=0;
    36aa:	19 82       	std	Y+1, r1	; 0x01

	char sendbuf[10] = {0}; // clear buffer;
    36ac:	8e 01       	movw	r16, r28
    36ae:	0e 5f       	subi	r16, 0xFE	; 254
    36b0:	1f 4f       	sbci	r17, 0xFF	; 255
    36b2:	8a e0       	ldi	r24, 0x0A	; 10
    36b4:	f8 01       	movw	r30, r16
    36b6:	11 92       	st	Z+, r1
    36b8:	8a 95       	dec	r24
    36ba:	e9 f7       	brne	.-6      	; 0x36b6 <rcfg_getStopBits+0x24>

	serialEepromGetConfig(NULL,NULL,&stop_bits,NULL);
    36bc:	80 e0       	ldi	r24, 0x00	; 0
    36be:	90 e0       	ldi	r25, 0x00	; 0
    36c0:	60 e0       	ldi	r22, 0x00	; 0
    36c2:	70 e0       	ldi	r23, 0x00	; 0
    36c4:	ae 01       	movw	r20, r28
    36c6:	4f 5f       	subi	r20, 0xFF	; 255
    36c8:	5f 4f       	sbci	r21, 0xFF	; 255
    36ca:	20 e0       	ldi	r18, 0x00	; 0
    36cc:	30 e0       	ldi	r19, 0x00	; 0
    36ce:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	ultoa(stop_bits+1, sendbuf, 10);
    36d2:	69 81       	ldd	r22, Y+1	; 0x01
    36d4:	70 e0       	ldi	r23, 0x00	; 0
    36d6:	6f 5f       	subi	r22, 0xFF	; 255
    36d8:	7f 4f       	sbci	r23, 0xFF	; 255
    36da:	88 27       	eor	r24, r24
    36dc:	77 fd       	sbrc	r23, 7
    36de:	80 95       	com	r24
    36e0:	98 2f       	mov	r25, r24
    36e2:	a8 01       	movw	r20, r16
    36e4:	2a e0       	ldi	r18, 0x0A	; 10
    36e6:	30 e0       	ldi	r19, 0x00	; 0
    36e8:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    36ec:	8a 81       	ldd	r24, Y+2	; 0x02
    36ee:	88 23       	and	r24, r24
    36f0:	11 f1       	breq	.+68     	; 0x3736 <rcfg_getStopBits+0xa4>
    36f2:	60 e0       	ldi	r22, 0x00	; 0
    36f4:	fe 01       	movw	r30, r28
    36f6:	33 96       	adiw	r30, 0x03	; 3
    len++;
    36f8:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    36fa:	81 91       	ld	r24, Z+
    36fc:	88 23       	and	r24, r24
    36fe:	e1 f7       	brne	.-8      	; 0x36f8 <rcfg_getStopBits+0x66>
    3700:	70 e0       	ldi	r23, 0x00	; 0
	char sendbuf[10] = {0}; // clear buffer;

	serialEepromGetConfig(NULL,NULL,&stop_bits,NULL);
	ultoa(stop_bits+1, sendbuf, 10);

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3702:	c8 01       	movw	r24, r16
    3704:	40 e3       	ldi	r20, 0x30	; 48
    3706:	59 e0       	ldi	r21, 0x09	; 9
    3708:	26 e3       	ldi	r18, 0x36	; 54
    370a:	39 e0       	ldi	r19, 0x09	; 9
    370c:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString("\r\nStopBits: ");
    3710:	84 ef       	ldi	r24, 0xF4	; 244
    3712:	91 e0       	ldi	r25, 0x01	; 1
    3714:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(sendbuf);
    3718:	c8 01       	movw	r24, r16
    371a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

  return RCFG_SUCCESS;
}
    371e:	80 e0       	ldi	r24, 0x00	; 0
    3720:	2b 96       	adiw	r28, 0x0b	; 11
    3722:	0f b6       	in	r0, 0x3f	; 63
    3724:	f8 94       	cli
    3726:	de bf       	out	0x3e, r29	; 62
    3728:	0f be       	out	0x3f, r0	; 63
    372a:	cd bf       	out	0x3d, r28	; 61
    372c:	cf 91       	pop	r28
    372e:	df 91       	pop	r29
    3730:	1f 91       	pop	r17
    3732:	0f 91       	pop	r16
    3734:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3736:	60 e0       	ldi	r22, 0x00	; 0
    3738:	70 e0       	ldi	r23, 0x00	; 0
    373a:	e3 cf       	rjmp	.-58     	; 0x3702 <rcfg_getStopBits+0x70>

0000373c <rcfg_getParity>:
	}
	else
		return RCFG_FAIL;
}
uint8_t rcfg_getParity(char * buf)
{
    373c:	0f 93       	push	r16
    373e:	1f 93       	push	r17
    3740:	df 93       	push	r29
    3742:	cf 93       	push	r28
    3744:	cd b7       	in	r28, 0x3d	; 61
    3746:	de b7       	in	r29, 0x3e	; 62
    3748:	2b 97       	sbiw	r28, 0x0b	; 11
    374a:	0f b6       	in	r0, 0x3f	; 63
    374c:	f8 94       	cli
    374e:	de bf       	out	0x3e, r29	; 62
    3750:	0f be       	out	0x3f, r0	; 63
    3752:	cd bf       	out	0x3d, r28	; 61

	uint8_t parity=0;
    3754:	19 82       	std	Y+1, r1	; 0x01

	char sendbuf[10] = {0}; // clear buffer;
    3756:	8e 01       	movw	r16, r28
    3758:	0e 5f       	subi	r16, 0xFE	; 254
    375a:	1f 4f       	sbci	r17, 0xFF	; 255
    375c:	8a e0       	ldi	r24, 0x0A	; 10
    375e:	f8 01       	movw	r30, r16
    3760:	11 92       	st	Z+, r1
    3762:	8a 95       	dec	r24
    3764:	e9 f7       	brne	.-6      	; 0x3760 <rcfg_getParity+0x24>

	serialEepromGetConfig(NULL,&parity,NULL,NULL);
    3766:	80 e0       	ldi	r24, 0x00	; 0
    3768:	90 e0       	ldi	r25, 0x00	; 0
    376a:	be 01       	movw	r22, r28
    376c:	6f 5f       	subi	r22, 0xFF	; 255
    376e:	7f 4f       	sbci	r23, 0xFF	; 255
    3770:	40 e0       	ldi	r20, 0x00	; 0
    3772:	50 e0       	ldi	r21, 0x00	; 0
    3774:	20 e0       	ldi	r18, 0x00	; 0
    3776:	30 e0       	ldi	r19, 0x00	; 0
    3778:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	ultoa(parity, sendbuf, 10);
    377c:	69 81       	ldd	r22, Y+1	; 0x01
    377e:	70 e0       	ldi	r23, 0x00	; 0
    3780:	80 e0       	ldi	r24, 0x00	; 0
    3782:	90 e0       	ldi	r25, 0x00	; 0
    3784:	a8 01       	movw	r20, r16
    3786:	2a e0       	ldi	r18, 0x0A	; 10
    3788:	30 e0       	ldi	r19, 0x00	; 0
    378a:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    378e:	8a 81       	ldd	r24, Y+2	; 0x02
    3790:	88 23       	and	r24, r24
    3792:	f1 f1       	breq	.+124    	; 0x3810 <rcfg_getParity+0xd4>
    3794:	60 e0       	ldi	r22, 0x00	; 0
    3796:	fe 01       	movw	r30, r28
    3798:	33 96       	adiw	r30, 0x03	; 3
    len++;
    379a:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    379c:	81 91       	ld	r24, Z+
    379e:	88 23       	and	r24, r24
    37a0:	e1 f7       	brne	.-8      	; 0x379a <rcfg_getParity+0x5e>
    37a2:	70 e0       	ldi	r23, 0x00	; 0
	char sendbuf[10] = {0}; // clear buffer;

	serialEepromGetConfig(NULL,&parity,NULL,NULL);
	ultoa(parity, sendbuf, 10);

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    37a4:	c8 01       	movw	r24, r16
    37a6:	40 e3       	ldi	r20, 0x30	; 48
    37a8:	59 e0       	ldi	r21, 0x09	; 9
    37aa:	26 e3       	ldi	r18, 0x36	; 54
    37ac:	39 e0       	ldi	r19, 0x09	; 9
    37ae:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString("\r\n");
    37b2:	81 e0       	ldi	r24, 0x01	; 1
    37b4:	92 e0       	ldi	r25, 0x02	; 2
    37b6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(sendbuf);
    37ba:	c8 01       	movw	r24, r16
    37bc:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	switch (parity)
    37c0:	89 81       	ldd	r24, Y+1	; 0x01
    37c2:	81 30       	cpi	r24, 0x01	; 1
    37c4:	01 f1       	breq	.+64     	; 0x3806 <rcfg_getParity+0xca>
    37c6:	81 30       	cpi	r24, 0x01	; 1
    37c8:	80 f4       	brcc	.+32     	; 0x37ea <rcfg_getParity+0xae>
	{
		case 0:
			putString("\r\nParity Disabled: ");
    37ca:	84 e0       	ldi	r24, 0x04	; 4
    37cc:	92 e0       	ldi	r25, 0x02	; 2
    37ce:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
		break;
	}
	

  return RCFG_SUCCESS;
}
    37d2:	80 e0       	ldi	r24, 0x00	; 0
    37d4:	2b 96       	adiw	r28, 0x0b	; 11
    37d6:	0f b6       	in	r0, 0x3f	; 63
    37d8:	f8 94       	cli
    37da:	de bf       	out	0x3e, r29	; 62
    37dc:	0f be       	out	0x3f, r0	; 63
    37de:	cd bf       	out	0x3d, r28	; 61
    37e0:	cf 91       	pop	r28
    37e2:	df 91       	pop	r29
    37e4:	1f 91       	pop	r17
    37e6:	0f 91       	pop	r16
    37e8:	08 95       	ret
	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);

	putString("\r\n");
	putString(sendbuf);

	switch (parity)
    37ea:	82 30       	cpi	r24, 0x02	; 2
    37ec:	39 f0       	breq	.+14     	; 0x37fc <rcfg_getParity+0xc0>
    37ee:	83 30       	cpi	r24, 0x03	; 3
    37f0:	81 f7       	brne	.-32     	; 0x37d2 <rcfg_getParity+0x96>
		break;
		case 2:
			putString("\r\nParity Enabled, Even Parity: ");
		break;
		case 3:
			putString("\r\nParity Enabled, Odd Parity: ");
    37f2:	8c e4       	ldi	r24, 0x4C	; 76
    37f4:	92 e0       	ldi	r25, 0x02	; 2
    37f6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    37fa:	eb cf       	rjmp	.-42     	; 0x37d2 <rcfg_getParity+0x96>
		break;
		case 1:
			putString("\r\nParity Reserved: ");
		break;
		case 2:
			putString("\r\nParity Enabled, Even Parity: ");
    37fc:	8c e2       	ldi	r24, 0x2C	; 44
    37fe:	92 e0       	ldi	r25, 0x02	; 2
    3800:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    3804:	e6 cf       	rjmp	.-52     	; 0x37d2 <rcfg_getParity+0x96>
	{
		case 0:
			putString("\r\nParity Disabled: ");
		break;
		case 1:
			putString("\r\nParity Reserved: ");
    3806:	88 e1       	ldi	r24, 0x18	; 24
    3808:	92 e0       	ldi	r25, 0x02	; 2
    380a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    380e:	e1 cf       	rjmp	.-62     	; 0x37d2 <rcfg_getParity+0x96>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3810:	60 e0       	ldi	r22, 0x00	; 0
    3812:	70 e0       	ldi	r23, 0x00	; 0
    3814:	c7 cf       	rjmp	.-114    	; 0x37a4 <rcfg_getParity+0x68>

00003816 <rcfg_getBaud>:
	serialEepromSetConfig( prescaler,parity,stop_bits,data_bits );
	return RCFG_SUCCESS;
}

uint8_t rcfg_getBaud(char * buf)
{
    3816:	0f 93       	push	r16
    3818:	1f 93       	push	r17
    381a:	df 93       	push	r29
    381c:	cf 93       	push	r28
    381e:	cd b7       	in	r28, 0x3d	; 61
    3820:	de b7       	in	r29, 0x3e	; 62
    3822:	2c 97       	sbiw	r28, 0x0c	; 12
    3824:	0f b6       	in	r0, 0x3f	; 63
    3826:	f8 94       	cli
    3828:	de bf       	out	0x3e, r29	; 62
    382a:	0f be       	out	0x3f, r0	; 63
    382c:	cd bf       	out	0x3d, r28	; 61
  uint16_t prescaler;
  serialEepromGetConfig(&prescaler,NULL,NULL,NULL);
    382e:	ce 01       	movw	r24, r28
    3830:	01 96       	adiw	r24, 0x01	; 1
    3832:	60 e0       	ldi	r22, 0x00	; 0
    3834:	70 e0       	ldi	r23, 0x00	; 0
    3836:	40 e0       	ldi	r20, 0x00	; 0
    3838:	50 e0       	ldi	r21, 0x00	; 0
    383a:	20 e0       	ldi	r18, 0x00	; 0
    383c:	30 e0       	ldi	r19, 0x00	; 0
    383e:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>

  char sendbuf[10] = {0}; // clear buffer;
    3842:	8e 01       	movw	r16, r28
    3844:	0d 5f       	subi	r16, 0xFD	; 253
    3846:	1f 4f       	sbci	r17, 0xFF	; 255
    3848:	8a e0       	ldi	r24, 0x0A	; 10
    384a:	f8 01       	movw	r30, r16
    384c:	11 92       	st	Z+, r1
    384e:	8a 95       	dec	r24
    3850:	e9 f7       	brne	.-6      	; 0x384c <rcfg_getBaud+0x36>
// BAUD = CLOCK_FREQUENCY / (16 * (UBBR + 1))
  //      = (CLOCK_FREQUENCY / 16) / (UBBR + 1)

  uint32_t baud=F_CPU  / (16 * (prescaler + 1));

  ultoa(baud, sendbuf, 10);
    3852:	29 81       	ldd	r18, Y+1	; 0x01
    3854:	3a 81       	ldd	r19, Y+2	; 0x02
    3856:	2f 5f       	subi	r18, 0xFF	; 255
    3858:	3f 4f       	sbci	r19, 0xFF	; 255
    385a:	22 95       	swap	r18
    385c:	32 95       	swap	r19
    385e:	30 7f       	andi	r19, 0xF0	; 240
    3860:	32 27       	eor	r19, r18
    3862:	20 7f       	andi	r18, 0xF0	; 240
    3864:	32 27       	eor	r19, r18
    3866:	40 e0       	ldi	r20, 0x00	; 0
    3868:	50 e0       	ldi	r21, 0x00	; 0
    386a:	60 e0       	ldi	r22, 0x00	; 0
    386c:	70 e0       	ldi	r23, 0x00	; 0
    386e:	81 ee       	ldi	r24, 0xE1	; 225
    3870:	90 e0       	ldi	r25, 0x00	; 0
    3872:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <__udivmodsi4>
    3876:	ca 01       	movw	r24, r20
    3878:	b9 01       	movw	r22, r18
    387a:	a8 01       	movw	r20, r16
    387c:	2a e0       	ldi	r18, 0x0A	; 10
    387e:	30 e0       	ldi	r19, 0x00	; 0
    3880:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3884:	8b 81       	ldd	r24, Y+3	; 0x03
    3886:	88 23       	and	r24, r24
    3888:	11 f1       	breq	.+68     	; 0x38ce <rcfg_getBaud+0xb8>
    388a:	60 e0       	ldi	r22, 0x00	; 0
    388c:	fe 01       	movw	r30, r28
    388e:	34 96       	adiw	r30, 0x04	; 4
    len++;
    3890:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3892:	81 91       	ld	r24, Z+
    3894:	88 23       	and	r24, r24
    3896:	e1 f7       	brne	.-8      	; 0x3890 <rcfg_getBaud+0x7a>
    3898:	70 e0       	ldi	r23, 0x00	; 0

  uint32_t baud=F_CPU  / (16 * (prescaler + 1));

  ultoa(baud, sendbuf, 10);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    389a:	c8 01       	movw	r24, r16
    389c:	40 e3       	ldi	r20, 0x30	; 48
    389e:	59 e0       	ldi	r21, 0x09	; 9
    38a0:	26 e3       	ldi	r18, 0x36	; 54
    38a2:	39 e0       	ldi	r19, 0x09	; 9
    38a4:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nBaudrate for Data: ");
    38a8:	8b e6       	ldi	r24, 0x6B	; 107
    38aa:	92 e0       	ldi	r25, 0x02	; 2
    38ac:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    38b0:	c8 01       	movw	r24, r16
    38b2:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    38b6:	80 e0       	ldi	r24, 0x00	; 0
    38b8:	2c 96       	adiw	r28, 0x0c	; 12
    38ba:	0f b6       	in	r0, 0x3f	; 63
    38bc:	f8 94       	cli
    38be:	de bf       	out	0x3e, r29	; 62
    38c0:	0f be       	out	0x3f, r0	; 63
    38c2:	cd bf       	out	0x3d, r28	; 61
    38c4:	cf 91       	pop	r28
    38c6:	df 91       	pop	r29
    38c8:	1f 91       	pop	r17
    38ca:	0f 91       	pop	r16
    38cc:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    38ce:	60 e0       	ldi	r22, 0x00	; 0
    38d0:	70 e0       	ldi	r23, 0x00	; 0
    38d2:	e3 cf       	rjmp	.-58     	; 0x389a <rcfg_getBaud+0x84>

000038d4 <rcfg_setDataBits>:
	putString(sendbuf);

  return RCFG_SUCCESS;
}
uint8_t rcfg_setDataBits(char * buf)
{
    38d4:	df 93       	push	r29
    38d6:	cf 93       	push	r28
    38d8:	cd b7       	in	r28, 0x3d	; 61
    38da:	de b7       	in	r29, 0x3e	; 62
    38dc:	27 97       	sbiw	r28, 0x07	; 7
    38de:	0f b6       	in	r0, 0x3f	; 63
    38e0:	f8 94       	cli
    38e2:	de bf       	out	0x3e, r29	; 62
    38e4:	0f be       	out	0x3f, r0	; 63
    38e6:	cd bf       	out	0x3d, r28	; 61
    38e8:	9f 83       	std	Y+7, r25	; 0x07
    38ea:	8e 83       	std	Y+6, r24	; 0x06
	uint16_t prescaler=0;
    38ec:	1d 82       	std	Y+5, r1	; 0x05
    38ee:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t parity=0;
    38f0:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    38f2:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    38f4:	1b 82       	std	Y+3, r1	; 0x03

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
    38f6:	ce 01       	movw	r24, r28
    38f8:	04 96       	adiw	r24, 0x04	; 4
    38fa:	be 01       	movw	r22, r28
    38fc:	6f 5f       	subi	r22, 0xFF	; 255
    38fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3900:	ae 01       	movw	r20, r28
    3902:	4e 5f       	subi	r20, 0xFE	; 254
    3904:	5f 4f       	sbci	r21, 0xFF	; 255
    3906:	9e 01       	movw	r18, r28
    3908:	2d 5f       	subi	r18, 0xFD	; 253
    390a:	3f 4f       	sbci	r19, 0xFF	; 255
    390c:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	data_bits = rcfg_parseUInt(&buf);
    3910:	ce 01       	movw	r24, r28
    3912:	06 96       	adiw	r24, 0x06	; 6
    3914:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <rcfg_parseUInt>
    3918:	26 2f       	mov	r18, r22
	if((5<=data_bits)&&(data_bits<=8))
    391a:	25 50       	subi	r18, 0x05	; 5
    391c:	24 30       	cpi	r18, 0x04	; 4
    391e:	50 f0       	brcs	.+20     	; 0x3934 <rcfg_setDataBits+0x60>
    3920:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
		return RCFG_FAIL;

  	
}
    3922:	27 96       	adiw	r28, 0x07	; 7
    3924:	0f b6       	in	r0, 0x3f	; 63
    3926:	f8 94       	cli
    3928:	de bf       	out	0x3e, r29	; 62
    392a:	0f be       	out	0x3f, r0	; 63
    392c:	cd bf       	out	0x3d, r28	; 61
    392e:	cf 91       	pop	r28
    3930:	df 91       	pop	r29
    3932:	08 95       	ret

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
	data_bits = rcfg_parseUInt(&buf);
	if((5<=data_bits)&&(data_bits<=8))
	{
		data_bits-=5;
    3934:	2b 83       	std	Y+3, r18	; 0x03
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits );
    3936:	8c 81       	ldd	r24, Y+4	; 0x04
    3938:	9d 81       	ldd	r25, Y+5	; 0x05
    393a:	69 81       	ldd	r22, Y+1	; 0x01
    393c:	4a 81       	ldd	r20, Y+2	; 0x02
    393e:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <serialEepromSetConfig>
    3942:	80 e0       	ldi	r24, 0x00	; 0
    3944:	ee cf       	rjmp	.-36     	; 0x3922 <rcfg_setDataBits+0x4e>

00003946 <rcfg_setStopBits>:
	

  return RCFG_SUCCESS;
}
uint8_t rcfg_setStopBits(char * buf)
{
    3946:	df 93       	push	r29
    3948:	cf 93       	push	r28
    394a:	cd b7       	in	r28, 0x3d	; 61
    394c:	de b7       	in	r29, 0x3e	; 62
    394e:	27 97       	sbiw	r28, 0x07	; 7
    3950:	0f b6       	in	r0, 0x3f	; 63
    3952:	f8 94       	cli
    3954:	de bf       	out	0x3e, r29	; 62
    3956:	0f be       	out	0x3f, r0	; 63
    3958:	cd bf       	out	0x3d, r28	; 61
    395a:	9f 83       	std	Y+7, r25	; 0x07
    395c:	8e 83       	std	Y+6, r24	; 0x06
	uint16_t prescaler=0;
    395e:	1d 82       	std	Y+5, r1	; 0x05
    3960:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t parity=0;
    3962:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    3964:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    3966:	1b 82       	std	Y+3, r1	; 0x03

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
    3968:	ce 01       	movw	r24, r28
    396a:	04 96       	adiw	r24, 0x04	; 4
    396c:	be 01       	movw	r22, r28
    396e:	6f 5f       	subi	r22, 0xFF	; 255
    3970:	7f 4f       	sbci	r23, 0xFF	; 255
    3972:	ae 01       	movw	r20, r28
    3974:	4e 5f       	subi	r20, 0xFE	; 254
    3976:	5f 4f       	sbci	r21, 0xFF	; 255
    3978:	9e 01       	movw	r18, r28
    397a:	2d 5f       	subi	r18, 0xFD	; 253
    397c:	3f 4f       	sbci	r19, 0xFF	; 255
    397e:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	stop_bits = rcfg_parseUInt(&buf);
    3982:	ce 01       	movw	r24, r28
    3984:	06 96       	adiw	r24, 0x06	; 6
    3986:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <rcfg_parseUInt>
    398a:	46 2f       	mov	r20, r22

	if((stop_bits==1)||(stop_bits==2))
    398c:	41 50       	subi	r20, 0x01	; 1
    398e:	42 30       	cpi	r20, 0x02	; 2
    3990:	50 f0       	brcs	.+20     	; 0x39a6 <rcfg_setStopBits+0x60>
    3992:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
		return RCFG_FAIL;


}
    3994:	27 96       	adiw	r28, 0x07	; 7
    3996:	0f b6       	in	r0, 0x3f	; 63
    3998:	f8 94       	cli
    399a:	de bf       	out	0x3e, r29	; 62
    399c:	0f be       	out	0x3f, r0	; 63
    399e:	cd bf       	out	0x3d, r28	; 61
    39a0:	cf 91       	pop	r28
    39a2:	df 91       	pop	r29
    39a4:	08 95       	ret
	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
	stop_bits = rcfg_parseUInt(&buf);

	if((stop_bits==1)||(stop_bits==2))
	{
		stop_bits-=1;
    39a6:	4a 83       	std	Y+2, r20	; 0x02
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits );
    39a8:	8c 81       	ldd	r24, Y+4	; 0x04
    39aa:	9d 81       	ldd	r25, Y+5	; 0x05
    39ac:	69 81       	ldd	r22, Y+1	; 0x01
    39ae:	2b 81       	ldd	r18, Y+3	; 0x03
    39b0:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <serialEepromSetConfig>
    39b4:	80 e0       	ldi	r24, 0x00	; 0
    39b6:	ee cf       	rjmp	.-36     	; 0x3994 <rcfg_setStopBits+0x4e>

000039b8 <rcfg_setParity>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setParity(char * buf)
{
    39b8:	df 93       	push	r29
    39ba:	cf 93       	push	r28
    39bc:	cd b7       	in	r28, 0x3d	; 61
    39be:	de b7       	in	r29, 0x3e	; 62
    39c0:	27 97       	sbiw	r28, 0x07	; 7
    39c2:	0f b6       	in	r0, 0x3f	; 63
    39c4:	f8 94       	cli
    39c6:	de bf       	out	0x3e, r29	; 62
    39c8:	0f be       	out	0x3f, r0	; 63
    39ca:	cd bf       	out	0x3d, r28	; 61
    39cc:	9f 83       	std	Y+7, r25	; 0x07
    39ce:	8e 83       	std	Y+6, r24	; 0x06
	uint16_t prescaler=0;
    39d0:	1d 82       	std	Y+5, r1	; 0x05
    39d2:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t parity=0;
    39d4:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    39d6:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    39d8:	1b 82       	std	Y+3, r1	; 0x03

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
    39da:	ce 01       	movw	r24, r28
    39dc:	04 96       	adiw	r24, 0x04	; 4
    39de:	be 01       	movw	r22, r28
    39e0:	6f 5f       	subi	r22, 0xFF	; 255
    39e2:	7f 4f       	sbci	r23, 0xFF	; 255
    39e4:	ae 01       	movw	r20, r28
    39e6:	4e 5f       	subi	r20, 0xFE	; 254
    39e8:	5f 4f       	sbci	r21, 0xFF	; 255
    39ea:	9e 01       	movw	r18, r28
    39ec:	2d 5f       	subi	r18, 0xFD	; 253
    39ee:	3f 4f       	sbci	r19, 0xFF	; 255
    39f0:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	parity = rcfg_parseUInt(&buf);
    39f4:	ce 01       	movw	r24, r28
    39f6:	06 96       	adiw	r24, 0x06	; 6
    39f8:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <rcfg_parseUInt>

	if(parity<=3)
    39fc:	64 30       	cpi	r22, 0x04	; 4
    39fe:	50 f0       	brcs	.+20     	; 0x3a14 <rcfg_setParity+0x5c>
    3a00:	81 e0       	ldi	r24, 0x01	; 1
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits );
		return RCFG_SUCCESS;
	}
	else
		return RCFG_FAIL;
}
    3a02:	27 96       	adiw	r28, 0x07	; 7
    3a04:	0f b6       	in	r0, 0x3f	; 63
    3a06:	f8 94       	cli
    3a08:	de bf       	out	0x3e, r29	; 62
    3a0a:	0f be       	out	0x3f, r0	; 63
    3a0c:	cd bf       	out	0x3d, r28	; 61
    3a0e:	cf 91       	pop	r28
    3a10:	df 91       	pop	r29
    3a12:	08 95       	ret
	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
	parity = rcfg_parseUInt(&buf);

	if(parity<=3)
	{
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits );
    3a14:	8c 81       	ldd	r24, Y+4	; 0x04
    3a16:	9d 81       	ldd	r25, Y+5	; 0x05
    3a18:	4a 81       	ldd	r20, Y+2	; 0x02
    3a1a:	2b 81       	ldd	r18, Y+3	; 0x03
	uint8_t parity=0;
	uint8_t stop_bits=0;
	uint8_t data_bits=0;

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
	parity = rcfg_parseUInt(&buf);
    3a1c:	69 83       	std	Y+1, r22	; 0x01

	if(parity<=3)
	{
		serialEepromSetConfig( prescaler,parity,stop_bits,data_bits );
    3a1e:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <serialEepromSetConfig>
    3a22:	80 e0       	ldi	r24, 0x00	; 0
    3a24:	ee cf       	rjmp	.-36     	; 0x3a02 <rcfg_setParity+0x4a>

00003a26 <rcfg_setBaud>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setBaud(char * buf)
{
    3a26:	df 93       	push	r29
    3a28:	cf 93       	push	r28
    3a2a:	cd b7       	in	r28, 0x3d	; 61
    3a2c:	de b7       	in	r29, 0x3e	; 62
    3a2e:	27 97       	sbiw	r28, 0x07	; 7
    3a30:	0f b6       	in	r0, 0x3f	; 63
    3a32:	f8 94       	cli
    3a34:	de bf       	out	0x3e, r29	; 62
    3a36:	0f be       	out	0x3f, r0	; 63
    3a38:	cd bf       	out	0x3d, r28	; 61
    3a3a:	9f 83       	std	Y+7, r25	; 0x07
    3a3c:	8e 83       	std	Y+6, r24	; 0x06
	uint16_t prescaler=0;
    3a3e:	1d 82       	std	Y+5, r1	; 0x05
    3a40:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t parity=0;
    3a42:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    3a44:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    3a46:	1b 82       	std	Y+3, r1	; 0x03

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
    3a48:	ce 01       	movw	r24, r28
    3a4a:	04 96       	adiw	r24, 0x04	; 4
    3a4c:	be 01       	movw	r22, r28
    3a4e:	6f 5f       	subi	r22, 0xFF	; 255
    3a50:	7f 4f       	sbci	r23, 0xFF	; 255
    3a52:	ae 01       	movw	r20, r28
    3a54:	4e 5f       	subi	r20, 0xFE	; 254
    3a56:	5f 4f       	sbci	r21, 0xFF	; 255
    3a58:	9e 01       	movw	r18, r28
    3a5a:	2d 5f       	subi	r18, 0xFD	; 253
    3a5c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a5e:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	uint32_t baud = rcfg_parseUInt(&buf);
    3a62:	ce 01       	movw	r24, r28
    3a64:	06 96       	adiw	r24, 0x06	; 6
    3a66:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <rcfg_parseUInt>
    3a6a:	9b 01       	movw	r18, r22
    3a6c:	ac 01       	movw	r20, r24
	prescaler=F_CPU / (16 * baud) -1;
    3a6e:	22 0f       	add	r18, r18
    3a70:	33 1f       	adc	r19, r19
    3a72:	44 1f       	adc	r20, r20
    3a74:	55 1f       	adc	r21, r21
    3a76:	22 0f       	add	r18, r18
    3a78:	33 1f       	adc	r19, r19
    3a7a:	44 1f       	adc	r20, r20
    3a7c:	55 1f       	adc	r21, r21
    3a7e:	22 0f       	add	r18, r18
    3a80:	33 1f       	adc	r19, r19
    3a82:	44 1f       	adc	r20, r20
    3a84:	55 1f       	adc	r21, r21
    3a86:	22 0f       	add	r18, r18
    3a88:	33 1f       	adc	r19, r19
    3a8a:	44 1f       	adc	r20, r20
    3a8c:	55 1f       	adc	r21, r21
    3a8e:	60 e0       	ldi	r22, 0x00	; 0
    3a90:	70 e0       	ldi	r23, 0x00	; 0
    3a92:	81 ee       	ldi	r24, 0xE1	; 225
    3a94:	90 e0       	ldi	r25, 0x00	; 0
    3a96:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <__udivmodsi4>
    3a9a:	da 01       	movw	r26, r20
    3a9c:	c9 01       	movw	r24, r18
    3a9e:	01 97       	sbiw	r24, 0x01	; 1
    3aa0:	9d 83       	std	Y+5, r25	; 0x05
    3aa2:	8c 83       	std	Y+4, r24	; 0x04
	serialEepromSetConfig( prescaler,parity,stop_bits,data_bits );
    3aa4:	69 81       	ldd	r22, Y+1	; 0x01
    3aa6:	4a 81       	ldd	r20, Y+2	; 0x02
    3aa8:	2b 81       	ldd	r18, Y+3	; 0x03
    3aaa:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <serialEepromSetConfig>
	return RCFG_SUCCESS;
}
    3aae:	80 e0       	ldi	r24, 0x00	; 0
    3ab0:	27 96       	adiw	r28, 0x07	; 7
    3ab2:	0f b6       	in	r0, 0x3f	; 63
    3ab4:	f8 94       	cli
    3ab6:	de bf       	out	0x3e, r29	; 62
    3ab8:	0f be       	out	0x3f, r0	; 63
    3aba:	cd bf       	out	0x3d, r28	; 61
    3abc:	cf 91       	pop	r28
    3abe:	df 91       	pop	r29
    3ac0:	08 95       	ret

00003ac2 <rcfg_setDPORT_Config>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDPORT_Config(char *buf) {
    3ac2:	cf 92       	push	r12
    3ac4:	df 92       	push	r13
    3ac6:	ef 92       	push	r14
    3ac8:	ff 92       	push	r15
    3aca:	0f 93       	push	r16
    3acc:	1f 93       	push	r17
    3ace:	df 93       	push	r29
    3ad0:	cf 93       	push	r28
    3ad2:	00 d0       	rcall	.+0      	; 0x3ad4 <rcfg_setDPORT_Config+0x12>
    3ad4:	cd b7       	in	r28, 0x3d	; 61
    3ad6:	de b7       	in	r29, 0x3e	; 62
    3ad8:	9a 83       	std	Y+2, r25	; 0x02
    3ada:	89 83       	std	Y+1, r24	; 0x01
  portAddress_t dport = (portAddress_t)rcfg_parseUInt(&buf);
    3adc:	ce 01       	movw	r24, r28
    3ade:	01 96       	adiw	r24, 0x01	; 1
    3ae0:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <rcfg_parseUInt>
    3ae4:	6b 01       	movw	r12, r22
    3ae6:	7c 01       	movw	r14, r24

  configEepromSetConfig(0, 0, 0, dport, 0);
    3ae8:	60 e0       	ldi	r22, 0x00	; 0
    3aea:	70 e0       	ldi	r23, 0x00	; 0
    3aec:	80 e0       	ldi	r24, 0x00	; 0
    3aee:	90 e0       	ldi	r25, 0x00	; 0
    3af0:	40 e0       	ldi	r20, 0x00	; 0
    3af2:	50 e0       	ldi	r21, 0x00	; 0
    3af4:	00 e0       	ldi	r16, 0x00	; 0
    3af6:	10 e0       	ldi	r17, 0x00	; 0
    3af8:	20 e0       	ldi	r18, 0x00	; 0
    3afa:	30 e0       	ldi	r19, 0x00	; 0
    3afc:	76 01       	movw	r14, r12
    3afe:	cc 24       	eor	r12, r12
    3b00:	dd 24       	eor	r13, r13
    3b02:	0e 94 a1 2a 	call	0x5542	; 0x5542 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3b06:	80 e0       	ldi	r24, 0x00	; 0
    3b08:	0f 90       	pop	r0
    3b0a:	0f 90       	pop	r0
    3b0c:	cf 91       	pop	r28
    3b0e:	df 91       	pop	r29
    3b10:	1f 91       	pop	r17
    3b12:	0f 91       	pop	r16
    3b14:	ff 90       	pop	r15
    3b16:	ef 90       	pop	r14
    3b18:	df 90       	pop	r13
    3b1a:	cf 90       	pop	r12
    3b1c:	08 95       	ret

00003b1e <rcfg_setDPORT_Data>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDPORT_Data(char *buf) {
    3b1e:	cf 92       	push	r12
    3b20:	df 92       	push	r13
    3b22:	ef 92       	push	r14
    3b24:	ff 92       	push	r15
    3b26:	0f 93       	push	r16
    3b28:	1f 93       	push	r17
    3b2a:	df 93       	push	r29
    3b2c:	cf 93       	push	r28
    3b2e:	00 d0       	rcall	.+0      	; 0x3b30 <rcfg_setDPORT_Data+0x12>
    3b30:	cd b7       	in	r28, 0x3d	; 61
    3b32:	de b7       	in	r29, 0x3e	; 62
    3b34:	9a 83       	std	Y+2, r25	; 0x02
    3b36:	89 83       	std	Y+1, r24	; 0x01
  portAddress_t dport = (portAddress_t)rcfg_parseUInt(&buf);
    3b38:	ce 01       	movw	r24, r28
    3b3a:	01 96       	adiw	r24, 0x01	; 1
    3b3c:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <rcfg_parseUInt>
    3b40:	9b 01       	movw	r18, r22
    3b42:	ac 01       	movw	r20, r24

  configEepromSetConfig(0, dport, 0, 0, 0);
    3b44:	60 e0       	ldi	r22, 0x00	; 0
    3b46:	70 e0       	ldi	r23, 0x00	; 0
    3b48:	80 e0       	ldi	r24, 0x00	; 0
    3b4a:	90 e0       	ldi	r25, 0x00	; 0
    3b4c:	a9 01       	movw	r20, r18
    3b4e:	00 e0       	ldi	r16, 0x00	; 0
    3b50:	10 e0       	ldi	r17, 0x00	; 0
    3b52:	20 e0       	ldi	r18, 0x00	; 0
    3b54:	30 e0       	ldi	r19, 0x00	; 0
    3b56:	ee 24       	eor	r14, r14
    3b58:	ff 24       	eor	r15, r15
    3b5a:	cc 24       	eor	r12, r12
    3b5c:	dd 24       	eor	r13, r13
    3b5e:	0e 94 a1 2a 	call	0x5542	; 0x5542 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3b62:	80 e0       	ldi	r24, 0x00	; 0
    3b64:	0f 90       	pop	r0
    3b66:	0f 90       	pop	r0
    3b68:	cf 91       	pop	r28
    3b6a:	df 91       	pop	r29
    3b6c:	1f 91       	pop	r17
    3b6e:	0f 91       	pop	r16
    3b70:	ff 90       	pop	r15
    3b72:	ef 90       	pop	r14
    3b74:	df 90       	pop	r13
    3b76:	cf 90       	pop	r12
    3b78:	08 95       	ret

00003b7a <rcfg_getDPORT_Config>:
  configEepromSetConfig(0, 0, dip, 0, 0);

  return RCFG_SUCCESS;
}

uint8_t rcfg_getDPORT_Config(char *buf) {
    3b7a:	0f 93       	push	r16
    3b7c:	1f 93       	push	r17
    3b7e:	df 93       	push	r29
    3b80:	cf 93       	push	r28
    3b82:	cd b7       	in	r28, 0x3d	; 61
    3b84:	de b7       	in	r29, 0x3e	; 62
    3b86:	27 97       	sbiw	r28, 0x07	; 7
    3b88:	0f b6       	in	r0, 0x3f	; 63
    3b8a:	f8 94       	cli
    3b8c:	de bf       	out	0x3e, r29	; 62
    3b8e:	0f be       	out	0x3f, r0	; 63
    3b90:	cd bf       	out	0x3d, r28	; 61
  portAddress_t dport;
  configEepromGetConfig(NULL, NULL, NULL, &dport, NULL);
    3b92:	80 e0       	ldi	r24, 0x00	; 0
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	60 e0       	ldi	r22, 0x00	; 0
    3b98:	70 e0       	ldi	r23, 0x00	; 0
    3b9a:	40 e0       	ldi	r20, 0x00	; 0
    3b9c:	50 e0       	ldi	r21, 0x00	; 0
    3b9e:	9e 01       	movw	r18, r28
    3ba0:	2f 5f       	subi	r18, 0xFF	; 255
    3ba2:	3f 4f       	sbci	r19, 0xFF	; 255
    3ba4:	00 e0       	ldi	r16, 0x00	; 0
    3ba6:	10 e0       	ldi	r17, 0x00	; 0
    3ba8:	0e 94 bf 29 	call	0x537e	; 0x537e <configEepromGetConfig>

  char sendbuf[5] = {0}; // clear buffer;
    3bac:	8e 01       	movw	r16, r28
    3bae:	0d 5f       	subi	r16, 0xFD	; 253
    3bb0:	1f 4f       	sbci	r17, 0xFF	; 255
    3bb2:	85 e0       	ldi	r24, 0x05	; 5
    3bb4:	f8 01       	movw	r30, r16
    3bb6:	11 92       	st	Z+, r1
    3bb8:	8a 95       	dec	r24
    3bba:	e9 f7       	brne	.-6      	; 0x3bb6 <rcfg_getDPORT_Config+0x3c>
  ultoa(dport, sendbuf, 10);
    3bbc:	69 81       	ldd	r22, Y+1	; 0x01
    3bbe:	7a 81       	ldd	r23, Y+2	; 0x02
    3bc0:	80 e0       	ldi	r24, 0x00	; 0
    3bc2:	90 e0       	ldi	r25, 0x00	; 0
    3bc4:	a8 01       	movw	r20, r16
    3bc6:	2a e0       	ldi	r18, 0x0A	; 10
    3bc8:	30 e0       	ldi	r19, 0x00	; 0
    3bca:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3bce:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd0:	88 23       	and	r24, r24
    3bd2:	11 f1       	breq	.+68     	; 0x3c18 <rcfg_getDPORT_Config+0x9e>
    3bd4:	60 e0       	ldi	r22, 0x00	; 0
    3bd6:	fe 01       	movw	r30, r28
    3bd8:	34 96       	adiw	r30, 0x04	; 4
    len++;
    3bda:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3bdc:	81 91       	ld	r24, Z+
    3bde:	88 23       	and	r24, r24
    3be0:	e1 f7       	brne	.-8      	; 0x3bda <rcfg_getDPORT_Config+0x60>
    3be2:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(NULL, NULL, NULL, &dport, NULL);

  char sendbuf[5] = {0}; // clear buffer;
  ultoa(dport, sendbuf, 10);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3be4:	c8 01       	movw	r24, r16
    3be6:	40 e3       	ldi	r20, 0x30	; 48
    3be8:	59 e0       	ldi	r21, 0x09	; 9
    3bea:	26 e3       	ldi	r18, 0x36	; 54
    3bec:	39 e0       	ldi	r19, 0x09	; 9
    3bee:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
  
  putString("\r\nDestination Port for Config-Channel: ");
    3bf2:	81 e8       	ldi	r24, 0x81	; 129
    3bf4:	92 e0       	ldi	r25, 0x02	; 2
    3bf6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    3bfa:	c8 01       	movw	r24, r16
    3bfc:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    3c00:	80 e0       	ldi	r24, 0x00	; 0
    3c02:	27 96       	adiw	r28, 0x07	; 7
    3c04:	0f b6       	in	r0, 0x3f	; 63
    3c06:	f8 94       	cli
    3c08:	de bf       	out	0x3e, r29	; 62
    3c0a:	0f be       	out	0x3f, r0	; 63
    3c0c:	cd bf       	out	0x3d, r28	; 61
    3c0e:	cf 91       	pop	r28
    3c10:	df 91       	pop	r29
    3c12:	1f 91       	pop	r17
    3c14:	0f 91       	pop	r16
    3c16:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3c18:	60 e0       	ldi	r22, 0x00	; 0
    3c1a:	70 e0       	ldi	r23, 0x00	; 0
    3c1c:	e3 cf       	rjmp	.-58     	; 0x3be4 <rcfg_getDPORT_Config+0x6a>

00003c1e <rcfg_getDPORT_Data>:
  configEepromSetConfig(dip,0,0,0,0);

  return RCFG_SUCCESS;
}

uint8_t rcfg_getDPORT_Data(char *buf) {
    3c1e:	0f 93       	push	r16
    3c20:	1f 93       	push	r17
    3c22:	df 93       	push	r29
    3c24:	cf 93       	push	r28
    3c26:	cd b7       	in	r28, 0x3d	; 61
    3c28:	de b7       	in	r29, 0x3e	; 62
    3c2a:	27 97       	sbiw	r28, 0x07	; 7
    3c2c:	0f b6       	in	r0, 0x3f	; 63
    3c2e:	f8 94       	cli
    3c30:	de bf       	out	0x3e, r29	; 62
    3c32:	0f be       	out	0x3f, r0	; 63
    3c34:	cd bf       	out	0x3d, r28	; 61
  portAddress_t dport;
  configEepromGetConfig(NULL, &dport, NULL, NULL, NULL);
    3c36:	80 e0       	ldi	r24, 0x00	; 0
    3c38:	90 e0       	ldi	r25, 0x00	; 0
    3c3a:	be 01       	movw	r22, r28
    3c3c:	6f 5f       	subi	r22, 0xFF	; 255
    3c3e:	7f 4f       	sbci	r23, 0xFF	; 255
    3c40:	40 e0       	ldi	r20, 0x00	; 0
    3c42:	50 e0       	ldi	r21, 0x00	; 0
    3c44:	20 e0       	ldi	r18, 0x00	; 0
    3c46:	30 e0       	ldi	r19, 0x00	; 0
    3c48:	00 e0       	ldi	r16, 0x00	; 0
    3c4a:	10 e0       	ldi	r17, 0x00	; 0
    3c4c:	0e 94 bf 29 	call	0x537e	; 0x537e <configEepromGetConfig>

  char sendbuf[5] = {0}; // clear buffer;
    3c50:	8e 01       	movw	r16, r28
    3c52:	0d 5f       	subi	r16, 0xFD	; 253
    3c54:	1f 4f       	sbci	r17, 0xFF	; 255
    3c56:	85 e0       	ldi	r24, 0x05	; 5
    3c58:	f8 01       	movw	r30, r16
    3c5a:	11 92       	st	Z+, r1
    3c5c:	8a 95       	dec	r24
    3c5e:	e9 f7       	brne	.-6      	; 0x3c5a <rcfg_getDPORT_Data+0x3c>
  ultoa(dport, sendbuf, 10);
    3c60:	69 81       	ldd	r22, Y+1	; 0x01
    3c62:	7a 81       	ldd	r23, Y+2	; 0x02
    3c64:	80 e0       	ldi	r24, 0x00	; 0
    3c66:	90 e0       	ldi	r25, 0x00	; 0
    3c68:	a8 01       	movw	r20, r16
    3c6a:	2a e0       	ldi	r18, 0x0A	; 10
    3c6c:	30 e0       	ldi	r19, 0x00	; 0
    3c6e:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3c72:	8b 81       	ldd	r24, Y+3	; 0x03
    3c74:	88 23       	and	r24, r24
    3c76:	11 f1       	breq	.+68     	; 0x3cbc <rcfg_getDPORT_Data+0x9e>
    3c78:	60 e0       	ldi	r22, 0x00	; 0
    3c7a:	fe 01       	movw	r30, r28
    3c7c:	34 96       	adiw	r30, 0x04	; 4
    len++;
    3c7e:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3c80:	81 91       	ld	r24, Z+
    3c82:	88 23       	and	r24, r24
    3c84:	e1 f7       	brne	.-8      	; 0x3c7e <rcfg_getDPORT_Data+0x60>
    3c86:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(NULL, &dport, NULL, NULL, NULL);

  char sendbuf[5] = {0}; // clear buffer;
  ultoa(dport, sendbuf, 10);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3c88:	c8 01       	movw	r24, r16
    3c8a:	40 e3       	ldi	r20, 0x30	; 48
    3c8c:	59 e0       	ldi	r21, 0x09	; 9
    3c8e:	26 e3       	ldi	r18, 0x36	; 54
    3c90:	39 e0       	ldi	r19, 0x09	; 9
    3c92:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nDestination Port for Data-Channel: ");
    3c96:	89 ea       	ldi	r24, 0xA9	; 169
    3c98:	92 e0       	ldi	r25, 0x02	; 2
    3c9a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    3c9e:	c8 01       	movw	r24, r16
    3ca0:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    3ca4:	80 e0       	ldi	r24, 0x00	; 0
    3ca6:	27 96       	adiw	r28, 0x07	; 7
    3ca8:	0f b6       	in	r0, 0x3f	; 63
    3caa:	f8 94       	cli
    3cac:	de bf       	out	0x3e, r29	; 62
    3cae:	0f be       	out	0x3f, r0	; 63
    3cb0:	cd bf       	out	0x3d, r28	; 61
    3cb2:	cf 91       	pop	r28
    3cb4:	df 91       	pop	r29
    3cb6:	1f 91       	pop	r17
    3cb8:	0f 91       	pop	r16
    3cba:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3cbc:	60 e0       	ldi	r22, 0x00	; 0
    3cbe:	70 e0       	ldi	r23, 0x00	; 0
    3cc0:	e3 cf       	rjmp	.-58     	; 0x3c88 <rcfg_getDPORT_Data+0x6a>

00003cc2 <rcfg_setDIP_Config>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDIP_Config(char *buf) {
    3cc2:	cf 92       	push	r12
    3cc4:	df 92       	push	r13
    3cc6:	ef 92       	push	r14
    3cc8:	ff 92       	push	r15
    3cca:	0f 93       	push	r16
    3ccc:	1f 93       	push	r17
    3cce:	df 93       	push	r29
    3cd0:	cf 93       	push	r28
    3cd2:	00 d0       	rcall	.+0      	; 0x3cd4 <rcfg_setDIP_Config+0x12>
    3cd4:	cd b7       	in	r28, 0x3d	; 61
    3cd6:	de b7       	in	r29, 0x3e	; 62
    3cd8:	9a 83       	std	Y+2, r25	; 0x02
    3cda:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t dip = rcfg_parseIP(&buf);
    3cdc:	ce 01       	movw	r24, r28
    3cde:	01 96       	adiw	r24, 0x01	; 1
    3ce0:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>
    3ce4:	8b 01       	movw	r16, r22
    3ce6:	9c 01       	movw	r18, r24

  configEepromSetConfig(0, 0, dip, 0, 0);
    3ce8:	60 e0       	ldi	r22, 0x00	; 0
    3cea:	70 e0       	ldi	r23, 0x00	; 0
    3cec:	80 e0       	ldi	r24, 0x00	; 0
    3cee:	90 e0       	ldi	r25, 0x00	; 0
    3cf0:	40 e0       	ldi	r20, 0x00	; 0
    3cf2:	50 e0       	ldi	r21, 0x00	; 0
    3cf4:	ee 24       	eor	r14, r14
    3cf6:	ff 24       	eor	r15, r15
    3cf8:	cc 24       	eor	r12, r12
    3cfa:	dd 24       	eor	r13, r13
    3cfc:	0e 94 a1 2a 	call	0x5542	; 0x5542 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3d00:	80 e0       	ldi	r24, 0x00	; 0
    3d02:	0f 90       	pop	r0
    3d04:	0f 90       	pop	r0
    3d06:	cf 91       	pop	r28
    3d08:	df 91       	pop	r29
    3d0a:	1f 91       	pop	r17
    3d0c:	0f 91       	pop	r16
    3d0e:	ff 90       	pop	r15
    3d10:	ef 90       	pop	r14
    3d12:	df 90       	pop	r13
    3d14:	cf 90       	pop	r12
    3d16:	08 95       	ret

00003d18 <rcfg_setDIP_Data>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_setDIP_Data(char *buf) {
    3d18:	cf 92       	push	r12
    3d1a:	df 92       	push	r13
    3d1c:	ef 92       	push	r14
    3d1e:	ff 92       	push	r15
    3d20:	0f 93       	push	r16
    3d22:	1f 93       	push	r17
    3d24:	df 93       	push	r29
    3d26:	cf 93       	push	r28
    3d28:	00 d0       	rcall	.+0      	; 0x3d2a <rcfg_setDIP_Data+0x12>
    3d2a:	cd b7       	in	r28, 0x3d	; 61
    3d2c:	de b7       	in	r29, 0x3e	; 62
    3d2e:	9a 83       	std	Y+2, r25	; 0x02
    3d30:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t dip = rcfg_parseIP(&buf);
    3d32:	ce 01       	movw	r24, r28
    3d34:	01 96       	adiw	r24, 0x01	; 1
    3d36:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>

  configEepromSetConfig(dip,0,0,0,0);
    3d3a:	40 e0       	ldi	r20, 0x00	; 0
    3d3c:	50 e0       	ldi	r21, 0x00	; 0
    3d3e:	00 e0       	ldi	r16, 0x00	; 0
    3d40:	10 e0       	ldi	r17, 0x00	; 0
    3d42:	20 e0       	ldi	r18, 0x00	; 0
    3d44:	30 e0       	ldi	r19, 0x00	; 0
    3d46:	ee 24       	eor	r14, r14
    3d48:	ff 24       	eor	r15, r15
    3d4a:	cc 24       	eor	r12, r12
    3d4c:	dd 24       	eor	r13, r13
    3d4e:	0e 94 a1 2a 	call	0x5542	; 0x5542 <configEepromSetConfig>

  return RCFG_SUCCESS;
}
    3d52:	80 e0       	ldi	r24, 0x00	; 0
    3d54:	0f 90       	pop	r0
    3d56:	0f 90       	pop	r0
    3d58:	cf 91       	pop	r28
    3d5a:	df 91       	pop	r29
    3d5c:	1f 91       	pop	r17
    3d5e:	0f 91       	pop	r16
    3d60:	ff 90       	pop	r15
    3d62:	ef 90       	pop	r14
    3d64:	df 90       	pop	r13
    3d66:	cf 90       	pop	r12
    3d68:	08 95       	ret

00003d6a <rcfg_setNet>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setNet(char * buf)
{
    3d6a:	6f 92       	push	r6
    3d6c:	7f 92       	push	r7
    3d6e:	8f 92       	push	r8
    3d70:	9f 92       	push	r9
    3d72:	af 92       	push	r10
    3d74:	bf 92       	push	r11
    3d76:	cf 92       	push	r12
    3d78:	df 92       	push	r13
    3d7a:	ef 92       	push	r14
    3d7c:	ff 92       	push	r15
    3d7e:	0f 93       	push	r16
    3d80:	1f 93       	push	r17
    3d82:	df 93       	push	r29
    3d84:	cf 93       	push	r28
    3d86:	00 d0       	rcall	.+0      	; 0x3d88 <rcfg_setNet+0x1e>
    3d88:	cd b7       	in	r28, 0x3d	; 61
    3d8a:	de b7       	in	r29, 0x3e	; 62
    3d8c:	9a 83       	std	Y+2, r25	; 0x02
    3d8e:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t ip = rcfg_parseIP(&buf);
    3d90:	8e 01       	movw	r16, r28
    3d92:	0f 5f       	subi	r16, 0xFF	; 255
    3d94:	1f 4f       	sbci	r17, 0xFF	; 255
    3d96:	c8 01       	movw	r24, r16
    3d98:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>
    3d9c:	3b 01       	movw	r6, r22
    3d9e:	4c 01       	movw	r8, r24
  while(*buf == ' ') // skip whitespace(s)
    3da0:	e9 81       	ldd	r30, Y+1	; 0x01
    3da2:	fa 81       	ldd	r31, Y+2	; 0x02
    3da4:	80 81       	ld	r24, Z
    3da6:	80 32       	cpi	r24, 0x20	; 32
    3da8:	31 f4       	brne	.+12     	; 0x3db6 <rcfg_setNet+0x4c>
    buf++;
    3daa:	31 96       	adiw	r30, 0x01	; 1
    3dac:	fa 83       	std	Y+2, r31	; 0x02
    3dae:	e9 83       	std	Y+1, r30	; 0x01
}

uint8_t rcfg_setNet(char * buf)
{
  ipAddress_t ip = rcfg_parseIP(&buf);
  while(*buf == ' ') // skip whitespace(s)
    3db0:	80 81       	ld	r24, Z
    3db2:	80 32       	cpi	r24, 0x20	; 32
    3db4:	d1 f3       	breq	.-12     	; 0x3daa <rcfg_setNet+0x40>
    buf++;
  ipAddress_t nm = rcfg_parseIP(&buf);
    3db6:	c8 01       	movw	r24, r16
    3db8:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>
    3dbc:	5b 01       	movw	r10, r22
    3dbe:	6c 01       	movw	r12, r24
  while(*buf == ' ')
    3dc0:	e9 81       	ldd	r30, Y+1	; 0x01
    3dc2:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc4:	80 81       	ld	r24, Z
    3dc6:	80 32       	cpi	r24, 0x20	; 32
    3dc8:	31 f4       	brne	.+12     	; 0x3dd6 <rcfg_setNet+0x6c>
    buf++;
    3dca:	31 96       	adiw	r30, 0x01	; 1
    3dcc:	fa 83       	std	Y+2, r31	; 0x02
    3dce:	e9 83       	std	Y+1, r30	; 0x01
{
  ipAddress_t ip = rcfg_parseIP(&buf);
  while(*buf == ' ') // skip whitespace(s)
    buf++;
  ipAddress_t nm = rcfg_parseIP(&buf);
  while(*buf == ' ')
    3dd0:	80 81       	ld	r24, Z
    3dd2:	80 32       	cpi	r24, 0x20	; 32
    3dd4:	d1 f3       	breq	.-12     	; 0x3dca <rcfg_setNet+0x60>
    buf++;
  ipAddress_t gw = rcfg_parseIP(&buf);
    3dd6:	c8 01       	movw	r24, r16
    3dd8:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>
    3ddc:	7b 01       	movw	r14, r22
    3dde:	8c 01       	movw	r16, r24

  ipEepromSetConfig(ip,nm,gw);
    3de0:	c4 01       	movw	r24, r8
    3de2:	b3 01       	movw	r22, r6
    3de4:	a6 01       	movw	r20, r12
    3de6:	95 01       	movw	r18, r10
    3de8:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    3dec:	80 e0       	ldi	r24, 0x00	; 0
    3dee:	0f 90       	pop	r0
    3df0:	0f 90       	pop	r0
    3df2:	cf 91       	pop	r28
    3df4:	df 91       	pop	r29
    3df6:	1f 91       	pop	r17
    3df8:	0f 91       	pop	r16
    3dfa:	ff 90       	pop	r15
    3dfc:	ef 90       	pop	r14
    3dfe:	df 90       	pop	r13
    3e00:	cf 90       	pop	r12
    3e02:	bf 90       	pop	r11
    3e04:	af 90       	pop	r10
    3e06:	9f 90       	pop	r9
    3e08:	8f 90       	pop	r8
    3e0a:	7f 90       	pop	r7
    3e0c:	6f 90       	pop	r6
    3e0e:	08 95       	ret

00003e10 <rcfg_setGW>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setGW(char * buf)
{
    3e10:	ef 92       	push	r14
    3e12:	ff 92       	push	r15
    3e14:	0f 93       	push	r16
    3e16:	1f 93       	push	r17
    3e18:	df 93       	push	r29
    3e1a:	cf 93       	push	r28
    3e1c:	00 d0       	rcall	.+0      	; 0x3e1e <rcfg_setGW+0xe>
    3e1e:	cd b7       	in	r28, 0x3d	; 61
    3e20:	de b7       	in	r29, 0x3e	; 62
    3e22:	9a 83       	std	Y+2, r25	; 0x02
    3e24:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t gw = rcfg_parseIP(&buf);
    3e26:	ce 01       	movw	r24, r28
    3e28:	01 96       	adiw	r24, 0x01	; 1
    3e2a:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>
    3e2e:	7b 01       	movw	r14, r22
    3e30:	8c 01       	movw	r16, r24

  ipEepromSetConfig(0,0,gw);
    3e32:	60 e0       	ldi	r22, 0x00	; 0
    3e34:	70 e0       	ldi	r23, 0x00	; 0
    3e36:	80 e0       	ldi	r24, 0x00	; 0
    3e38:	90 e0       	ldi	r25, 0x00	; 0
    3e3a:	20 e0       	ldi	r18, 0x00	; 0
    3e3c:	30 e0       	ldi	r19, 0x00	; 0
    3e3e:	40 e0       	ldi	r20, 0x00	; 0
    3e40:	50 e0       	ldi	r21, 0x00	; 0
    3e42:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    3e46:	80 e0       	ldi	r24, 0x00	; 0
    3e48:	0f 90       	pop	r0
    3e4a:	0f 90       	pop	r0
    3e4c:	cf 91       	pop	r28
    3e4e:	df 91       	pop	r29
    3e50:	1f 91       	pop	r17
    3e52:	0f 91       	pop	r16
    3e54:	ff 90       	pop	r15
    3e56:	ef 90       	pop	r14
    3e58:	08 95       	ret

00003e5a <rcfg_setNM>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setNM(char * buf)
{
    3e5a:	ef 92       	push	r14
    3e5c:	ff 92       	push	r15
    3e5e:	0f 93       	push	r16
    3e60:	1f 93       	push	r17
    3e62:	df 93       	push	r29
    3e64:	cf 93       	push	r28
    3e66:	00 d0       	rcall	.+0      	; 0x3e68 <rcfg_setNM+0xe>
    3e68:	cd b7       	in	r28, 0x3d	; 61
    3e6a:	de b7       	in	r29, 0x3e	; 62
    3e6c:	9a 83       	std	Y+2, r25	; 0x02
    3e6e:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t nm = rcfg_parseIP(&buf);
    3e70:	ce 01       	movw	r24, r28
    3e72:	01 96       	adiw	r24, 0x01	; 1
    3e74:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>
    3e78:	9b 01       	movw	r18, r22
    3e7a:	ac 01       	movw	r20, r24

  ipEepromSetConfig(0,nm,0);
    3e7c:	60 e0       	ldi	r22, 0x00	; 0
    3e7e:	70 e0       	ldi	r23, 0x00	; 0
    3e80:	80 e0       	ldi	r24, 0x00	; 0
    3e82:	90 e0       	ldi	r25, 0x00	; 0
    3e84:	ee 24       	eor	r14, r14
    3e86:	ff 24       	eor	r15, r15
    3e88:	87 01       	movw	r16, r14
    3e8a:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    3e8e:	80 e0       	ldi	r24, 0x00	; 0
    3e90:	0f 90       	pop	r0
    3e92:	0f 90       	pop	r0
    3e94:	cf 91       	pop	r28
    3e96:	df 91       	pop	r29
    3e98:	1f 91       	pop	r17
    3e9a:	0f 91       	pop	r16
    3e9c:	ff 90       	pop	r15
    3e9e:	ef 90       	pop	r14
    3ea0:	08 95       	ret

00003ea2 <rcfg_setIP>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_setIP(char * buf)
{
    3ea2:	ef 92       	push	r14
    3ea4:	ff 92       	push	r15
    3ea6:	0f 93       	push	r16
    3ea8:	1f 93       	push	r17
    3eaa:	df 93       	push	r29
    3eac:	cf 93       	push	r28
    3eae:	00 d0       	rcall	.+0      	; 0x3eb0 <rcfg_setIP+0xe>
    3eb0:	cd b7       	in	r28, 0x3d	; 61
    3eb2:	de b7       	in	r29, 0x3e	; 62
    3eb4:	9a 83       	std	Y+2, r25	; 0x02
    3eb6:	89 83       	std	Y+1, r24	; 0x01
  ipAddress_t ip = rcfg_parseIP(&buf);
    3eb8:	ce 01       	movw	r24, r28
    3eba:	01 96       	adiw	r24, 0x01	; 1
    3ebc:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <rcfg_parseIP>

  ipEepromSetConfig(ip,0,0);
    3ec0:	20 e0       	ldi	r18, 0x00	; 0
    3ec2:	30 e0       	ldi	r19, 0x00	; 0
    3ec4:	40 e0       	ldi	r20, 0x00	; 0
    3ec6:	50 e0       	ldi	r21, 0x00	; 0
    3ec8:	ee 24       	eor	r14, r14
    3eca:	ff 24       	eor	r15, r15
    3ecc:	87 01       	movw	r16, r14
    3ece:	0e 94 63 09 	call	0x12c6	; 0x12c6 <ipEepromSetConfig>

  return RCFG_SUCCESS;
}
    3ed2:	80 e0       	ldi	r24, 0x00	; 0
    3ed4:	0f 90       	pop	r0
    3ed6:	0f 90       	pop	r0
    3ed8:	cf 91       	pop	r28
    3eda:	df 91       	pop	r29
    3edc:	1f 91       	pop	r17
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	08 95       	ret

00003ee6 <rcfg_getMAC>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getMAC(char * buf)
{
    3ee6:	bf 92       	push	r11
    3ee8:	cf 92       	push	r12
    3eea:	df 92       	push	r13
    3eec:	ef 92       	push	r14
    3eee:	ff 92       	push	r15
    3ef0:	0f 93       	push	r16
    3ef2:	1f 93       	push	r17
    3ef4:	df 93       	push	r29
    3ef6:	cf 93       	push	r28
    3ef8:	cd b7       	in	r28, 0x3d	; 61
    3efa:	de b7       	in	r29, 0x3e	; 62
    3efc:	67 97       	sbiw	r28, 0x17	; 23
    3efe:	0f b6       	in	r0, 0x3f	; 63
    3f00:	f8 94       	cli
    3f02:	de bf       	out	0x3e, r29	; 62
    3f04:	0f be       	out	0x3f, r0	; 63
    3f06:	cd bf       	out	0x3d, r28	; 61
  uint8_t mac[6];


  char sendbuf[17] = {0}; // clear buffer
    3f08:	e7 e0       	ldi	r30, 0x07	; 7
    3f0a:	ce 2e       	mov	r12, r30
    3f0c:	d1 2c       	mov	r13, r1
    3f0e:	cc 0e       	add	r12, r28
    3f10:	dd 1e       	adc	r13, r29
    3f12:	81 e1       	ldi	r24, 0x11	; 17
    3f14:	f6 01       	movw	r30, r12
    3f16:	11 92       	st	Z+, r1
    3f18:	8a 95       	dec	r24
    3f1a:	e9 f7       	brne	.-6      	; 0x3f16 <rcfg_getMAC+0x30>
    3f1c:	7e 01       	movw	r14, r28
    3f1e:	08 94       	sec
    3f20:	e1 1c       	adc	r14, r1
    3f22:	f1 1c       	adc	r15, r1
    3f24:	86 01       	movw	r16, r12
    utoa(mac[i], bufpos, 16);
    while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    *bufpos++ = ':';
    3f26:	7a e3       	ldi	r23, 0x3A	; 58
    3f28:	b7 2e       	mov	r11, r23

  char sendbuf[17] = {0}; // clear buffer
  char * bufpos = sendbuf;
  uint8_t i;
  for (i=0; i<=5; i++) {
    utoa(mac[i], bufpos, 16);
    3f2a:	f7 01       	movw	r30, r14
    3f2c:	80 81       	ld	r24, Z
    3f2e:	90 e0       	ldi	r25, 0x00	; 0
    3f30:	b8 01       	movw	r22, r16
    3f32:	40 e1       	ldi	r20, 0x10	; 16
    3f34:	50 e0       	ldi	r21, 0x00	; 0
    3f36:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    3f3a:	02 c0       	rjmp	.+4      	; 0x3f40 <rcfg_getMAC+0x5a>
    while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    3f3c:	0f 5f       	subi	r16, 0xFF	; 255
    3f3e:	1f 4f       	sbci	r17, 0xFF	; 255
  char sendbuf[17] = {0}; // clear buffer
  char * bufpos = sendbuf;
  uint8_t i;
  for (i=0; i<=5; i++) {
    utoa(mac[i], bufpos, 16);
    while ( (*bufpos >= '0' && *bufpos <= '9') ||
    3f40:	f8 01       	movw	r30, r16
    3f42:	90 81       	ld	r25, Z
    3f44:	89 2f       	mov	r24, r25
    3f46:	80 53       	subi	r24, 0x30	; 48
    3f48:	8a 30       	cpi	r24, 0x0A	; 10
    3f4a:	c0 f3       	brcs	.-16     	; 0x3f3c <rcfg_getMAC+0x56>
    3f4c:	81 53       	subi	r24, 0x31	; 49
    3f4e:	86 30       	cpi	r24, 0x06	; 6
    3f50:	a8 f3       	brcs	.-22     	; 0x3f3c <rcfg_getMAC+0x56>
    3f52:	91 54       	subi	r25, 0x41	; 65
    3f54:	96 30       	cpi	r25, 0x06	; 6
    3f56:	90 f3       	brcs	.-28     	; 0x3f3c <rcfg_getMAC+0x56>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    *bufpos++ = ':';
    3f58:	b1 92       	st	Z+, r11
    3f5a:	08 94       	sec
    3f5c:	e1 1c       	adc	r14, r1
    3f5e:	f1 1c       	adc	r15, r1


  char sendbuf[17] = {0}; // clear buffer
  char * bufpos = sendbuf;
  uint8_t i;
  for (i=0; i<=5; i++) {
    3f60:	ec 14       	cp	r14, r12
    3f62:	fd 04       	cpc	r15, r13
    3f64:	11 f0       	breq	.+4      	; 0x3f6a <rcfg_getMAC+0x84>
    3f66:	8f 01       	movw	r16, r30
    3f68:	e0 cf       	rjmp	.-64     	; 0x3f2a <rcfg_getMAC+0x44>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    *bufpos++ = ':';
  }
  *(--bufpos) = '\0';
    3f6a:	f8 01       	movw	r30, r16
    3f6c:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3f6e:	8f 81       	ldd	r24, Y+7	; 0x07
    3f70:	88 23       	and	r24, r24
    3f72:	39 f1       	breq	.+78     	; 0x3fc2 <rcfg_getMAC+0xdc>
    3f74:	60 e0       	ldi	r22, 0x00	; 0
    3f76:	fe 01       	movw	r30, r28
    3f78:	38 96       	adiw	r30, 0x08	; 8
    len++;
    3f7a:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3f7c:	81 91       	ld	r24, Z+
    3f7e:	88 23       	and	r24, r24
    3f80:	e1 f7       	brne	.-8      	; 0x3f7a <rcfg_getMAC+0x94>
    3f82:	70 e0       	ldi	r23, 0x00	; 0
	  bufpos++;
    *bufpos++ = ':';
  }
  *(--bufpos) = '\0';

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    3f84:	c6 01       	movw	r24, r12
    3f86:	40 e3       	ldi	r20, 0x30	; 48
    3f88:	59 e0       	ldi	r21, 0x09	; 9
    3f8a:	26 e3       	ldi	r18, 0x36	; 54
    3f8c:	39 e0       	ldi	r19, 0x09	; 9
    3f8e:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nMAC-Address: ");
    3f92:	8f ec       	ldi	r24, 0xCF	; 207
    3f94:	92 e0       	ldi	r25, 0x02	; 2
    3f96:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    3f9a:	c6 01       	movw	r24, r12
    3f9c:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    3fa0:	80 e0       	ldi	r24, 0x00	; 0
    3fa2:	67 96       	adiw	r28, 0x17	; 23
    3fa4:	0f b6       	in	r0, 0x3f	; 63
    3fa6:	f8 94       	cli
    3fa8:	de bf       	out	0x3e, r29	; 62
    3faa:	0f be       	out	0x3f, r0	; 63
    3fac:	cd bf       	out	0x3d, r28	; 61
    3fae:	cf 91       	pop	r28
    3fb0:	df 91       	pop	r29
    3fb2:	1f 91       	pop	r17
    3fb4:	0f 91       	pop	r16
    3fb6:	ff 90       	pop	r15
    3fb8:	ef 90       	pop	r14
    3fba:	df 90       	pop	r13
    3fbc:	cf 90       	pop	r12
    3fbe:	bf 90       	pop	r11
    3fc0:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    3fc2:	60 e0       	ldi	r22, 0x00	; 0
    3fc4:	70 e0       	ldi	r23, 0x00	; 0
    3fc6:	de cf       	rjmp	.-68     	; 0x3f84 <rcfg_getMAC+0x9e>

00003fc8 <ip2str>:
    len++;
  return len;
}

char * ip2str(char * buf, ipAddress_t ip)
{
    3fc8:	df 92       	push	r13
    3fca:	ef 92       	push	r14
    3fcc:	ff 92       	push	r15
    3fce:	0f 93       	push	r16
    3fd0:	1f 93       	push	r17
    3fd2:	df 93       	push	r29
    3fd4:	cf 93       	push	r28
    3fd6:	00 d0       	rcall	.+0      	; 0x3fd8 <ip2str+0x10>
    3fd8:	00 d0       	rcall	.+0      	; 0x3fda <ip2str+0x12>
    3fda:	cd b7       	in	r28, 0x3d	; 61
    3fdc:	de b7       	in	r29, 0x3e	; 62
    3fde:	8c 01       	movw	r16, r24
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    3fe0:	49 83       	std	Y+1, r20	; 0x01
    3fe2:	5a 83       	std	Y+2, r21	; 0x02
    3fe4:	6b 83       	std	Y+3, r22	; 0x03
    3fe6:	7c 83       	std	Y+4, r23	; 0x04
    3fe8:	a4 e0       	ldi	r26, 0x04	; 4
    3fea:	ea 2e       	mov	r14, r26
    3fec:	f1 2c       	mov	r15, r1
    3fee:	ec 0e       	add	r14, r28
    3ff0:	fd 1e       	adc	r15, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    3ff2:	fe e2       	ldi	r31, 0x2E	; 46
    3ff4:	df 2e       	mov	r13, r31
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    3ff6:	f7 01       	movw	r30, r14
    3ff8:	80 81       	ld	r24, Z
    3ffa:	90 e0       	ldi	r25, 0x00	; 0
    3ffc:	b8 01       	movw	r22, r16
    3ffe:	4a e0       	ldi	r20, 0x0A	; 10
    4000:	50 e0       	ldi	r21, 0x00	; 0
    4002:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4006:	02 c0       	rjmp	.+4      	; 0x400c <ip2str+0x44>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4008:	0f 5f       	subi	r16, 0xFF	; 255
    400a:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    400c:	f8 01       	movw	r30, r16
    400e:	80 81       	ld	r24, Z
    4010:	80 53       	subi	r24, 0x30	; 48
    4012:	8a 30       	cpi	r24, 0x0A	; 10
    4014:	c8 f3       	brcs	.-14     	; 0x4008 <ip2str+0x40>
      buf++;
    *buf++ = '.';
    4016:	f8 01       	movw	r30, r16
    4018:	d1 92       	st	Z+, r13
    401a:	08 94       	sec
    401c:	e1 08       	sbc	r14, r1
    401e:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4020:	ec 16       	cp	r14, r28
    4022:	fd 06       	cpc	r15, r29
    4024:	11 f0       	breq	.+4      	; 0x402a <ip2str+0x62>
    4026:	8f 01       	movw	r16, r30
    4028:	e6 cf       	rjmp	.-52     	; 0x3ff6 <ip2str+0x2e>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    402a:	f8 01       	movw	r30, r16
    402c:	10 82       	st	Z, r1

  // return current position in buf
  return buf;
}
    402e:	c8 01       	movw	r24, r16
    4030:	0f 90       	pop	r0
    4032:	0f 90       	pop	r0
    4034:	0f 90       	pop	r0
    4036:	0f 90       	pop	r0
    4038:	cf 91       	pop	r28
    403a:	df 91       	pop	r29
    403c:	1f 91       	pop	r17
    403e:	0f 91       	pop	r16
    4040:	ff 90       	pop	r15
    4042:	ef 90       	pop	r14
    4044:	df 90       	pop	r13
    4046:	08 95       	ret

00004048 <rcfg_setMAC>:
}



uint8_t rcfg_setMAC(char * buf)
{
    4048:	0f 93       	push	r16
    404a:	1f 93       	push	r17
    404c:	df 93       	push	r29
    404e:	cf 93       	push	r28
    4050:	cd b7       	in	r28, 0x3d	; 61
    4052:	de b7       	in	r29, 0x3e	; 62
    4054:	28 97       	sbiw	r28, 0x08	; 8
    4056:	0f b6       	in	r0, 0x3f	; 63
    4058:	f8 94       	cli
    405a:	de bf       	out	0x3e, r29	; 62
    405c:	0f be       	out	0x3f, r0	; 63
    405e:	cd bf       	out	0x3d, r28	; 61
    4060:	98 87       	std	Y+8, r25	; 0x08
    4062:	8f 83       	std	Y+7, r24	; 0x07
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    4064:	8e 01       	movw	r16, r28
    4066:	09 5f       	subi	r16, 0xF9	; 249
    4068:	1f 4f       	sbci	r17, 0xFF	; 255
    406a:	c8 01       	movw	r24, r16
    406c:	0e 94 db 26 	call	0x4db6	; 0x4db6 <rcfg_parseUHex>
    4070:	69 83       	std	Y+1, r22	; 0x01
    buf++; // skip byte delimiter (usually ':')
    4072:	8f 81       	ldd	r24, Y+7	; 0x07
    4074:	98 85       	ldd	r25, Y+8	; 0x08
    4076:	01 96       	adiw	r24, 0x01	; 1
    4078:	98 87       	std	Y+8, r25	; 0x08
    407a:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    407c:	c8 01       	movw	r24, r16
    407e:	0e 94 db 26 	call	0x4db6	; 0x4db6 <rcfg_parseUHex>
    4082:	6a 83       	std	Y+2, r22	; 0x02
    buf++; // skip byte delimiter (usually ':')
    4084:	8f 81       	ldd	r24, Y+7	; 0x07
    4086:	98 85       	ldd	r25, Y+8	; 0x08
    4088:	01 96       	adiw	r24, 0x01	; 1
    408a:	98 87       	std	Y+8, r25	; 0x08
    408c:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    408e:	c8 01       	movw	r24, r16
    4090:	0e 94 db 26 	call	0x4db6	; 0x4db6 <rcfg_parseUHex>
    4094:	6b 83       	std	Y+3, r22	; 0x03
    buf++; // skip byte delimiter (usually ':')
    4096:	8f 81       	ldd	r24, Y+7	; 0x07
    4098:	98 85       	ldd	r25, Y+8	; 0x08
    409a:	01 96       	adiw	r24, 0x01	; 1
    409c:	98 87       	std	Y+8, r25	; 0x08
    409e:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    40a0:	c8 01       	movw	r24, r16
    40a2:	0e 94 db 26 	call	0x4db6	; 0x4db6 <rcfg_parseUHex>
    40a6:	6c 83       	std	Y+4, r22	; 0x04
    buf++; // skip byte delimiter (usually ':')
    40a8:	8f 81       	ldd	r24, Y+7	; 0x07
    40aa:	98 85       	ldd	r25, Y+8	; 0x08
    40ac:	01 96       	adiw	r24, 0x01	; 1
    40ae:	98 87       	std	Y+8, r25	; 0x08
    40b0:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    40b2:	c8 01       	movw	r24, r16
    40b4:	0e 94 db 26 	call	0x4db6	; 0x4db6 <rcfg_parseUHex>
    40b8:	6d 83       	std	Y+5, r22	; 0x05
    buf++; // skip byte delimiter (usually ':')
    40ba:	8f 81       	ldd	r24, Y+7	; 0x07
    40bc:	98 85       	ldd	r25, Y+8	; 0x08
    40be:	01 96       	adiw	r24, 0x01	; 1
    40c0:	98 87       	std	Y+8, r25	; 0x08
    40c2:	8f 83       	std	Y+7, r24	; 0x07
uint8_t rcfg_setMAC(char * buf)
{
  uint8_t mac[6];
  uint8_t i;
  for (i=0; i<=5; i++) {
    mac[i] = rcfg_parseUHex(&buf);
    40c4:	c8 01       	movw	r24, r16
    40c6:	0e 94 db 26 	call	0x4db6	; 0x4db6 <rcfg_parseUHex>
    40ca:	6e 83       	std	Y+6, r22	; 0x06
    buf++; // skip byte delimiter (usually ':')
    40cc:	8f 81       	ldd	r24, Y+7	; 0x07
    40ce:	98 85       	ldd	r25, Y+8	; 0x08
    40d0:	01 96       	adiw	r24, 0x01	; 1
    40d2:	98 87       	std	Y+8, r25	; 0x08
    40d4:	8f 83       	std	Y+7, r24	; 0x07
  }
  ethernetEepromSetConfig(mac);
    40d6:	ce 01       	movw	r24, r28
    40d8:	01 96       	adiw	r24, 0x01	; 1
    40da:	0e 94 31 07 	call	0xe62	; 0xe62 <ethernetEepromSetConfig>

  return RCFG_SUCCESS;
}
    40de:	80 e0       	ldi	r24, 0x00	; 0
    40e0:	28 96       	adiw	r28, 0x08	; 8
    40e2:	0f b6       	in	r0, 0x3f	; 63
    40e4:	f8 94       	cli
    40e6:	de bf       	out	0x3e, r29	; 62
    40e8:	0f be       	out	0x3f, r0	; 63
    40ea:	cd bf       	out	0x3d, r28	; 61
    40ec:	cf 91       	pop	r28
    40ee:	df 91       	pop	r29
    40f0:	1f 91       	pop	r17
    40f2:	0f 91       	pop	r16
    40f4:	08 95       	ret

000040f6 <rcfg_getDIP_Config>:
  configEepromSetConfig(0, dport, 0, 0, 0);

  return RCFG_SUCCESS;
}

uint8_t rcfg_getDIP_Config(char *buf) {
    40f6:	9f 92       	push	r9
    40f8:	af 92       	push	r10
    40fa:	bf 92       	push	r11
    40fc:	cf 92       	push	r12
    40fe:	df 92       	push	r13
    4100:	ef 92       	push	r14
    4102:	ff 92       	push	r15
    4104:	0f 93       	push	r16
    4106:	1f 93       	push	r17
    4108:	df 93       	push	r29
    410a:	cf 93       	push	r28
    410c:	cd b7       	in	r28, 0x3d	; 61
    410e:	de b7       	in	r29, 0x3e	; 62
    4110:	67 97       	sbiw	r28, 0x17	; 23
    4112:	0f b6       	in	r0, 0x3f	; 63
    4114:	f8 94       	cli
    4116:	de bf       	out	0x3e, r29	; 62
    4118:	0f be       	out	0x3f, r0	; 63
    411a:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t dip;
  configEepromGetConfig(NULL, NULL, &dip, NULL, NULL);
    411c:	80 e0       	ldi	r24, 0x00	; 0
    411e:	90 e0       	ldi	r25, 0x00	; 0
    4120:	60 e0       	ldi	r22, 0x00	; 0
    4122:	70 e0       	ldi	r23, 0x00	; 0
    4124:	ae 01       	movw	r20, r28
    4126:	4f 5f       	subi	r20, 0xFF	; 255
    4128:	5f 4f       	sbci	r21, 0xFF	; 255
    412a:	20 e0       	ldi	r18, 0x00	; 0
    412c:	30 e0       	ldi	r19, 0x00	; 0
    412e:	00 e0       	ldi	r16, 0x00	; 0
    4130:	10 e0       	ldi	r17, 0x00	; 0
    4132:	0e 94 bf 29 	call	0x537e	; 0x537e <configEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer;
    4136:	29 e0       	ldi	r18, 0x09	; 9
    4138:	a2 2e       	mov	r10, r18
    413a:	b1 2c       	mov	r11, r1
    413c:	ac 0e       	add	r10, r28
    413e:	bd 1e       	adc	r11, r29
    4140:	8f e0       	ldi	r24, 0x0F	; 15
    4142:	f5 01       	movw	r30, r10
    4144:	11 92       	st	Z+, r1
    4146:	8a 95       	dec	r24
    4148:	e9 f7       	brne	.-6      	; 0x4144 <rcfg_getDIP_Config+0x4e>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    414a:	89 81       	ldd	r24, Y+1	; 0x01
    414c:	9a 81       	ldd	r25, Y+2	; 0x02
    414e:	ab 81       	ldd	r26, Y+3	; 0x03
    4150:	bc 81       	ldd	r27, Y+4	; 0x04
    4152:	8d 83       	std	Y+5, r24	; 0x05
    4154:	9e 83       	std	Y+6, r25	; 0x06
    4156:	af 83       	std	Y+7, r26	; 0x07
    4158:	b8 87       	std	Y+8, r27	; 0x08
    415a:	98 e0       	ldi	r25, 0x08	; 8
    415c:	e9 2e       	mov	r14, r25
    415e:	f1 2c       	mov	r15, r1
    4160:	ec 0e       	add	r14, r28
    4162:	fd 1e       	adc	r15, r29
    4164:	85 01       	movw	r16, r10
    4166:	84 e0       	ldi	r24, 0x04	; 4
    4168:	c8 2e       	mov	r12, r24
    416a:	d1 2c       	mov	r13, r1
    416c:	cc 0e       	add	r12, r28
    416e:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4170:	be e2       	ldi	r27, 0x2E	; 46
    4172:	9b 2e       	mov	r9, r27
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4174:	f7 01       	movw	r30, r14
    4176:	80 81       	ld	r24, Z
    4178:	90 e0       	ldi	r25, 0x00	; 0
    417a:	b8 01       	movw	r22, r16
    417c:	4a e0       	ldi	r20, 0x0A	; 10
    417e:	50 e0       	ldi	r21, 0x00	; 0
    4180:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4184:	02 c0       	rjmp	.+4      	; 0x418a <rcfg_getDIP_Config+0x94>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4186:	0f 5f       	subi	r16, 0xFF	; 255
    4188:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    418a:	f8 01       	movw	r30, r16
    418c:	80 81       	ld	r24, Z
    418e:	80 53       	subi	r24, 0x30	; 48
    4190:	8a 30       	cpi	r24, 0x0A	; 10
    4192:	c8 f3       	brcs	.-14     	; 0x4186 <rcfg_getDIP_Config+0x90>
      buf++;
    *buf++ = '.';
    4194:	f8 01       	movw	r30, r16
    4196:	91 92       	st	Z+, r9
    4198:	08 94       	sec
    419a:	e1 08       	sbc	r14, r1
    419c:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    419e:	ec 14       	cp	r14, r12
    41a0:	fd 04       	cpc	r15, r13
    41a2:	11 f0       	breq	.+4      	; 0x41a8 <rcfg_getDIP_Config+0xb2>
    41a4:	8f 01       	movw	r16, r30
    41a6:	e6 cf       	rjmp	.-52     	; 0x4174 <rcfg_getDIP_Config+0x7e>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    41a8:	f8 01       	movw	r30, r16
    41aa:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    41ac:	89 85       	ldd	r24, Y+9	; 0x09
    41ae:	88 23       	and	r24, r24
    41b0:	49 f1       	breq	.+82     	; 0x4204 <rcfg_getDIP_Config+0x10e>
    41b2:	60 e0       	ldi	r22, 0x00	; 0
    41b4:	fe 01       	movw	r30, r28
    41b6:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    41b8:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    41ba:	81 91       	ld	r24, Z+
    41bc:	88 23       	and	r24, r24
    41be:	e1 f7       	brne	.-8      	; 0x41b8 <rcfg_getDIP_Config+0xc2>
    41c0:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(NULL, NULL, &dip, NULL, NULL);

  char sendbuf[15] = {0}; // clear buffer;
  ip2str(sendbuf, dip);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    41c2:	c5 01       	movw	r24, r10
    41c4:	40 e3       	ldi	r20, 0x30	; 48
    41c6:	59 e0       	ldi	r21, 0x09	; 9
    41c8:	26 e3       	ldi	r18, 0x36	; 54
    41ca:	39 e0       	ldi	r19, 0x09	; 9
    41cc:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nDestination IP for Config-Channel: ");
    41d0:	8f ed       	ldi	r24, 0xDF	; 223
    41d2:	92 e0       	ldi	r25, 0x02	; 2
    41d4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    41d8:	c5 01       	movw	r24, r10
    41da:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    41de:	80 e0       	ldi	r24, 0x00	; 0
    41e0:	67 96       	adiw	r28, 0x17	; 23
    41e2:	0f b6       	in	r0, 0x3f	; 63
    41e4:	f8 94       	cli
    41e6:	de bf       	out	0x3e, r29	; 62
    41e8:	0f be       	out	0x3f, r0	; 63
    41ea:	cd bf       	out	0x3d, r28	; 61
    41ec:	cf 91       	pop	r28
    41ee:	df 91       	pop	r29
    41f0:	1f 91       	pop	r17
    41f2:	0f 91       	pop	r16
    41f4:	ff 90       	pop	r15
    41f6:	ef 90       	pop	r14
    41f8:	df 90       	pop	r13
    41fa:	cf 90       	pop	r12
    41fc:	bf 90       	pop	r11
    41fe:	af 90       	pop	r10
    4200:	9f 90       	pop	r9
    4202:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4204:	60 e0       	ldi	r22, 0x00	; 0
    4206:	70 e0       	ldi	r23, 0x00	; 0
    4208:	dc cf       	rjmp	.-72     	; 0x41c2 <rcfg_getDIP_Config+0xcc>

0000420a <rcfg_getDIP_Data>:


  return RCFG_SUCCESS;
}

uint8_t rcfg_getDIP_Data(char *buf) {
    420a:	9f 92       	push	r9
    420c:	af 92       	push	r10
    420e:	bf 92       	push	r11
    4210:	cf 92       	push	r12
    4212:	df 92       	push	r13
    4214:	ef 92       	push	r14
    4216:	ff 92       	push	r15
    4218:	0f 93       	push	r16
    421a:	1f 93       	push	r17
    421c:	df 93       	push	r29
    421e:	cf 93       	push	r28
    4220:	cd b7       	in	r28, 0x3d	; 61
    4222:	de b7       	in	r29, 0x3e	; 62
    4224:	67 97       	sbiw	r28, 0x17	; 23
    4226:	0f b6       	in	r0, 0x3f	; 63
    4228:	f8 94       	cli
    422a:	de bf       	out	0x3e, r29	; 62
    422c:	0f be       	out	0x3f, r0	; 63
    422e:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t dip;
  configEepromGetConfig(&dip, NULL, NULL, NULL, NULL);
    4230:	ce 01       	movw	r24, r28
    4232:	01 96       	adiw	r24, 0x01	; 1
    4234:	60 e0       	ldi	r22, 0x00	; 0
    4236:	70 e0       	ldi	r23, 0x00	; 0
    4238:	40 e0       	ldi	r20, 0x00	; 0
    423a:	50 e0       	ldi	r21, 0x00	; 0
    423c:	20 e0       	ldi	r18, 0x00	; 0
    423e:	30 e0       	ldi	r19, 0x00	; 0
    4240:	00 e0       	ldi	r16, 0x00	; 0
    4242:	10 e0       	ldi	r17, 0x00	; 0
    4244:	0e 94 bf 29 	call	0x537e	; 0x537e <configEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer;
    4248:	69 e0       	ldi	r22, 0x09	; 9
    424a:	a6 2e       	mov	r10, r22
    424c:	b1 2c       	mov	r11, r1
    424e:	ac 0e       	add	r10, r28
    4250:	bd 1e       	adc	r11, r29
    4252:	8f e0       	ldi	r24, 0x0F	; 15
    4254:	f5 01       	movw	r30, r10
    4256:	11 92       	st	Z+, r1
    4258:	8a 95       	dec	r24
    425a:	e9 f7       	brne	.-6      	; 0x4256 <rcfg_getDIP_Data+0x4c>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    425c:	89 81       	ldd	r24, Y+1	; 0x01
    425e:	9a 81       	ldd	r25, Y+2	; 0x02
    4260:	ab 81       	ldd	r26, Y+3	; 0x03
    4262:	bc 81       	ldd	r27, Y+4	; 0x04
    4264:	8d 83       	std	Y+5, r24	; 0x05
    4266:	9e 83       	std	Y+6, r25	; 0x06
    4268:	af 83       	std	Y+7, r26	; 0x07
    426a:	b8 87       	std	Y+8, r27	; 0x08
    426c:	58 e0       	ldi	r21, 0x08	; 8
    426e:	e5 2e       	mov	r14, r21
    4270:	f1 2c       	mov	r15, r1
    4272:	ec 0e       	add	r14, r28
    4274:	fd 1e       	adc	r15, r29
    4276:	85 01       	movw	r16, r10
    4278:	44 e0       	ldi	r20, 0x04	; 4
    427a:	c4 2e       	mov	r12, r20
    427c:	d1 2c       	mov	r13, r1
    427e:	cc 0e       	add	r12, r28
    4280:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4282:	3e e2       	ldi	r19, 0x2E	; 46
    4284:	93 2e       	mov	r9, r19
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4286:	f7 01       	movw	r30, r14
    4288:	80 81       	ld	r24, Z
    428a:	90 e0       	ldi	r25, 0x00	; 0
    428c:	b8 01       	movw	r22, r16
    428e:	4a e0       	ldi	r20, 0x0A	; 10
    4290:	50 e0       	ldi	r21, 0x00	; 0
    4292:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4296:	02 c0       	rjmp	.+4      	; 0x429c <rcfg_getDIP_Data+0x92>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4298:	0f 5f       	subi	r16, 0xFF	; 255
    429a:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    429c:	f8 01       	movw	r30, r16
    429e:	80 81       	ld	r24, Z
    42a0:	80 53       	subi	r24, 0x30	; 48
    42a2:	8a 30       	cpi	r24, 0x0A	; 10
    42a4:	c8 f3       	brcs	.-14     	; 0x4298 <rcfg_getDIP_Data+0x8e>
      buf++;
    *buf++ = '.';
    42a6:	f8 01       	movw	r30, r16
    42a8:	91 92       	st	Z+, r9
    42aa:	08 94       	sec
    42ac:	e1 08       	sbc	r14, r1
    42ae:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    42b0:	ec 14       	cp	r14, r12
    42b2:	fd 04       	cpc	r15, r13
    42b4:	11 f0       	breq	.+4      	; 0x42ba <rcfg_getDIP_Data+0xb0>
    42b6:	8f 01       	movw	r16, r30
    42b8:	e6 cf       	rjmp	.-52     	; 0x4286 <rcfg_getDIP_Data+0x7c>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    42ba:	f8 01       	movw	r30, r16
    42bc:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    42be:	89 85       	ldd	r24, Y+9	; 0x09
    42c0:	88 23       	and	r24, r24
    42c2:	49 f1       	breq	.+82     	; 0x4316 <rcfg_getDIP_Data+0x10c>
    42c4:	60 e0       	ldi	r22, 0x00	; 0
    42c6:	fe 01       	movw	r30, r28
    42c8:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    42ca:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    42cc:	81 91       	ld	r24, Z+
    42ce:	88 23       	and	r24, r24
    42d0:	e1 f7       	brne	.-8      	; 0x42ca <rcfg_getDIP_Data+0xc0>
    42d2:	70 e0       	ldi	r23, 0x00	; 0
  configEepromGetConfig(&dip, NULL, NULL, NULL, NULL);

  char sendbuf[15] = {0}; // clear buffer;
  ip2str(sendbuf, dip);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    42d4:	c5 01       	movw	r24, r10
    42d6:	40 e3       	ldi	r20, 0x30	; 48
    42d8:	59 e0       	ldi	r21, 0x09	; 9
    42da:	26 e3       	ldi	r18, 0x36	; 54
    42dc:	39 e0       	ldi	r19, 0x09	; 9
    42de:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nDestination IP for Data-Channel: ");
    42e2:	85 e0       	ldi	r24, 0x05	; 5
    42e4:	93 e0       	ldi	r25, 0x03	; 3
    42e6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    42ea:	c5 01       	movw	r24, r10
    42ec:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    42f0:	80 e0       	ldi	r24, 0x00	; 0
    42f2:	67 96       	adiw	r28, 0x17	; 23
    42f4:	0f b6       	in	r0, 0x3f	; 63
    42f6:	f8 94       	cli
    42f8:	de bf       	out	0x3e, r29	; 62
    42fa:	0f be       	out	0x3f, r0	; 63
    42fc:	cd bf       	out	0x3d, r28	; 61
    42fe:	cf 91       	pop	r28
    4300:	df 91       	pop	r29
    4302:	1f 91       	pop	r17
    4304:	0f 91       	pop	r16
    4306:	ff 90       	pop	r15
    4308:	ef 90       	pop	r14
    430a:	df 90       	pop	r13
    430c:	cf 90       	pop	r12
    430e:	bf 90       	pop	r11
    4310:	af 90       	pop	r10
    4312:	9f 90       	pop	r9
    4314:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4316:	60 e0       	ldi	r22, 0x00	; 0
    4318:	70 e0       	ldi	r23, 0x00	; 0
    431a:	dc cf       	rjmp	.-72     	; 0x42d4 <rcfg_getDIP_Data+0xca>

0000431c <rcfg_getNet>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getNet(char * buf)
{
    431c:	4f 92       	push	r4
    431e:	5f 92       	push	r5
    4320:	6f 92       	push	r6
    4322:	7f 92       	push	r7
    4324:	9f 92       	push	r9
    4326:	af 92       	push	r10
    4328:	bf 92       	push	r11
    432a:	cf 92       	push	r12
    432c:	df 92       	push	r13
    432e:	ef 92       	push	r14
    4330:	ff 92       	push	r15
    4332:	0f 93       	push	r16
    4334:	1f 93       	push	r17
    4336:	df 93       	push	r29
    4338:	cf 93       	push	r28
    433a:	cd b7       	in	r28, 0x3d	; 61
    433c:	de b7       	in	r29, 0x3e	; 62
    433e:	c7 54       	subi	r28, 0x47	; 71
    4340:	d0 40       	sbci	r29, 0x00	; 0
    4342:	0f b6       	in	r0, 0x3f	; 63
    4344:	f8 94       	cli
    4346:	de bf       	out	0x3e, r29	; 62
    4348:	0f be       	out	0x3f, r0	; 63
    434a:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t ip, nm, gw;
  ipEepromGetConfig(&ip, &nm, &gw);
    434c:	ce 01       	movw	r24, r28
    434e:	01 96       	adiw	r24, 0x01	; 1
    4350:	be 01       	movw	r22, r28
    4352:	6b 5f       	subi	r22, 0xFB	; 251
    4354:	7f 4f       	sbci	r23, 0xFF	; 255
    4356:	ae 01       	movw	r20, r28
    4358:	47 5f       	subi	r20, 0xF7	; 247
    435a:	5f 4f       	sbci	r21, 0xFF	; 255
    435c:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[47] = {0}; // clear buffer;
    4360:	29 e1       	ldi	r18, 0x19	; 25
    4362:	42 2e       	mov	r4, r18
    4364:	51 2c       	mov	r5, r1
    4366:	4c 0e       	add	r4, r28
    4368:	5d 1e       	adc	r5, r29
    436a:	8f e2       	ldi	r24, 0x2F	; 47
    436c:	f2 01       	movw	r30, r4
    436e:	11 92       	st	Z+, r1
    4370:	8a 95       	dec	r24
    4372:	e9 f7       	brne	.-6      	; 0x436e <rcfg_getNet+0x52>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4374:	89 81       	ldd	r24, Y+1	; 0x01
    4376:	9a 81       	ldd	r25, Y+2	; 0x02
    4378:	ab 81       	ldd	r26, Y+3	; 0x03
    437a:	bc 81       	ldd	r27, Y+4	; 0x04
    437c:	8d 87       	std	Y+13, r24	; 0x0d
    437e:	9e 87       	std	Y+14, r25	; 0x0e
    4380:	af 87       	std	Y+15, r26	; 0x0f
    4382:	b8 8b       	std	Y+16, r27	; 0x10
    4384:	90 e1       	ldi	r25, 0x10	; 16
    4386:	69 2e       	mov	r6, r25
    4388:	71 2c       	mov	r7, r1
    438a:	6c 0e       	add	r6, r28
    438c:	7d 1e       	adc	r7, r29
    438e:	63 01       	movw	r12, r6
    4390:	82 01       	movw	r16, r4
    4392:	8c e0       	ldi	r24, 0x0C	; 12
    4394:	a8 2e       	mov	r10, r24
    4396:	b1 2c       	mov	r11, r1
    4398:	ac 0e       	add	r10, r28
    439a:	bd 1e       	adc	r11, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    439c:	be e2       	ldi	r27, 0x2E	; 46
    439e:	9b 2e       	mov	r9, r27
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    43a0:	f6 01       	movw	r30, r12
    43a2:	80 81       	ld	r24, Z
    43a4:	90 e0       	ldi	r25, 0x00	; 0
    43a6:	b8 01       	movw	r22, r16
    43a8:	4a e0       	ldi	r20, 0x0A	; 10
    43aa:	50 e0       	ldi	r21, 0x00	; 0
    43ac:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    43b0:	02 c0       	rjmp	.+4      	; 0x43b6 <rcfg_getNet+0x9a>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    43b2:	0f 5f       	subi	r16, 0xFF	; 255
    43b4:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    43b6:	f8 01       	movw	r30, r16
    43b8:	80 81       	ld	r24, Z
    43ba:	80 53       	subi	r24, 0x30	; 48
    43bc:	8a 30       	cpi	r24, 0x0A	; 10
    43be:	c8 f3       	brcs	.-14     	; 0x43b2 <rcfg_getNet+0x96>
      buf++;
    *buf++ = '.';
    43c0:	f8 01       	movw	r30, r16
    43c2:	91 92       	st	Z+, r9
    43c4:	7f 01       	movw	r14, r30
    43c6:	08 94       	sec
    43c8:	c1 08       	sbc	r12, r1
    43ca:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    43cc:	ca 14       	cp	r12, r10
    43ce:	db 04       	cpc	r13, r11
    43d0:	11 f0       	breq	.+4      	; 0x43d6 <rcfg_getNet+0xba>
    43d2:	8f 01       	movw	r16, r30
    43d4:	e5 cf       	rjmp	.-54     	; 0x43a0 <rcfg_getNet+0x84>
  ipEepromGetConfig(&ip, &nm, &gw);

  char sendbuf[47] = {0}; // clear buffer;
  char * newpos;
  newpos = ip2str(sendbuf, ip);
  *newpos++ = ' ';
    43d6:	80 e2       	ldi	r24, 0x20	; 32
    43d8:	f8 01       	movw	r30, r16
    43da:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    43dc:	8d 81       	ldd	r24, Y+5	; 0x05
    43de:	9e 81       	ldd	r25, Y+6	; 0x06
    43e0:	af 81       	ldd	r26, Y+7	; 0x07
    43e2:	b8 85       	ldd	r27, Y+8	; 0x08
    43e4:	89 8b       	std	Y+17, r24	; 0x11
    43e6:	9a 8b       	std	Y+18, r25	; 0x12
    43e8:	ab 8b       	std	Y+19, r26	; 0x13
    43ea:	bc 8b       	std	Y+20, r27	; 0x14
    43ec:	a4 e1       	ldi	r26, 0x14	; 20
    43ee:	aa 2e       	mov	r10, r26
    43f0:	b1 2c       	mov	r11, r1
    43f2:	ac 0e       	add	r10, r28
    43f4:	bd 1e       	adc	r11, r29
    43f6:	65 01       	movw	r12, r10
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    43f8:	fe e2       	ldi	r31, 0x2E	; 46
    43fa:	9f 2e       	mov	r9, r31
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    43fc:	f6 01       	movw	r30, r12
    43fe:	80 81       	ld	r24, Z
    4400:	90 e0       	ldi	r25, 0x00	; 0
    4402:	b7 01       	movw	r22, r14
    4404:	4a e0       	ldi	r20, 0x0A	; 10
    4406:	50 e0       	ldi	r21, 0x00	; 0
    4408:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    440c:	03 c0       	rjmp	.+6      	; 0x4414 <rcfg_getNet+0xf8>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    440e:	08 94       	sec
    4410:	e1 1c       	adc	r14, r1
    4412:	f1 1c       	adc	r15, r1
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4414:	f7 01       	movw	r30, r14
    4416:	80 81       	ld	r24, Z
    4418:	80 53       	subi	r24, 0x30	; 48
    441a:	8a 30       	cpi	r24, 0x0A	; 10
    441c:	c0 f3       	brcs	.-16     	; 0x440e <rcfg_getNet+0xf2>
      buf++;
    *buf++ = '.';
    441e:	f7 01       	movw	r30, r14
    4420:	91 92       	st	Z+, r9
    4422:	8f 01       	movw	r16, r30
    4424:	08 94       	sec
    4426:	c1 08       	sbc	r12, r1
    4428:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    442a:	c6 14       	cp	r12, r6
    442c:	d7 04       	cpc	r13, r7
    442e:	11 f0       	breq	.+4      	; 0x4434 <rcfg_getNet+0x118>
    4430:	7f 01       	movw	r14, r30
    4432:	e4 cf       	rjmp	.-56     	; 0x43fc <rcfg_getNet+0xe0>
  char sendbuf[47] = {0}; // clear buffer;
  char * newpos;
  newpos = ip2str(sendbuf, ip);
  *newpos++ = ' ';
  newpos = ip2str(newpos, nm);
  *newpos++ = ' ';
    4434:	80 e2       	ldi	r24, 0x20	; 32
    4436:	f7 01       	movw	r30, r14
    4438:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    443a:	89 85       	ldd	r24, Y+9	; 0x09
    443c:	9a 85       	ldd	r25, Y+10	; 0x0a
    443e:	ab 85       	ldd	r26, Y+11	; 0x0b
    4440:	bc 85       	ldd	r27, Y+12	; 0x0c
    4442:	8d 8b       	std	Y+21, r24	; 0x15
    4444:	9e 8b       	std	Y+22, r25	; 0x16
    4446:	af 8b       	std	Y+23, r26	; 0x17
    4448:	b8 8f       	std	Y+24, r27	; 0x18
    444a:	e8 e1       	ldi	r30, 0x18	; 24
    444c:	ee 2e       	mov	r14, r30
    444e:	f1 2c       	mov	r15, r1
    4450:	ec 0e       	add	r14, r28
    4452:	fd 1e       	adc	r15, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4454:	7e e2       	ldi	r23, 0x2E	; 46
    4456:	d7 2e       	mov	r13, r23
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4458:	f7 01       	movw	r30, r14
    445a:	80 81       	ld	r24, Z
    445c:	90 e0       	ldi	r25, 0x00	; 0
    445e:	b8 01       	movw	r22, r16
    4460:	4a e0       	ldi	r20, 0x0A	; 10
    4462:	50 e0       	ldi	r21, 0x00	; 0
    4464:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4468:	02 c0       	rjmp	.+4      	; 0x446e <rcfg_getNet+0x152>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    446a:	0f 5f       	subi	r16, 0xFF	; 255
    446c:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    446e:	f8 01       	movw	r30, r16
    4470:	80 81       	ld	r24, Z
    4472:	80 53       	subi	r24, 0x30	; 48
    4474:	8a 30       	cpi	r24, 0x0A	; 10
    4476:	c8 f3       	brcs	.-14     	; 0x446a <rcfg_getNet+0x14e>
      buf++;
    *buf++ = '.';
    4478:	f8 01       	movw	r30, r16
    447a:	d1 92       	st	Z+, r13
    447c:	08 94       	sec
    447e:	e1 08       	sbc	r14, r1
    4480:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4482:	ea 14       	cp	r14, r10
    4484:	fb 04       	cpc	r15, r11
    4486:	11 f0       	breq	.+4      	; 0x448c <rcfg_getNet+0x170>
    4488:	8f 01       	movw	r16, r30
    448a:	e6 cf       	rjmp	.-52     	; 0x4458 <rcfg_getNet+0x13c>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    448c:	f8 01       	movw	r30, r16
    448e:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4490:	89 8d       	ldd	r24, Y+25	; 0x19
    4492:	88 23       	and	r24, r24
    4494:	71 f1       	breq	.+92     	; 0x44f2 <rcfg_getNet+0x1d6>
    4496:	60 e0       	ldi	r22, 0x00	; 0
    4498:	fe 01       	movw	r30, r28
    449a:	7a 96       	adiw	r30, 0x1a	; 26
    len++;
    449c:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    449e:	81 91       	ld	r24, Z+
    44a0:	88 23       	and	r24, r24
    44a2:	e1 f7       	brne	.-8      	; 0x449c <rcfg_getNet+0x180>
    44a4:	70 e0       	ldi	r23, 0x00	; 0
  *newpos++ = ' ';
  newpos = ip2str(newpos, nm);
  *newpos++ = ' ';
  ip2str(newpos,gw);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    44a6:	c2 01       	movw	r24, r4
    44a8:	40 e3       	ldi	r20, 0x30	; 48
    44aa:	59 e0       	ldi	r21, 0x09	; 9
    44ac:	26 e3       	ldi	r18, 0x36	; 54
    44ae:	39 e0       	ldi	r19, 0x09	; 9
    44b0:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nNIC-Overview: ");
    44b4:	89 e2       	ldi	r24, 0x29	; 41
    44b6:	93 e0       	ldi	r25, 0x03	; 3
    44b8:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    44bc:	c2 01       	movw	r24, r4
    44be:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    44c2:	80 e0       	ldi	r24, 0x00	; 0
    44c4:	c9 5b       	subi	r28, 0xB9	; 185
    44c6:	df 4f       	sbci	r29, 0xFF	; 255
    44c8:	0f b6       	in	r0, 0x3f	; 63
    44ca:	f8 94       	cli
    44cc:	de bf       	out	0x3e, r29	; 62
    44ce:	0f be       	out	0x3f, r0	; 63
    44d0:	cd bf       	out	0x3d, r28	; 61
    44d2:	cf 91       	pop	r28
    44d4:	df 91       	pop	r29
    44d6:	1f 91       	pop	r17
    44d8:	0f 91       	pop	r16
    44da:	ff 90       	pop	r15
    44dc:	ef 90       	pop	r14
    44de:	df 90       	pop	r13
    44e0:	cf 90       	pop	r12
    44e2:	bf 90       	pop	r11
    44e4:	af 90       	pop	r10
    44e6:	9f 90       	pop	r9
    44e8:	7f 90       	pop	r7
    44ea:	6f 90       	pop	r6
    44ec:	5f 90       	pop	r5
    44ee:	4f 90       	pop	r4
    44f0:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    44f2:	60 e0       	ldi	r22, 0x00	; 0
    44f4:	70 e0       	ldi	r23, 0x00	; 0
    44f6:	d7 cf       	rjmp	.-82     	; 0x44a6 <rcfg_getNet+0x18a>

000044f8 <rcfg_getGW>:




uint8_t rcfg_getGW(char * buf)
{
    44f8:	9f 92       	push	r9
    44fa:	af 92       	push	r10
    44fc:	bf 92       	push	r11
    44fe:	cf 92       	push	r12
    4500:	df 92       	push	r13
    4502:	ef 92       	push	r14
    4504:	ff 92       	push	r15
    4506:	0f 93       	push	r16
    4508:	1f 93       	push	r17
    450a:	df 93       	push	r29
    450c:	cf 93       	push	r28
    450e:	cd b7       	in	r28, 0x3d	; 61
    4510:	de b7       	in	r29, 0x3e	; 62
    4512:	67 97       	sbiw	r28, 0x17	; 23
    4514:	0f b6       	in	r0, 0x3f	; 63
    4516:	f8 94       	cli
    4518:	de bf       	out	0x3e, r29	; 62
    451a:	0f be       	out	0x3f, r0	; 63
    451c:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t gw;
  ipEepromGetConfig(NULL, NULL, &gw);
    451e:	80 e0       	ldi	r24, 0x00	; 0
    4520:	90 e0       	ldi	r25, 0x00	; 0
    4522:	60 e0       	ldi	r22, 0x00	; 0
    4524:	70 e0       	ldi	r23, 0x00	; 0
    4526:	ae 01       	movw	r20, r28
    4528:	4f 5f       	subi	r20, 0xFF	; 255
    452a:	5f 4f       	sbci	r21, 0xFF	; 255
    452c:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer;
    4530:	69 e0       	ldi	r22, 0x09	; 9
    4532:	a6 2e       	mov	r10, r22
    4534:	b1 2c       	mov	r11, r1
    4536:	ac 0e       	add	r10, r28
    4538:	bd 1e       	adc	r11, r29
    453a:	8f e0       	ldi	r24, 0x0F	; 15
    453c:	f5 01       	movw	r30, r10
    453e:	11 92       	st	Z+, r1
    4540:	8a 95       	dec	r24
    4542:	e9 f7       	brne	.-6      	; 0x453e <rcfg_getGW+0x46>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4544:	89 81       	ldd	r24, Y+1	; 0x01
    4546:	9a 81       	ldd	r25, Y+2	; 0x02
    4548:	ab 81       	ldd	r26, Y+3	; 0x03
    454a:	bc 81       	ldd	r27, Y+4	; 0x04
    454c:	8d 83       	std	Y+5, r24	; 0x05
    454e:	9e 83       	std	Y+6, r25	; 0x06
    4550:	af 83       	std	Y+7, r26	; 0x07
    4552:	b8 87       	std	Y+8, r27	; 0x08
    4554:	58 e0       	ldi	r21, 0x08	; 8
    4556:	e5 2e       	mov	r14, r21
    4558:	f1 2c       	mov	r15, r1
    455a:	ec 0e       	add	r14, r28
    455c:	fd 1e       	adc	r15, r29
    455e:	85 01       	movw	r16, r10
    4560:	44 e0       	ldi	r20, 0x04	; 4
    4562:	c4 2e       	mov	r12, r20
    4564:	d1 2c       	mov	r13, r1
    4566:	cc 0e       	add	r12, r28
    4568:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    456a:	3e e2       	ldi	r19, 0x2E	; 46
    456c:	93 2e       	mov	r9, r19
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    456e:	f7 01       	movw	r30, r14
    4570:	80 81       	ld	r24, Z
    4572:	90 e0       	ldi	r25, 0x00	; 0
    4574:	b8 01       	movw	r22, r16
    4576:	4a e0       	ldi	r20, 0x0A	; 10
    4578:	50 e0       	ldi	r21, 0x00	; 0
    457a:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    457e:	02 c0       	rjmp	.+4      	; 0x4584 <rcfg_getGW+0x8c>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4580:	0f 5f       	subi	r16, 0xFF	; 255
    4582:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4584:	f8 01       	movw	r30, r16
    4586:	80 81       	ld	r24, Z
    4588:	80 53       	subi	r24, 0x30	; 48
    458a:	8a 30       	cpi	r24, 0x0A	; 10
    458c:	c8 f3       	brcs	.-14     	; 0x4580 <rcfg_getGW+0x88>
      buf++;
    *buf++ = '.';
    458e:	f8 01       	movw	r30, r16
    4590:	91 92       	st	Z+, r9
    4592:	08 94       	sec
    4594:	e1 08       	sbc	r14, r1
    4596:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4598:	ec 14       	cp	r14, r12
    459a:	fd 04       	cpc	r15, r13
    459c:	11 f0       	breq	.+4      	; 0x45a2 <rcfg_getGW+0xaa>
    459e:	8f 01       	movw	r16, r30
    45a0:	e6 cf       	rjmp	.-52     	; 0x456e <rcfg_getGW+0x76>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    45a2:	f8 01       	movw	r30, r16
    45a4:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    45a6:	89 85       	ldd	r24, Y+9	; 0x09
    45a8:	88 23       	and	r24, r24
    45aa:	49 f1       	breq	.+82     	; 0x45fe <rcfg_getGW+0x106>
    45ac:	60 e0       	ldi	r22, 0x00	; 0
    45ae:	fe 01       	movw	r30, r28
    45b0:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    45b2:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    45b4:	81 91       	ld	r24, Z+
    45b6:	88 23       	and	r24, r24
    45b8:	e1 f7       	brne	.-8      	; 0x45b2 <rcfg_getGW+0xba>
    45ba:	70 e0       	ldi	r23, 0x00	; 0
  ipEepromGetConfig(NULL, NULL, &gw);

  char sendbuf[15] = {0}; // clear buffer;
  ip2str(sendbuf, gw);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    45bc:	c5 01       	movw	r24, r10
    45be:	40 e3       	ldi	r20, 0x30	; 48
    45c0:	59 e0       	ldi	r21, 0x09	; 9
    45c2:	26 e3       	ldi	r18, 0x36	; 54
    45c4:	39 e0       	ldi	r19, 0x09	; 9
    45c6:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nGateway: ");
    45ca:	8a e3       	ldi	r24, 0x3A	; 58
    45cc:	93 e0       	ldi	r25, 0x03	; 3
    45ce:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    45d2:	c5 01       	movw	r24, r10
    45d4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    45d8:	80 e0       	ldi	r24, 0x00	; 0
    45da:	67 96       	adiw	r28, 0x17	; 23
    45dc:	0f b6       	in	r0, 0x3f	; 63
    45de:	f8 94       	cli
    45e0:	de bf       	out	0x3e, r29	; 62
    45e2:	0f be       	out	0x3f, r0	; 63
    45e4:	cd bf       	out	0x3d, r28	; 61
    45e6:	cf 91       	pop	r28
    45e8:	df 91       	pop	r29
    45ea:	1f 91       	pop	r17
    45ec:	0f 91       	pop	r16
    45ee:	ff 90       	pop	r15
    45f0:	ef 90       	pop	r14
    45f2:	df 90       	pop	r13
    45f4:	cf 90       	pop	r12
    45f6:	bf 90       	pop	r11
    45f8:	af 90       	pop	r10
    45fa:	9f 90       	pop	r9
    45fc:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    45fe:	60 e0       	ldi	r22, 0x00	; 0
    4600:	70 e0       	ldi	r23, 0x00	; 0
    4602:	dc cf       	rjmp	.-72     	; 0x45bc <rcfg_getGW+0xc4>

00004604 <rcfg_getNM>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getNM(char * buf)
{
    4604:	9f 92       	push	r9
    4606:	af 92       	push	r10
    4608:	bf 92       	push	r11
    460a:	cf 92       	push	r12
    460c:	df 92       	push	r13
    460e:	ef 92       	push	r14
    4610:	ff 92       	push	r15
    4612:	0f 93       	push	r16
    4614:	1f 93       	push	r17
    4616:	df 93       	push	r29
    4618:	cf 93       	push	r28
    461a:	cd b7       	in	r28, 0x3d	; 61
    461c:	de b7       	in	r29, 0x3e	; 62
    461e:	67 97       	sbiw	r28, 0x17	; 23
    4620:	0f b6       	in	r0, 0x3f	; 63
    4622:	f8 94       	cli
    4624:	de bf       	out	0x3e, r29	; 62
    4626:	0f be       	out	0x3f, r0	; 63
    4628:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t nm;
  ipEepromGetConfig(NULL, &nm, NULL);
    462a:	80 e0       	ldi	r24, 0x00	; 0
    462c:	90 e0       	ldi	r25, 0x00	; 0
    462e:	be 01       	movw	r22, r28
    4630:	6f 5f       	subi	r22, 0xFF	; 255
    4632:	7f 4f       	sbci	r23, 0xFF	; 255
    4634:	40 e0       	ldi	r20, 0x00	; 0
    4636:	50 e0       	ldi	r21, 0x00	; 0
    4638:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer
    463c:	a9 e0       	ldi	r26, 0x09	; 9
    463e:	aa 2e       	mov	r10, r26
    4640:	b1 2c       	mov	r11, r1
    4642:	ac 0e       	add	r10, r28
    4644:	bd 1e       	adc	r11, r29
    4646:	8f e0       	ldi	r24, 0x0F	; 15
    4648:	f5 01       	movw	r30, r10
    464a:	11 92       	st	Z+, r1
    464c:	8a 95       	dec	r24
    464e:	e9 f7       	brne	.-6      	; 0x464a <rcfg_getNM+0x46>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4650:	89 81       	ldd	r24, Y+1	; 0x01
    4652:	9a 81       	ldd	r25, Y+2	; 0x02
    4654:	ab 81       	ldd	r26, Y+3	; 0x03
    4656:	bc 81       	ldd	r27, Y+4	; 0x04
    4658:	8d 83       	std	Y+5, r24	; 0x05
    465a:	9e 83       	std	Y+6, r25	; 0x06
    465c:	af 83       	std	Y+7, r26	; 0x07
    465e:	b8 87       	std	Y+8, r27	; 0x08
    4660:	f8 e0       	ldi	r31, 0x08	; 8
    4662:	ef 2e       	mov	r14, r31
    4664:	f1 2c       	mov	r15, r1
    4666:	ec 0e       	add	r14, r28
    4668:	fd 1e       	adc	r15, r29
    466a:	85 01       	movw	r16, r10
    466c:	e4 e0       	ldi	r30, 0x04	; 4
    466e:	ce 2e       	mov	r12, r30
    4670:	d1 2c       	mov	r13, r1
    4672:	cc 0e       	add	r12, r28
    4674:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4676:	7e e2       	ldi	r23, 0x2E	; 46
    4678:	97 2e       	mov	r9, r23
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    467a:	f7 01       	movw	r30, r14
    467c:	80 81       	ld	r24, Z
    467e:	90 e0       	ldi	r25, 0x00	; 0
    4680:	b8 01       	movw	r22, r16
    4682:	4a e0       	ldi	r20, 0x0A	; 10
    4684:	50 e0       	ldi	r21, 0x00	; 0
    4686:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    468a:	02 c0       	rjmp	.+4      	; 0x4690 <rcfg_getNM+0x8c>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    468c:	0f 5f       	subi	r16, 0xFF	; 255
    468e:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4690:	f8 01       	movw	r30, r16
    4692:	80 81       	ld	r24, Z
    4694:	80 53       	subi	r24, 0x30	; 48
    4696:	8a 30       	cpi	r24, 0x0A	; 10
    4698:	c8 f3       	brcs	.-14     	; 0x468c <rcfg_getNM+0x88>
      buf++;
    *buf++ = '.';
    469a:	f8 01       	movw	r30, r16
    469c:	91 92       	st	Z+, r9
    469e:	08 94       	sec
    46a0:	e1 08       	sbc	r14, r1
    46a2:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    46a4:	ec 14       	cp	r14, r12
    46a6:	fd 04       	cpc	r15, r13
    46a8:	11 f0       	breq	.+4      	; 0x46ae <rcfg_getNM+0xaa>
    46aa:	8f 01       	movw	r16, r30
    46ac:	e6 cf       	rjmp	.-52     	; 0x467a <rcfg_getNM+0x76>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    46ae:	f8 01       	movw	r30, r16
    46b0:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    46b2:	89 85       	ldd	r24, Y+9	; 0x09
    46b4:	88 23       	and	r24, r24
    46b6:	49 f1       	breq	.+82     	; 0x470a <rcfg_getNM+0x106>
    46b8:	60 e0       	ldi	r22, 0x00	; 0
    46ba:	fe 01       	movw	r30, r28
    46bc:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    46be:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    46c0:	81 91       	ld	r24, Z+
    46c2:	88 23       	and	r24, r24
    46c4:	e1 f7       	brne	.-8      	; 0x46be <rcfg_getNM+0xba>
    46c6:	70 e0       	ldi	r23, 0x00	; 0
  ipEepromGetConfig(NULL, &nm, NULL);

  char sendbuf[15] = {0}; // clear buffer
  ip2str(sendbuf, nm);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    46c8:	c5 01       	movw	r24, r10
    46ca:	40 e3       	ldi	r20, 0x30	; 48
    46cc:	59 e0       	ldi	r21, 0x09	; 9
    46ce:	26 e3       	ldi	r18, 0x36	; 54
    46d0:	39 e0       	ldi	r19, 0x09	; 9
    46d2:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>


  putString("\r\nNetwork-Mask: ");
    46d6:	86 e4       	ldi	r24, 0x46	; 70
    46d8:	93 e0       	ldi	r25, 0x03	; 3
    46da:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    46de:	c5 01       	movw	r24, r10
    46e0:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;


}
    46e4:	80 e0       	ldi	r24, 0x00	; 0
    46e6:	67 96       	adiw	r28, 0x17	; 23
    46e8:	0f b6       	in	r0, 0x3f	; 63
    46ea:	f8 94       	cli
    46ec:	de bf       	out	0x3e, r29	; 62
    46ee:	0f be       	out	0x3f, r0	; 63
    46f0:	cd bf       	out	0x3d, r28	; 61
    46f2:	cf 91       	pop	r28
    46f4:	df 91       	pop	r29
    46f6:	1f 91       	pop	r17
    46f8:	0f 91       	pop	r16
    46fa:	ff 90       	pop	r15
    46fc:	ef 90       	pop	r14
    46fe:	df 90       	pop	r13
    4700:	cf 90       	pop	r12
    4702:	bf 90       	pop	r11
    4704:	af 90       	pop	r10
    4706:	9f 90       	pop	r9
    4708:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    470a:	60 e0       	ldi	r22, 0x00	; 0
    470c:	70 e0       	ldi	r23, 0x00	; 0
    470e:	dc cf       	rjmp	.-72     	; 0x46c8 <rcfg_getNM+0xc4>

00004710 <rcfg_getIP>:

  return RCFG_SUCCESS;
}

uint8_t rcfg_getIP(char * buf)
{
    4710:	9f 92       	push	r9
    4712:	af 92       	push	r10
    4714:	bf 92       	push	r11
    4716:	cf 92       	push	r12
    4718:	df 92       	push	r13
    471a:	ef 92       	push	r14
    471c:	ff 92       	push	r15
    471e:	0f 93       	push	r16
    4720:	1f 93       	push	r17
    4722:	df 93       	push	r29
    4724:	cf 93       	push	r28
    4726:	cd b7       	in	r28, 0x3d	; 61
    4728:	de b7       	in	r29, 0x3e	; 62
    472a:	67 97       	sbiw	r28, 0x17	; 23
    472c:	0f b6       	in	r0, 0x3f	; 63
    472e:	f8 94       	cli
    4730:	de bf       	out	0x3e, r29	; 62
    4732:	0f be       	out	0x3f, r0	; 63
    4734:	cd bf       	out	0x3d, r28	; 61
  ipAddress_t ip;
  ipEepromGetConfig(&ip, NULL, NULL);
    4736:	ce 01       	movw	r24, r28
    4738:	01 96       	adiw	r24, 0x01	; 1
    473a:	60 e0       	ldi	r22, 0x00	; 0
    473c:	70 e0       	ldi	r23, 0x00	; 0
    473e:	40 e0       	ldi	r20, 0x00	; 0
    4740:	50 e0       	ldi	r21, 0x00	; 0
    4742:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

  char sendbuf[15] = {0}; // clear buffer
    4746:	29 e0       	ldi	r18, 0x09	; 9
    4748:	a2 2e       	mov	r10, r18
    474a:	b1 2c       	mov	r11, r1
    474c:	ac 0e       	add	r10, r28
    474e:	bd 1e       	adc	r11, r29
    4750:	8f e0       	ldi	r24, 0x0F	; 15
    4752:	f5 01       	movw	r30, r10
    4754:	11 92       	st	Z+, r1
    4756:	8a 95       	dec	r24
    4758:	e9 f7       	brne	.-6      	; 0x4754 <rcfg_getIP+0x44>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    475a:	89 81       	ldd	r24, Y+1	; 0x01
    475c:	9a 81       	ldd	r25, Y+2	; 0x02
    475e:	ab 81       	ldd	r26, Y+3	; 0x03
    4760:	bc 81       	ldd	r27, Y+4	; 0x04
    4762:	8d 83       	std	Y+5, r24	; 0x05
    4764:	9e 83       	std	Y+6, r25	; 0x06
    4766:	af 83       	std	Y+7, r26	; 0x07
    4768:	b8 87       	std	Y+8, r27	; 0x08
    476a:	98 e0       	ldi	r25, 0x08	; 8
    476c:	e9 2e       	mov	r14, r25
    476e:	f1 2c       	mov	r15, r1
    4770:	ec 0e       	add	r14, r28
    4772:	fd 1e       	adc	r15, r29
    4774:	85 01       	movw	r16, r10
    4776:	84 e0       	ldi	r24, 0x04	; 4
    4778:	c8 2e       	mov	r12, r24
    477a:	d1 2c       	mov	r13, r1
    477c:	cc 0e       	add	r12, r28
    477e:	dd 1e       	adc	r13, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4780:	be e2       	ldi	r27, 0x2E	; 46
    4782:	9b 2e       	mov	r9, r27
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4784:	f7 01       	movw	r30, r14
    4786:	80 81       	ld	r24, Z
    4788:	90 e0       	ldi	r25, 0x00	; 0
    478a:	b8 01       	movw	r22, r16
    478c:	4a e0       	ldi	r20, 0x0A	; 10
    478e:	50 e0       	ldi	r21, 0x00	; 0
    4790:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4794:	02 c0       	rjmp	.+4      	; 0x479a <rcfg_getIP+0x8a>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4796:	0f 5f       	subi	r16, 0xFF	; 255
    4798:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    479a:	f8 01       	movw	r30, r16
    479c:	80 81       	ld	r24, Z
    479e:	80 53       	subi	r24, 0x30	; 48
    47a0:	8a 30       	cpi	r24, 0x0A	; 10
    47a2:	c8 f3       	brcs	.-14     	; 0x4796 <rcfg_getIP+0x86>
      buf++;
    *buf++ = '.';
    47a4:	f8 01       	movw	r30, r16
    47a6:	91 92       	st	Z+, r9
    47a8:	08 94       	sec
    47aa:	e1 08       	sbc	r14, r1
    47ac:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    47ae:	ec 14       	cp	r14, r12
    47b0:	fd 04       	cpc	r15, r13
    47b2:	11 f0       	breq	.+4      	; 0x47b8 <rcfg_getIP+0xa8>
    47b4:	8f 01       	movw	r16, r30
    47b6:	e6 cf       	rjmp	.-52     	; 0x4784 <rcfg_getIP+0x74>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    47b8:	f8 01       	movw	r30, r16
    47ba:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    47bc:	89 85       	ldd	r24, Y+9	; 0x09
    47be:	88 23       	and	r24, r24
    47c0:	49 f1       	breq	.+82     	; 0x4814 <rcfg_getIP+0x104>
    47c2:	60 e0       	ldi	r22, 0x00	; 0
    47c4:	fe 01       	movw	r30, r28
    47c6:	3a 96       	adiw	r30, 0x0a	; 10
    len++;
    47c8:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    47ca:	81 91       	ld	r24, Z+
    47cc:	88 23       	and	r24, r24
    47ce:	e1 f7       	brne	.-8      	; 0x47c8 <rcfg_getIP+0xb8>
    47d0:	70 e0       	ldi	r23, 0x00	; 0
  ipEepromGetConfig(&ip, NULL, NULL);

  char sendbuf[15] = {0}; // clear buffer
  ip2str(sendbuf, ip);

  rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    47d2:	c5 01       	movw	r24, r10
    47d4:	40 e3       	ldi	r20, 0x30	; 48
    47d6:	59 e0       	ldi	r21, 0x09	; 9
    47d8:	26 e3       	ldi	r18, 0x36	; 54
    47da:	39 e0       	ldi	r19, 0x09	; 9
    47dc:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

  putString("\r\nIP-Address: ");
    47e0:	87 e5       	ldi	r24, 0x57	; 87
    47e2:	93 e0       	ldi	r25, 0x03	; 3
    47e4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  putString(sendbuf);
    47e8:	c5 01       	movw	r24, r10
    47ea:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


  return RCFG_SUCCESS;
}
    47ee:	80 e0       	ldi	r24, 0x00	; 0
    47f0:	67 96       	adiw	r28, 0x17	; 23
    47f2:	0f b6       	in	r0, 0x3f	; 63
    47f4:	f8 94       	cli
    47f6:	de bf       	out	0x3e, r29	; 62
    47f8:	0f be       	out	0x3f, r0	; 63
    47fa:	cd bf       	out	0x3d, r28	; 61
    47fc:	cf 91       	pop	r28
    47fe:	df 91       	pop	r29
    4800:	1f 91       	pop	r17
    4802:	0f 91       	pop	r16
    4804:	ff 90       	pop	r15
    4806:	ef 90       	pop	r14
    4808:	df 90       	pop	r13
    480a:	cf 90       	pop	r12
    480c:	bf 90       	pop	r11
    480e:	af 90       	pop	r10
    4810:	9f 90       	pop	r9
    4812:	08 95       	ret
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4814:	60 e0       	ldi	r22, 0x00	; 0
    4816:	70 e0       	ldi	r23, 0x00	; 0
    4818:	dc cf       	rjmp	.-72     	; 0x47d2 <rcfg_getIP+0xc2>

0000481a <rcfg_getConfig>:
}



uint8_t rcfg_getConfig(char * buf)
{
    481a:	4f 92       	push	r4
    481c:	5f 92       	push	r5
    481e:	7f 92       	push	r7
    4820:	8f 92       	push	r8
    4822:	9f 92       	push	r9
    4824:	af 92       	push	r10
    4826:	bf 92       	push	r11
    4828:	cf 92       	push	r12
    482a:	df 92       	push	r13
    482c:	ef 92       	push	r14
    482e:	ff 92       	push	r15
    4830:	0f 93       	push	r16
    4832:	1f 93       	push	r17
    4834:	df 93       	push	r29
    4836:	cf 93       	push	r28
    4838:	cd b7       	in	r28, 0x3d	; 61
    483a:	de b7       	in	r29, 0x3e	; 62
    483c:	c5 57       	subi	r28, 0x75	; 117
    483e:	d0 40       	sbci	r29, 0x00	; 0
    4840:	0f b6       	in	r0, 0x3f	; 63
    4842:	f8 94       	cli
    4844:	de bf       	out	0x3e, r29	; 62
    4846:	0f be       	out	0x3f, r0	; 63
    4848:	cd bf       	out	0x3d, r28	; 61


//Address 100 IP4_EEPROM

	ipAddress_t ip, nm, gw;
	ipEepromGetConfig(&ip, &nm, &gw);
    484a:	ce 01       	movw	r24, r28
    484c:	0c 96       	adiw	r24, 0x0c	; 12
    484e:	be 01       	movw	r22, r28
    4850:	60 5f       	subi	r22, 0xF0	; 240
    4852:	7f 4f       	sbci	r23, 0xFF	; 255
    4854:	ae 01       	movw	r20, r28
    4856:	4c 5e       	subi	r20, 0xEC	; 236
    4858:	5f 4f       	sbci	r21, 0xFF	; 255
    485a:	0e 94 3a 08 	call	0x1074	; 0x1074 <ipEepromGetConfig>

	char sendbuf[50] = {0}; // clear buffer;
    485e:	34 e4       	ldi	r19, 0x44	; 68
    4860:	83 2e       	mov	r8, r19
    4862:	91 2c       	mov	r9, r1
    4864:	8c 0e       	add	r8, r28
    4866:	9d 1e       	adc	r9, r29
    4868:	82 e3       	ldi	r24, 0x32	; 50
    486a:	f4 01       	movw	r30, r8
    486c:	11 92       	st	Z+, r1
    486e:	8a 95       	dec	r24
    4870:	e9 f7       	brne	.-6      	; 0x486c <rcfg_getConfig+0x52>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4872:	8c 85       	ldd	r24, Y+12	; 0x0c
    4874:	9d 85       	ldd	r25, Y+13	; 0x0d
    4876:	ae 85       	ldd	r26, Y+14	; 0x0e
    4878:	bf 85       	ldd	r27, Y+15	; 0x0f
    487a:	88 a3       	std	Y+32, r24	; 0x20
    487c:	99 a3       	std	Y+33, r25	; 0x21
    487e:	aa a3       	std	Y+34, r26	; 0x22
    4880:	bb a3       	std	Y+35, r27	; 0x23
    4882:	23 e2       	ldi	r18, 0x23	; 35
    4884:	42 2e       	mov	r4, r18
    4886:	51 2c       	mov	r5, r1
    4888:	4c 0e       	add	r4, r28
    488a:	5d 1e       	adc	r5, r29
    488c:	62 01       	movw	r12, r4
    488e:	84 01       	movw	r16, r8
    4890:	9f e1       	ldi	r25, 0x1F	; 31
    4892:	a9 2e       	mov	r10, r25
    4894:	b1 2c       	mov	r11, r1
    4896:	ac 0e       	add	r10, r28
    4898:	bd 1e       	adc	r11, r29
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    489a:	8e e2       	ldi	r24, 0x2E	; 46
    489c:	78 2e       	mov	r7, r24
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    489e:	f6 01       	movw	r30, r12
    48a0:	80 81       	ld	r24, Z
    48a2:	90 e0       	ldi	r25, 0x00	; 0
    48a4:	b8 01       	movw	r22, r16
    48a6:	4a e0       	ldi	r20, 0x0A	; 10
    48a8:	50 e0       	ldi	r21, 0x00	; 0
    48aa:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    48ae:	02 c0       	rjmp	.+4      	; 0x48b4 <rcfg_getConfig+0x9a>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    48b0:	0f 5f       	subi	r16, 0xFF	; 255
    48b2:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    48b4:	f8 01       	movw	r30, r16
    48b6:	80 81       	ld	r24, Z
    48b8:	80 53       	subi	r24, 0x30	; 48
    48ba:	8a 30       	cpi	r24, 0x0A	; 10
    48bc:	c8 f3       	brcs	.-14     	; 0x48b0 <rcfg_getConfig+0x96>
      buf++;
    *buf++ = '.';
    48be:	f8 01       	movw	r30, r16
    48c0:	71 92       	st	Z+, r7
    48c2:	7f 01       	movw	r14, r30
    48c4:	08 94       	sec
    48c6:	c1 08       	sbc	r12, r1
    48c8:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    48ca:	ca 14       	cp	r12, r10
    48cc:	db 04       	cpc	r13, r11
    48ce:	11 f0       	breq	.+4      	; 0x48d4 <rcfg_getConfig+0xba>
    48d0:	8f 01       	movw	r16, r30
    48d2:	e5 cf       	rjmp	.-54     	; 0x489e <rcfg_getConfig+0x84>
	ipEepromGetConfig(&ip, &nm, &gw);

	char sendbuf[50] = {0}; // clear buffer;
	char * newpos;
	newpos = ip2str(sendbuf, ip);
	*newpos++ = ' ';
    48d4:	80 e2       	ldi	r24, 0x20	; 32
    48d6:	f8 01       	movw	r30, r16
    48d8:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    48da:	88 89       	ldd	r24, Y+16	; 0x10
    48dc:	99 89       	ldd	r25, Y+17	; 0x11
    48de:	aa 89       	ldd	r26, Y+18	; 0x12
    48e0:	bb 89       	ldd	r27, Y+19	; 0x13
    48e2:	8c a3       	std	Y+36, r24	; 0x24
    48e4:	9d a3       	std	Y+37, r25	; 0x25
    48e6:	ae a3       	std	Y+38, r26	; 0x26
    48e8:	bf a3       	std	Y+39, r27	; 0x27
    48ea:	07 e2       	ldi	r16, 0x27	; 39
    48ec:	a0 2e       	mov	r10, r16
    48ee:	b1 2c       	mov	r11, r1
    48f0:	ac 0e       	add	r10, r28
    48f2:	bd 1e       	adc	r11, r29
    48f4:	65 01       	movw	r12, r10
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    48f6:	1e e2       	ldi	r17, 0x2E	; 46
    48f8:	71 2e       	mov	r7, r17
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    48fa:	f6 01       	movw	r30, r12
    48fc:	80 81       	ld	r24, Z
    48fe:	90 e0       	ldi	r25, 0x00	; 0
    4900:	b7 01       	movw	r22, r14
    4902:	4a e0       	ldi	r20, 0x0A	; 10
    4904:	50 e0       	ldi	r21, 0x00	; 0
    4906:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    490a:	03 c0       	rjmp	.+6      	; 0x4912 <rcfg_getConfig+0xf8>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    490c:	08 94       	sec
    490e:	e1 1c       	adc	r14, r1
    4910:	f1 1c       	adc	r15, r1
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4912:	f7 01       	movw	r30, r14
    4914:	80 81       	ld	r24, Z
    4916:	80 53       	subi	r24, 0x30	; 48
    4918:	8a 30       	cpi	r24, 0x0A	; 10
    491a:	c0 f3       	brcs	.-16     	; 0x490c <rcfg_getConfig+0xf2>
      buf++;
    *buf++ = '.';
    491c:	f7 01       	movw	r30, r14
    491e:	71 92       	st	Z+, r7
    4920:	8f 01       	movw	r16, r30
    4922:	08 94       	sec
    4924:	c1 08       	sbc	r12, r1
    4926:	d1 08       	sbc	r13, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4928:	c4 14       	cp	r12, r4
    492a:	d5 04       	cpc	r13, r5
    492c:	11 f0       	breq	.+4      	; 0x4932 <rcfg_getConfig+0x118>
    492e:	7f 01       	movw	r14, r30
    4930:	e4 cf       	rjmp	.-56     	; 0x48fa <rcfg_getConfig+0xe0>
	char sendbuf[50] = {0}; // clear buffer;
	char * newpos;
	newpos = ip2str(sendbuf, ip);
	*newpos++ = ' ';
	newpos = ip2str(newpos, nm);
	*newpos++ = ' ';
    4932:	80 e2       	ldi	r24, 0x20	; 32
    4934:	f7 01       	movw	r30, r14
    4936:	80 83       	st	Z, r24
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4938:	8c 89       	ldd	r24, Y+20	; 0x14
    493a:	9d 89       	ldd	r25, Y+21	; 0x15
    493c:	ae 89       	ldd	r26, Y+22	; 0x16
    493e:	bf 89       	ldd	r27, Y+23	; 0x17
    4940:	88 a7       	std	Y+40, r24	; 0x28
    4942:	99 a7       	std	Y+41, r25	; 0x29
    4944:	aa a7       	std	Y+42, r26	; 0x2a
    4946:	bb a7       	std	Y+43, r27	; 0x2b
    4948:	bb e2       	ldi	r27, 0x2B	; 43
    494a:	4b 2e       	mov	r4, r27
    494c:	51 2c       	mov	r5, r1
    494e:	4c 0e       	add	r4, r28
    4950:	5d 1e       	adc	r5, r29
    4952:	72 01       	movw	r14, r4
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4954:	ae e2       	ldi	r26, 0x2E	; 46
    4956:	da 2e       	mov	r13, r26
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4958:	f7 01       	movw	r30, r14
    495a:	80 81       	ld	r24, Z
    495c:	90 e0       	ldi	r25, 0x00	; 0
    495e:	b8 01       	movw	r22, r16
    4960:	4a e0       	ldi	r20, 0x0A	; 10
    4962:	50 e0       	ldi	r21, 0x00	; 0
    4964:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4968:	02 c0       	rjmp	.+4      	; 0x496e <rcfg_getConfig+0x154>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    496a:	0f 5f       	subi	r16, 0xFF	; 255
    496c:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    496e:	f8 01       	movw	r30, r16
    4970:	80 81       	ld	r24, Z
    4972:	80 53       	subi	r24, 0x30	; 48
    4974:	8a 30       	cpi	r24, 0x0A	; 10
    4976:	c8 f3       	brcs	.-14     	; 0x496a <rcfg_getConfig+0x150>
      buf++;
    *buf++ = '.';
    4978:	f8 01       	movw	r30, r16
    497a:	d1 92       	st	Z+, r13
    497c:	08 94       	sec
    497e:	e1 08       	sbc	r14, r1
    4980:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4982:	ea 14       	cp	r14, r10
    4984:	fb 04       	cpc	r15, r11
    4986:	11 f0       	breq	.+4      	; 0x498c <rcfg_getConfig+0x172>
    4988:	8f 01       	movw	r16, r30
    498a:	e6 cf       	rjmp	.-52     	; 0x4958 <rcfg_getConfig+0x13e>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    498c:	f8 01       	movw	r30, r16
    498e:	10 82       	st	Z, r1
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4990:	f4 01       	movw	r30, r8
    4992:	80 81       	ld	r24, Z
    4994:	88 23       	and	r24, r24
    4996:	09 f4       	brne	.+2      	; 0x499a <rcfg_getConfig+0x180>
    4998:	c6 c1       	rjmp	.+908    	; 0x4d26 <rcfg_getConfig+0x50c>
    499a:	60 e0       	ldi	r22, 0x00	; 0
    499c:	f4 01       	movw	r30, r8
    499e:	31 96       	adiw	r30, 0x01	; 1
    len++;
    49a0:	6f 5f       	subi	r22, 0xFF	; 255
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    49a2:	81 91       	ld	r24, Z+
    49a4:	88 23       	and	r24, r24
    49a6:	e1 f7       	brne	.-8      	; 0x49a0 <rcfg_getConfig+0x186>
    49a8:	70 e0       	ldi	r23, 0x00	; 0
	*newpos++ = ' ';
	newpos = ip2str(newpos, nm);
	*newpos++ = ' ';
	ip2str(newpos,gw);

	rtpSendCommand(sendbuf, stringLength(sendbuf), &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    49aa:	c4 01       	movw	r24, r8
    49ac:	40 e3       	ldi	r20, 0x30	; 48
    49ae:	59 e0       	ldi	r21, 0x09	; 9
    49b0:	26 e3       	ldi	r18, 0x36	; 54
    49b2:	39 e0       	ldi	r19, 0x09	; 9
    49b4:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>

	putString("\r\nConfig-Overview: ");
    49b8:	86 e6       	ldi	r24, 0x66	; 102
    49ba:	93 e0       	ldi	r25, 0x03	; 3
    49bc:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString("\r\nAb Adresse 0x100: ");
    49c0:	8a e7       	ldi	r24, 0x7A	; 122
    49c2:	93 e0       	ldi	r25, 0x03	; 3
    49c4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>



	putString("(IP,Netmask,GW) ");
    49c8:	8f e8       	ldi	r24, 0x8F	; 143
    49ca:	93 e0       	ldi	r25, 0x03	; 3
    49cc:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(sendbuf);
    49d0:	c4 01       	movw	r24, r8
    49d2:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	//Address 200 MAC_EEPROM
	

	uint8_t mac[6];
	ethernetEepromGetConfig(mac);
    49d6:	8e 01       	movw	r16, r28
    49d8:	0c 5c       	subi	r16, 0xCC	; 204
    49da:	1f 4f       	sbci	r17, 0xFF	; 255
    49dc:	c8 01       	movw	r24, r16
    49de:	0e 94 f7 06 	call	0xdee	; 0xdee <ethernetEepromGetConfig>

	sendbuf[0] = '\0'; // clear buffer
    49e2:	f4 01       	movw	r30, r8
    49e4:	10 82       	st	Z, r1
    49e6:	78 01       	movw	r14, r16
    49e8:	84 01       	movw	r16, r8
    49ea:	fa e3       	ldi	r31, 0x3A	; 58
    49ec:	cf 2e       	mov	r12, r31
    49ee:	d1 2c       	mov	r13, r1
    49f0:	cc 0e       	add	r12, r28
    49f2:	dd 1e       	adc	r13, r29
	utoa(mac[i], bufpos, 16);
	while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
	*bufpos++ = ':';
    49f4:	ea e3       	ldi	r30, 0x3A	; 58
    49f6:	be 2e       	mov	r11, r30

	sendbuf[0] = '\0'; // clear buffer
	char * bufpos = sendbuf;
	uint8_t i;
	for (i=0; i<=5; i++) {
	utoa(mac[i], bufpos, 16);
    49f8:	f7 01       	movw	r30, r14
    49fa:	80 81       	ld	r24, Z
    49fc:	90 e0       	ldi	r25, 0x00	; 0
    49fe:	b8 01       	movw	r22, r16
    4a00:	40 e1       	ldi	r20, 0x10	; 16
    4a02:	50 e0       	ldi	r21, 0x00	; 0
    4a04:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4a08:	02 c0       	rjmp	.+4      	; 0x4a0e <rcfg_getConfig+0x1f4>
	while ( (*bufpos >= '0' && *bufpos <= '9') ||
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
    4a0a:	0f 5f       	subi	r16, 0xFF	; 255
    4a0c:	1f 4f       	sbci	r17, 0xFF	; 255
	sendbuf[0] = '\0'; // clear buffer
	char * bufpos = sendbuf;
	uint8_t i;
	for (i=0; i<=5; i++) {
	utoa(mac[i], bufpos, 16);
	while ( (*bufpos >= '0' && *bufpos <= '9') ||
    4a0e:	f8 01       	movw	r30, r16
    4a10:	90 81       	ld	r25, Z
    4a12:	89 2f       	mov	r24, r25
    4a14:	80 53       	subi	r24, 0x30	; 48
    4a16:	8a 30       	cpi	r24, 0x0A	; 10
    4a18:	c0 f3       	brcs	.-16     	; 0x4a0a <rcfg_getConfig+0x1f0>
    4a1a:	81 53       	subi	r24, 0x31	; 49
    4a1c:	86 30       	cpi	r24, 0x06	; 6
    4a1e:	a8 f3       	brcs	.-22     	; 0x4a0a <rcfg_getConfig+0x1f0>
    4a20:	91 54       	subi	r25, 0x41	; 65
    4a22:	96 30       	cpi	r25, 0x06	; 6
    4a24:	90 f3       	brcs	.-28     	; 0x4a0a <rcfg_getConfig+0x1f0>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
	*bufpos++ = ':';
    4a26:	b1 92       	st	Z+, r11
    4a28:	08 94       	sec
    4a2a:	e1 1c       	adc	r14, r1
    4a2c:	f1 1c       	adc	r15, r1
	ethernetEepromGetConfig(mac);

	sendbuf[0] = '\0'; // clear buffer
	char * bufpos = sendbuf;
	uint8_t i;
	for (i=0; i<=5; i++) {
    4a2e:	ec 14       	cp	r14, r12
    4a30:	fd 04       	cpc	r15, r13
    4a32:	11 f0       	breq	.+4      	; 0x4a38 <rcfg_getConfig+0x21e>
    4a34:	8f 01       	movw	r16, r30
    4a36:	e0 cf       	rjmp	.-64     	; 0x49f8 <rcfg_getConfig+0x1de>
	    (*bufpos >= 'a' && *bufpos <= 'f') ||
	    (*bufpos >= 'A' && *bufpos <= 'F') )
	  bufpos++;
	*bufpos++ = ':';
	}
	*(--bufpos) = '\0';
    4a38:	f8 01       	movw	r30, r16
    4a3a:	10 82       	st	Z, r1

	putString("\r\nAb Adresse 0x200: ");
    4a3c:	80 ea       	ldi	r24, 0xA0	; 160
    4a3e:	93 e0       	ldi	r25, 0x03	; 3
    4a40:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString("(MAC-Address) ");
    4a44:	85 eb       	ldi	r24, 0xB5	; 181
    4a46:	93 e0       	ldi	r25, 0x03	; 3
    4a48:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(sendbuf);
    4a4c:	c4 01       	movw	r24, r8
    4a4e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>



	//Address 300 SERIAL_EEPROM

	uint16_t prescaler=0;
    4a52:	1d 82       	std	Y+5, r1	; 0x05
    4a54:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t parity=0;
    4a56:	19 82       	std	Y+1, r1	; 0x01
	uint8_t stop_bits=0;
    4a58:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t data_bits=0;
    4a5a:	1b 82       	std	Y+3, r1	; 0x03

	serialEepromGetConfig(&prescaler,&parity,&stop_bits,&data_bits);
    4a5c:	ce 01       	movw	r24, r28
    4a5e:	04 96       	adiw	r24, 0x04	; 4
    4a60:	be 01       	movw	r22, r28
    4a62:	6f 5f       	subi	r22, 0xFF	; 255
    4a64:	7f 4f       	sbci	r23, 0xFF	; 255
    4a66:	ae 01       	movw	r20, r28
    4a68:	4e 5f       	subi	r20, 0xFE	; 254
    4a6a:	5f 4f       	sbci	r21, 0xFF	; 255
    4a6c:	9e 01       	movw	r18, r28
    4a6e:	2d 5f       	subi	r18, 0xFD	; 253
    4a70:	3f 4f       	sbci	r19, 0xFF	; 255
    4a72:	0e 94 06 0c 	call	0x180c	; 0x180c <serialEepromGetConfig>
	stop_bits+=1;
    4a76:	8a 81       	ldd	r24, Y+2	; 0x02
    4a78:	8f 5f       	subi	r24, 0xFF	; 255
    4a7a:	8a 83       	std	Y+2, r24	; 0x02
	data_bits+=5;
    4a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a7e:	8b 5f       	subi	r24, 0xFB	; 251
    4a80:	8b 83       	std	Y+3, r24	; 0x03

	putString("\r\nAb Adresse 0x300: ");
    4a82:	84 ec       	ldi	r24, 0xC4	; 196
    4a84:	93 e0       	ldi	r25, 0x03	; 3
    4a86:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


	putString("(Prescaler,Parity,StopBits,DataBits)  ");
    4a8a:	89 ed       	ldi	r24, 0xD9	; 217
    4a8c:	93 e0       	ldi	r25, 0x03	; 3
    4a8e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	char buffer[10];

	ultoa(prescaler,buffer,10);
    4a92:	6c 81       	ldd	r22, Y+4	; 0x04
    4a94:	7d 81       	ldd	r23, Y+5	; 0x05
    4a96:	80 e0       	ldi	r24, 0x00	; 0
    4a98:	90 e0       	ldi	r25, 0x00	; 0
    4a9a:	a7 01       	movw	r20, r14
    4a9c:	2a e0       	ldi	r18, 0x0A	; 10
    4a9e:	30 e0       	ldi	r19, 0x00	; 0
    4aa0:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(buffer);
    4aa4:	c7 01       	movw	r24, r14
    4aa6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	putString("  ");
    4aaa:	80 e0       	ldi	r24, 0x00	; 0
    4aac:	94 e0       	ldi	r25, 0x04	; 4
    4aae:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	ultoa(parity,buffer,10);
    4ab2:	69 81       	ldd	r22, Y+1	; 0x01
    4ab4:	70 e0       	ldi	r23, 0x00	; 0
    4ab6:	80 e0       	ldi	r24, 0x00	; 0
    4ab8:	90 e0       	ldi	r25, 0x00	; 0
    4aba:	a7 01       	movw	r20, r14
    4abc:	2a e0       	ldi	r18, 0x0A	; 10
    4abe:	30 e0       	ldi	r19, 0x00	; 0
    4ac0:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(buffer);
    4ac4:	c7 01       	movw	r24, r14
    4ac6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	putString("  ");
    4aca:	80 e0       	ldi	r24, 0x00	; 0
    4acc:	94 e0       	ldi	r25, 0x04	; 4
    4ace:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	ultoa(stop_bits,buffer,10);
    4ad2:	6a 81       	ldd	r22, Y+2	; 0x02
    4ad4:	70 e0       	ldi	r23, 0x00	; 0
    4ad6:	80 e0       	ldi	r24, 0x00	; 0
    4ad8:	90 e0       	ldi	r25, 0x00	; 0
    4ada:	a7 01       	movw	r20, r14
    4adc:	2a e0       	ldi	r18, 0x0A	; 10
    4ade:	30 e0       	ldi	r19, 0x00	; 0
    4ae0:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(buffer);
    4ae4:	c7 01       	movw	r24, r14
    4ae6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	putString("  ");
    4aea:	80 e0       	ldi	r24, 0x00	; 0
    4aec:	94 e0       	ldi	r25, 0x04	; 4
    4aee:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	ultoa(data_bits,buffer,10);
    4af2:	6b 81       	ldd	r22, Y+3	; 0x03
    4af4:	70 e0       	ldi	r23, 0x00	; 0
    4af6:	80 e0       	ldi	r24, 0x00	; 0
    4af8:	90 e0       	ldi	r25, 0x00	; 0
    4afa:	a7 01       	movw	r20, r14
    4afc:	2a e0       	ldi	r18, 0x0A	; 10
    4afe:	30 e0       	ldi	r19, 0x00	; 0
    4b00:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(buffer);
    4b04:	c7 01       	movw	r24, r14
    4b06:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	putString("\r\nPrescaler belongs to this baudrate: ");
    4b0a:	83 e0       	ldi	r24, 0x03	; 3
    4b0c:	94 e0       	ldi	r25, 0x04	; 4
    4b0e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>


	uint32_t baud=F_CPU  / (16 * (prescaler + 1));
	ultoa(baud, buffer, 10);
    4b12:	2c 81       	ldd	r18, Y+4	; 0x04
    4b14:	3d 81       	ldd	r19, Y+5	; 0x05
    4b16:	2f 5f       	subi	r18, 0xFF	; 255
    4b18:	3f 4f       	sbci	r19, 0xFF	; 255
    4b1a:	22 95       	swap	r18
    4b1c:	32 95       	swap	r19
    4b1e:	30 7f       	andi	r19, 0xF0	; 240
    4b20:	32 27       	eor	r19, r18
    4b22:	20 7f       	andi	r18, 0xF0	; 240
    4b24:	32 27       	eor	r19, r18
    4b26:	40 e0       	ldi	r20, 0x00	; 0
    4b28:	50 e0       	ldi	r21, 0x00	; 0
    4b2a:	60 e0       	ldi	r22, 0x00	; 0
    4b2c:	70 e0       	ldi	r23, 0x00	; 0
    4b2e:	81 ee       	ldi	r24, 0xE1	; 225
    4b30:	90 e0       	ldi	r25, 0x00	; 0
    4b32:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <__udivmodsi4>
    4b36:	ca 01       	movw	r24, r20
    4b38:	b9 01       	movw	r22, r18
    4b3a:	a7 01       	movw	r20, r14
    4b3c:	2a e0       	ldi	r18, 0x0A	; 10
    4b3e:	30 e0       	ldi	r19, 0x00	; 0
    4b40:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(buffer);
    4b44:	c7 01       	movw	r24, r14
    4b46:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	putString("\r\nParity Value means: ");
    4b4a:	8a e2       	ldi	r24, 0x2A	; 42
    4b4c:	94 e0       	ldi	r25, 0x04	; 4
    4b4e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	switch (parity)
    4b52:	89 81       	ldd	r24, Y+1	; 0x01
    4b54:	81 30       	cpi	r24, 0x01	; 1
    4b56:	09 f4       	brne	.+2      	; 0x4b5a <rcfg_getConfig+0x340>
    4b58:	e1 c0       	rjmp	.+450    	; 0x4d1c <rcfg_getConfig+0x502>
    4b5a:	81 30       	cpi	r24, 0x01	; 1
    4b5c:	08 f4       	brcc	.+2      	; 0x4b60 <rcfg_getConfig+0x346>
    4b5e:	50 c0       	rjmp	.+160    	; 0x4c00 <rcfg_getConfig+0x3e6>
    4b60:	82 30       	cpi	r24, 0x02	; 2
    4b62:	09 f4       	brne	.+2      	; 0x4b66 <rcfg_getConfig+0x34c>
    4b64:	d6 c0       	rjmp	.+428    	; 0x4d12 <rcfg_getConfig+0x4f8>
    4b66:	83 30       	cpi	r24, 0x03	; 3
    4b68:	21 f4       	brne	.+8      	; 0x4b72 <rcfg_getConfig+0x358>
		break;
		case 2:
			putString("Parity Enabled, Even Parity: ");
		break;
		case 3:
			putString("Parity Enabled, Odd Parity: ");
    4b6a:	83 e8       	ldi	r24, 0x83	; 131
    4b6c:	94 e0       	ldi	r25, 0x04	; 4
    4b6e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	portAddress_t dport_data;
	portAddress_t dport_config;
	portAddress_t  sPort;


	configEepromGetConfig(&dip_data, &dport_data, &dip_config, &dport_config, &sPort);
    4b72:	ce 01       	movw	r24, r28
    4b74:	48 96       	adiw	r24, 0x18	; 24
    4b76:	be 01       	movw	r22, r28
    4b78:	6a 5f       	subi	r22, 0xFA	; 250
    4b7a:	7f 4f       	sbci	r23, 0xFF	; 255
    4b7c:	ae 01       	movw	r20, r28
    4b7e:	44 5e       	subi	r20, 0xE4	; 228
    4b80:	5f 4f       	sbci	r21, 0xFF	; 255
    4b82:	9e 01       	movw	r18, r28
    4b84:	28 5f       	subi	r18, 0xF8	; 248
    4b86:	3f 4f       	sbci	r19, 0xFF	; 255
    4b88:	8e 01       	movw	r16, r28
    4b8a:	06 5f       	subi	r16, 0xF6	; 246
    4b8c:	1f 4f       	sbci	r17, 0xFF	; 255
    4b8e:	0e 94 bf 29 	call	0x537e	; 0x537e <configEepromGetConfig>

	



	putString("\r\nAb Adresse 0x400: ");
    4b92:	80 ea       	ldi	r24, 0xA0	; 160
    4b94:	94 e0       	ldi	r25, 0x04	; 4
    4b96:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString("(IP_d,port_d,IP_c,port_c,sPort) ");
    4b9a:	85 eb       	ldi	r24, 0xB5	; 181
    4b9c:	94 e0       	ldi	r25, 0x04	; 4
    4b9e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	putString("\r\n");
    4ba2:	81 e0       	ldi	r24, 0x01	; 1
    4ba4:	92 e0       	ldi	r25, 0x02	; 2
    4ba6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4baa:	88 8d       	ldd	r24, Y+24	; 0x18
    4bac:	99 8d       	ldd	r25, Y+25	; 0x19
    4bae:	aa 8d       	ldd	r26, Y+26	; 0x1a
    4bb0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    4bb2:	8c a7       	std	Y+44, r24	; 0x2c
    4bb4:	9d a7       	std	Y+45, r25	; 0x2d
    4bb6:	ae a7       	std	Y+46, r26	; 0x2e
    4bb8:	bf a7       	std	Y+47, r27	; 0x2f
    4bba:	6f e2       	ldi	r22, 0x2F	; 47
    4bbc:	a6 2e       	mov	r10, r22
    4bbe:	b1 2c       	mov	r11, r1
    4bc0:	ac 0e       	add	r10, r28
    4bc2:	bd 1e       	adc	r11, r29
    4bc4:	75 01       	movw	r14, r10
    4bc6:	84 01       	movw	r16, r8
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4bc8:	5e e2       	ldi	r21, 0x2E	; 46
    4bca:	d5 2e       	mov	r13, r21
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4bcc:	f7 01       	movw	r30, r14
    4bce:	80 81       	ld	r24, Z
    4bd0:	90 e0       	ldi	r25, 0x00	; 0
    4bd2:	b8 01       	movw	r22, r16
    4bd4:	4a e0       	ldi	r20, 0x0A	; 10
    4bd6:	50 e0       	ldi	r21, 0x00	; 0
    4bd8:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4bdc:	02 c0       	rjmp	.+4      	; 0x4be2 <rcfg_getConfig+0x3c8>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4bde:	0f 5f       	subi	r16, 0xFF	; 255
    4be0:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4be2:	f8 01       	movw	r30, r16
    4be4:	80 81       	ld	r24, Z
    4be6:	80 53       	subi	r24, 0x30	; 48
    4be8:	8a 30       	cpi	r24, 0x0A	; 10
    4bea:	c8 f3       	brcs	.-14     	; 0x4bde <rcfg_getConfig+0x3c4>
      buf++;
    *buf++ = '.';
    4bec:	f8 01       	movw	r30, r16
    4bee:	d1 92       	st	Z+, r13
    4bf0:	08 94       	sec
    4bf2:	e1 08       	sbc	r14, r1
    4bf4:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4bf6:	e4 14       	cp	r14, r4
    4bf8:	f5 04       	cpc	r15, r5
    4bfa:	39 f0       	breq	.+14     	; 0x4c0a <rcfg_getConfig+0x3f0>
    4bfc:	8f 01       	movw	r16, r30
    4bfe:	e6 cf       	rjmp	.-52     	; 0x4bcc <rcfg_getConfig+0x3b2>

	putString("\r\nParity Value means: ");
	switch (parity)
	{
		case 0:
			putString("Parity Disabled: ");
    4c00:	81 e4       	ldi	r24, 0x41	; 65
    4c02:	94 e0       	ldi	r25, 0x04	; 4
    4c04:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    4c08:	b4 cf       	rjmp	.-152    	; 0x4b72 <rcfg_getConfig+0x358>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    4c0a:	f8 01       	movw	r30, r16
    4c0c:	10 82       	st	Z, r1
	putString("\r\nAb Adresse 0x400: ");
	putString("(IP_d,port_d,IP_c,port_c,sPort) ");

	putString("\r\n");
	ip2str(sendbuf, dip_data);
	putString(sendbuf);
    4c0e:	c4 01       	movw	r24, r8
    4c10:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(" ");
    4c14:	86 ed       	ldi	r24, 0xD6	; 214
    4c16:	94 e0       	ldi	r25, 0x04	; 4
    4c18:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	ultoa(dport_data,sendbuf, 10);
    4c1c:	6e 81       	ldd	r22, Y+6	; 0x06
    4c1e:	7f 81       	ldd	r23, Y+7	; 0x07
    4c20:	80 e0       	ldi	r24, 0x00	; 0
    4c22:	90 e0       	ldi	r25, 0x00	; 0
    4c24:	a4 01       	movw	r20, r8
    4c26:	2a e0       	ldi	r18, 0x0A	; 10
    4c28:	30 e0       	ldi	r19, 0x00	; 0
    4c2a:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(sendbuf);
    4c2e:	c4 01       	movw	r24, r8
    4c30:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(" ");
    4c34:	86 ed       	ldi	r24, 0xD6	; 214
    4c36:	94 e0       	ldi	r25, 0x04	; 4
    4c38:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
{
  union {
    ipAddress_t ip;
    uint8_t byte[3];
  } conv;
  conv.ip = ip;
    4c3c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4c3e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4c40:	ae 8d       	ldd	r26, Y+30	; 0x1e
    4c42:	bf 8d       	ldd	r27, Y+31	; 0x1f
    4c44:	88 ab       	std	Y+48, r24	; 0x30
    4c46:	99 ab       	std	Y+49, r25	; 0x31
    4c48:	aa ab       	std	Y+50, r26	; 0x32
    4c4a:	bb ab       	std	Y+51, r27	; 0x33
    4c4c:	43 e3       	ldi	r20, 0x33	; 51
    4c4e:	e4 2e       	mov	r14, r20
    4c50:	f1 2c       	mov	r15, r1
    4c52:	ec 0e       	add	r14, r28
    4c54:	fd 1e       	adc	r15, r29
    4c56:	84 01       	movw	r16, r8
  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
    4c58:	3e e2       	ldi	r19, 0x2E	; 46
    4c5a:	d3 2e       	mov	r13, r19
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    4c5c:	f7 01       	movw	r30, r14
    4c5e:	80 81       	ld	r24, Z
    4c60:	90 e0       	ldi	r25, 0x00	; 0
    4c62:	b8 01       	movw	r22, r16
    4c64:	4a e0       	ldi	r20, 0x0A	; 10
    4c66:	50 e0       	ldi	r21, 0x00	; 0
    4c68:	0e 94 d9 2e 	call	0x5db2	; 0x5db2 <utoa>
    4c6c:	02 c0       	rjmp	.+4      	; 0x4c72 <rcfg_getConfig+0x458>
    while( *buf >= '0' && *buf <= '9')
      buf++;
    4c6e:	0f 5f       	subi	r16, 0xFF	; 255
    4c70:	1f 4f       	sbci	r17, 0xFF	; 255
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
    4c72:	f8 01       	movw	r30, r16
    4c74:	80 81       	ld	r24, Z
    4c76:	80 53       	subi	r24, 0x30	; 48
    4c78:	8a 30       	cpi	r24, 0x0A	; 10
    4c7a:	c8 f3       	brcs	.-14     	; 0x4c6e <rcfg_getConfig+0x454>
      buf++;
    *buf++ = '.';
    4c7c:	f8 01       	movw	r30, r16
    4c7e:	d1 92       	st	Z+, r13
    4c80:	08 94       	sec
    4c82:	e1 08       	sbc	r14, r1
    4c84:	f1 08       	sbc	r15, r1
    uint8_t byte[3];
  } conv;
  conv.ip = ip;

  int8_t i;
  for (i=3; i>=0; i--) {
    4c86:	ea 14       	cp	r14, r10
    4c88:	fb 04       	cpc	r15, r11
    4c8a:	11 f0       	breq	.+4      	; 0x4c90 <rcfg_getConfig+0x476>
    4c8c:	8f 01       	movw	r16, r30
    4c8e:	e6 cf       	rjmp	.-52     	; 0x4c5c <rcfg_getConfig+0x442>
    utoa(conv.byte[i], buf, 10);
    while( *buf >= '0' && *buf <= '9')
      buf++;
    *buf++ = '.';
  }
  *(--buf) = '\0';
    4c90:	f8 01       	movw	r30, r16
    4c92:	10 82       	st	Z, r1
	ultoa(dport_data,sendbuf, 10);
	putString(sendbuf);
	putString(" ");

	ip2str(sendbuf, dip_config);
	putString(sendbuf);
    4c94:	c4 01       	movw	r24, r8
    4c96:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(" ");
    4c9a:	86 ed       	ldi	r24, 0xD6	; 214
    4c9c:	94 e0       	ldi	r25, 0x04	; 4
    4c9e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	ultoa(dport_config,sendbuf,10);
    4ca2:	68 85       	ldd	r22, Y+8	; 0x08
    4ca4:	79 85       	ldd	r23, Y+9	; 0x09
    4ca6:	80 e0       	ldi	r24, 0x00	; 0
    4ca8:	90 e0       	ldi	r25, 0x00	; 0
    4caa:	a4 01       	movw	r20, r8
    4cac:	2a e0       	ldi	r18, 0x0A	; 10
    4cae:	30 e0       	ldi	r19, 0x00	; 0
    4cb0:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(sendbuf);
    4cb4:	c4 01       	movw	r24, r8
    4cb6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(" ");
    4cba:	86 ed       	ldi	r24, 0xD6	; 214
    4cbc:	94 e0       	ldi	r25, 0x04	; 4
    4cbe:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>

	ultoa(sPort,sendbuf, 10);
    4cc2:	6a 85       	ldd	r22, Y+10	; 0x0a
    4cc4:	7b 85       	ldd	r23, Y+11	; 0x0b
    4cc6:	80 e0       	ldi	r24, 0x00	; 0
    4cc8:	90 e0       	ldi	r25, 0x00	; 0
    4cca:	a4 01       	movw	r20, r8
    4ccc:	2a e0       	ldi	r18, 0x0A	; 10
    4cce:	30 e0       	ldi	r19, 0x00	; 0
    4cd0:	0e 94 b4 2e 	call	0x5d68	; 0x5d68 <ultoa>
	putString(sendbuf);
    4cd4:	c4 01       	movw	r24, r8
    4cd6:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString("\r\n");
    4cda:	81 e0       	ldi	r24, 0x01	; 1
    4cdc:	92 e0       	ldi	r25, 0x02	; 2
    4cde:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>




	return RCFG_SUCCESS;
}
    4ce2:	80 e0       	ldi	r24, 0x00	; 0
    4ce4:	cb 58       	subi	r28, 0x8B	; 139
    4ce6:	df 4f       	sbci	r29, 0xFF	; 255
    4ce8:	0f b6       	in	r0, 0x3f	; 63
    4cea:	f8 94       	cli
    4cec:	de bf       	out	0x3e, r29	; 62
    4cee:	0f be       	out	0x3f, r0	; 63
    4cf0:	cd bf       	out	0x3d, r28	; 61
    4cf2:	cf 91       	pop	r28
    4cf4:	df 91       	pop	r29
    4cf6:	1f 91       	pop	r17
    4cf8:	0f 91       	pop	r16
    4cfa:	ff 90       	pop	r15
    4cfc:	ef 90       	pop	r14
    4cfe:	df 90       	pop	r13
    4d00:	cf 90       	pop	r12
    4d02:	bf 90       	pop	r11
    4d04:	af 90       	pop	r10
    4d06:	9f 90       	pop	r9
    4d08:	8f 90       	pop	r8
    4d0a:	7f 90       	pop	r7
    4d0c:	5f 90       	pop	r5
    4d0e:	4f 90       	pop	r4
    4d10:	08 95       	ret
		break;
		case 1:
			putString("Parity Reserved: ");
		break;
		case 2:
			putString("Parity Enabled, Even Parity: ");
    4d12:	85 e6       	ldi	r24, 0x65	; 101
    4d14:	94 e0       	ldi	r25, 0x04	; 4
    4d16:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    4d1a:	2b cf       	rjmp	.-426    	; 0x4b72 <rcfg_getConfig+0x358>
	{
		case 0:
			putString("Parity Disabled: ");
		break;
		case 1:
			putString("Parity Reserved: ");
    4d1c:	83 e5       	ldi	r24, 0x53	; 83
    4d1e:	94 e0       	ldi	r25, 0x04	; 4
    4d20:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    4d24:	26 cf       	rjmp	.-436    	; 0x4b72 <rcfg_getConfig+0x358>
static uint8_t isDisabled = 0;

uint8_t stringLength(char * buf)
{
  uint8_t len = 0;
  while (*buf++)
    4d26:	60 e0       	ldi	r22, 0x00	; 0
    4d28:	70 e0       	ldi	r23, 0x00	; 0
    4d2a:	3f ce       	rjmp	.-898    	; 0x49aa <rcfg_getConfig+0x190>

00004d2c <rcfg_parseUInt>:
  return value;
}
*/

uint32_t rcfg_parseUInt(char ** pbuf)
{
    4d2c:	af 92       	push	r10
    4d2e:	bf 92       	push	r11
    4d30:	df 92       	push	r13
    4d32:	ef 92       	push	r14
    4d34:	ff 92       	push	r15
    4d36:	0f 93       	push	r16
    4d38:	1f 93       	push	r17
    4d3a:	cf 93       	push	r28
    4d3c:	df 93       	push	r29
    4d3e:	5c 01       	movw	r10, r24
  char * buf = *pbuf;
    4d40:	fc 01       	movw	r30, r24
    4d42:	c0 81       	ld	r28, Z
    4d44:	d1 81       	ldd	r29, Z+1	; 0x01

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4d46:	d8 80       	ld	r13, Y
    4d48:	8d 2d       	mov	r24, r13
    4d4a:	80 53       	subi	r24, 0x30	; 48
    4d4c:	8a 30       	cpi	r24, 0x0A	; 10
    4d4e:	78 f5       	brcc	.+94     	; 0x4dae <rcfg_parseUInt+0x82>
    4d50:	ee 24       	eor	r14, r14
    4d52:	ff 24       	eor	r15, r15
    4d54:	87 01       	movw	r16, r14
  {
    value *= 10;
    4d56:	c8 01       	movw	r24, r16
    4d58:	b7 01       	movw	r22, r14
    4d5a:	2a e0       	ldi	r18, 0x0A	; 10
    4d5c:	30 e0       	ldi	r19, 0x00	; 0
    4d5e:	40 e0       	ldi	r20, 0x00	; 0
    4d60:	50 e0       	ldi	r21, 0x00	; 0
    4d62:	0e 94 ff 2e 	call	0x5dfe	; 0x5dfe <__mulsi3>
    value += (*buf) - '0';
    4d66:	2d 2d       	mov	r18, r13
    4d68:	33 27       	eor	r19, r19
    4d6a:	27 fd       	sbrc	r18, 7
    4d6c:	30 95       	com	r19
    4d6e:	20 53       	subi	r18, 0x30	; 48
    4d70:	30 40       	sbci	r19, 0x00	; 0
    4d72:	79 01       	movw	r14, r18
    4d74:	00 27       	eor	r16, r16
    4d76:	f7 fc       	sbrc	r15, 7
    4d78:	00 95       	com	r16
    4d7a:	10 2f       	mov	r17, r16
    4d7c:	e6 0e       	add	r14, r22
    4d7e:	f7 1e       	adc	r15, r23
    4d80:	08 1f       	adc	r16, r24
    4d82:	19 1f       	adc	r17, r25
    buf++;
    4d84:	21 96       	adiw	r28, 0x01	; 1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4d86:	d8 80       	ld	r13, Y
    4d88:	8d 2d       	mov	r24, r13
    4d8a:	80 53       	subi	r24, 0x30	; 48
    4d8c:	8a 30       	cpi	r24, 0x0A	; 10
    4d8e:	18 f3       	brcs	.-58     	; 0x4d56 <rcfg_parseUInt+0x2a>
    value *= 10;
    value += (*buf) - '0';
    buf++;
  }

  *pbuf = buf;
    4d90:	f5 01       	movw	r30, r10
    4d92:	d1 83       	std	Z+1, r29	; 0x01
    4d94:	c0 83       	st	Z, r28
  return value;
}
    4d96:	b7 01       	movw	r22, r14
    4d98:	c8 01       	movw	r24, r16
    4d9a:	df 91       	pop	r29
    4d9c:	cf 91       	pop	r28
    4d9e:	1f 91       	pop	r17
    4da0:	0f 91       	pop	r16
    4da2:	ff 90       	pop	r15
    4da4:	ef 90       	pop	r14
    4da6:	df 90       	pop	r13
    4da8:	bf 90       	pop	r11
    4daa:	af 90       	pop	r10
    4dac:	08 95       	ret
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4dae:	ee 24       	eor	r14, r14
    4db0:	ff 24       	eor	r15, r15
    4db2:	87 01       	movw	r16, r14
    4db4:	ed cf       	rjmp	.-38     	; 0x4d90 <rcfg_parseUInt+0x64>

00004db6 <rcfg_parseUHex>:
}
*/

uint32_t rcfg_parseUHex(char ** pbuf)
// expects exactly 2 chars!
{
    4db6:	dc 01       	movw	r26, r24
  char * buf = *pbuf;
    4db8:	ed 91       	ld	r30, X+
    4dba:	fc 91       	ld	r31, X
    4dbc:	11 97       	sbiw	r26, 0x01	; 1
    4dbe:	80 e0       	ldi	r24, 0x00	; 0
    4dc0:	20 e0       	ldi	r18, 0x00	; 0
    4dc2:	30 e0       	ldi	r19, 0x00	; 0
    4dc4:	40 e0       	ldi	r20, 0x00	; 0
    4dc6:	50 e0       	ldi	r21, 0x00	; 0

  uint8_t nibble = 0;
  uint32_t value = 0;

  while (1/*nibble <= 0x0f*/) {
    value <<= 4;
    4dc8:	22 0f       	add	r18, r18
    4dca:	33 1f       	adc	r19, r19
    4dcc:	44 1f       	adc	r20, r20
    4dce:	55 1f       	adc	r21, r21
    4dd0:	22 0f       	add	r18, r18
    4dd2:	33 1f       	adc	r19, r19
    4dd4:	44 1f       	adc	r20, r20
    4dd6:	55 1f       	adc	r21, r21
    4dd8:	22 0f       	add	r18, r18
    4dda:	33 1f       	adc	r19, r19
    4ddc:	44 1f       	adc	r20, r20
    4dde:	55 1f       	adc	r21, r21
    4de0:	22 0f       	add	r18, r18
    4de2:	33 1f       	adc	r19, r19
    4de4:	44 1f       	adc	r20, r20
    4de6:	55 1f       	adc	r21, r21
	value += nibble;
    4de8:	28 0f       	add	r18, r24
    4dea:	31 1d       	adc	r19, r1
    4dec:	41 1d       	adc	r20, r1
    4dee:	51 1d       	adc	r21, r1
  
    if ( (*buf) >= '0' && (*buf) <= '9' )
    4df0:	90 81       	ld	r25, Z
    4df2:	89 2f       	mov	r24, r25
    4df4:	80 53       	subi	r24, 0x30	; 48
    4df6:	8a 30       	cpi	r24, 0x0A	; 10
    4df8:	40 f0       	brcs	.+16     	; 0x4e0a <rcfg_parseUHex+0x54>
      nibble = (*buf) - '0';
    else if ( (*buf) >= 'a' && (*buf) <= 'f' )
    4dfa:	81 53       	subi	r24, 0x31	; 49
    4dfc:	86 30       	cpi	r24, 0x06	; 6
    4dfe:	20 f0       	brcs	.+8      	; 0x4e08 <rcfg_parseUHex+0x52>
      nibble = (*buf) - 'a' + 10;
    else if ( (*buf) >= 'A' && (*buf) <= 'F' )
    4e00:	89 2f       	mov	r24, r25
    4e02:	81 54       	subi	r24, 0x41	; 65
    4e04:	86 30       	cpi	r24, 0x06	; 6
    4e06:	18 f4       	brcc	.+6      	; 0x4e0e <rcfg_parseUHex+0x58>
      nibble = (*buf) - 'A' + 10;
    4e08:	86 5f       	subi	r24, 0xF6	; 246
      nibble = 0xff;
	  buf--;
	  */
    }

    buf++;
    4e0a:	31 96       	adiw	r30, 0x01	; 1
    4e0c:	dd cf       	rjmp	.-70     	; 0x4dc8 <rcfg_parseUHex+0x12>
  }

  *pbuf = buf;
    4e0e:	ed 93       	st	X+, r30
    4e10:	fc 93       	st	X, r31
  return value;
}
    4e12:	b9 01       	movw	r22, r18
    4e14:	ca 01       	movw	r24, r20
    4e16:	08 95       	ret

00004e18 <rcfg_parseIP>:

ipAddress_t rcfg_parseIP(char ** pbuf)
{
    4e18:	4f 92       	push	r4
    4e1a:	5f 92       	push	r5
    4e1c:	6f 92       	push	r6
    4e1e:	7f 92       	push	r7
    4e20:	8f 92       	push	r8
    4e22:	9f 92       	push	r9
    4e24:	af 92       	push	r10
    4e26:	bf 92       	push	r11
    4e28:	cf 92       	push	r12
    4e2a:	df 92       	push	r13
    4e2c:	ef 92       	push	r14
    4e2e:	ff 92       	push	r15
    4e30:	0f 93       	push	r16
    4e32:	1f 93       	push	r17
    4e34:	df 93       	push	r29
    4e36:	cf 93       	push	r28
    4e38:	cd b7       	in	r28, 0x3d	; 61
    4e3a:	de b7       	in	r29, 0x3e	; 62
    4e3c:	28 97       	sbiw	r28, 0x08	; 8
    4e3e:	0f b6       	in	r0, 0x3f	; 63
    4e40:	f8 94       	cli
    4e42:	de bf       	out	0x3e, r29	; 62
    4e44:	0f be       	out	0x3f, r0	; 63
    4e46:	cd bf       	out	0x3d, r28	; 61
    4e48:	2c 01       	movw	r4, r24
  char * buf = *pbuf;
    4e4a:	dc 01       	movw	r26, r24
    4e4c:	ad 90       	ld	r10, X+
    4e4e:	bc 90       	ld	r11, X
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4e50:	f5 01       	movw	r30, r10
    4e52:	d0 80       	ld	r13, Z
    4e54:	8d 2d       	mov	r24, r13
    4e56:	80 53       	subi	r24, 0x30	; 48
    4e58:	8a 30       	cpi	r24, 0x0A	; 10
    4e5a:	08 f0       	brcs	.+2      	; 0x4e5e <rcfg_parseIP+0x46>
    4e5c:	02 c1       	rjmp	.+516    	; 0x5062 <rcfg_parseIP+0x24a>
    4e5e:	ee 24       	eor	r14, r14
    4e60:	ff 24       	eor	r15, r15
    4e62:	87 01       	movw	r16, r14
  {
    value *= 10;
    4e64:	c8 01       	movw	r24, r16
    4e66:	b7 01       	movw	r22, r14
    4e68:	2a e0       	ldi	r18, 0x0A	; 10
    4e6a:	30 e0       	ldi	r19, 0x00	; 0
    4e6c:	40 e0       	ldi	r20, 0x00	; 0
    4e6e:	50 e0       	ldi	r21, 0x00	; 0
    4e70:	0e 94 ff 2e 	call	0x5dfe	; 0x5dfe <__mulsi3>
    value += (*buf) - '0';
    4e74:	2d 2d       	mov	r18, r13
    4e76:	33 27       	eor	r19, r19
    4e78:	27 fd       	sbrc	r18, 7
    4e7a:	30 95       	com	r19
    4e7c:	20 53       	subi	r18, 0x30	; 48
    4e7e:	30 40       	sbci	r19, 0x00	; 0
    4e80:	79 01       	movw	r14, r18
    4e82:	00 27       	eor	r16, r16
    4e84:	f7 fc       	sbrc	r15, 7
    4e86:	00 95       	com	r16
    4e88:	10 2f       	mov	r17, r16
    4e8a:	e6 0e       	add	r14, r22
    4e8c:	f7 1e       	adc	r15, r23
    4e8e:	08 1f       	adc	r16, r24
    4e90:	19 1f       	adc	r17, r25
    buf++;
    4e92:	08 94       	sec
    4e94:	a1 1c       	adc	r10, r1
    4e96:	b1 1c       	adc	r11, r1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4e98:	d5 01       	movw	r26, r10
    4e9a:	dc 90       	ld	r13, X
    4e9c:	8d 2d       	mov	r24, r13
    4e9e:	80 53       	subi	r24, 0x30	; 48
    4ea0:	8a 30       	cpi	r24, 0x0A	; 10
    4ea2:	00 f3       	brcs	.-64     	; 0x4e64 <rcfg_parseIP+0x4c>
    4ea4:	9e 2c       	mov	r9, r14
    4ea6:	88 24       	eor	r8, r8
    4ea8:	77 24       	eor	r7, r7
    4eaa:	66 24       	eor	r6, r6
{
  char * buf = *pbuf;

  ipAddress_t ip = 0;
  ip = (ipAddress_t)rcfg_parseUInt(&buf) << 24;
  if (*buf != '.')
    4eac:	be e2       	ldi	r27, 0x2E	; 46
    4eae:	db 16       	cp	r13, r27
    4eb0:	e9 f0       	breq	.+58     	; 0x4eec <rcfg_parseIP+0xd4>
    return 0;
  buf++;
  ip |= (ipAddress_t)rcfg_parseUInt(&buf); 

  *pbuf = buf;
  return ip;
    4eb2:	20 e0       	ldi	r18, 0x00	; 0
    4eb4:	30 e0       	ldi	r19, 0x00	; 0
    4eb6:	40 e0       	ldi	r20, 0x00	; 0
    4eb8:	50 e0       	ldi	r21, 0x00	; 0
}
    4eba:	b9 01       	movw	r22, r18
    4ebc:	ca 01       	movw	r24, r20
    4ebe:	28 96       	adiw	r28, 0x08	; 8
    4ec0:	0f b6       	in	r0, 0x3f	; 63
    4ec2:	f8 94       	cli
    4ec4:	de bf       	out	0x3e, r29	; 62
    4ec6:	0f be       	out	0x3f, r0	; 63
    4ec8:	cd bf       	out	0x3d, r28	; 61
    4eca:	cf 91       	pop	r28
    4ecc:	df 91       	pop	r29
    4ece:	1f 91       	pop	r17
    4ed0:	0f 91       	pop	r16
    4ed2:	ff 90       	pop	r15
    4ed4:	ef 90       	pop	r14
    4ed6:	df 90       	pop	r13
    4ed8:	cf 90       	pop	r12
    4eda:	bf 90       	pop	r11
    4edc:	af 90       	pop	r10
    4ede:	9f 90       	pop	r9
    4ee0:	8f 90       	pop	r8
    4ee2:	7f 90       	pop	r7
    4ee4:	6f 90       	pop	r6
    4ee6:	5f 90       	pop	r5
    4ee8:	4f 90       	pop	r4
    4eea:	08 95       	ret

  ipAddress_t ip = 0;
  ip = (ipAddress_t)rcfg_parseUInt(&buf) << 24;
  if (*buf != '.')
    return 0;
  buf++;
    4eec:	65 01       	movw	r12, r10
    4eee:	08 94       	sec
    4ef0:	c1 1c       	adc	r12, r1
    4ef2:	d1 1c       	adc	r13, r1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4ef4:	f5 01       	movw	r30, r10
    4ef6:	b1 80       	ldd	r11, Z+1	; 0x01
    4ef8:	8b 2d       	mov	r24, r11
    4efa:	80 53       	subi	r24, 0x30	; 48
    4efc:	8a 30       	cpi	r24, 0x0A	; 10
    4efe:	08 f0       	brcs	.+2      	; 0x4f02 <rcfg_parseIP+0xea>
    4f00:	b4 c0       	rjmp	.+360    	; 0x506a <rcfg_parseIP+0x252>
    4f02:	ee 24       	eor	r14, r14
    4f04:	ff 24       	eor	r15, r15
    4f06:	87 01       	movw	r16, r14
  {
    value *= 10;
    4f08:	c8 01       	movw	r24, r16
    4f0a:	b7 01       	movw	r22, r14
    4f0c:	2a e0       	ldi	r18, 0x0A	; 10
    4f0e:	30 e0       	ldi	r19, 0x00	; 0
    4f10:	40 e0       	ldi	r20, 0x00	; 0
    4f12:	50 e0       	ldi	r21, 0x00	; 0
    4f14:	0e 94 ff 2e 	call	0x5dfe	; 0x5dfe <__mulsi3>
    value += (*buf) - '0';
    4f18:	2b 2d       	mov	r18, r11
    4f1a:	33 27       	eor	r19, r19
    4f1c:	27 fd       	sbrc	r18, 7
    4f1e:	30 95       	com	r19
    4f20:	20 53       	subi	r18, 0x30	; 48
    4f22:	30 40       	sbci	r19, 0x00	; 0
    4f24:	79 01       	movw	r14, r18
    4f26:	00 27       	eor	r16, r16
    4f28:	f7 fc       	sbrc	r15, 7
    4f2a:	00 95       	com	r16
    4f2c:	10 2f       	mov	r17, r16
    4f2e:	e6 0e       	add	r14, r22
    4f30:	f7 1e       	adc	r15, r23
    4f32:	08 1f       	adc	r16, r24
    4f34:	19 1f       	adc	r17, r25
    buf++;
    4f36:	08 94       	sec
    4f38:	c1 1c       	adc	r12, r1
    4f3a:	d1 1c       	adc	r13, r1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4f3c:	d6 01       	movw	r26, r12
    4f3e:	bc 90       	ld	r11, X
    4f40:	8b 2d       	mov	r24, r11
    4f42:	80 53       	subi	r24, 0x30	; 48
    4f44:	8a 30       	cpi	r24, 0x0A	; 10
    4f46:	00 f3       	brcs	.-64     	; 0x4f08 <rcfg_parseIP+0xf0>
    4f48:	d7 01       	movw	r26, r14
    4f4a:	99 27       	eor	r25, r25
    4f4c:	88 27       	eor	r24, r24
    4f4e:	89 83       	std	Y+1, r24	; 0x01
    4f50:	9a 83       	std	Y+2, r25	; 0x02
    4f52:	ab 83       	std	Y+3, r26	; 0x03
    4f54:	bc 83       	std	Y+4, r27	; 0x04
  ip = (ipAddress_t)rcfg_parseUInt(&buf) << 24;
  if (*buf != '.')
    return 0;
  buf++;
  ip |= (ipAddress_t)rcfg_parseUInt(&buf) << 16;
  if (*buf != '.')
    4f56:	9e e2       	ldi	r25, 0x2E	; 46
    4f58:	b9 16       	cp	r11, r25
    4f5a:	09 f0       	breq	.+2      	; 0x4f5e <rcfg_parseIP+0x146>
    4f5c:	aa cf       	rjmp	.-172    	; 0x4eb2 <rcfg_parseIP+0x9a>
    return 0;
  buf++;
    4f5e:	56 01       	movw	r10, r12
    4f60:	08 94       	sec
    4f62:	a1 1c       	adc	r10, r1
    4f64:	b1 1c       	adc	r11, r1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4f66:	d6 01       	movw	r26, r12
    4f68:	11 96       	adiw	r26, 0x01	; 1
    4f6a:	dc 90       	ld	r13, X
    4f6c:	8d 2d       	mov	r24, r13
    4f6e:	80 53       	subi	r24, 0x30	; 48
    4f70:	8a 30       	cpi	r24, 0x0A	; 10
    4f72:	08 f0       	brcs	.+2      	; 0x4f76 <rcfg_parseIP+0x15e>
    4f74:	7f c0       	rjmp	.+254    	; 0x5074 <rcfg_parseIP+0x25c>
    4f76:	ee 24       	eor	r14, r14
    4f78:	ff 24       	eor	r15, r15
    4f7a:	87 01       	movw	r16, r14
  {
    value *= 10;
    4f7c:	c8 01       	movw	r24, r16
    4f7e:	b7 01       	movw	r22, r14
    4f80:	2a e0       	ldi	r18, 0x0A	; 10
    4f82:	30 e0       	ldi	r19, 0x00	; 0
    4f84:	40 e0       	ldi	r20, 0x00	; 0
    4f86:	50 e0       	ldi	r21, 0x00	; 0
    4f88:	0e 94 ff 2e 	call	0x5dfe	; 0x5dfe <__mulsi3>
    value += (*buf) - '0';
    4f8c:	2d 2d       	mov	r18, r13
    4f8e:	33 27       	eor	r19, r19
    4f90:	27 fd       	sbrc	r18, 7
    4f92:	30 95       	com	r19
    4f94:	20 53       	subi	r18, 0x30	; 48
    4f96:	30 40       	sbci	r19, 0x00	; 0
    4f98:	79 01       	movw	r14, r18
    4f9a:	00 27       	eor	r16, r16
    4f9c:	f7 fc       	sbrc	r15, 7
    4f9e:	00 95       	com	r16
    4fa0:	10 2f       	mov	r17, r16
    4fa2:	e6 0e       	add	r14, r22
    4fa4:	f7 1e       	adc	r15, r23
    4fa6:	08 1f       	adc	r16, r24
    4fa8:	19 1f       	adc	r17, r25
    buf++;
    4faa:	08 94       	sec
    4fac:	a1 1c       	adc	r10, r1
    4fae:	b1 1c       	adc	r11, r1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4fb0:	f5 01       	movw	r30, r10
    4fb2:	d0 80       	ld	r13, Z
    4fb4:	8d 2d       	mov	r24, r13
    4fb6:	80 53       	subi	r24, 0x30	; 48
    4fb8:	8a 30       	cpi	r24, 0x0A	; 10
    4fba:	00 f3       	brcs	.-64     	; 0x4f7c <rcfg_parseIP+0x164>
    4fbc:	b0 2f       	mov	r27, r16
    4fbe:	af 2d       	mov	r26, r15
    4fc0:	9e 2d       	mov	r25, r14
    4fc2:	88 27       	eor	r24, r24
    4fc4:	8d 83       	std	Y+5, r24	; 0x05
    4fc6:	9e 83       	std	Y+6, r25	; 0x06
    4fc8:	af 83       	std	Y+7, r26	; 0x07
    4fca:	b8 87       	std	Y+8, r27	; 0x08
  ip |= (ipAddress_t)rcfg_parseUInt(&buf) << 16;
  if (*buf != '.')
    return 0;
  buf++;
  ip |= (ipAddress_t)rcfg_parseUInt(&buf) << 8;
  if (*buf != '.')
    4fcc:	9e e2       	ldi	r25, 0x2E	; 46
    4fce:	d9 16       	cp	r13, r25
    4fd0:	09 f0       	breq	.+2      	; 0x4fd4 <rcfg_parseIP+0x1bc>
    4fd2:	6f cf       	rjmp	.-290    	; 0x4eb2 <rcfg_parseIP+0x9a>
    return 0;
  buf++;
    4fd4:	65 01       	movw	r12, r10
    4fd6:	08 94       	sec
    4fd8:	c1 1c       	adc	r12, r1
    4fda:	d1 1c       	adc	r13, r1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    4fdc:	d5 01       	movw	r26, r10
    4fde:	11 96       	adiw	r26, 0x01	; 1
    4fe0:	bc 90       	ld	r11, X
    4fe2:	8b 2d       	mov	r24, r11
    4fe4:	80 53       	subi	r24, 0x30	; 48
    4fe6:	8a 30       	cpi	r24, 0x0A	; 10
    4fe8:	08 f0       	brcs	.+2      	; 0x4fec <rcfg_parseIP+0x1d4>
    4fea:	49 c0       	rjmp	.+146    	; 0x507e <rcfg_parseIP+0x266>
    4fec:	ee 24       	eor	r14, r14
    4fee:	ff 24       	eor	r15, r15
    4ff0:	87 01       	movw	r16, r14
  {
    value *= 10;
    4ff2:	c8 01       	movw	r24, r16
    4ff4:	b7 01       	movw	r22, r14
    4ff6:	2a e0       	ldi	r18, 0x0A	; 10
    4ff8:	30 e0       	ldi	r19, 0x00	; 0
    4ffa:	40 e0       	ldi	r20, 0x00	; 0
    4ffc:	50 e0       	ldi	r21, 0x00	; 0
    4ffe:	0e 94 ff 2e 	call	0x5dfe	; 0x5dfe <__mulsi3>
    value += (*buf) - '0';
    5002:	2b 2d       	mov	r18, r11
    5004:	33 27       	eor	r19, r19
    5006:	27 fd       	sbrc	r18, 7
    5008:	30 95       	com	r19
    500a:	20 53       	subi	r18, 0x30	; 48
    500c:	30 40       	sbci	r19, 0x00	; 0
    500e:	79 01       	movw	r14, r18
    5010:	00 27       	eor	r16, r16
    5012:	f7 fc       	sbrc	r15, 7
    5014:	00 95       	com	r16
    5016:	10 2f       	mov	r17, r16
    5018:	e6 0e       	add	r14, r22
    501a:	f7 1e       	adc	r15, r23
    501c:	08 1f       	adc	r16, r24
    501e:	19 1f       	adc	r17, r25
    buf++;
    5020:	08 94       	sec
    5022:	c1 1c       	adc	r12, r1
    5024:	d1 1c       	adc	r13, r1
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    5026:	f6 01       	movw	r30, r12
    5028:	b0 80       	ld	r11, Z
    502a:	8b 2d       	mov	r24, r11
    502c:	80 53       	subi	r24, 0x30	; 48
    502e:	8a 30       	cpi	r24, 0x0A	; 10
    5030:	00 f3       	brcs	.-64     	; 0x4ff2 <rcfg_parseIP+0x1da>
  ipAddress_t ip = 0;
  ip = (ipAddress_t)rcfg_parseUInt(&buf) << 24;
  if (*buf != '.')
    return 0;
  buf++;
  ip |= (ipAddress_t)rcfg_parseUInt(&buf) << 16;
    5032:	29 81       	ldd	r18, Y+1	; 0x01
    5034:	3a 81       	ldd	r19, Y+2	; 0x02
    5036:	4b 81       	ldd	r20, Y+3	; 0x03
    5038:	5c 81       	ldd	r21, Y+4	; 0x04
    503a:	26 29       	or	r18, r6
    503c:	37 29       	or	r19, r7
    503e:	48 29       	or	r20, r8
    5040:	59 29       	or	r21, r9
  if (*buf != '.')
    return 0;
  buf++;
  ip |= (ipAddress_t)rcfg_parseUInt(&buf) << 8;
    5042:	8d 81       	ldd	r24, Y+5	; 0x05
    5044:	9e 81       	ldd	r25, Y+6	; 0x06
    5046:	af 81       	ldd	r26, Y+7	; 0x07
    5048:	b8 85       	ldd	r27, Y+8	; 0x08
    504a:	28 2b       	or	r18, r24
    504c:	39 2b       	or	r19, r25
    504e:	4a 2b       	or	r20, r26
    5050:	5b 2b       	or	r21, r27
  if (*buf != '.')
    return 0;
  buf++;
  ip |= (ipAddress_t)rcfg_parseUInt(&buf); 
    5052:	2e 29       	or	r18, r14
    5054:	3f 29       	or	r19, r15
    5056:	40 2b       	or	r20, r16
    5058:	51 2b       	or	r21, r17

  *pbuf = buf;
    505a:	d2 01       	movw	r26, r4
    505c:	cd 92       	st	X+, r12
    505e:	dc 92       	st	X, r13
    5060:	2c cf       	rjmp	.-424    	; 0x4eba <rcfg_parseIP+0xa2>
uint32_t rcfg_parseUInt(char ** pbuf)
{
  char * buf = *pbuf;

  uint32_t value = 0;
  while ( (*buf) >= '0' && (*buf) <= '9' )
    5062:	66 24       	eor	r6, r6
    5064:	77 24       	eor	r7, r7
    5066:	43 01       	movw	r8, r6
    5068:	21 cf       	rjmp	.-446    	; 0x4eac <rcfg_parseIP+0x94>
    506a:	19 82       	std	Y+1, r1	; 0x01
    506c:	1a 82       	std	Y+2, r1	; 0x02
    506e:	1b 82       	std	Y+3, r1	; 0x03
    5070:	1c 82       	std	Y+4, r1	; 0x04
    5072:	71 cf       	rjmp	.-286    	; 0x4f56 <rcfg_parseIP+0x13e>
    5074:	1d 82       	std	Y+5, r1	; 0x05
    5076:	1e 82       	std	Y+6, r1	; 0x06
    5078:	1f 82       	std	Y+7, r1	; 0x07
    507a:	18 86       	std	Y+8, r1	; 0x08
    507c:	a7 cf       	rjmp	.-178    	; 0x4fcc <rcfg_parseIP+0x1b4>
    507e:	ee 24       	eor	r14, r14
    5080:	ff 24       	eor	r15, r15
    5082:	87 01       	movw	r16, r14
    5084:	d6 cf       	rjmp	.-84     	; 0x5032 <rcfg_parseIP+0x21a>

00005086 <onRtpControl>:
  {":DISABLE", rcfg_Disable},
  {"", NULL} // end-of-table -- do not delete this line!
};

void onRtpControl(char* buf, uint8_t len)
{
    5086:	1f 93       	push	r17
    5088:	cf 93       	push	r28
    508a:	df 93       	push	r29
    508c:	ec 01       	movw	r28, r24
    508e:	16 2f       	mov	r17, r22



  // check if rcfg has been disabled using ":DISABLE?"
  if (Config_is_Disabled()) {
    5090:	0e 94 f3 1a 	call	0x35e6	; 0x35e6 <Config_is_Disabled>
    5094:	88 23       	and	r24, r24
    5096:	09 f0       	breq	.+2      	; 0x509a <onRtpControl+0x14>
    5098:	84 c0       	rjmp	.+264    	; 0x51a2 <onRtpControl+0x11c>
  }


  // some syntax checks
  uint8_t pos = 1;
  while (pos < len)
    509a:	12 30       	cpi	r17, 0x02	; 2
    509c:	08 f4       	brcc	.+2      	; 0x50a0 <onRtpControl+0x1a>
    509e:	d2 c0       	rjmp	.+420    	; 0x5244 <onRtpControl+0x1be>
  {
    if (buf[pos] == '?')
    50a0:	89 81       	ldd	r24, Y+1	; 0x01
    50a2:	8f 33       	cpi	r24, 0x3F	; 63
    50a4:	61 f0       	breq	.+24     	; 0x50be <onRtpControl+0x38>
    50a6:	fe 01       	movw	r30, r28
    50a8:	91 e0       	ldi	r25, 0x01	; 1
    50aa:	04 c0       	rjmp	.+8      	; 0x50b4 <onRtpControl+0x2e>
    50ac:	82 81       	ldd	r24, Z+2	; 0x02
    50ae:	31 96       	adiw	r30, 0x01	; 1
    50b0:	8f 33       	cpi	r24, 0x3F	; 63
    50b2:	19 f0       	breq	.+6      	; 0x50ba <onRtpControl+0x34>
    {
      break;
    }
    pos++;
    50b4:	9f 5f       	subi	r25, 0xFF	; 255
  }


  // some syntax checks
  uint8_t pos = 1;
  while (pos < len)
    50b6:	91 17       	cp	r25, r17
    50b8:	c8 f3       	brcs	.-14     	; 0x50ac <onRtpControl+0x26>
  }
  
 


  if (pos == len || buf[0] != ':')
    50ba:	91 17       	cp	r25, r17
    50bc:	19 f0       	breq	.+6      	; 0x50c4 <onRtpControl+0x3e>
    50be:	88 81       	ld	r24, Y
    50c0:	8a 33       	cpi	r24, 0x3A	; 58
    50c2:	a9 f0       	breq	.+42     	; 0x50ee <onRtpControl+0x68>
  {
    putString("\r\nonRtpControl() Syntax Error,sent:");
    50c4:	8d e1       	ldi	r24, 0x1D	; 29
    50c6:	95 e0       	ldi	r25, 0x05	; 5
    50c8:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
	putString(buf);
    50cc:	ce 01       	movw	r24, r28
    50ce:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    // '?' not found or ':' missing
    rtpSendCommand("Syntax Error\n", 13, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    50d2:	81 e4       	ldi	r24, 0x41	; 65
    50d4:	95 e0       	ldi	r25, 0x05	; 5
    50d6:	6d e0       	ldi	r22, 0x0D	; 13
    50d8:	70 e0       	ldi	r23, 0x00	; 0
    50da:	40 e3       	ldi	r20, 0x30	; 48
    50dc:	59 e0       	ldi	r21, 0x09	; 9
    50de:	26 e3       	ldi	r18, 0x36	; 54
    50e0:	39 e0       	ldi	r19, 0x09	; 9
    50e2:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
  // command not found
  rtpSendCommand("Error located between ears of user.\n", 36, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);    
  return;

  
}
    50e6:	df 91       	pop	r29
    50e8:	cf 91       	pop	r28
    50ea:	1f 91       	pop	r17
    50ec:	08 95       	ret
    return;
  }
  
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    50ee:	60 91 17 07 	lds	r22, 0x0717
    50f2:	70 91 18 07 	lds	r23, 0x0718
    50f6:	61 15       	cp	r22, r1
    50f8:	71 05       	cpc	r23, r1
    50fa:	09 f4       	brne	.+2      	; 0x50fe <onRtpControl+0x78>
    50fc:	3d c0       	rjmp	.+122    	; 0x5178 <onRtpControl+0xf2>
    50fe:	50 e0       	ldi	r21, 0x00	; 0
    5100:	a0 e0       	ldi	r26, 0x00	; 0
    5102:	b0 e0       	ldi	r27, 0x00	; 0
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    5104:	1a e3       	ldi	r17, 0x3A	; 58
    5106:	aa 0f       	add	r26, r26
    5108:	bb 1f       	adc	r27, r27
    510a:	aa 0f       	add	r26, r26
    510c:	bb 1f       	adc	r27, r27
    510e:	ab 5e       	subi	r26, 0xEB	; 235
    5110:	b8 4f       	sbci	r27, 0xF8	; 248
    5112:	0d 90       	ld	r0, X+
    5114:	bc 91       	ld	r27, X
    5116:	a0 2d       	mov	r26, r0
    5118:	4c 91       	ld	r20, X
    511a:	84 2f       	mov	r24, r20
    511c:	81 27       	eor	r24, r17
    511e:	8f 75       	andi	r24, 0x5F	; 95
    5120:	09 f0       	breq	.+2      	; 0x5124 <onRtpControl+0x9e>
    5122:	5b c0       	rjmp	.+182    	; 0x51da <onRtpControl+0x154>
	putString(buf);
    // '?' not found or ':' missing
    rtpSendCommand("Syntax Error\n", 13, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);

	
    return;
    5124:	90 e0       	ldi	r25, 0x00	; 0
    5126:	02 c0       	rjmp	.+4      	; 0x512c <onRtpControl+0xa6>
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    5128:	e0 32       	cpi	r30, 0x20	; 32
    512a:	79 f0       	breq	.+30     	; 0x514a <onRtpControl+0xc4>
	  pos++;
    512c:	9f 5f       	subi	r25, 0xFF	; 255
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    512e:	29 2f       	mov	r18, r25
    5130:	30 e0       	ldi	r19, 0x00	; 0
    5132:	fd 01       	movw	r30, r26
    5134:	e2 0f       	add	r30, r18
    5136:	f3 1f       	adc	r31, r19
    5138:	40 81       	ld	r20, Z
    513a:	fe 01       	movw	r30, r28
    513c:	e2 0f       	add	r30, r18
    513e:	f3 1f       	adc	r31, r19
    5140:	e0 81       	ld	r30, Z
    5142:	8e 2f       	mov	r24, r30
    5144:	84 27       	eor	r24, r20
    5146:	8f 75       	andi	r24, 0x5F	; 95
    5148:	79 f3       	breq	.-34     	; 0x5128 <onRtpControl+0xa2>
	  pos++;
	}
	if (rcfg_commands[cmd].name[pos] == 0 && (buf[pos]==' ' || buf[pos]=='?') ) {
    514a:	44 23       	and	r20, r20
    514c:	31 f4       	brne	.+12     	; 0x515a <onRtpControl+0xd4>
    514e:	e0 32       	cpi	r30, 0x20	; 32
    5150:	09 f4       	brne	.+2      	; 0x5154 <onRtpControl+0xce>
    5152:	47 c0       	rjmp	.+142    	; 0x51e2 <onRtpControl+0x15c>
    5154:	ef 33       	cpi	r30, 0x3F	; 63
    5156:	09 f4       	brne	.+2      	; 0x515a <onRtpControl+0xd4>
    5158:	44 c0       	rjmp	.+136    	; 0x51e2 <onRtpControl+0x15c>

	  return;
	}
	
	// compare to next command
	cmd++;
    515a:	5f 5f       	subi	r21, 0xFF	; 255
    return;
  }
  
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    515c:	a5 2f       	mov	r26, r21
    515e:	b0 e0       	ldi	r27, 0x00	; 0
    5160:	fd 01       	movw	r30, r26
    5162:	ee 0f       	add	r30, r30
    5164:	ff 1f       	adc	r31, r31
    5166:	ee 0f       	add	r30, r30
    5168:	ff 1f       	adc	r31, r31
    516a:	e9 5e       	subi	r30, 0xE9	; 233
    516c:	f8 4f       	sbci	r31, 0xF8	; 248
    516e:	60 81       	ld	r22, Z
    5170:	71 81       	ldd	r23, Z+1	; 0x01
    5172:	61 15       	cp	r22, r1
    5174:	71 05       	cpc	r23, r1
    5176:	39 f6       	brne	.-114    	; 0x5106 <onRtpControl+0x80>
	// compare to next command
	cmd++;
  }


  putString("onRtpControl() Command not found, sent:");
    5178:	8d e8       	ldi	r24, 0x8D	; 141
    517a:	95 e0       	ldi	r25, 0x05	; 5
    517c:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
 putString(buf);
    5180:	ce 01       	movw	r24, r28
    5182:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  // command not found
  rtpSendCommand("Error located between ears of user.\n", 36, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);    
    5186:	85 eb       	ldi	r24, 0xB5	; 181
    5188:	95 e0       	ldi	r25, 0x05	; 5
    518a:	64 e2       	ldi	r22, 0x24	; 36
    518c:	70 e0       	ldi	r23, 0x00	; 0
    518e:	40 e3       	ldi	r20, 0x30	; 48
    5190:	59 e0       	ldi	r21, 0x09	; 9
    5192:	26 e3       	ldi	r18, 0x36	; 54
    5194:	39 e0       	ldi	r19, 0x09	; 9
    5196:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
  return;

  
}
    519a:	df 91       	pop	r29
    519c:	cf 91       	pop	r28
    519e:	1f 91       	pop	r17
    51a0:	08 95       	ret



  // check if rcfg has been disabled using ":DISABLE?"
  if (Config_is_Disabled()) {
    rtpSendCommand("Config has been disabled.", 25, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    51a2:	88 ed       	ldi	r24, 0xD8	; 216
    51a4:	94 e0       	ldi	r25, 0x04	; 4
    51a6:	69 e1       	ldi	r22, 0x19	; 25
    51a8:	70 e0       	ldi	r23, 0x00	; 0
    51aa:	40 e3       	ldi	r20, 0x30	; 48
    51ac:	59 e0       	ldi	r21, 0x09	; 9
    51ae:	26 e3       	ldi	r18, 0x36	; 54
    51b0:	39 e0       	ldi	r19, 0x09	; 9
    51b2:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
    rtpSendCommand("FAIL\n", 5, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    51b6:	82 ef       	ldi	r24, 0xF2	; 242
    51b8:	94 e0       	ldi	r25, 0x04	; 4
    51ba:	65 e0       	ldi	r22, 0x05	; 5
    51bc:	70 e0       	ldi	r23, 0x00	; 0
    51be:	40 e3       	ldi	r20, 0x30	; 48
    51c0:	59 e0       	ldi	r21, 0x09	; 9
    51c2:	26 e3       	ldi	r18, 0x36	; 54
    51c4:	39 e0       	ldi	r19, 0x09	; 9
    51c6:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
	putString("\r\nonRtpControl() Config_is_Disabled:");
    51ca:	88 ef       	ldi	r24, 0xF8	; 248
    51cc:	94 e0       	ldi	r25, 0x04	; 4
    51ce:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
  // command not found
  rtpSendCommand("Error located between ears of user.\n", 36, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);    
  return;

  
}
    51d2:	df 91       	pop	r29
    51d4:	cf 91       	pop	r28
    51d6:	1f 91       	pop	r17
    51d8:	08 95       	ret
  
  uint8_t cmd=0;
  while (rcfg_commands[cmd].func != NULL) {
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
    51da:	ea e3       	ldi	r30, 0x3A	; 58
    51dc:	20 e0       	ldi	r18, 0x00	; 0
    51de:	30 e0       	ldi	r19, 0x00	; 0
    51e0:	b4 cf       	rjmp	.-152    	; 0x514a <onRtpControl+0xc4>
	  pos++;
	}
	if (rcfg_commands[cmd].name[pos] == 0 && (buf[pos]==' ' || buf[pos]=='?') ) {
	  // command found
      while(buf[pos] == ' ')
    51e2:	de 01       	movw	r26, r28
    51e4:	a2 0f       	add	r26, r18
    51e6:	b3 1f       	adc	r27, r19
    51e8:	8c 91       	ld	r24, X
    51ea:	80 32       	cpi	r24, 0x20	; 32
    51ec:	41 f4       	brne	.+16     	; 0x51fe <onRtpControl+0x178>
    pos = 0;
	// find command (case-insensitive => "& 0x5f")
    while ( ((rcfg_commands[cmd].name[pos] ^ buf[pos]) & 0x5f) == 0 && buf[pos] != 0x20) {
	  pos++;
	}
	if (rcfg_commands[cmd].name[pos] == 0 && (buf[pos]==' ' || buf[pos]=='?') ) {
    51ee:	f9 01       	movw	r30, r18
    51f0:	31 96       	adiw	r30, 0x01	; 1
    51f2:	ec 0f       	add	r30, r28
    51f4:	fd 1f       	adc	r31, r29
    51f6:	df 01       	movw	r26, r30
	  // command found
      while(buf[pos] == ' ')
    51f8:	81 91       	ld	r24, Z+
    51fa:	80 32       	cpi	r24, 0x20	; 32
    51fc:	e1 f3       	breq	.-8      	; 0x51f6 <onRtpControl+0x170>
	    buf++;
      //rtpSendCommand(&rcfg_commands[cmd].name[0], 8, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort); // debug
      // execute command

      uint8_t rv;
      rv = rcfg_commands[cmd].func(&buf[pos]);
    51fe:	cd 01       	movw	r24, r26
    5200:	fb 01       	movw	r30, r22
    5202:	09 95       	icall
  


      // send ack
      if (rv == RCFG_SUCCESS ) 
    5204:	88 23       	and	r24, r24
    5206:	79 f4       	brne	.+30     	; 0x5226 <onRtpControl+0x1a0>
	  {
        rtpSendCommand("OK\n", 3, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    5208:	8f e4       	ldi	r24, 0x4F	; 79
    520a:	95 e0       	ldi	r25, 0x05	; 5
    520c:	63 e0       	ldi	r22, 0x03	; 3
    520e:	70 e0       	ldi	r23, 0x00	; 0
    5210:	40 e3       	ldi	r20, 0x30	; 48
    5212:	59 e0       	ldi	r21, 0x09	; 9
    5214:	26 e3       	ldi	r18, 0x36	; 54
    5216:	39 e0       	ldi	r19, 0x09	; 9
    5218:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
		putString("\r\nonRtpControl() meldet OK:");
    521c:	83 e5       	ldi	r24, 0x53	; 83
    521e:	95 e0       	ldi	r25, 0x05	; 5
    5220:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    5224:	60 cf       	rjmp	.-320    	; 0x50e6 <onRtpControl+0x60>
      } 
	  else 
	  {
        rtpSendCommand("FAIL\n", 5, &Config.IPv4.remoteAdrConfig, &Config.IPv4.localSrcPort);
    5226:	82 ef       	ldi	r24, 0xF2	; 242
    5228:	94 e0       	ldi	r25, 0x04	; 4
    522a:	65 e0       	ldi	r22, 0x05	; 5
    522c:	70 e0       	ldi	r23, 0x00	; 0
    522e:	40 e3       	ldi	r20, 0x30	; 48
    5230:	59 e0       	ldi	r21, 0x09	; 9
    5232:	26 e3       	ldi	r18, 0x36	; 54
    5234:	39 e0       	ldi	r19, 0x09	; 9
    5236:	0e 94 32 05 	call	0xa64	; 0xa64 <rtpSendCommand>
		putString("\r\nonRtpControl() meldet FAIL:");
    523a:	8f e6       	ldi	r24, 0x6F	; 111
    523c:	95 e0       	ldi	r25, 0x05	; 5
    523e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <putString>
    5242:	51 cf       	rjmp	.-350    	; 0x50e6 <onRtpControl+0x60>
  }


  // some syntax checks
  uint8_t pos = 1;
  while (pos < len)
    5244:	91 e0       	ldi	r25, 0x01	; 1
    5246:	39 cf       	rjmp	.-398    	; 0x50ba <onRtpControl+0x34>

00005248 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    5248:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    524a:	e1 99       	sbic	0x1c, 1	; 28
    524c:	fe cf       	rjmp	.-4      	; 0x524a <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    524e:	3f bb       	out	0x1f, r19	; 31
    5250:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    5252:	e0 9a       	sbi	0x1c, 0	; 28
    5254:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    5256:	08 95       	ret

00005258 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    5258:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    525a:	e1 99       	sbic	0x1c, 1	; 28
    525c:	fe cf       	rjmp	.-4      	; 0x525a <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    525e:	3f bb       	out	0x1f, r19	; 31
    5260:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    5262:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    5264:	0f b6       	in	r0, 0x3f	; 63
    5266:	f8 94       	cli
    5268:	e2 9a       	sbi	0x1c, 2	; 28
    526a:	e1 9a       	sbi	0x1c, 1	; 28
    526c:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    526e:	08 95       	ret

00005270 <EepromWriteConfig>:

  return 1; // data is valid
}

void EepromWriteConfig(void * baseadr, void * buf, uint8_t len)
{
    5270:	af 92       	push	r10
    5272:	bf 92       	push	r11
    5274:	cf 92       	push	r12
    5276:	df 92       	push	r13
    5278:	ef 92       	push	r14
    527a:	ff 92       	push	r15
    527c:	0f 93       	push	r16
    527e:	1f 93       	push	r17
    5280:	df 93       	push	r29
    5282:	cf 93       	push	r28
    5284:	00 d0       	rcall	.+0      	; 0x5286 <EepromWriteConfig+0x16>
    5286:	00 d0       	rcall	.+0      	; 0x5288 <EepromWriteConfig+0x18>
    5288:	cd b7       	in	r28, 0x3d	; 61
    528a:	de b7       	in	r29, 0x3e	; 62
    528c:	5c 01       	movw	r10, r24
    528e:	7b 01       	movw	r14, r22
    5290:	04 2f       	mov	r16, r20
  struct netCheckSum_t checksum;
  eeprom_write_block(buf, baseadr, len);
    5292:	10 e0       	ldi	r17, 0x00	; 0
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    5294:	8c e2       	ldi	r24, 0x2C	; 44
    5296:	c8 2e       	mov	r12, r24
    5298:	89 e2       	ldi	r24, 0x29	; 41
    529a:	d8 2e       	mov	r13, r24
    529c:	c5 01       	movw	r24, r10
    529e:	a8 01       	movw	r20, r16
    52a0:	96 01       	movw	r18, r12
    52a2:	0e 94 77 2e 	call	0x5cee	; 0x5cee <__eewr_block>

  checksum.positive = calculateCheckSum(buf, len);
    52a6:	c7 01       	movw	r24, r14
    52a8:	b8 01       	movw	r22, r16
    52aa:	0e 94 9b 1a 	call	0x3536	; 0x3536 <calculateCheckSum>
    52ae:	9a 83       	std	Y+2, r25	; 0x02
    52b0:	89 83       	std	Y+1, r24	; 0x01
  checksum.negative = ~checksum.positive;
    52b2:	80 95       	com	r24
    52b4:	90 95       	com	r25
    52b6:	9c 83       	std	Y+4, r25	; 0x04
    52b8:	8b 83       	std	Y+3, r24	; 0x03
    52ba:	c5 01       	movw	r24, r10
    52bc:	80 0f       	add	r24, r16
    52be:	91 1f       	adc	r25, r17
    52c0:	be 01       	movw	r22, r28
    52c2:	6f 5f       	subi	r22, 0xFF	; 255
    52c4:	7f 4f       	sbci	r23, 0xFF	; 255
    52c6:	44 e0       	ldi	r20, 0x04	; 4
    52c8:	50 e0       	ldi	r21, 0x00	; 0
    52ca:	96 01       	movw	r18, r12
    52cc:	0e 94 77 2e 	call	0x5cee	; 0x5cee <__eewr_block>
  eeprom_write_block(&checksum, baseadr+len, sizeof(checksum));
}
    52d0:	0f 90       	pop	r0
    52d2:	0f 90       	pop	r0
    52d4:	0f 90       	pop	r0
    52d6:	0f 90       	pop	r0
    52d8:	cf 91       	pop	r28
    52da:	df 91       	pop	r29
    52dc:	1f 91       	pop	r17
    52de:	0f 91       	pop	r16
    52e0:	ff 90       	pop	r15
    52e2:	ef 90       	pop	r14
    52e4:	df 90       	pop	r13
    52e6:	cf 90       	pop	r12
    52e8:	bf 90       	pop	r11
    52ea:	af 90       	pop	r10
    52ec:	08 95       	ret

000052ee <EepromReadConfig>:
}

#else

uint8_t EepromReadConfig(void * baseadr, void * buf, uint8_t len)
{
    52ee:	cf 92       	push	r12
    52f0:	df 92       	push	r13
    52f2:	ef 92       	push	r14
    52f4:	ff 92       	push	r15
    52f6:	0f 93       	push	r16
    52f8:	1f 93       	push	r17
    52fa:	df 93       	push	r29
    52fc:	cf 93       	push	r28
    52fe:	00 d0       	rcall	.+0      	; 0x5300 <EepromReadConfig+0x12>
    5300:	00 d0       	rcall	.+0      	; 0x5302 <EepromReadConfig+0x14>
    5302:	cd b7       	in	r28, 0x3d	; 61
    5304:	de b7       	in	r29, 0x3e	; 62
    5306:	8c 01       	movw	r16, r24
    5308:	6b 01       	movw	r12, r22
  struct netCheckSum_t checksum;

  // wait for eeprom
  while (eeprom_is_ready() == 0);
    530a:	e1 99       	sbic	0x1c, 1	; 28
    530c:	fe cf       	rjmp	.-4      	; 0x530a <EepromReadConfig+0x1c>

  // read config and checksum
  eeprom_read_block(buf,baseadr,len);
    530e:	e4 2e       	mov	r14, r20
    5310:	ff 24       	eor	r15, r15
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    5312:	c6 01       	movw	r24, r12
    5314:	b8 01       	movw	r22, r16
    5316:	a7 01       	movw	r20, r14
    5318:	24 e2       	ldi	r18, 0x24	; 36
    531a:	39 e2       	ldi	r19, 0x29	; 41
    531c:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
  eeprom_read_block(&checksum,baseadr+len,sizeof(checksum));

  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    5320:	0e 0d       	add	r16, r14
    5322:	1f 1d       	adc	r17, r15
    5324:	ce 01       	movw	r24, r28
    5326:	01 96       	adiw	r24, 0x01	; 1
    5328:	b8 01       	movw	r22, r16
    532a:	44 e0       	ldi	r20, 0x04	; 4
    532c:	50 e0       	ldi	r21, 0x00	; 0
    532e:	24 e2       	ldi	r18, 0x24	; 36
    5330:	39 e2       	ldi	r19, 0x29	; 41
    5332:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
    5336:	8b 81       	ldd	r24, Y+3	; 0x03
    5338:	9c 81       	ldd	r25, Y+4	; 0x04
    533a:	80 95       	com	r24
    533c:	90 95       	com	r25
    533e:	29 81       	ldd	r18, Y+1	; 0x01
    5340:	3a 81       	ldd	r19, Y+2	; 0x02
    5342:	28 17       	cp	r18, r24
    5344:	39 07       	cpc	r19, r25
    5346:	79 f0       	breq	.+30     	; 0x5366 <EepromReadConfig+0x78>
    5348:	40 e0       	ldi	r20, 0x00	; 0
  // as they are interlocked, it's time to proove the checksum
  if (calculateCheckSum(buf,len) != checksum.positive)
    return 0; // read config failed (bad checksum)

  return 1; // data is valid
}
    534a:	84 2f       	mov	r24, r20
    534c:	0f 90       	pop	r0
    534e:	0f 90       	pop	r0
    5350:	0f 90       	pop	r0
    5352:	0f 90       	pop	r0
    5354:	cf 91       	pop	r28
    5356:	df 91       	pop	r29
    5358:	1f 91       	pop	r17
    535a:	0f 91       	pop	r16
    535c:	ff 90       	pop	r15
    535e:	ef 90       	pop	r14
    5360:	df 90       	pop	r13
    5362:	cf 90       	pop	r12
    5364:	08 95       	ret
  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    return 0; // read config failed (bad checksum)

  // as they are interlocked, it's time to proove the checksum
  if (calculateCheckSum(buf,len) != checksum.positive)
    5366:	c6 01       	movw	r24, r12
    5368:	b7 01       	movw	r22, r14
    536a:	0e 94 9b 1a 	call	0x3536	; 0x3536 <calculateCheckSum>
    536e:	40 e0       	ldi	r20, 0x00	; 0
    5370:	29 81       	ldd	r18, Y+1	; 0x01
    5372:	3a 81       	ldd	r19, Y+2	; 0x02
    5374:	82 17       	cp	r24, r18
    5376:	93 07       	cpc	r25, r19
    5378:	41 f7       	brne	.-48     	; 0x534a <EepromReadConfig+0x5c>
    537a:	41 e0       	ldi	r20, 0x01	; 1
    537c:	e6 cf       	rjmp	.-52     	; 0x534a <EepromReadConfig+0x5c>

0000537e <configEepromGetConfig>:
  return;
}

void configEepromGetConfig(ipAddress_t * dIpData, portAddress_t * dPortData,
			   ipAddress_t * dIpConfig, portAddress_t * dPortConfig,
			   portAddress_t * sPort) {
    537e:	4f 92       	push	r4
    5380:	5f 92       	push	r5
    5382:	6f 92       	push	r6
    5384:	7f 92       	push	r7
    5386:	8f 92       	push	r8
    5388:	9f 92       	push	r9
    538a:	af 92       	push	r10
    538c:	bf 92       	push	r11
    538e:	cf 92       	push	r12
    5390:	df 92       	push	r13
    5392:	ef 92       	push	r14
    5394:	ff 92       	push	r15
    5396:	0f 93       	push	r16
    5398:	1f 93       	push	r17
    539a:	df 93       	push	r29
    539c:	cf 93       	push	r28
    539e:	cd b7       	in	r28, 0x3d	; 61
    53a0:	de b7       	in	r29, 0x3e	; 62
    53a2:	62 97       	sbiw	r28, 0x12	; 18
    53a4:	0f b6       	in	r0, 0x3f	; 63
    53a6:	f8 94       	cli
    53a8:	de bf       	out	0x3e, r29	; 62
    53aa:	0f be       	out	0x3f, r0	; 63
    53ac:	cd bf       	out	0x3d, r28	; 61
    53ae:	6c 01       	movw	r12, r24
    53b0:	5b 01       	movw	r10, r22
    53b2:	4a 01       	movw	r8, r20
    53b4:	39 01       	movw	r6, r18
    53b6:	28 01       	movw	r4, r16
uint8_t EepromReadConfig(void * baseadr, void * buf, uint8_t len)
{
  struct netCheckSum_t checksum;

  // wait for eeprom
  while (eeprom_is_ready() == 0);
    53b8:	e1 99       	sbic	0x1c, 1	; 28
    53ba:	fe cf       	rjmp	.-4      	; 0x53b8 <configEepromGetConfig+0x3a>
    53bc:	8e 01       	movw	r16, r28
    53be:	0b 5f       	subi	r16, 0xFB	; 251
    53c0:	1f 4f       	sbci	r17, 0xFF	; 255
    53c2:	c8 01       	movw	r24, r16
    53c4:	60 e0       	ldi	r22, 0x00	; 0
    53c6:	74 e0       	ldi	r23, 0x04	; 4
    53c8:	4e e0       	ldi	r20, 0x0E	; 14
    53ca:	50 e0       	ldi	r21, 0x00	; 0
    53cc:	24 e2       	ldi	r18, 0x24	; 36
    53ce:	39 e2       	ldi	r19, 0x29	; 41
    53d0:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
  // read config and checksum
  eeprom_read_block(buf,baseadr,len);
  eeprom_read_block(&checksum,baseadr+len,sizeof(checksum));

  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    53d4:	ce 01       	movw	r24, r28
    53d6:	01 96       	adiw	r24, 0x01	; 1
    53d8:	6e e0       	ldi	r22, 0x0E	; 14
    53da:	74 e0       	ldi	r23, 0x04	; 4
    53dc:	44 e0       	ldi	r20, 0x04	; 4
    53de:	50 e0       	ldi	r21, 0x00	; 0
    53e0:	24 e2       	ldi	r18, 0x24	; 36
    53e2:	39 e2       	ldi	r19, 0x29	; 41
    53e4:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
    53e8:	8b 81       	ldd	r24, Y+3	; 0x03
    53ea:	9c 81       	ldd	r25, Y+4	; 0x04
    53ec:	80 95       	com	r24
    53ee:	90 95       	com	r25
    53f0:	29 81       	ldd	r18, Y+1	; 0x01
    53f2:	3a 81       	ldd	r19, Y+2	; 0x02
    53f4:	28 17       	cp	r18, r24
    53f6:	39 07       	cpc	r19, r25
    53f8:	09 f4       	brne	.+2      	; 0x53fc <configEepromGetConfig+0x7e>
    53fa:	97 c0       	rjmp	.+302    	; 0x552a <configEepromGetConfig+0x1ac>
			   ipAddress_t * dIpConfig, portAddress_t * dPortConfig,
			   portAddress_t * sPort) {
  Config_t buf;
  if ( !EepromReadConfig((void*)CONFIG_EEPROM, &buf, sizeof(buf)) ) {
    // return fallback settings, if eeprom data is invalid
    buf = Config;
    53fc:	d8 01       	movw	r26, r16
    53fe:	ea e2       	ldi	r30, 0x2A	; 42
    5400:	f9 e0       	ldi	r31, 0x09	; 9
    5402:	8e e0       	ldi	r24, 0x0E	; 14
    5404:	01 90       	ld	r0, Z+
    5406:	0d 92       	st	X+, r0
    5408:	81 50       	subi	r24, 0x01	; 1
    540a:	e1 f7       	brne	.-8      	; 0x5404 <configEepromGetConfig+0x86>
  }

  // assign values if pointer != NULL
  if (dIpData)
    540c:	c1 14       	cp	r12, r1
    540e:	d1 04       	cpc	r13, r1
    5410:	69 f1       	breq	.+90     	; 0x546c <configEepromGetConfig+0xee>
    *dIpData = ntohl(buf.IPv4.remoteAdrData.ip);
    5412:	2d 81       	ldd	r18, Y+5	; 0x05
    5414:	3e 81       	ldd	r19, Y+6	; 0x06
    5416:	4f 81       	ldd	r20, Y+7	; 0x07
    5418:	58 85       	ldd	r21, Y+8	; 0x08
    541a:	12 2f       	mov	r17, r18
    541c:	00 27       	eor	r16, r16
    541e:	ff 24       	eor	r15, r15
    5420:	ee 24       	eor	r14, r14
    5422:	85 2f       	mov	r24, r21
    5424:	99 27       	eor	r25, r25
    5426:	aa 27       	eor	r26, r26
    5428:	bb 27       	eor	r27, r27
    542a:	e8 2a       	or	r14, r24
    542c:	f9 2a       	or	r15, r25
    542e:	0a 2b       	or	r16, r26
    5430:	1b 2b       	or	r17, r27
    5432:	da 01       	movw	r26, r20
    5434:	c9 01       	movw	r24, r18
    5436:	80 70       	andi	r24, 0x00	; 0
    5438:	90 70       	andi	r25, 0x00	; 0
    543a:	b0 70       	andi	r27, 0x00	; 0
    543c:	89 2f       	mov	r24, r25
    543e:	9a 2f       	mov	r25, r26
    5440:	ab 2f       	mov	r26, r27
    5442:	bb 27       	eor	r27, r27
    5444:	e8 2a       	or	r14, r24
    5446:	f9 2a       	or	r15, r25
    5448:	0a 2b       	or	r16, r26
    544a:	1b 2b       	or	r17, r27
    544c:	20 70       	andi	r18, 0x00	; 0
    544e:	40 70       	andi	r20, 0x00	; 0
    5450:	50 70       	andi	r21, 0x00	; 0
    5452:	54 2f       	mov	r21, r20
    5454:	43 2f       	mov	r20, r19
    5456:	32 2f       	mov	r19, r18
    5458:	22 27       	eor	r18, r18
    545a:	e2 2a       	or	r14, r18
    545c:	f3 2a       	or	r15, r19
    545e:	04 2b       	or	r16, r20
    5460:	15 2b       	or	r17, r21
    5462:	f6 01       	movw	r30, r12
    5464:	e0 82       	st	Z, r14
    5466:	f1 82       	std	Z+1, r15	; 0x01
    5468:	02 83       	std	Z+2, r16	; 0x02
    546a:	13 83       	std	Z+3, r17	; 0x03
  if (dPortData)
    546c:	a1 14       	cp	r10, r1
    546e:	b1 04       	cpc	r11, r1
    5470:	29 f0       	breq	.+10     	; 0x547c <configEepromGetConfig+0xfe>
    *dPortData = buf.IPv4.remoteAdrData.port;
    5472:	89 85       	ldd	r24, Y+9	; 0x09
    5474:	9a 85       	ldd	r25, Y+10	; 0x0a
    5476:	f5 01       	movw	r30, r10
    5478:	91 83       	std	Z+1, r25	; 0x01
    547a:	80 83       	st	Z, r24
  if (dIpConfig)
    547c:	81 14       	cp	r8, r1
    547e:	91 04       	cpc	r9, r1
    5480:	69 f1       	breq	.+90     	; 0x54dc <configEepromGetConfig+0x15e>
    *dIpConfig = ntohl(buf.IPv4.remoteAdrConfig.ip);
    5482:	2b 85       	ldd	r18, Y+11	; 0x0b
    5484:	3c 85       	ldd	r19, Y+12	; 0x0c
    5486:	4d 85       	ldd	r20, Y+13	; 0x0d
    5488:	5e 85       	ldd	r21, Y+14	; 0x0e
    548a:	12 2f       	mov	r17, r18
    548c:	00 27       	eor	r16, r16
    548e:	ff 24       	eor	r15, r15
    5490:	ee 24       	eor	r14, r14
    5492:	85 2f       	mov	r24, r21
    5494:	99 27       	eor	r25, r25
    5496:	aa 27       	eor	r26, r26
    5498:	bb 27       	eor	r27, r27
    549a:	e8 2a       	or	r14, r24
    549c:	f9 2a       	or	r15, r25
    549e:	0a 2b       	or	r16, r26
    54a0:	1b 2b       	or	r17, r27
    54a2:	da 01       	movw	r26, r20
    54a4:	c9 01       	movw	r24, r18
    54a6:	80 70       	andi	r24, 0x00	; 0
    54a8:	90 70       	andi	r25, 0x00	; 0
    54aa:	b0 70       	andi	r27, 0x00	; 0
    54ac:	89 2f       	mov	r24, r25
    54ae:	9a 2f       	mov	r25, r26
    54b0:	ab 2f       	mov	r26, r27
    54b2:	bb 27       	eor	r27, r27
    54b4:	e8 2a       	or	r14, r24
    54b6:	f9 2a       	or	r15, r25
    54b8:	0a 2b       	or	r16, r26
    54ba:	1b 2b       	or	r17, r27
    54bc:	20 70       	andi	r18, 0x00	; 0
    54be:	40 70       	andi	r20, 0x00	; 0
    54c0:	50 70       	andi	r21, 0x00	; 0
    54c2:	54 2f       	mov	r21, r20
    54c4:	43 2f       	mov	r20, r19
    54c6:	32 2f       	mov	r19, r18
    54c8:	22 27       	eor	r18, r18
    54ca:	e2 2a       	or	r14, r18
    54cc:	f3 2a       	or	r15, r19
    54ce:	04 2b       	or	r16, r20
    54d0:	15 2b       	or	r17, r21
    54d2:	f4 01       	movw	r30, r8
    54d4:	e0 82       	st	Z, r14
    54d6:	f1 82       	std	Z+1, r15	; 0x01
    54d8:	02 83       	std	Z+2, r16	; 0x02
    54da:	13 83       	std	Z+3, r17	; 0x03
  if (dPortConfig)
    54dc:	61 14       	cp	r6, r1
    54de:	71 04       	cpc	r7, r1
    54e0:	29 f0       	breq	.+10     	; 0x54ec <configEepromGetConfig+0x16e>
    *dPortConfig = buf.IPv4.remoteAdrConfig.port;
    54e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    54e4:	98 89       	ldd	r25, Y+16	; 0x10
    54e6:	f3 01       	movw	r30, r6
    54e8:	91 83       	std	Z+1, r25	; 0x01
    54ea:	80 83       	st	Z, r24
  if (sPort)
    54ec:	41 14       	cp	r4, r1
    54ee:	51 04       	cpc	r5, r1
    54f0:	29 f0       	breq	.+10     	; 0x54fc <configEepromGetConfig+0x17e>
    *sPort = buf.IPv4.localSrcPort;
    54f2:	89 89       	ldd	r24, Y+17	; 0x11
    54f4:	9a 89       	ldd	r25, Y+18	; 0x12
    54f6:	f2 01       	movw	r30, r4
    54f8:	91 83       	std	Z+1, r25	; 0x01
    54fa:	80 83       	st	Z, r24

  return;
}
    54fc:	62 96       	adiw	r28, 0x12	; 18
    54fe:	0f b6       	in	r0, 0x3f	; 63
    5500:	f8 94       	cli
    5502:	de bf       	out	0x3e, r29	; 62
    5504:	0f be       	out	0x3f, r0	; 63
    5506:	cd bf       	out	0x3d, r28	; 61
    5508:	cf 91       	pop	r28
    550a:	df 91       	pop	r29
    550c:	1f 91       	pop	r17
    550e:	0f 91       	pop	r16
    5510:	ff 90       	pop	r15
    5512:	ef 90       	pop	r14
    5514:	df 90       	pop	r13
    5516:	cf 90       	pop	r12
    5518:	bf 90       	pop	r11
    551a:	af 90       	pop	r10
    551c:	9f 90       	pop	r9
    551e:	8f 90       	pop	r8
    5520:	7f 90       	pop	r7
    5522:	6f 90       	pop	r6
    5524:	5f 90       	pop	r5
    5526:	4f 90       	pop	r4
    5528:	08 95       	ret
  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    return 0; // read config failed (bad checksum)

  // as they are interlocked, it's time to proove the checksum
  if (calculateCheckSum(buf,len) != checksum.positive)
    552a:	c8 01       	movw	r24, r16
    552c:	6e e0       	ldi	r22, 0x0E	; 14
    552e:	70 e0       	ldi	r23, 0x00	; 0
    5530:	0e 94 9b 1a 	call	0x3536	; 0x3536 <calculateCheckSum>
    5534:	29 81       	ldd	r18, Y+1	; 0x01
    5536:	3a 81       	ldd	r19, Y+2	; 0x02
    5538:	82 17       	cp	r24, r18
    553a:	93 07       	cpc	r25, r19
    553c:	09 f0       	breq	.+2      	; 0x5540 <configEepromGetConfig+0x1c2>
    553e:	5e cf       	rjmp	.-324    	; 0x53fc <configEepromGetConfig+0x7e>
    5540:	65 cf       	rjmp	.-310    	; 0x540c <configEepromGetConfig+0x8e>

00005542 <configEepromSetConfig>:
}

#ifdef REQUIRES_RCFG
void configEepromSetConfig(ipAddress_t dIpData, portAddress_t dPortData,
			   ipAddress_t dIpConfig, portAddress_t dPortConfig,
			   portAddress_t sPort) {
    5542:	2f 92       	push	r2
    5544:	3f 92       	push	r3
    5546:	4f 92       	push	r4
    5548:	5f 92       	push	r5
    554a:	6f 92       	push	r6
    554c:	7f 92       	push	r7
    554e:	8f 92       	push	r8
    5550:	9f 92       	push	r9
    5552:	af 92       	push	r10
    5554:	bf 92       	push	r11
    5556:	cf 92       	push	r12
    5558:	df 92       	push	r13
    555a:	ef 92       	push	r14
    555c:	ff 92       	push	r15
    555e:	0f 93       	push	r16
    5560:	1f 93       	push	r17
    5562:	df 93       	push	r29
    5564:	cf 93       	push	r28
    5566:	cd b7       	in	r28, 0x3d	; 61
    5568:	de b7       	in	r29, 0x3e	; 62
    556a:	62 97       	sbiw	r28, 0x12	; 18
    556c:	0f b6       	in	r0, 0x3f	; 63
    556e:	f8 94       	cli
    5570:	de bf       	out	0x3e, r29	; 62
    5572:	0f be       	out	0x3f, r0	; 63
    5574:	cd bf       	out	0x3d, r28	; 61
    5576:	4b 01       	movw	r8, r22
    5578:	5c 01       	movw	r10, r24
    557a:	1a 01       	movw	r2, r20
    557c:	28 01       	movw	r4, r16
    557e:	39 01       	movw	r6, r18
uint8_t EepromReadConfig(void * baseadr, void * buf, uint8_t len)
{
  struct netCheckSum_t checksum;

  // wait for eeprom
  while (eeprom_is_ready() == 0);
    5580:	e1 99       	sbic	0x1c, 1	; 28
    5582:	fe cf       	rjmp	.-4      	; 0x5580 <configEepromSetConfig+0x3e>
    5584:	8e 01       	movw	r16, r28
    5586:	0b 5f       	subi	r16, 0xFB	; 251
    5588:	1f 4f       	sbci	r17, 0xFF	; 255
    558a:	c8 01       	movw	r24, r16
    558c:	60 e0       	ldi	r22, 0x00	; 0
    558e:	74 e0       	ldi	r23, 0x04	; 4
    5590:	4e e0       	ldi	r20, 0x0E	; 14
    5592:	50 e0       	ldi	r21, 0x00	; 0
    5594:	24 e2       	ldi	r18, 0x24	; 36
    5596:	39 e2       	ldi	r19, 0x29	; 41
    5598:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
  // read config and checksum
  eeprom_read_block(buf,baseadr,len);
  eeprom_read_block(&checksum,baseadr+len,sizeof(checksum));

  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    559c:	ce 01       	movw	r24, r28
    559e:	01 96       	adiw	r24, 0x01	; 1
    55a0:	6e e0       	ldi	r22, 0x0E	; 14
    55a2:	74 e0       	ldi	r23, 0x04	; 4
    55a4:	44 e0       	ldi	r20, 0x04	; 4
    55a6:	50 e0       	ldi	r21, 0x00	; 0
    55a8:	24 e2       	ldi	r18, 0x24	; 36
    55aa:	39 e2       	ldi	r19, 0x29	; 41
    55ac:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
    55b0:	8b 81       	ldd	r24, Y+3	; 0x03
    55b2:	9c 81       	ldd	r25, Y+4	; 0x04
    55b4:	80 95       	com	r24
    55b6:	90 95       	com	r25
    55b8:	29 81       	ldd	r18, Y+1	; 0x01
    55ba:	3a 81       	ldd	r19, Y+2	; 0x02
    55bc:	28 17       	cp	r18, r24
    55be:	39 07       	cpc	r19, r25
    55c0:	09 f4       	brne	.+2      	; 0x55c4 <configEepromSetConfig+0x82>
    55c2:	b3 c0       	rjmp	.+358    	; 0x572a <configEepromSetConfig+0x1e8>
			   portAddress_t sPort) {
  Config_t buf;
  if ( !EepromReadConfig((void*)CONFIG_EEPROM, &buf, sizeof(buf)) ) {
    // if eeprom data is invalid,
    // create new configuration based upon the fallback settings
    buf = Config;
    55c4:	d8 01       	movw	r26, r16
    55c6:	ea e2       	ldi	r30, 0x2A	; 42
    55c8:	f9 e0       	ldi	r31, 0x09	; 9
    55ca:	8e e0       	ldi	r24, 0x0E	; 14
    55cc:	01 90       	ld	r0, Z+
    55ce:	0d 92       	st	X+, r0
    55d0:	81 50       	subi	r24, 0x01	; 1
    55d2:	e1 f7       	brne	.-8      	; 0x55cc <configEepromSetConfig+0x8a>
  }

  // set new values
  if (dIpData != 0)
    55d4:	81 14       	cp	r8, r1
    55d6:	91 04       	cpc	r9, r1
    55d8:	a1 04       	cpc	r10, r1
    55da:	b1 04       	cpc	r11, r1
    55dc:	69 f1       	breq	.+90     	; 0x5638 <configEepromSetConfig+0xf6>
    buf.IPv4.remoteAdrData.ip = htonl(dIpData);
    55de:	58 2d       	mov	r21, r8
    55e0:	44 27       	eor	r20, r20
    55e2:	33 27       	eor	r19, r19
    55e4:	22 27       	eor	r18, r18
    55e6:	8b 2d       	mov	r24, r11
    55e8:	99 27       	eor	r25, r25
    55ea:	aa 27       	eor	r26, r26
    55ec:	bb 27       	eor	r27, r27
    55ee:	28 2b       	or	r18, r24
    55f0:	39 2b       	or	r19, r25
    55f2:	4a 2b       	or	r20, r26
    55f4:	5b 2b       	or	r21, r27
    55f6:	d5 01       	movw	r26, r10
    55f8:	c4 01       	movw	r24, r8
    55fa:	80 70       	andi	r24, 0x00	; 0
    55fc:	90 70       	andi	r25, 0x00	; 0
    55fe:	b0 70       	andi	r27, 0x00	; 0
    5600:	89 2f       	mov	r24, r25
    5602:	9a 2f       	mov	r25, r26
    5604:	ab 2f       	mov	r26, r27
    5606:	bb 27       	eor	r27, r27
    5608:	28 2b       	or	r18, r24
    560a:	39 2b       	or	r19, r25
    560c:	4a 2b       	or	r20, r26
    560e:	5b 2b       	or	r21, r27
    5610:	80 e0       	ldi	r24, 0x00	; 0
    5612:	9f ef       	ldi	r25, 0xFF	; 255
    5614:	a0 e0       	ldi	r26, 0x00	; 0
    5616:	b0 e0       	ldi	r27, 0x00	; 0
    5618:	88 22       	and	r8, r24
    561a:	99 22       	and	r9, r25
    561c:	aa 22       	and	r10, r26
    561e:	bb 22       	and	r11, r27
    5620:	ba 2d       	mov	r27, r10
    5622:	a9 2d       	mov	r26, r9
    5624:	98 2d       	mov	r25, r8
    5626:	88 27       	eor	r24, r24
    5628:	28 2b       	or	r18, r24
    562a:	39 2b       	or	r19, r25
    562c:	4a 2b       	or	r20, r26
    562e:	5b 2b       	or	r21, r27
    5630:	2d 83       	std	Y+5, r18	; 0x05
    5632:	3e 83       	std	Y+6, r19	; 0x06
    5634:	4f 83       	std	Y+7, r20	; 0x07
    5636:	58 87       	std	Y+8, r21	; 0x08
  if (dPortData != 0)
    5638:	21 14       	cp	r2, r1
    563a:	31 04       	cpc	r3, r1
    563c:	11 f0       	breq	.+4      	; 0x5642 <configEepromSetConfig+0x100>
    buf.IPv4.remoteAdrData.port = dPortData;
    563e:	3a 86       	std	Y+10, r3	; 0x0a
    5640:	29 86       	std	Y+9, r2	; 0x09
  if (dIpConfig != 0)
    5642:	41 14       	cp	r4, r1
    5644:	51 04       	cpc	r5, r1
    5646:	61 04       	cpc	r6, r1
    5648:	71 04       	cpc	r7, r1
    564a:	69 f1       	breq	.+90     	; 0x56a6 <configEepromSetConfig+0x164>
    buf.IPv4.remoteAdrConfig.ip = htonl(dIpConfig);
    564c:	54 2d       	mov	r21, r4
    564e:	44 27       	eor	r20, r20
    5650:	33 27       	eor	r19, r19
    5652:	22 27       	eor	r18, r18
    5654:	87 2d       	mov	r24, r7
    5656:	99 27       	eor	r25, r25
    5658:	aa 27       	eor	r26, r26
    565a:	bb 27       	eor	r27, r27
    565c:	28 2b       	or	r18, r24
    565e:	39 2b       	or	r19, r25
    5660:	4a 2b       	or	r20, r26
    5662:	5b 2b       	or	r21, r27
    5664:	d3 01       	movw	r26, r6
    5666:	c2 01       	movw	r24, r4
    5668:	80 70       	andi	r24, 0x00	; 0
    566a:	90 70       	andi	r25, 0x00	; 0
    566c:	b0 70       	andi	r27, 0x00	; 0
    566e:	89 2f       	mov	r24, r25
    5670:	9a 2f       	mov	r25, r26
    5672:	ab 2f       	mov	r26, r27
    5674:	bb 27       	eor	r27, r27
    5676:	28 2b       	or	r18, r24
    5678:	39 2b       	or	r19, r25
    567a:	4a 2b       	or	r20, r26
    567c:	5b 2b       	or	r21, r27
    567e:	80 e0       	ldi	r24, 0x00	; 0
    5680:	9f ef       	ldi	r25, 0xFF	; 255
    5682:	a0 e0       	ldi	r26, 0x00	; 0
    5684:	b0 e0       	ldi	r27, 0x00	; 0
    5686:	48 22       	and	r4, r24
    5688:	59 22       	and	r5, r25
    568a:	6a 22       	and	r6, r26
    568c:	7b 22       	and	r7, r27
    568e:	b6 2d       	mov	r27, r6
    5690:	a5 2d       	mov	r26, r5
    5692:	94 2d       	mov	r25, r4
    5694:	88 27       	eor	r24, r24
    5696:	28 2b       	or	r18, r24
    5698:	39 2b       	or	r19, r25
    569a:	4a 2b       	or	r20, r26
    569c:	5b 2b       	or	r21, r27
    569e:	2b 87       	std	Y+11, r18	; 0x0b
    56a0:	3c 87       	std	Y+12, r19	; 0x0c
    56a2:	4d 87       	std	Y+13, r20	; 0x0d
    56a4:	5e 87       	std	Y+14, r21	; 0x0e
  if (dPortConfig != 0)
    56a6:	e1 14       	cp	r14, r1
    56a8:	f1 04       	cpc	r15, r1
    56aa:	11 f0       	breq	.+4      	; 0x56b0 <configEepromSetConfig+0x16e>
    buf.IPv4.remoteAdrConfig.port = dPortConfig;
    56ac:	f8 8a       	std	Y+16, r15	; 0x10
    56ae:	ef 86       	std	Y+15, r14	; 0x0f
  if (sPort != 0)
    56b0:	c1 14       	cp	r12, r1
    56b2:	d1 04       	cpc	r13, r1
    56b4:	11 f0       	breq	.+4      	; 0x56ba <configEepromSetConfig+0x178>
    buf.IPv4.localSrcPort = sPort;
    56b6:	da 8a       	std	Y+18, r13	; 0x12
    56b8:	c9 8a       	std	Y+17, r12	; 0x11
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    56ba:	80 e0       	ldi	r24, 0x00	; 0
    56bc:	94 e0       	ldi	r25, 0x04	; 4
    56be:	b8 01       	movw	r22, r16
    56c0:	4e e0       	ldi	r20, 0x0E	; 14
    56c2:	50 e0       	ldi	r21, 0x00	; 0
    56c4:	2c e2       	ldi	r18, 0x2C	; 44
    56c6:	39 e2       	ldi	r19, 0x29	; 41
    56c8:	0e 94 77 2e 	call	0x5cee	; 0x5cee <__eewr_block>
void EepromWriteConfig(void * baseadr, void * buf, uint8_t len)
{
  struct netCheckSum_t checksum;
  eeprom_write_block(buf, baseadr, len);

  checksum.positive = calculateCheckSum(buf, len);
    56cc:	c8 01       	movw	r24, r16
    56ce:	6e e0       	ldi	r22, 0x0E	; 14
    56d0:	70 e0       	ldi	r23, 0x00	; 0
    56d2:	0e 94 9b 1a 	call	0x3536	; 0x3536 <calculateCheckSum>
    56d6:	9a 83       	std	Y+2, r25	; 0x02
    56d8:	89 83       	std	Y+1, r24	; 0x01
  checksum.negative = ~checksum.positive;
    56da:	80 95       	com	r24
    56dc:	90 95       	com	r25
    56de:	9c 83       	std	Y+4, r25	; 0x04
    56e0:	8b 83       	std	Y+3, r24	; 0x03
    56e2:	8e e0       	ldi	r24, 0x0E	; 14
    56e4:	94 e0       	ldi	r25, 0x04	; 4
    56e6:	be 01       	movw	r22, r28
    56e8:	6f 5f       	subi	r22, 0xFF	; 255
    56ea:	7f 4f       	sbci	r23, 0xFF	; 255
    56ec:	44 e0       	ldi	r20, 0x04	; 4
    56ee:	50 e0       	ldi	r21, 0x00	; 0
    56f0:	2c e2       	ldi	r18, 0x2C	; 44
    56f2:	39 e2       	ldi	r19, 0x29	; 41
    56f4:	0e 94 77 2e 	call	0x5cee	; 0x5cee <__eewr_block>
  if (sPort != 0)
    buf.IPv4.localSrcPort = sPort;

  EepromWriteConfig((void*)CONFIG_EEPROM, &buf, sizeof(buf));
  return;
}
    56f8:	62 96       	adiw	r28, 0x12	; 18
    56fa:	0f b6       	in	r0, 0x3f	; 63
    56fc:	f8 94       	cli
    56fe:	de bf       	out	0x3e, r29	; 62
    5700:	0f be       	out	0x3f, r0	; 63
    5702:	cd bf       	out	0x3d, r28	; 61
    5704:	cf 91       	pop	r28
    5706:	df 91       	pop	r29
    5708:	1f 91       	pop	r17
    570a:	0f 91       	pop	r16
    570c:	ff 90       	pop	r15
    570e:	ef 90       	pop	r14
    5710:	df 90       	pop	r13
    5712:	cf 90       	pop	r12
    5714:	bf 90       	pop	r11
    5716:	af 90       	pop	r10
    5718:	9f 90       	pop	r9
    571a:	8f 90       	pop	r8
    571c:	7f 90       	pop	r7
    571e:	6f 90       	pop	r6
    5720:	5f 90       	pop	r5
    5722:	4f 90       	pop	r4
    5724:	3f 90       	pop	r3
    5726:	2f 90       	pop	r2
    5728:	08 95       	ret
  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    return 0; // read config failed (bad checksum)

  // as they are interlocked, it's time to proove the checksum
  if (calculateCheckSum(buf,len) != checksum.positive)
    572a:	c8 01       	movw	r24, r16
    572c:	6e e0       	ldi	r22, 0x0E	; 14
    572e:	70 e0       	ldi	r23, 0x00	; 0
    5730:	0e 94 9b 1a 	call	0x3536	; 0x3536 <calculateCheckSum>
    5734:	29 81       	ldd	r18, Y+1	; 0x01
    5736:	3a 81       	ldd	r19, Y+2	; 0x02
    5738:	82 17       	cp	r24, r18
    573a:	93 07       	cpc	r25, r19
    573c:	09 f0       	breq	.+2      	; 0x5740 <configEepromSetConfig+0x1fe>
    573e:	42 cf       	rjmp	.-380    	; 0x55c4 <configEepromSetConfig+0x82>
    5740:	49 cf       	rjmp	.-366    	; 0x55d4 <configEepromSetConfig+0x92>

00005742 <onInitConfig>:
// global settings which are needed in more than one module
// e.g. Config.IPv4 is needed in "serialbridge" and "rcfg"
Config_t Config;

void onInitConfig()
{
    5742:	df 93       	push	r29
    5744:	cf 93       	push	r28
    5746:	00 d0       	rcall	.+0      	; 0x5748 <onInitConfig+0x6>
    5748:	00 d0       	rcall	.+0      	; 0x574a <onInitConfig+0x8>
    574a:	cd b7       	in	r28, 0x3d	; 61
    574c:	de b7       	in	r29, 0x3e	; 62
uint8_t EepromReadConfig(void * baseadr, void * buf, uint8_t len)
{
  struct netCheckSum_t checksum;

  // wait for eeprom
  while (eeprom_is_ready() == 0);
    574e:	e1 99       	sbic	0x1c, 1	; 28
    5750:	fe cf       	rjmp	.-4      	; 0x574e <onInitConfig+0xc>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    5752:	8a e2       	ldi	r24, 0x2A	; 42
    5754:	99 e0       	ldi	r25, 0x09	; 9
    5756:	60 e0       	ldi	r22, 0x00	; 0
    5758:	74 e0       	ldi	r23, 0x04	; 4
    575a:	4e e0       	ldi	r20, 0x0E	; 14
    575c:	50 e0       	ldi	r21, 0x00	; 0
    575e:	24 e2       	ldi	r18, 0x24	; 36
    5760:	39 e2       	ldi	r19, 0x29	; 41
    5762:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
  // read config and checksum
  eeprom_read_block(buf,baseadr,len);
  eeprom_read_block(&checksum,baseadr+len,sizeof(checksum));

  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    5766:	ce 01       	movw	r24, r28
    5768:	01 96       	adiw	r24, 0x01	; 1
    576a:	6e e0       	ldi	r22, 0x0E	; 14
    576c:	74 e0       	ldi	r23, 0x04	; 4
    576e:	44 e0       	ldi	r20, 0x04	; 4
    5770:	50 e0       	ldi	r21, 0x00	; 0
    5772:	24 e2       	ldi	r18, 0x24	; 36
    5774:	39 e2       	ldi	r19, 0x29	; 41
    5776:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <__eerd_block>
    577a:	8b 81       	ldd	r24, Y+3	; 0x03
    577c:	9c 81       	ldd	r25, Y+4	; 0x04
    577e:	80 95       	com	r24
    5780:	90 95       	com	r25
    5782:	29 81       	ldd	r18, Y+1	; 0x01
    5784:	3a 81       	ldd	r19, Y+2	; 0x02
    5786:	28 17       	cp	r18, r24
    5788:	39 07       	cpc	r19, r25
    578a:	69 f1       	breq	.+90     	; 0x57e6 <onInitConfig+0xa4>
Config_t Config;

void onInitConfig()
{
  if ( !EepromReadConfig((void *)CONFIG_EEPROM, &Config.IPv4, sizeof(Config.IPv4)) ) {
    Config.IPv4.remoteAdrData.ip = IP4_REMOTE_HOST_DATA;
    578c:	21 e8       	ldi	r18, 0x81	; 129
    578e:	35 e4       	ldi	r19, 0x45	; 69
    5790:	40 eb       	ldi	r20, 0xB0	; 176
    5792:	5d e7       	ldi	r21, 0x7D	; 125
    5794:	20 93 2a 09 	sts	0x092A, r18
    5798:	30 93 2b 09 	sts	0x092B, r19
    579c:	40 93 2c 09 	sts	0x092C, r20
    57a0:	50 93 2d 09 	sts	0x092D, r21
    Config.IPv4.remoteAdrData.port = IP4_REMOTE_PORT_DATA;
    57a4:	81 e6       	ldi	r24, 0x61	; 97
    57a6:	9e e1       	ldi	r25, 0x1E	; 30
    57a8:	90 93 2f 09 	sts	0x092F, r25
    57ac:	80 93 2e 09 	sts	0x092E, r24
    Config.IPv4.remoteAdrConfig.ip = IP4_REMOTE_HOST_CONFIG;
    57b0:	20 93 30 09 	sts	0x0930, r18
    57b4:	30 93 31 09 	sts	0x0931, r19
    57b8:	40 93 32 09 	sts	0x0932, r20
    57bc:	50 93 33 09 	sts	0x0933, r21
    Config.IPv4.remoteAdrConfig.port = IP4_REMOTE_PORT_CONFIG;
    57c0:	82 e6       	ldi	r24, 0x62	; 98
    57c2:	9e e1       	ldi	r25, 0x1E	; 30
    57c4:	90 93 35 09 	sts	0x0935, r25
    57c8:	80 93 34 09 	sts	0x0934, r24
    Config.IPv4.localSrcPort = 55042;
    57cc:	82 e0       	ldi	r24, 0x02	; 2
    57ce:	97 ed       	ldi	r25, 0xD7	; 215
    57d0:	90 93 37 09 	sts	0x0937, r25
    57d4:	80 93 36 09 	sts	0x0936, r24
  }
}
    57d8:	0f 90       	pop	r0
    57da:	0f 90       	pop	r0
    57dc:	0f 90       	pop	r0
    57de:	0f 90       	pop	r0
    57e0:	cf 91       	pop	r28
    57e2:	df 91       	pop	r29
    57e4:	08 95       	ret
  // before calculating the checksum, we check if they are interlocked
  if (checksum.positive != ~checksum.negative)
    return 0; // read config failed (bad checksum)

  // as they are interlocked, it's time to proove the checksum
  if (calculateCheckSum(buf,len) != checksum.positive)
    57e6:	8a e2       	ldi	r24, 0x2A	; 42
    57e8:	99 e0       	ldi	r25, 0x09	; 9
    57ea:	6e e0       	ldi	r22, 0x0E	; 14
    57ec:	70 e0       	ldi	r23, 0x00	; 0
    57ee:	0e 94 9b 1a 	call	0x3536	; 0x3536 <calculateCheckSum>
    57f2:	29 81       	ldd	r18, Y+1	; 0x01
    57f4:	3a 81       	ldd	r19, Y+2	; 0x02
    57f6:	82 17       	cp	r24, r18
    57f8:	93 07       	cpc	r25, r19
    57fa:	41 f6       	brne	.-112    	; 0x578c <onInitConfig+0x4a>
    57fc:	ed cf       	rjmp	.-38     	; 0x57d8 <onInitConfig+0x96>

000057fe <com1Initialize>:
// Initialisierungen
//------------------------------------------------------------------------
void com1Initialize(uint16_t baud, uint8_t settings)
{

	DDRD |= (1<<PD2);	//PD2 =0 eingang (RXD)		0100
    57fe:	8a 9a       	sbi	0x11, 2	; 17
	DDRD &= ~(1<<PD3);		//PD3 =1 ausgang (TXD)
    5800:	8b 98       	cbi	0x11, 3	; 17



	PORTD |= (1<<PD2);	//PD0 ist eingang --> pullup hoch
    5802:	92 9a       	sbi	0x12, 2	; 18
	

	// UART initialisieren

 // disable double speed, as we don't need it 
    UCSR1A &= ~(1 << U2X0);
    5804:	eb e9       	ldi	r30, 0x9B	; 155
    5806:	f0 e0       	ldi	r31, 0x00	; 0
    5808:	80 81       	ld	r24, Z
    580a:	8d 7f       	andi	r24, 0xFD	; 253
    580c:	80 83       	st	Z, r24

	UBRR1L=(uint8_t)(F_CPU/(BAUD*16L))-1; 	// Baudrate festlegen
    580e:	87 e0       	ldi	r24, 0x07	; 7
    5810:	80 93 99 00 	sts	0x0099, r24
	UBRR1H=(uint8_t)((F_CPU/(BAUD*16L))-1)>>8; 	// Baudrate festlegen
    5814:	10 92 98 00 	sts	0x0098, r1

//	UBRR1L=7; 	// Baudrate festlegen
//	UBRR1H=7>>8; 	// Baudrate festlegen


	UCSR1B =(1<<RXCIE)|(1<<TXCIE)|(1<<UDRIE)|(1<<RXEN)|(1<<TXEN);
    5818:	88 ef       	ldi	r24, 0xF8	; 248
    581a:	80 93 9a 00 	sts	0x009A, r24
	UCSR1C =(1<<UCSZ1)|(1<<UCSZ0);
    581e:	86 e0       	ldi	r24, 0x06	; 6
    5820:	80 93 9d 00 	sts	0x009D, r24


	TCCR0=0x05; 	// Teiler 1/1024
    5824:	85 e0       	ldi	r24, 0x05	; 5
    5826:	83 bf       	out	0x33, r24	; 51
	TIMSK|=1; 	// Interrupt bei berlauf
    5828:	87 b7       	in	r24, 0x37	; 55
    582a:	81 60       	ori	r24, 0x01	; 1
    582c:	87 bf       	out	0x37, r24	; 55

com1_recv.recvCount = com1_recv.recvBuffer;
    582e:	82 e6       	ldi	r24, 0x62	; 98
    5830:	99 e0       	ldi	r25, 0x09	; 9
    5832:	90 93 8b 09 	sts	0x098B, r25
    5836:	80 93 8a 09 	sts	0x098A, r24

}
    583a:	08 95       	ret

0000583c <putChar>:
// Funktion 	: ...
// IN  	 	: char data
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
    583c:	98 2f       	mov	r25, r24
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    583e:	80 91 9b 00 	lds	r24, 0x009B
    5842:	85 ff       	sbrs	r24, 5
    5844:	fc cf       	rjmp	.-8      	; 0x583e <putChar+0x2>
	//sende
	UDR1=data;
    5846:	90 93 9c 00 	sts	0x009C, r25
}
    584a:	08 95       	ret

0000584c <getChar>:
// OUT 	 	: data
//----------------------------------------------------------------------
char getChar()
{
	//warte bis RX-complete RXC UCSRA / USR bei z.B.: AT090S2313
	while (!(UCSR1A&128));
    584c:	80 91 9b 00 	lds	r24, 0x009B
    5850:	87 ff       	sbrs	r24, 7
    5852:	fc cf       	rjmp	.-8      	; 0x584c <getChar>
	//empfangen
	;

	return UDR1;
    5854:	80 91 9c 00 	lds	r24, 0x009C
}
    5858:	08 95       	ret

0000585a <__vector_31>:

//--------------------------------------------------------------------
// USART_UDRE_vect - UART Interrupt bei Senderegister leer
//--------------------------------------------------------------------
ISR(USART1_UDRE_vect)
{
    585a:	1f 92       	push	r1
    585c:	0f 92       	push	r0
    585e:	0f b6       	in	r0, 0x3f	; 63
    5860:	0f 92       	push	r0
    5862:	0b b6       	in	r0, 0x3b	; 59
    5864:	0f 92       	push	r0
    5866:	11 24       	eor	r1, r1
    5868:	8f 93       	push	r24
    586a:	ef 93       	push	r30
    586c:	ff 93       	push	r31
	UCSR1B &= ~ (1 << UDRIE1);
    586e:	ea e9       	ldi	r30, 0x9A	; 154
    5870:	f0 e0       	ldi	r31, 0x00	; 0
    5872:	80 81       	ld	r24, Z
    5874:	8f 7d       	andi	r24, 0xDF	; 223
    5876:	80 83       	st	Z, r24
}
    5878:	ff 91       	pop	r31
    587a:	ef 91       	pop	r30
    587c:	8f 91       	pop	r24
    587e:	0f 90       	pop	r0
    5880:	0b be       	out	0x3b, r0	; 59
    5882:	0f 90       	pop	r0
    5884:	0f be       	out	0x3f, r0	; 63
    5886:	0f 90       	pop	r0
    5888:	1f 90       	pop	r1
    588a:	18 95       	reti

0000588c <__vector_32>:

//--------------------------------------------------------------------
// USART_TXC_vect - UART Interrupt bei Sendevorgang beendet
//--------------------------------------------------------------------
ISR(USART1_TX_vect)
{
    588c:	1f 92       	push	r1
    588e:	0f 92       	push	r0
    5890:	0f b6       	in	r0, 0x3f	; 63
    5892:	0f 92       	push	r0
    5894:	11 24       	eor	r1, r1
	
}
    5896:	0f 90       	pop	r0
    5898:	0f be       	out	0x3f, r0	; 63
    589a:	0f 90       	pop	r0
    589c:	1f 90       	pop	r1
    589e:	18 95       	reti

000058a0 <putString>:
// Funktion 	: ...
// IN  	 	: char *buffer, Zeichenkette mit NUll abgeschlossen
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString(char *buffer)
{
    58a0:	fc 01       	movw	r30, r24
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    58a2:	90 81       	ld	r25, Z
    58a4:	99 23       	and	r25, r25
    58a6:	51 f0       	breq	.+20     	; 0x58bc <putString+0x1c>
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    58a8:	80 91 9b 00 	lds	r24, 0x009B
    58ac:	85 ff       	sbrs	r24, 5
    58ae:	fc cf       	rjmp	.-8      	; 0x58a8 <putString+0x8>
	//sende
	UDR1=data;
    58b0:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    58b4:	91 81       	ldd	r25, Z+1	; 0x01
    58b6:	31 96       	adiw	r30, 0x01	; 1
    58b8:	99 23       	and	r25, r25
    58ba:	b1 f7       	brne	.-20     	; 0x58a8 <putString+0x8>
    58bc:	08 95       	ret

000058be <ExecuteCommand>:

}


void ExecuteCommand(char* command,uint8_t len)
{
    58be:	1f 93       	push	r17
    58c0:	cf 93       	push	r28
    58c2:	df 93       	push	r29
    58c4:	ec 01       	movw	r28, r24
    58c6:	16 2f       	mov	r17, r22
	if(strcmp(command,"hallo")==0)
    58c8:	6d e8       	ldi	r22, 0x8D	; 141
    58ca:	77 e0       	ldi	r23, 0x07	; 7
    58cc:	0e 94 4b 2e 	call	0x5c96	; 0x5c96 <strcmp>
    58d0:	00 97       	sbiw	r24, 0x00	; 0
    58d2:	b1 f4       	brne	.+44     	; 0x5900 <ExecuteCommand+0x42>
    58d4:	e4 e9       	ldi	r30, 0x94	; 148
    58d6:	f7 e0       	ldi	r31, 0x07	; 7
    58d8:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    58da:	80 91 9b 00 	lds	r24, 0x009B
    58de:	85 ff       	sbrs	r24, 5
    58e0:	fc cf       	rjmp	.-8      	; 0x58da <ExecuteCommand+0x1c>
	//sende
	UDR1=data;
    58e2:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    58e6:	91 91       	ld	r25, Z+
    58e8:	99 23       	and	r25, r25
    58ea:	b9 f7       	brne	.-18     	; 0x58da <ExecuteCommand+0x1c>
void ExecuteCommand(char* command,uint8_t len)
{
	if(strcmp(command,"hallo")==0)
	{
		putString("Befehl erfolgreich dekodiert");
		debug=0;
    58ec:	10 92 e4 07 	sts	0x07E4, r1
    58f0:	10 92 e3 07 	sts	0x07E3, r1
		DebugTimerList();
    58f4:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <DebugTimerList>
	 	 CommandBuffer.NewCommand=1;
		strcpy(CommandBuffer.recvCommand,command);
		CommandBuffer.len=len;
	}

}
    58f8:	df 91       	pop	r29
    58fa:	cf 91       	pop	r28
    58fc:	1f 91       	pop	r17
    58fe:	08 95       	ret
	{
		putString("Befehl erfolgreich dekodiert");
		debug=0;
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
    5900:	ce 01       	movw	r24, r28
    5902:	60 eb       	ldi	r22, 0xB0	; 176
    5904:	77 e0       	ldi	r23, 0x07	; 7
    5906:	0e 94 4b 2e 	call	0x5c96	; 0x5c96 <strcmp>
    590a:	00 97       	sbiw	r24, 0x00	; 0
    590c:	b1 f4       	brne	.+44     	; 0x593a <ExecuteCommand+0x7c>
    590e:	e7 eb       	ldi	r30, 0xB7	; 183
    5910:	f7 e0       	ldi	r31, 0x07	; 7
    5912:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5914:	80 91 9b 00 	lds	r24, 0x009B
    5918:	85 ff       	sbrs	r24, 5
    591a:	fc cf       	rjmp	.-8      	; 0x5914 <ExecuteCommand+0x56>
	//sende
	UDR1=data;
    591c:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5920:	91 91       	ld	r25, Z+
    5922:	99 23       	and	r25, r25
    5924:	b9 f7       	brne	.-18     	; 0x5914 <ExecuteCommand+0x56>
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
	{
		putString("Befehl2 erfolgreich dekodiert");
		debug=1;
    5926:	81 e0       	ldi	r24, 0x01	; 1
    5928:	90 e0       	ldi	r25, 0x00	; 0
    592a:	90 93 e4 07 	sts	0x07E4, r25
    592e:	80 93 e3 07 	sts	0x07E3, r24
	 	 CommandBuffer.NewCommand=1;
		strcpy(CommandBuffer.recvCommand,command);
		CommandBuffer.len=len;
	}

}
    5932:	df 91       	pop	r29
    5934:	cf 91       	pop	r28
    5936:	1f 91       	pop	r17
    5938:	08 95       	ret
		debug=1;
	}

	else
	{
	 	 CommandBuffer.NewCommand=1;
    593a:	81 e0       	ldi	r24, 0x01	; 1
    593c:	80 93 60 09 	sts	0x0960, r24
		strcpy(CommandBuffer.recvCommand,command);
    5940:	88 e3       	ldi	r24, 0x38	; 56
    5942:	99 e0       	ldi	r25, 0x09	; 9
    5944:	be 01       	movw	r22, r28
    5946:	0e 94 54 2e 	call	0x5ca8	; 0x5ca8 <strcpy>
		CommandBuffer.len=len;
    594a:	10 93 61 09 	sts	0x0961, r17
    594e:	d4 cf       	rjmp	.-88     	; 0x58f8 <ExecuteCommand+0x3a>

00005950 <__vector_30>:

//--------------------------------------------------------------------
// USART_RXC_vect - UART Interrupt bei Datenempfang komplett
//--------------------------------------------------------------------
ISR(USART1_RX_vect)
{
    5950:	1f 92       	push	r1
    5952:	0f 92       	push	r0
    5954:	0f b6       	in	r0, 0x3f	; 63
    5956:	0f 92       	push	r0
    5958:	0b b6       	in	r0, 0x3b	; 59
    595a:	0f 92       	push	r0
    595c:	11 24       	eor	r1, r1
    595e:	1f 93       	push	r17
    5960:	2f 93       	push	r18
    5962:	3f 93       	push	r19
    5964:	4f 93       	push	r20
    5966:	5f 93       	push	r21
    5968:	6f 93       	push	r22
    596a:	7f 93       	push	r23
    596c:	8f 93       	push	r24
    596e:	9f 93       	push	r25
    5970:	af 93       	push	r26
    5972:	bf 93       	push	r27
    5974:	cf 93       	push	r28
    5976:	df 93       	push	r29
    5978:	ef 93       	push	r30
    597a:	ff 93       	push	r31
// OUT 	 	: data
//----------------------------------------------------------------------
char getChar()
{
	//warte bis RX-complete RXC UCSRA / USR bei z.B.: AT090S2313
	while (!(UCSR1A&128));
    597c:	80 91 9b 00 	lds	r24, 0x009B
    5980:	87 ff       	sbrs	r24, 7
    5982:	fc cf       	rjmp	.-8      	; 0x597c <__vector_30+0x2c>
	//empfangen
	;

	return UDR1;
    5984:	90 91 9c 00 	lds	r25, 0x009C
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5988:	80 91 9b 00 	lds	r24, 0x009B
    598c:	85 ff       	sbrs	r24, 5
    598e:	fc cf       	rjmp	.-8      	; 0x5988 <__vector_30+0x38>
	//sende
	UDR1=data;
    5990:	90 93 9c 00 	sts	0x009C, r25

	char x=getChar();
	putChar(x);


	if(x != 0xD)	//einfaches newline testen
    5994:	9d 30       	cpi	r25, 0x0D	; 13
    5996:	21 f1       	breq	.+72     	; 0x59e0 <__vector_30+0x90>
	{
		
		// Save the received byte...
	    com1_recv.recvCount[0] = x;
    5998:	e0 91 8a 09 	lds	r30, 0x098A
    599c:	f0 91 8b 09 	lds	r31, 0x098B
    59a0:	90 83       	st	Z, r25
  
	    // increase our helper...
	    com1_recv.recvCount++;
    59a2:	80 91 8a 09 	lds	r24, 0x098A
    59a6:	90 91 8b 09 	lds	r25, 0x098B
    59aa:	01 96       	adiw	r24, 0x01	; 1
    59ac:	90 93 8b 09 	sts	0x098B, r25
    59b0:	80 93 8a 09 	sts	0x098A, r24
		com1_recv.recvCount = com1_recv.recvBuffer;

	
	}

}
    59b4:	ff 91       	pop	r31
    59b6:	ef 91       	pop	r30
    59b8:	df 91       	pop	r29
    59ba:	cf 91       	pop	r28
    59bc:	bf 91       	pop	r27
    59be:	af 91       	pop	r26
    59c0:	9f 91       	pop	r25
    59c2:	8f 91       	pop	r24
    59c4:	7f 91       	pop	r23
    59c6:	6f 91       	pop	r22
    59c8:	5f 91       	pop	r21
    59ca:	4f 91       	pop	r20
    59cc:	3f 91       	pop	r19
    59ce:	2f 91       	pop	r18
    59d0:	1f 91       	pop	r17
    59d2:	0f 90       	pop	r0
    59d4:	0b be       	out	0x3b, r0	; 59
    59d6:	0f 90       	pop	r0
    59d8:	0f be       	out	0x3f, r0	; 63
    59da:	0f 90       	pop	r0
    59dc:	1f 90       	pop	r1
    59de:	18 95       	reti
		
	}
	else 
	{

		com1_recv.recvCount[0] = '\0';
    59e0:	e0 91 8a 09 	lds	r30, 0x098A
    59e4:	f0 91 8b 09 	lds	r31, 0x098B
    59e8:	10 82       	st	Z, r1

		ExecuteCommand(com1_recv.recvBuffer,com1_recv.recvCount-com1_recv.recvBuffer);
    59ea:	10 91 8a 09 	lds	r17, 0x098A
}


void ExecuteCommand(char* command,uint8_t len)
{
	if(strcmp(command,"hallo")==0)
    59ee:	c2 e6       	ldi	r28, 0x62	; 98
    59f0:	d9 e0       	ldi	r29, 0x09	; 9
    59f2:	ce 01       	movw	r24, r28
    59f4:	6d e8       	ldi	r22, 0x8D	; 141
    59f6:	77 e0       	ldi	r23, 0x07	; 7
    59f8:	0e 94 4b 2e 	call	0x5c96	; 0x5c96 <strcmp>
    59fc:	00 97       	sbiw	r24, 0x00	; 0
    59fe:	19 f5       	brne	.+70     	; 0x5a46 <__vector_30+0xf6>
    5a00:	e4 e9       	ldi	r30, 0x94	; 148
    5a02:	f7 e0       	ldi	r31, 0x07	; 7
    5a04:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5a06:	80 91 9b 00 	lds	r24, 0x009B
    5a0a:	85 ff       	sbrs	r24, 5
    5a0c:	fc cf       	rjmp	.-8      	; 0x5a06 <__vector_30+0xb6>
	//sende
	UDR1=data;
    5a0e:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5a12:	91 91       	ld	r25, Z+
    5a14:	99 23       	and	r25, r25
    5a16:	b9 f7       	brne	.-18     	; 0x5a06 <__vector_30+0xb6>
void ExecuteCommand(char* command,uint8_t len)
{
	if(strcmp(command,"hallo")==0)
	{
		putString("Befehl erfolgreich dekodiert");
		debug=0;
    5a18:	10 92 e4 07 	sts	0x07E4, r1
    5a1c:	10 92 e3 07 	sts	0x07E3, r1
		DebugTimerList();
    5a20:	0e 94 11 0e 	call	0x1c22	; 0x1c22 <DebugTimerList>

	else
	{
	 	 CommandBuffer.NewCommand=1;
		strcpy(CommandBuffer.recvCommand,command);
		CommandBuffer.len=len;
    5a24:	e5 ed       	ldi	r30, 0xD5	; 213
    5a26:	f7 e0       	ldi	r31, 0x07	; 7
    5a28:	9e e6       	ldi	r25, 0x6E	; 110
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5a2a:	80 91 9b 00 	lds	r24, 0x009B
    5a2e:	85 ff       	sbrs	r24, 5
    5a30:	fc cf       	rjmp	.-8      	; 0x5a2a <__vector_30+0xda>
	//sende
	UDR1=data;
    5a32:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5a36:	91 91       	ld	r25, Z+
    5a38:	99 23       	and	r25, r25
    5a3a:	b9 f7       	brne	.-18     	; 0x5a2a <__vector_30+0xda>
		ExecuteCommand(com1_recv.recvBuffer,com1_recv.recvCount-com1_recv.recvBuffer);
	
	
		putString("nix\r\n");

		com1_recv.recvCount = com1_recv.recvBuffer;
    5a3c:	d0 93 8b 09 	sts	0x098B, r29
    5a40:	c0 93 8a 09 	sts	0x098A, r28
    5a44:	b7 cf       	rjmp	.-146    	; 0x59b4 <__vector_30+0x64>
	{
		putString("Befehl erfolgreich dekodiert");
		debug=0;
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
    5a46:	ce 01       	movw	r24, r28
    5a48:	60 eb       	ldi	r22, 0xB0	; 176
    5a4a:	77 e0       	ldi	r23, 0x07	; 7
    5a4c:	0e 94 4b 2e 	call	0x5c96	; 0x5c96 <strcmp>
    5a50:	00 97       	sbiw	r24, 0x00	; 0
    5a52:	99 f4       	brne	.+38     	; 0x5a7a <__vector_30+0x12a>
    5a54:	e7 eb       	ldi	r30, 0xB7	; 183
    5a56:	f7 e0       	ldi	r31, 0x07	; 7
    5a58:	92 e4       	ldi	r25, 0x42	; 66
// OUT 	 	: ...
//----------------------------------------------------------------------
void putChar(char data)
{
	//warte bis UDR leer ist UCSRA / USR bei z.B.: 2313
	while (!(UCSR1A&32));
    5a5a:	80 91 9b 00 	lds	r24, 0x009B
    5a5e:	85 ff       	sbrs	r24, 5
    5a60:	fc cf       	rjmp	.-8      	; 0x5a5a <__vector_30+0x10a>
	//sende
	UDR1=data;
    5a62:	90 93 9c 00 	sts	0x009C, r25
// OUT 	 	: ...
//----------------------------------------------------------------------
void putString(char *buffer)
{
int i=0;
	for (i=0; buffer[i] !=0;i++) putChar (buffer[i]);
    5a66:	91 91       	ld	r25, Z+
    5a68:	99 23       	and	r25, r25
    5a6a:	b9 f7       	brne	.-18     	; 0x5a5a <__vector_30+0x10a>
		DebugTimerList();
	}
	else if(strcmp(command,"nicht")==0)
	{
		putString("Befehl2 erfolgreich dekodiert");
		debug=1;
    5a6c:	81 e0       	ldi	r24, 0x01	; 1
    5a6e:	90 e0       	ldi	r25, 0x00	; 0
    5a70:	90 93 e4 07 	sts	0x07E4, r25
    5a74:	80 93 e3 07 	sts	0x07E3, r24
    5a78:	d5 cf       	rjmp	.-86     	; 0x5a24 <__vector_30+0xd4>
	}

	else
	{
	 	 CommandBuffer.NewCommand=1;
    5a7a:	81 e0       	ldi	r24, 0x01	; 1
    5a7c:	80 93 60 09 	sts	0x0960, r24
		strcpy(CommandBuffer.recvCommand,command);
    5a80:	88 e3       	ldi	r24, 0x38	; 56
    5a82:	99 e0       	ldi	r25, 0x09	; 9
    5a84:	be 01       	movw	r22, r28
    5a86:	0e 94 54 2e 	call	0x5ca8	; 0x5ca8 <strcpy>
		CommandBuffer.len=len;
    5a8a:	1c 1b       	sub	r17, r28
    5a8c:	10 93 61 09 	sts	0x0961, r17
    5a90:	c9 cf       	rjmp	.-110    	; 0x5a24 <__vector_30+0xd4>

00005a92 <malloc>:
    5a92:	cf 93       	push	r28
    5a94:	df 93       	push	r29
    5a96:	bc 01       	movw	r22, r24
    5a98:	82 30       	cpi	r24, 0x02	; 2
    5a9a:	91 05       	cpc	r25, r1
    5a9c:	10 f4       	brcc	.+4      	; 0x5aa2 <malloc+0x10>
    5a9e:	62 e0       	ldi	r22, 0x02	; 2
    5aa0:	70 e0       	ldi	r23, 0x00	; 0
    5aa2:	a0 91 8e 09 	lds	r26, 0x098E
    5aa6:	b0 91 8f 09 	lds	r27, 0x098F
    5aaa:	ed 01       	movw	r28, r26
    5aac:	e0 e0       	ldi	r30, 0x00	; 0
    5aae:	f0 e0       	ldi	r31, 0x00	; 0
    5ab0:	40 e0       	ldi	r20, 0x00	; 0
    5ab2:	50 e0       	ldi	r21, 0x00	; 0
    5ab4:	21 c0       	rjmp	.+66     	; 0x5af8 <malloc+0x66>
    5ab6:	88 81       	ld	r24, Y
    5ab8:	99 81       	ldd	r25, Y+1	; 0x01
    5aba:	86 17       	cp	r24, r22
    5abc:	97 07       	cpc	r25, r23
    5abe:	69 f4       	brne	.+26     	; 0x5ada <malloc+0x48>
    5ac0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ac2:	9b 81       	ldd	r25, Y+3	; 0x03
    5ac4:	30 97       	sbiw	r30, 0x00	; 0
    5ac6:	19 f0       	breq	.+6      	; 0x5ace <malloc+0x3c>
    5ac8:	93 83       	std	Z+3, r25	; 0x03
    5aca:	82 83       	std	Z+2, r24	; 0x02
    5acc:	04 c0       	rjmp	.+8      	; 0x5ad6 <malloc+0x44>
    5ace:	90 93 8f 09 	sts	0x098F, r25
    5ad2:	80 93 8e 09 	sts	0x098E, r24
    5ad6:	fe 01       	movw	r30, r28
    5ad8:	34 c0       	rjmp	.+104    	; 0x5b42 <malloc+0xb0>
    5ada:	68 17       	cp	r22, r24
    5adc:	79 07       	cpc	r23, r25
    5ade:	38 f4       	brcc	.+14     	; 0x5aee <malloc+0x5c>
    5ae0:	41 15       	cp	r20, r1
    5ae2:	51 05       	cpc	r21, r1
    5ae4:	19 f0       	breq	.+6      	; 0x5aec <malloc+0x5a>
    5ae6:	84 17       	cp	r24, r20
    5ae8:	95 07       	cpc	r25, r21
    5aea:	08 f4       	brcc	.+2      	; 0x5aee <malloc+0x5c>
    5aec:	ac 01       	movw	r20, r24
    5aee:	fe 01       	movw	r30, r28
    5af0:	8a 81       	ldd	r24, Y+2	; 0x02
    5af2:	9b 81       	ldd	r25, Y+3	; 0x03
    5af4:	9c 01       	movw	r18, r24
    5af6:	e9 01       	movw	r28, r18
    5af8:	20 97       	sbiw	r28, 0x00	; 0
    5afa:	e9 f6       	brne	.-70     	; 0x5ab6 <malloc+0x24>
    5afc:	41 15       	cp	r20, r1
    5afe:	51 05       	cpc	r21, r1
    5b00:	a9 f1       	breq	.+106    	; 0x5b6c <malloc+0xda>
    5b02:	ca 01       	movw	r24, r20
    5b04:	86 1b       	sub	r24, r22
    5b06:	97 0b       	sbc	r25, r23
    5b08:	04 97       	sbiw	r24, 0x04	; 4
    5b0a:	08 f4       	brcc	.+2      	; 0x5b0e <malloc+0x7c>
    5b0c:	ba 01       	movw	r22, r20
    5b0e:	e0 e0       	ldi	r30, 0x00	; 0
    5b10:	f0 e0       	ldi	r31, 0x00	; 0
    5b12:	2a c0       	rjmp	.+84     	; 0x5b68 <malloc+0xd6>
    5b14:	8d 91       	ld	r24, X+
    5b16:	9c 91       	ld	r25, X
    5b18:	11 97       	sbiw	r26, 0x01	; 1
    5b1a:	84 17       	cp	r24, r20
    5b1c:	95 07       	cpc	r25, r21
    5b1e:	f9 f4       	brne	.+62     	; 0x5b5e <malloc+0xcc>
    5b20:	64 17       	cp	r22, r20
    5b22:	75 07       	cpc	r23, r21
    5b24:	81 f4       	brne	.+32     	; 0x5b46 <malloc+0xb4>
    5b26:	12 96       	adiw	r26, 0x02	; 2
    5b28:	8d 91       	ld	r24, X+
    5b2a:	9c 91       	ld	r25, X
    5b2c:	13 97       	sbiw	r26, 0x03	; 3
    5b2e:	30 97       	sbiw	r30, 0x00	; 0
    5b30:	19 f0       	breq	.+6      	; 0x5b38 <malloc+0xa6>
    5b32:	93 83       	std	Z+3, r25	; 0x03
    5b34:	82 83       	std	Z+2, r24	; 0x02
    5b36:	04 c0       	rjmp	.+8      	; 0x5b40 <malloc+0xae>
    5b38:	90 93 8f 09 	sts	0x098F, r25
    5b3c:	80 93 8e 09 	sts	0x098E, r24
    5b40:	fd 01       	movw	r30, r26
    5b42:	32 96       	adiw	r30, 0x02	; 2
    5b44:	4c c0       	rjmp	.+152    	; 0x5bde <malloc+0x14c>
    5b46:	ca 01       	movw	r24, r20
    5b48:	86 1b       	sub	r24, r22
    5b4a:	97 0b       	sbc	r25, r23
    5b4c:	fd 01       	movw	r30, r26
    5b4e:	e8 0f       	add	r30, r24
    5b50:	f9 1f       	adc	r31, r25
    5b52:	61 93       	st	Z+, r22
    5b54:	71 93       	st	Z+, r23
    5b56:	02 97       	sbiw	r24, 0x02	; 2
    5b58:	8d 93       	st	X+, r24
    5b5a:	9c 93       	st	X, r25
    5b5c:	40 c0       	rjmp	.+128    	; 0x5bde <malloc+0x14c>
    5b5e:	fd 01       	movw	r30, r26
    5b60:	82 81       	ldd	r24, Z+2	; 0x02
    5b62:	93 81       	ldd	r25, Z+3	; 0x03
    5b64:	9c 01       	movw	r18, r24
    5b66:	d9 01       	movw	r26, r18
    5b68:	10 97       	sbiw	r26, 0x00	; 0
    5b6a:	a1 f6       	brne	.-88     	; 0x5b14 <malloc+0x82>
    5b6c:	80 91 8c 09 	lds	r24, 0x098C
    5b70:	90 91 8d 09 	lds	r25, 0x098D
    5b74:	89 2b       	or	r24, r25
    5b76:	41 f4       	brne	.+16     	; 0x5b88 <malloc+0xf6>
    5b78:	80 91 dc 07 	lds	r24, 0x07DC
    5b7c:	90 91 dd 07 	lds	r25, 0x07DD
    5b80:	90 93 8d 09 	sts	0x098D, r25
    5b84:	80 93 8c 09 	sts	0x098C, r24
    5b88:	40 91 de 07 	lds	r20, 0x07DE
    5b8c:	50 91 df 07 	lds	r21, 0x07DF
    5b90:	41 15       	cp	r20, r1
    5b92:	51 05       	cpc	r21, r1
    5b94:	41 f4       	brne	.+16     	; 0x5ba6 <malloc+0x114>
    5b96:	4d b7       	in	r20, 0x3d	; 61
    5b98:	5e b7       	in	r21, 0x3e	; 62
    5b9a:	80 91 da 07 	lds	r24, 0x07DA
    5b9e:	90 91 db 07 	lds	r25, 0x07DB
    5ba2:	48 1b       	sub	r20, r24
    5ba4:	59 0b       	sbc	r21, r25
    5ba6:	20 91 8c 09 	lds	r18, 0x098C
    5baa:	30 91 8d 09 	lds	r19, 0x098D
    5bae:	ca 01       	movw	r24, r20
    5bb0:	82 1b       	sub	r24, r18
    5bb2:	93 0b       	sbc	r25, r19
    5bb4:	86 17       	cp	r24, r22
    5bb6:	97 07       	cpc	r25, r23
    5bb8:	80 f0       	brcs	.+32     	; 0x5bda <malloc+0x148>
    5bba:	ab 01       	movw	r20, r22
    5bbc:	4e 5f       	subi	r20, 0xFE	; 254
    5bbe:	5f 4f       	sbci	r21, 0xFF	; 255
    5bc0:	84 17       	cp	r24, r20
    5bc2:	95 07       	cpc	r25, r21
    5bc4:	50 f0       	brcs	.+20     	; 0x5bda <malloc+0x148>
    5bc6:	42 0f       	add	r20, r18
    5bc8:	53 1f       	adc	r21, r19
    5bca:	50 93 8d 09 	sts	0x098D, r21
    5bce:	40 93 8c 09 	sts	0x098C, r20
    5bd2:	f9 01       	movw	r30, r18
    5bd4:	61 93       	st	Z+, r22
    5bd6:	71 93       	st	Z+, r23
    5bd8:	02 c0       	rjmp	.+4      	; 0x5bde <malloc+0x14c>
    5bda:	e0 e0       	ldi	r30, 0x00	; 0
    5bdc:	f0 e0       	ldi	r31, 0x00	; 0
    5bde:	cf 01       	movw	r24, r30
    5be0:	df 91       	pop	r29
    5be2:	cf 91       	pop	r28
    5be4:	08 95       	ret

00005be6 <free>:
    5be6:	cf 93       	push	r28
    5be8:	df 93       	push	r29
    5bea:	00 97       	sbiw	r24, 0x00	; 0
    5bec:	09 f4       	brne	.+2      	; 0x5bf0 <free+0xa>
    5bee:	50 c0       	rjmp	.+160    	; 0x5c90 <free+0xaa>
    5bf0:	ec 01       	movw	r28, r24
    5bf2:	22 97       	sbiw	r28, 0x02	; 2
    5bf4:	1b 82       	std	Y+3, r1	; 0x03
    5bf6:	1a 82       	std	Y+2, r1	; 0x02
    5bf8:	a0 91 8e 09 	lds	r26, 0x098E
    5bfc:	b0 91 8f 09 	lds	r27, 0x098F
    5c00:	10 97       	sbiw	r26, 0x00	; 0
    5c02:	09 f1       	breq	.+66     	; 0x5c46 <free+0x60>
    5c04:	40 e0       	ldi	r20, 0x00	; 0
    5c06:	50 e0       	ldi	r21, 0x00	; 0
    5c08:	ac 17       	cp	r26, r28
    5c0a:	bd 07       	cpc	r27, r29
    5c0c:	08 f1       	brcs	.+66     	; 0x5c50 <free+0x6a>
    5c0e:	bb 83       	std	Y+3, r27	; 0x03
    5c10:	aa 83       	std	Y+2, r26	; 0x02
    5c12:	fe 01       	movw	r30, r28
    5c14:	21 91       	ld	r18, Z+
    5c16:	31 91       	ld	r19, Z+
    5c18:	e2 0f       	add	r30, r18
    5c1a:	f3 1f       	adc	r31, r19
    5c1c:	ae 17       	cp	r26, r30
    5c1e:	bf 07       	cpc	r27, r31
    5c20:	79 f4       	brne	.+30     	; 0x5c40 <free+0x5a>
    5c22:	8d 91       	ld	r24, X+
    5c24:	9c 91       	ld	r25, X
    5c26:	11 97       	sbiw	r26, 0x01	; 1
    5c28:	28 0f       	add	r18, r24
    5c2a:	39 1f       	adc	r19, r25
    5c2c:	2e 5f       	subi	r18, 0xFE	; 254
    5c2e:	3f 4f       	sbci	r19, 0xFF	; 255
    5c30:	39 83       	std	Y+1, r19	; 0x01
    5c32:	28 83       	st	Y, r18
    5c34:	12 96       	adiw	r26, 0x02	; 2
    5c36:	8d 91       	ld	r24, X+
    5c38:	9c 91       	ld	r25, X
    5c3a:	13 97       	sbiw	r26, 0x03	; 3
    5c3c:	9b 83       	std	Y+3, r25	; 0x03
    5c3e:	8a 83       	std	Y+2, r24	; 0x02
    5c40:	41 15       	cp	r20, r1
    5c42:	51 05       	cpc	r21, r1
    5c44:	71 f4       	brne	.+28     	; 0x5c62 <free+0x7c>
    5c46:	d0 93 8f 09 	sts	0x098F, r29
    5c4a:	c0 93 8e 09 	sts	0x098E, r28
    5c4e:	20 c0       	rjmp	.+64     	; 0x5c90 <free+0xaa>
    5c50:	12 96       	adiw	r26, 0x02	; 2
    5c52:	8d 91       	ld	r24, X+
    5c54:	9c 91       	ld	r25, X
    5c56:	13 97       	sbiw	r26, 0x03	; 3
    5c58:	ad 01       	movw	r20, r26
    5c5a:	00 97       	sbiw	r24, 0x00	; 0
    5c5c:	11 f0       	breq	.+4      	; 0x5c62 <free+0x7c>
    5c5e:	dc 01       	movw	r26, r24
    5c60:	d3 cf       	rjmp	.-90     	; 0x5c08 <free+0x22>
    5c62:	fa 01       	movw	r30, r20
    5c64:	d3 83       	std	Z+3, r29	; 0x03
    5c66:	c2 83       	std	Z+2, r28	; 0x02
    5c68:	21 91       	ld	r18, Z+
    5c6a:	31 91       	ld	r19, Z+
    5c6c:	e2 0f       	add	r30, r18
    5c6e:	f3 1f       	adc	r31, r19
    5c70:	ce 17       	cp	r28, r30
    5c72:	df 07       	cpc	r29, r31
    5c74:	69 f4       	brne	.+26     	; 0x5c90 <free+0xaa>
    5c76:	88 81       	ld	r24, Y
    5c78:	99 81       	ldd	r25, Y+1	; 0x01
    5c7a:	28 0f       	add	r18, r24
    5c7c:	39 1f       	adc	r19, r25
    5c7e:	2e 5f       	subi	r18, 0xFE	; 254
    5c80:	3f 4f       	sbci	r19, 0xFF	; 255
    5c82:	fa 01       	movw	r30, r20
    5c84:	31 83       	std	Z+1, r19	; 0x01
    5c86:	20 83       	st	Z, r18
    5c88:	8a 81       	ldd	r24, Y+2	; 0x02
    5c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c8c:	93 83       	std	Z+3, r25	; 0x03
    5c8e:	82 83       	std	Z+2, r24	; 0x02
    5c90:	df 91       	pop	r29
    5c92:	cf 91       	pop	r28
    5c94:	08 95       	ret

00005c96 <strcmp>:
    5c96:	fb 01       	movw	r30, r22
    5c98:	dc 01       	movw	r26, r24
    5c9a:	8d 91       	ld	r24, X+
    5c9c:	01 90       	ld	r0, Z+
    5c9e:	80 19       	sub	r24, r0
    5ca0:	01 10       	cpse	r0, r1
    5ca2:	d9 f3       	breq	.-10     	; 0x5c9a <strcmp+0x4>
    5ca4:	99 0b       	sbc	r25, r25
    5ca6:	08 95       	ret

00005ca8 <strcpy>:
    5ca8:	fb 01       	movw	r30, r22
    5caa:	dc 01       	movw	r26, r24
    5cac:	01 90       	ld	r0, Z+
    5cae:	0d 92       	st	X+, r0
    5cb0:	00 20       	and	r0, r0
    5cb2:	e1 f7       	brne	.-8      	; 0x5cac <strcpy+0x4>
    5cb4:	08 95       	ret

00005cb6 <__eerd_block>:
    5cb6:	a0 e0       	ldi	r26, 0x00	; 0
    5cb8:	b0 e0       	ldi	r27, 0x00	; 0
    5cba:	e1 e6       	ldi	r30, 0x61	; 97
    5cbc:	fe e2       	ldi	r31, 0x2E	; 46
    5cbe:	0c 94 5e 2f 	jmp	0x5ebc	; 0x5ebc <__prologue_saves__+0x14>
    5cc2:	7c 01       	movw	r14, r24
    5cc4:	eb 01       	movw	r28, r22
    5cc6:	8a 01       	movw	r16, r20
    5cc8:	69 01       	movw	r12, r18
    5cca:	09 c0       	rjmp	.+18     	; 0x5cde <__eerd_block+0x28>
    5ccc:	ce 01       	movw	r24, r28
    5cce:	21 96       	adiw	r28, 0x01	; 1
    5cd0:	f6 01       	movw	r30, r12
    5cd2:	09 95       	icall
    5cd4:	f7 01       	movw	r30, r14
    5cd6:	81 93       	st	Z+, r24
    5cd8:	7f 01       	movw	r14, r30
    5cda:	01 50       	subi	r16, 0x01	; 1
    5cdc:	10 40       	sbci	r17, 0x00	; 0
    5cde:	01 15       	cp	r16, r1
    5ce0:	11 05       	cpc	r17, r1
    5ce2:	a1 f7       	brne	.-24     	; 0x5ccc <__eerd_block+0x16>
    5ce4:	cd b7       	in	r28, 0x3d	; 61
    5ce6:	de b7       	in	r29, 0x3e	; 62
    5ce8:	e8 e0       	ldi	r30, 0x08	; 8
    5cea:	0c 94 7a 2f 	jmp	0x5ef4	; 0x5ef4 <__epilogue_restores__+0x14>

00005cee <__eewr_block>:
    5cee:	a0 e0       	ldi	r26, 0x00	; 0
    5cf0:	b0 e0       	ldi	r27, 0x00	; 0
    5cf2:	ed e7       	ldi	r30, 0x7D	; 125
    5cf4:	fe e2       	ldi	r31, 0x2E	; 46
    5cf6:	0c 94 5e 2f 	jmp	0x5ebc	; 0x5ebc <__prologue_saves__+0x14>
    5cfa:	ec 01       	movw	r28, r24
    5cfc:	7b 01       	movw	r14, r22
    5cfe:	8a 01       	movw	r16, r20
    5d00:	69 01       	movw	r12, r18
    5d02:	09 c0       	rjmp	.+18     	; 0x5d16 <__eewr_block+0x28>
    5d04:	ce 01       	movw	r24, r28
    5d06:	21 96       	adiw	r28, 0x01	; 1
    5d08:	f7 01       	movw	r30, r14
    5d0a:	61 91       	ld	r22, Z+
    5d0c:	7f 01       	movw	r14, r30
    5d0e:	f6 01       	movw	r30, r12
    5d10:	09 95       	icall
    5d12:	01 50       	subi	r16, 0x01	; 1
    5d14:	10 40       	sbci	r17, 0x00	; 0
    5d16:	01 15       	cp	r16, r1
    5d18:	11 05       	cpc	r17, r1
    5d1a:	a1 f7       	brne	.-24     	; 0x5d04 <__eewr_block+0x16>
    5d1c:	cd b7       	in	r28, 0x3d	; 61
    5d1e:	de b7       	in	r29, 0x3e	; 62
    5d20:	e8 e0       	ldi	r30, 0x08	; 8
    5d22:	0c 94 7a 2f 	jmp	0x5ef4	; 0x5ef4 <__epilogue_restores__+0x14>

00005d26 <itoa>:
    5d26:	fb 01       	movw	r30, r22
    5d28:	9f 01       	movw	r18, r30
    5d2a:	e8 94       	clt
    5d2c:	42 30       	cpi	r20, 0x02	; 2
    5d2e:	c4 f0       	brlt	.+48     	; 0x5d60 <itoa+0x3a>
    5d30:	45 32       	cpi	r20, 0x25	; 37
    5d32:	b4 f4       	brge	.+44     	; 0x5d60 <itoa+0x3a>
    5d34:	4a 30       	cpi	r20, 0x0A	; 10
    5d36:	29 f4       	brne	.+10     	; 0x5d42 <itoa+0x1c>
    5d38:	97 fb       	bst	r25, 7
    5d3a:	1e f4       	brtc	.+6      	; 0x5d42 <itoa+0x1c>
    5d3c:	90 95       	com	r25
    5d3e:	81 95       	neg	r24
    5d40:	9f 4f       	sbci	r25, 0xFF	; 255
    5d42:	64 2f       	mov	r22, r20
    5d44:	77 27       	eor	r23, r23
    5d46:	0e 94 40 2f 	call	0x5e80	; 0x5e80 <__udivmodhi4>
    5d4a:	80 5d       	subi	r24, 0xD0	; 208
    5d4c:	8a 33       	cpi	r24, 0x3A	; 58
    5d4e:	0c f0       	brlt	.+2      	; 0x5d52 <itoa+0x2c>
    5d50:	89 5d       	subi	r24, 0xD9	; 217
    5d52:	81 93       	st	Z+, r24
    5d54:	cb 01       	movw	r24, r22
    5d56:	00 97       	sbiw	r24, 0x00	; 0
    5d58:	a1 f7       	brne	.-24     	; 0x5d42 <itoa+0x1c>
    5d5a:	16 f4       	brtc	.+4      	; 0x5d60 <itoa+0x3a>
    5d5c:	5d e2       	ldi	r21, 0x2D	; 45
    5d5e:	51 93       	st	Z+, r21
    5d60:	10 82       	st	Z, r1
    5d62:	c9 01       	movw	r24, r18
    5d64:	0c 94 ef 2e 	jmp	0x5dde	; 0x5dde <strrev>

00005d68 <ultoa>:
    5d68:	fa 01       	movw	r30, r20
    5d6a:	cf 93       	push	r28
    5d6c:	ff 93       	push	r31
    5d6e:	ef 93       	push	r30
    5d70:	22 30       	cpi	r18, 0x02	; 2
    5d72:	cc f0       	brlt	.+50     	; 0x5da6 <ultoa+0x3e>
    5d74:	25 32       	cpi	r18, 0x25	; 37
    5d76:	bc f4       	brge	.+46     	; 0x5da6 <ultoa+0x3e>
    5d78:	c2 2f       	mov	r28, r18
    5d7a:	2c 2f       	mov	r18, r28
    5d7c:	33 27       	eor	r19, r19
    5d7e:	44 27       	eor	r20, r20
    5d80:	55 27       	eor	r21, r21
    5d82:	ff 93       	push	r31
    5d84:	ef 93       	push	r30
    5d86:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <__udivmodsi4>
    5d8a:	ef 91       	pop	r30
    5d8c:	ff 91       	pop	r31
    5d8e:	60 5d       	subi	r22, 0xD0	; 208
    5d90:	6a 33       	cpi	r22, 0x3A	; 58
    5d92:	0c f0       	brlt	.+2      	; 0x5d96 <ultoa+0x2e>
    5d94:	69 5d       	subi	r22, 0xD9	; 217
    5d96:	61 93       	st	Z+, r22
    5d98:	b9 01       	movw	r22, r18
    5d9a:	ca 01       	movw	r24, r20
    5d9c:	60 50       	subi	r22, 0x00	; 0
    5d9e:	70 40       	sbci	r23, 0x00	; 0
    5da0:	80 40       	sbci	r24, 0x00	; 0
    5da2:	90 40       	sbci	r25, 0x00	; 0
    5da4:	51 f7       	brne	.-44     	; 0x5d7a <ultoa+0x12>
    5da6:	10 82       	st	Z, r1
    5da8:	8f 91       	pop	r24
    5daa:	9f 91       	pop	r25
    5dac:	cf 91       	pop	r28
    5dae:	0c 94 ef 2e 	jmp	0x5dde	; 0x5dde <strrev>

00005db2 <utoa>:
    5db2:	fb 01       	movw	r30, r22
    5db4:	9f 01       	movw	r18, r30
    5db6:	42 30       	cpi	r20, 0x02	; 2
    5db8:	74 f0       	brlt	.+28     	; 0x5dd6 <utoa+0x24>
    5dba:	45 32       	cpi	r20, 0x25	; 37
    5dbc:	64 f4       	brge	.+24     	; 0x5dd6 <utoa+0x24>
    5dbe:	64 2f       	mov	r22, r20
    5dc0:	77 27       	eor	r23, r23
    5dc2:	0e 94 40 2f 	call	0x5e80	; 0x5e80 <__udivmodhi4>
    5dc6:	80 5d       	subi	r24, 0xD0	; 208
    5dc8:	8a 33       	cpi	r24, 0x3A	; 58
    5dca:	0c f0       	brlt	.+2      	; 0x5dce <utoa+0x1c>
    5dcc:	89 5d       	subi	r24, 0xD9	; 217
    5dce:	81 93       	st	Z+, r24
    5dd0:	cb 01       	movw	r24, r22
    5dd2:	00 97       	sbiw	r24, 0x00	; 0
    5dd4:	a1 f7       	brne	.-24     	; 0x5dbe <utoa+0xc>
    5dd6:	10 82       	st	Z, r1
    5dd8:	c9 01       	movw	r24, r18
    5dda:	0c 94 ef 2e 	jmp	0x5dde	; 0x5dde <strrev>

00005dde <strrev>:
    5dde:	dc 01       	movw	r26, r24
    5de0:	fc 01       	movw	r30, r24
    5de2:	67 2f       	mov	r22, r23
    5de4:	71 91       	ld	r23, Z+
    5de6:	77 23       	and	r23, r23
    5de8:	e1 f7       	brne	.-8      	; 0x5de2 <strrev+0x4>
    5dea:	32 97       	sbiw	r30, 0x02	; 2
    5dec:	04 c0       	rjmp	.+8      	; 0x5df6 <strrev+0x18>
    5dee:	7c 91       	ld	r23, X
    5df0:	6d 93       	st	X+, r22
    5df2:	70 83       	st	Z, r23
    5df4:	62 91       	ld	r22, -Z
    5df6:	ae 17       	cp	r26, r30
    5df8:	bf 07       	cpc	r27, r31
    5dfa:	c8 f3       	brcs	.-14     	; 0x5dee <strrev+0x10>
    5dfc:	08 95       	ret

00005dfe <__mulsi3>:
    5dfe:	62 9f       	mul	r22, r18
    5e00:	d0 01       	movw	r26, r0
    5e02:	73 9f       	mul	r23, r19
    5e04:	f0 01       	movw	r30, r0
    5e06:	82 9f       	mul	r24, r18
    5e08:	e0 0d       	add	r30, r0
    5e0a:	f1 1d       	adc	r31, r1
    5e0c:	64 9f       	mul	r22, r20
    5e0e:	e0 0d       	add	r30, r0
    5e10:	f1 1d       	adc	r31, r1
    5e12:	92 9f       	mul	r25, r18
    5e14:	f0 0d       	add	r31, r0
    5e16:	83 9f       	mul	r24, r19
    5e18:	f0 0d       	add	r31, r0
    5e1a:	74 9f       	mul	r23, r20
    5e1c:	f0 0d       	add	r31, r0
    5e1e:	65 9f       	mul	r22, r21
    5e20:	f0 0d       	add	r31, r0
    5e22:	99 27       	eor	r25, r25
    5e24:	72 9f       	mul	r23, r18
    5e26:	b0 0d       	add	r27, r0
    5e28:	e1 1d       	adc	r30, r1
    5e2a:	f9 1f       	adc	r31, r25
    5e2c:	63 9f       	mul	r22, r19
    5e2e:	b0 0d       	add	r27, r0
    5e30:	e1 1d       	adc	r30, r1
    5e32:	f9 1f       	adc	r31, r25
    5e34:	bd 01       	movw	r22, r26
    5e36:	cf 01       	movw	r24, r30
    5e38:	11 24       	eor	r1, r1
    5e3a:	08 95       	ret

00005e3c <__udivmodsi4>:
    5e3c:	a1 e2       	ldi	r26, 0x21	; 33
    5e3e:	1a 2e       	mov	r1, r26
    5e40:	aa 1b       	sub	r26, r26
    5e42:	bb 1b       	sub	r27, r27
    5e44:	fd 01       	movw	r30, r26
    5e46:	0d c0       	rjmp	.+26     	; 0x5e62 <__udivmodsi4_ep>

00005e48 <__udivmodsi4_loop>:
    5e48:	aa 1f       	adc	r26, r26
    5e4a:	bb 1f       	adc	r27, r27
    5e4c:	ee 1f       	adc	r30, r30
    5e4e:	ff 1f       	adc	r31, r31
    5e50:	a2 17       	cp	r26, r18
    5e52:	b3 07       	cpc	r27, r19
    5e54:	e4 07       	cpc	r30, r20
    5e56:	f5 07       	cpc	r31, r21
    5e58:	20 f0       	brcs	.+8      	; 0x5e62 <__udivmodsi4_ep>
    5e5a:	a2 1b       	sub	r26, r18
    5e5c:	b3 0b       	sbc	r27, r19
    5e5e:	e4 0b       	sbc	r30, r20
    5e60:	f5 0b       	sbc	r31, r21

00005e62 <__udivmodsi4_ep>:
    5e62:	66 1f       	adc	r22, r22
    5e64:	77 1f       	adc	r23, r23
    5e66:	88 1f       	adc	r24, r24
    5e68:	99 1f       	adc	r25, r25
    5e6a:	1a 94       	dec	r1
    5e6c:	69 f7       	brne	.-38     	; 0x5e48 <__udivmodsi4_loop>
    5e6e:	60 95       	com	r22
    5e70:	70 95       	com	r23
    5e72:	80 95       	com	r24
    5e74:	90 95       	com	r25
    5e76:	9b 01       	movw	r18, r22
    5e78:	ac 01       	movw	r20, r24
    5e7a:	bd 01       	movw	r22, r26
    5e7c:	cf 01       	movw	r24, r30
    5e7e:	08 95       	ret

00005e80 <__udivmodhi4>:
    5e80:	aa 1b       	sub	r26, r26
    5e82:	bb 1b       	sub	r27, r27
    5e84:	51 e1       	ldi	r21, 0x11	; 17
    5e86:	07 c0       	rjmp	.+14     	; 0x5e96 <__udivmodhi4_ep>

00005e88 <__udivmodhi4_loop>:
    5e88:	aa 1f       	adc	r26, r26
    5e8a:	bb 1f       	adc	r27, r27
    5e8c:	a6 17       	cp	r26, r22
    5e8e:	b7 07       	cpc	r27, r23
    5e90:	10 f0       	brcs	.+4      	; 0x5e96 <__udivmodhi4_ep>
    5e92:	a6 1b       	sub	r26, r22
    5e94:	b7 0b       	sbc	r27, r23

00005e96 <__udivmodhi4_ep>:
    5e96:	88 1f       	adc	r24, r24
    5e98:	99 1f       	adc	r25, r25
    5e9a:	5a 95       	dec	r21
    5e9c:	a9 f7       	brne	.-22     	; 0x5e88 <__udivmodhi4_loop>
    5e9e:	80 95       	com	r24
    5ea0:	90 95       	com	r25
    5ea2:	bc 01       	movw	r22, r24
    5ea4:	cd 01       	movw	r24, r26
    5ea6:	08 95       	ret

00005ea8 <__prologue_saves__>:
    5ea8:	2f 92       	push	r2
    5eaa:	3f 92       	push	r3
    5eac:	4f 92       	push	r4
    5eae:	5f 92       	push	r5
    5eb0:	6f 92       	push	r6
    5eb2:	7f 92       	push	r7
    5eb4:	8f 92       	push	r8
    5eb6:	9f 92       	push	r9
    5eb8:	af 92       	push	r10
    5eba:	bf 92       	push	r11
    5ebc:	cf 92       	push	r12
    5ebe:	df 92       	push	r13
    5ec0:	ef 92       	push	r14
    5ec2:	ff 92       	push	r15
    5ec4:	0f 93       	push	r16
    5ec6:	1f 93       	push	r17
    5ec8:	cf 93       	push	r28
    5eca:	df 93       	push	r29
    5ecc:	cd b7       	in	r28, 0x3d	; 61
    5ece:	de b7       	in	r29, 0x3e	; 62
    5ed0:	ca 1b       	sub	r28, r26
    5ed2:	db 0b       	sbc	r29, r27
    5ed4:	0f b6       	in	r0, 0x3f	; 63
    5ed6:	f8 94       	cli
    5ed8:	de bf       	out	0x3e, r29	; 62
    5eda:	0f be       	out	0x3f, r0	; 63
    5edc:	cd bf       	out	0x3d, r28	; 61
    5ede:	09 94       	ijmp

00005ee0 <__epilogue_restores__>:
    5ee0:	2a 88       	ldd	r2, Y+18	; 0x12
    5ee2:	39 88       	ldd	r3, Y+17	; 0x11
    5ee4:	48 88       	ldd	r4, Y+16	; 0x10
    5ee6:	5f 84       	ldd	r5, Y+15	; 0x0f
    5ee8:	6e 84       	ldd	r6, Y+14	; 0x0e
    5eea:	7d 84       	ldd	r7, Y+13	; 0x0d
    5eec:	8c 84       	ldd	r8, Y+12	; 0x0c
    5eee:	9b 84       	ldd	r9, Y+11	; 0x0b
    5ef0:	aa 84       	ldd	r10, Y+10	; 0x0a
    5ef2:	b9 84       	ldd	r11, Y+9	; 0x09
    5ef4:	c8 84       	ldd	r12, Y+8	; 0x08
    5ef6:	df 80       	ldd	r13, Y+7	; 0x07
    5ef8:	ee 80       	ldd	r14, Y+6	; 0x06
    5efa:	fd 80       	ldd	r15, Y+5	; 0x05
    5efc:	0c 81       	ldd	r16, Y+4	; 0x04
    5efe:	1b 81       	ldd	r17, Y+3	; 0x03
    5f00:	aa 81       	ldd	r26, Y+2	; 0x02
    5f02:	b9 81       	ldd	r27, Y+1	; 0x01
    5f04:	ce 0f       	add	r28, r30
    5f06:	d1 1d       	adc	r29, r1
    5f08:	0f b6       	in	r0, 0x3f	; 63
    5f0a:	f8 94       	cli
    5f0c:	de bf       	out	0x3e, r29	; 62
    5f0e:	0f be       	out	0x3f, r0	; 63
    5f10:	cd bf       	out	0x3d, r28	; 61
    5f12:	ed 01       	movw	r28, r26
    5f14:	08 95       	ret

00005f16 <_exit>:
    5f16:	f8 94       	cli

00005f18 <__stop_program>:
    5f18:	ff cf       	rjmp	.-2      	; 0x5f18 <__stop_program>
